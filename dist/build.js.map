{"version":3,"sources":["webpack:///build.js","webpack:///webpack/bootstrap eb3810306eedc3d9dc1d","webpack:///./src/main.js","webpack:///./~/three/build/three.js","webpack:///./~/vue-resource/dist/vue-resource.common.js","webpack:///./~/vue/dist/vue.common.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_vue","_vue2","_vueResource","_vueResource2","_three","_three2","use","AlbumCube","extend","template","component","el","components","ready","init","ImageUtils","crossOrigin","scene","Scene","camera","PerspectiveCamera","document","getElementById","offsetWidth","window","innerHeight","renderer","WebGLRenderer","setClearColor","setSize","shadowMap","enabled","appendChild","domElement","ambientLight","AmbientLight","add","lights","PointLight","position","set","geometry","BoxGeometry","material","MeshLambertMaterial","color","transparent","opacity","cube","Mesh","z","render","requestAnimationFrame","rotation","x","y","handleResize","aspect","updateProjectionMatrix","componentToHex","hex","toString","length","rgbToHex","rgb","i","intervalTexture","datas","file","shift","push","loader","TextureLoader","load","texture","map","needsUpdate","xhr","console","log","url","albumColors","AlbumColors","getColors","colors","parseInt","body","style","background","getElementsByTagName","firstElementChild","onload","addEventListener","APIkey","Limit","User","this","$http","get","params","method","format","user","api_key","limit","page","then","d","json","allCovers","albums","topalbums","album","image","j","title","name","split","join","ext","pop","setInterval","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","THREE","REVISION","undefined","Number","EPSILON","Math","pow","sign","Function","prototype","Object","defineProperty","match","assign","target","TypeError","output","index","arguments","source","nextKey","hasOwnProperty","MOUSE","LEFT","MIDDLE","RIGHT","CullFaceNone","CullFaceBack","CullFaceFront","CullFaceFrontBack","FrontFaceDirectionCW","FrontFaceDirectionCCW","BasicShadowMap","PCFShadowMap","PCFSoftShadowMap","FrontSide","BackSide","DoubleSide","FlatShading","SmoothShading","NoColors","FaceColors","VertexColors","NoBlending","NormalBlending","AdditiveBlending","SubtractiveBlending","MultiplyBlending","CustomBlending","AddEquation","SubtractEquation","ReverseSubtractEquation","MinEquation","MaxEquation","ZeroFactor","OneFactor","SrcColorFactor","OneMinusSrcColorFactor","SrcAlphaFactor","OneMinusSrcAlphaFactor","DstAlphaFactor","OneMinusDstAlphaFactor","DstColorFactor","OneMinusDstColorFactor","SrcAlphaSaturateFactor","NeverDepth","AlwaysDepth","LessDepth","LessEqualDepth","EqualDepth","GreaterEqualDepth","GreaterDepth","NotEqualDepth","MultiplyOperation","MixOperation","AddOperation","NoToneMapping","LinearToneMapping","ReinhardToneMapping","Uncharted2ToneMapping","CineonToneMapping","UVMapping","CubeReflectionMapping","CubeRefractionMapping","EquirectangularReflectionMapping","EquirectangularRefractionMapping","SphericalReflectionMapping","CubeUVReflectionMapping","CubeUVRefractionMapping","RepeatWrapping","ClampToEdgeWrapping","MirroredRepeatWrapping","NearestFilter","NearestMipMapNearestFilter","NearestMipMapLinearFilter","LinearFilter","LinearMipMapNearestFilter","LinearMipMapLinearFilter","UnsignedByteType","ByteType","ShortType","UnsignedShortType","IntType","UnsignedIntType","FloatType","HalfFloatType","UnsignedShort4444Type","UnsignedShort5551Type","UnsignedShort565Type","AlphaFormat","RGBFormat","RGBAFormat","LuminanceFormat","LuminanceAlphaFormat","RGBEFormat","DepthFormat","RGB_S3TC_DXT1_Format","RGBA_S3TC_DXT1_Format","RGBA_S3TC_DXT3_Format","RGBA_S3TC_DXT5_Format","RGB_PVRTC_4BPPV1_Format","RGB_PVRTC_2BPPV1_Format","RGBA_PVRTC_4BPPV1_Format","RGBA_PVRTC_2BPPV1_Format","RGB_ETC1_Format","LoopOnce","LoopRepeat","LoopPingPong","InterpolateDiscrete","InterpolateLinear","InterpolateSmooth","ZeroCurvatureEnding","ZeroSlopeEnding","WrapAroundEnding","TrianglesDrawMode","TriangleStripDrawMode","TriangleFanDrawMode","LinearEncoding","sRGBEncoding","GammaEncoding","RGBEEncoding","LogLuvEncoding","RGBM7Encoding","RGBM16Encoding","RGBDEncoding","BasicDepthPacking","RGBADepthPacking","Color","r","g","b","setRGB","constructor","value","copy","setHex","setStyle","setScalar","scalar","floor","setHSL","hue2rgb","q","t","h","s","l","euclideanModulo","clamp","handleAlpha","string","parseFloat","warn","exec","min","size","charAt","ColorKeywords","clone","copyGammaToLinear","gammaFactor","copyLinearToGamma","safeInverse","convertGammaToLinear","convertLinearToGamma","sqrt","getHex","getHexString","slice","getHSL","optionalTarget","hue","saturation","hsl","max","lightness","delta","getStyle","offsetHSL","addColors","color1","color2","addScalar","multiply","multiplyScalar","lerp","alpha","equals","fromArray","array","offset","toArray","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","Quaternion","w","_x","_y","_z","_w","onChangeCallback","quaternion","setFromEuler","euler","update","Euler","Error","c1","cos","c2","c3","s1","sin","s2","s3","order","setFromAxisAngle","axis","angle","halfAngle","setFromRotationMatrix","te","elements","m11","m12","m13","m21","m22","m23","m31","m32","m33","trace","setFromUnitVectors","v1","EPS","vFrom","vTo","Vector3","dot","abs","crossVectors","normalize","inverse","conjugate","v","lengthSq","multiplyQuaternions","premultiply","a","qax","qay","qaz","qaw","qbx","qby","qbz","qbw","slerp","qb","cosHalfTheta","sinHalfTheta","halfTheta","atan2","ratioA","ratioB","onChange","callback","qa","qm","slerpFlat","dst","dstOffset","src0","srcOffset0","src1","srcOffset1","x0","y0","z0","w0","x1","y1","z1","w1","dir","sqrSin","len","tDir","f","Vector2","width","height","setX","setY","setComponent","getComponent","addVectors","addScaledVector","sub","subVectors","subScalar","isFinite","divide","divideScalar","clampScalar","minVal","maxVal","clampLength","ceil","round","roundToZero","negate","lengthManhattan","PI","distanceTo","distanceToSquared","dx","dy","setLength","lerpVectors","v2","fromAttribute","attribute","itemSize","rotateAround","center","setZ","multiplyVectors","applyEuler","error","applyQuaternion","applyAxisAngle","applyMatrix3","e","applyMatrix4","applyProjection","qx","qy","qz","qw","ix","iy","iz","iw","project","matrix","Matrix4","multiplyMatrices","projectionMatrix","getInverse","matrixWorld","unproject","transformDirection","cross","ax","ay","az","bx","by","bz","projectOnVector","vector","projectOnPlane","planeNormal","reflect","normal","angleTo","theta","acos","dz","setFromSpherical","sinPhiRadius","phi","radius","setFromMatrixPosition","setFromMatrixColumn","setFromMatrixScale","sx","sy","sz","temp","Vector4","setW","setAxisAngleFromQuaternion","setAxisAngleFromRotationMatrix","epsilon","epsilon2","xx","yy","zz","xy","xz","yz","_order","DefaultOrder","RotationOrders","asin","setFromQuaternion","makeRotationFromQuaternion","setFromVector3","reorder","newOrder","toVector3","optionalResult","Line3","start","end","line","result","distanceSq","distance","at","closestPointToPointParameter","startP","startEnd","point","clampToLine","startEnd2","startEnd_startP","closestPointToPoint","Box2","Infinity","setFromPoints","points","makeEmpty","il","expandByPoint","setFromCenterAndSize","halfSize","box","isEmpty","expandByVector","expandByScalar","containsPoint","containsBox","getParameter","intersectsBox","clampPoint","distanceToPoint","clampedPoint","intersect","union","translate","Box3","setFromArray","minX","minY","minZ","maxX","maxY","maxZ","setFromObject","object","scope","updateMatrixWorld","traverse","node","Geometry","vertices","BufferGeometry","attributes","positions","intersectsSphere","closestPoint","sphere","intersectsPlane","plane","constant","getBoundingSphere","Sphere","Matrix3","Float32Array","n11","n12","n13","n21","n22","n23","n31","n32","n33","identity","me","setFromMatrix4","applyToVector3Array","applyToBuffer","buffer","getX","getY","getZ","setXYZ","determinant","throwOnDegenerate","t11","t12","t13","det","msg","detInv","transpose","tmp","flattenToArrayOffset","getNormalMatrix","matrix4","transposeIntoArray","n14","n24","n34","n41","n42","n43","n44","copyPosition","extractBasis","xAxis","yAxis","zAxis","makeBasis","extractRotation","scaleX","scaleY","scaleZ","makeRotationFromEuler","ae","af","be","bf","ce","cf","de","df","ac","ad","bc","bd","x2","y2","z2","wx","wy","wz","lookAt","eye","up","n","a11","a12","a13","a14","a21","a22","a23","a24","a31","a32","a33","a34","a41","a42","a43","a44","b11","b12","b13","b14","b21","b22","b23","b24","b31","b32","b33","b34","b41","b42","b43","b44","multiplyToArray","getPosition","setPosition","t14","scale","getMaxScaleOnAxis","scaleXSq","scaleYSq","scaleZSq","makeTranslation","makeRotationX","makeRotationY","makeRotationZ","makeRotationAxis","tx","ty","makeScale","compose","decompose","invSX","invSY","invSZ","makeFrustum","left","right","bottom","top","near","far","makePerspective","fov","ymax","DEG2RAD","ymin","xmin","xmax","makeOrthographic","Ray","origin","direction","ray","recast","directionDistance","distanceSqToPoint","distanceSqToSegment","segCenter","segDir","diff","v0","optionalPointOnRay","optionalPointOnSegment","s0","sqrDist","extDet","segExtent","a01","b0","b1","invDet","intersectSphere","tca","d2","radius2","thc","t0","t1","distanceToPlane","denominator","intersectPlane","distToPoint","intersectBox","tmin","tmax","tymin","tymax","tzmin","tzmax","invdirx","invdiry","invdirz","intersectTriangle","edge1","edge2","backfaceCulling","DdN","DdQxE2","DdE1xQ","QdN","optionalCenter","maxRadiusSq","empty","radiusSum","deltaLengthSq","getBoundingBox","Frustum","p0","p1","p2","p3","p4","p5","planes","Plane","frustum","setFromMatrix","me0","me1","me2","me3","me4","me5","me6","me7","me8","me9","me10","me11","me12","me13","me14","me15","setComponents","intersectsObject","boundingSphere","computeBoundingSphere","intersectsSprite","sprite","negRadius","d1","setFromNormalAndCoplanarPoint","setFromCoplanarPoints","inverseNormalLength","distanceToSphere","projectPoint","orthoPoint","perpendicularMagnitude","intersectLine","intersectsLine","startSign","endSign","coplanarPoint","m1","optionalNormalMatrix","referencePoint","normalMatrix","Spherical","other","makeSafe","vec3","RAD2DEG","generateUUID","chars","uuid","Array","rnd","random","mapLinear","a1","a2","b2","smoothstep","smootherstep","random16","randInt","low","high","randFloat","randFloatSpread","range","degToRad","degrees","radToDeg","radians","isPowerOfTwo","nearestPowerOfTwo","LN2","nextPowerOfTwo","Spline","interpolate","t2","t3","intPoint","weight","w2","w3","pa","pb","pc","pd","v3","initFromArray","getPoint","k","getControlPointsArray","coords","getLength","nSubDivisions","nSamples","oldIntPoint","oldPosition","tmpVec","chunkLengths","totalLength","chunks","total","reparametrizeByArcLength","samplingCoef","indexCurrent","indexNext","realDistance","sampling","newpoints","sl","Triangle","resultLengthSq","barycoordFromPoint","dot00","dot01","dot02","dot11","dot12","denom","invDenom","u","setFromPointsAndIndices","i0","i1","i2","triangle","area","midpoint","edgeList","projectedPoint","minDistance","Interpolant","parameterPositions","sampleValues","sampleSize","resultBuffer","_cachedIndex","valueSize","evaluate","pp","validate_interval","seek","linear_scan","forward_scan","giveUpAt","afterEnd_","t1global","beforeStart_","mid","intervalChanged_","interpolate_","settings","DefaultSettings_","getSettings_","copySampleValue_","values","stride","CubicInterpolant","_weightPrev","_offsetPrev","_weightNext","_offsetNext","create","endingStart","endingEnd","iPrev","iNext","tPrev","tNext","halfDt","o1","o0","oP","oN","wP","wN","ppp","sP","sN","DiscreteInterpolant","LinearInterpolant","offset1","offset0","weight1","weight0","QuaternionLinearInterpolant","Clock","autoStart","startTime","oldTime","elapsedTime","running","performance","Date","now","stop","getElapsedTime","getDelta","newTime","EventDispatcher","type","listener","_listeners","listeners","indexOf","hasEventListener","removeEventListener","listenerArray","splice","dispatchEvent","event","Layers","mask","channel","enable","toggle","disable","test","layers","ascSort","intersectObject","raycaster","intersects","recursive","visible","raycast","children","Raycaster","Line","LOD","Points","threshold","Sprite","defineProperties","PointCloud","linePrecision","setFromCamera","OrthographicCamera","sort","intersectObjects","objects","isArray","Object3D","onRotationChange","onQuaternionChange","Object3DIdCount","parent","DefaultUp","enumerable","modelViewMatrix","matrixAutoUpdate","DefaultMatrixAutoUpdate","matrixWorldNeedsUpdate","castShadow","receiveShadow","frustumCulled","renderOrder","userData","applyMatrix","setRotationFromAxisAngle","setRotationFromEuler","setRotationFromMatrix","setRotationFromQuaternion","rotateOnAxis","q1","rotateX","rotateY","rotateZ","translateOnAxis","translateX","translateY","translateZ","localToWorld","worldToLocal","remove","getObjectById","getObjectByProperty","getObjectByName","child","getWorldPosition","getWorldQuaternion","getWorldRotation","getWorldScale","getWorldDirection","traverseVisible","traverseAncestors","updateMatrix","force","toJSON","meta","extractFromCache","cache","key","data","metadata","isRootObject","geometries","materials","textures","images","version","generator","JSON","stringify","parse","Face3","materialIndex","vertexNormals","vertexColors","BufferAttribute","normalized","dynamic","updateRange","count","setDynamic","copyAt","index1","index2","copyArray","copyColorsArray","copyIndicesArray","indices","copyVector2sArray","vectors","copyVector3sArray","copyVector4sArray","getW","setXY","setXYZW","Int8Attribute","Int8Array","Uint8Attribute","Uint8Array","Uint8ClampedAttribute","Uint8ClampedArray","Int16Attribute","Int16Array","Uint16Attribute","Uint16Array","Int32Attribute","Int32Array","Uint32Attribute","Uint32Array","Float32Attribute","Float64Attribute","Float64Array","DynamicBufferAttribute","InstancedBufferAttribute","meshPerAttribute","InterleavedBuffer","InstancedInterleavedBuffer","InterleavedBufferAttribute","interleavedBuffer","GeometryIdCount","faces","faceVertexUvs","morphTargets","morphNormals","skinWeights","skinIndices","lineDistances","boundingBox","verticesNeedUpdate","elementsNeedUpdate","uvsNeedUpdate","normalsNeedUpdate","colorsNeedUpdate","lineDistancesNeedUpdate","groupsNeedUpdate","vertex","face","jl","computeBoundingBox","fromBufferGeometry","addFace","normals","tempNormals","uvs","tempUVs","uvs2","tempUVs2","uv","uv2","groups","group","computeFaceNormals","cb","ab","fl","vA","vB","vC","computeVertexNormals","areaWeighted","vl","computeMorphNormals","__originalFaceNormal","__originalVertexNormals","tmpGeo","faceNormals","faceNormal","dstNormalsFace","dstNormalsVertex","computeTangents","computeLineDistances","merge","materialIndexOffset","vertexOffset","vertices1","vertices2","faces1","faces2","uvs1","vertexCopy","faceCopy","faceVertexNormals","faceVertexColors","uvCopy","mergeMesh","mesh","mergeVertices","verticesMap","unique","changes","precisionPoints","precision","faceIndicesToRemove","dupIndex","idx","sortFacesByMaterialIndex","materialIndexSort","_id","newUvs1","newUvs2","setBit","getNormalIndex","hash","normalsHash","getColorIndex","colorsHash","getUvIndex","uvsHash","parameters","hasMaterial","hasFaceUv","hasFaceVertexUv","hasFaceNormal","hasFaceVertexNormal","hasFaceColor","hasFaceVertexColor","faceType","uvsCopy","kl","dispose","DirectGeometry","computeGroups","fromGeometry","morphTargetsPosition","hasFaceVertexUv2","morphTargetsLength","morphTargetsNormal","morphNormalsLength","hasSkinIndices","hasSkinWeights","vertexUvs","morphTarget","morphNormal","morphAttributes","drawRange","getIndex","setIndex","addAttribute","getAttribute","removeAttribute","addGroup","clearGroups","setDrawRange","updateFromObject","direct","__directGeometry","lineDistance","fromDirectGeometry","TypeArray","isNaN","pA","pB","pC","normalizeNormals","attribute1","attributeArray1","attribute2","attributeArray2","attributeSize","toNonIndexed","geometry2","array2","MaxIndex","InstancedBufferGeometry","maxInstancedCount","instances","Uniform","onUpdate","onUpdateCallback","AnimationAction","_new","mixer","clip","localRoot","_mixer","_clip","_localRoot","tracks","nTracks","interpolants","interpolantSettings","interpolant","createInterpolant","_interpolantSettings","_interpolants","_propertyBindings","_cacheIndex","_byClipCacheIndex","_timeScaleInterpolant","_weightInterpolant","loop","_loopCount","_startTime","time","timeScale","_effectiveTimeScale","_effectiveWeight","repetitions","paused","clampWhenFinished","zeroSlopeAtStart","zeroSlopeAtEnd","play","_activateAction","_deactivateAction","reset","stopFading","stopWarping","isRunning","_isActiveAction","isScheduled","startAt","setLoop","mode","setEffectiveWeight","getEffectiveWeight","fadeIn","duration","_scheduleFading","fadeOut","crossFadeFrom","fadeOutAction","warp","fadeInDuration","fadeOutDuration","startEndRatio","endStartRatio","crossFadeTo","fadeInAction","weightInterpolant","_takeBackControlInterpolant","setEffectiveTimeScale","getEffectiveTimeScale","setDuration","syncWith","action","halt","startTimeScale","endTimeScale","_lendControlInterpolant","times","timeScaleInterpolant","getMixer","getClip","getRoot","_root","_update","deltaTime","timeDirection","accuIndex","timeRunning","_updateTimeScale","clipTime","_updateTime","_updateWeight","propertyMixers","accumulate","interpolantValue","loopCount","_setEndings","handle_stop","pingPong","loopDelta","pending","atStart","atEnd","weightNow","weightThen","AnimationClip","resetDuration","trim","optimize","track","jsonTracks","frameTime","fps","KeyframeTrack","clipTracks","CreateFromMorphTargetSequence","morphTargetSequence","noLoop","numMorphTargets","AnimationUtils","getKeyframeOrder","sortedArray","NumberKeyframeTrack","findByName","objectOrClipArray","clipArray","o","animations","CreateClipsFromMorphTargetSequences","animationToMorphTargets","pattern","parts","animationMorphTargets","clips","parseAnimation","animation","bones","nodeName","addNonemptyTrack","trackType","trackName","animationKeys","propertyName","destTracks","flattenJSON","clipName","hierarchyTracks","hierarchy","keys","morphTargetNames","morphTargetName","animationKey","boneName","VectorKeyframeTrack","QuaternionKeyframeTrack","AnimationMixer","root","_initMemoryManager","_accuIndex","clipAction","optionalRoot","rootUuid","clipObject","clipUuid","actionsForClip","_actionsByClip","prototypeAction","existingAction","actionByRoot","knownActions","newAction","_Action","_bindAction","_addInactiveAction","stopAllAction","actions","_actions","nActions","_nActiveActions","bindings","_bindings","nBindings","_nActiveBindings","useCount","apply","uncacheClip","actionsByClip","actionsToRemove","cacheIndex","lastInactiveAction","_removeInactiveBindingsForAction","uncacheRoot","_removeInactiveAction","bindingsByRoot","_bindingsByRootAndName","bindingByName","binding","restoreOriginalState","_removeInactiveBinding","uncacheAction","bindingsByName","referenceCount","_addInactiveBinding","path","parsedPath","PropertyMixer","PropertyBinding","ValueTypeName","getValueSize","_lendBinding","saveOriginalState","_lendAction","_takeBackBinding","_takeBackAction","_controlInterpolants","_nActiveControlInterpolants","stats","inUse","controlInterpolants","knownActionsForClip","lastKnownAction","byClipCacheIndex","prevIndex","lastActiveIndex","firstInactiveAction","firstInactiveIndex","lastActiveAction","propBinding","rootNode","lastInactiveBinding","remove_empty_map","_","firstInactiveBinding","lastActiveBinding","_controlInterpolantsResultBuffer","__cacheIndex","lastActiveInterpolant","AnimationObjectGroup","var_args","_objects","nCachedObjects_","_indicesByUUID","_paths","_parsedPaths","_bindingsIndicesByPath","bindingsPerObject","nObjects","nCachedObjects","indicesByUUID","paths","parsedPaths","knownObject","firstActiveIndex","lastCachedObject","bindingsForPath","lastCached","lastCachedIndex","firstActiveObject","firstActive","uncache","lastIndex","lastObject","last","subscribe_","indicesByPath","unsubscribe_","lastBindingsIndex","lastBindings","lastBindingsPath","arraySlice","from","to","isTypedArray","subarray","convertArray","forceClone","BYTES_PER_ELEMENT","ArrayBuffer","isView","DataView","compareTime","nValues","srcOffset","jsonKeys","valuePropertyName","interpolation","TimeBufferType","ValueBufferType","setInterpolation","DefaultInterpolation","validate","InterpolantFactoryMethodDiscrete","InterpolantFactoryMethodLinear","InterpolantFactoryMethodSmooth","factoryMethod","message","getInterpolation","timeOffset","endTime","nKeys","valid","prevTime","currTime","writeIndex","keep","timeNext","offsetP","offsetN","readOffset","writeOffset","_getTrackTypeForValueTypeName","typeName","toLowerCase","ColorKeyframeTrack","BooleanKeyframeTrack","StringKeyframeTrack","parseTrackName","findNode","getValue","targetArray","bind","setValue","sourceArray","targetObject","objectName","propertyIndex","_getValue_unavailable","_setValue_unavailable","objectIndex","skeleton","nodeProperty","versioning","Versioning","None","NeedsUpdate","MatrixWorldNeedsUpdate","bindingType","BindingType","Direct","ArrayElement","resolvedProperty","HasFromToArray","EntireArray","GetterByBindingType","SetterByBindingTypeAndVersioning","unbind","_getValue_unbound","_setValue_unbound","dest","Composite","targetGroup","optionalParsedPath","_targetGroup","firstValidIndex","re","matches","results","searchSkeleton","bone","searchNodeSubtree","childNode","subTreeNode","mixFunction","bufferType","_slerp","_select","_lerp","_mixBufferRegion","cumulativeWeight","currentWeight","mix","originalValueOffset","Audio","context","createBufferSource","onended","onEnded","gain","createGain","connect","getInput","autoplay","playbackRate","isPlaying","hasPlaybackControl","sourceType","filters","getOutput","setNodeSource","audioNode","setBuffer","audioBuffer","pause","currentTime","disconnect","getFilters","setFilters","getFilter","setFilter","filter","setPlaybackRate","getPlaybackRate","getLoop","getVolume","setVolume","AudioAnalyser","audio","fftSize","analyser","createAnalyser","frequencyBinCount","getFrequencyData","getByteFrequencyData","getAverageFrequency","AudioContext","webkitAudioContext","PositionalAudio","panner","createPanner","getRefDistance","refDistance","setRefDistance","getRolloffFactor","rolloffFactor","setRolloffFactor","getDistanceModel","distanceModel","setDistanceModel","getMaxDistance","maxDistance","setMaxDistance","AudioListener","destination","removeFilter","getMasterVolume","setMasterVolume","orientation","setOrientation","Camera","matrixWorldInverse","CubeCamera","cubeResolution","cameraPX","cameraNX","cameraPY","cameraNY","cameraPZ","cameraNZ","options","magFilter","minFilter","renderTarget","WebGLRenderTargetCube","updateCubeMap","generateMipmaps","activeCubeFace","setRenderTarget","zoom","view","setViewOffset","fullWidth","fullHeight","offsetX","offsetY","clearViewOffset","cx","cy","zoomW","zoomH","scaleW","scaleH","focus","filmGauge","filmOffset","setFocalLength","focalLength","vExtentSlope","getFilmHeight","atan","getFocalLength","getEffectiveFOV","getFilmWidth","skew","StereoCamera","cameraL","cameraR","eyeRight","eyeLeft","eyeSep","eyeSepOnProjection","Light","intensity","groundColor","decay","penumbra","LightShadow","bias","mapSize","DirectionalLight","shadow","DirectionalLightShadow","light","HemisphereLight","skyColor","power","SpotLight","SpotLightShadow","AudioLoader","manager","DefaultLoadingManager","onLoad","onProgress","onError","XHRLoader","setResponseType","decodeAudioData","Cache","files","clear","Loader","onLoadStart","onLoadProgress","onLoadComplete","extractUrlBase","initMaterials","texturePath","createMaterial","textureLoader","materialLoader","loadTexture","repeat","wrap","anisotropy","fullPath","Handlers","setCrossOrigin","wrapS","wrapT","MaterialLoader","blending","specular","emissive","shininess","mapDiffuseRepeat","mapDiffuseOffset","mapDiffuseWrap","mapDiffuseAnisotropy","emissiveMap","mapEmissiveRepeat","mapEmissiveOffset","mapEmissiveWrap","mapEmissiveAnisotropy","lightMap","mapLightRepeat","mapLightOffset","mapLightWrap","mapLightAnisotropy","aoMap","mapAORepeat","mapAOOffset","mapAOWrap","mapAOAnisotropy","bumpMap","mapBumpRepeat","mapBumpOffset","mapBumpWrap","mapBumpAnisotropy","bumpScale","normalMap","mapNormalRepeat","mapNormalOffset","mapNormalWrap","mapNormalAnisotropy","normalScale","specularMap","mapSpecularRepeat","mapSpecularOffset","mapSpecularWrap","mapSpecularAnisotropy","metalnessMap","mapMetalnessRepeat","mapMetalnessOffset","mapMetalnessWrap","mapMetalnessAnisotropy","roughnessMap","mapRoughnessRepeat","mapRoughnessOffset","mapRoughnessWrap","mapRoughnessAnisotropy","alphaMap","mapAlphaRepeat","mapAlphaOffset","mapAlphaWrap","mapAlphaAnisotropy","side","setTextures","handlers","regex","cached","setTimeout","request","XMLHttpRequest","overrideMimeType","open","response","status","itemEnd","itemError","responseType","withCredentials","send","itemStart","setPath","setWithCredentials","FontLoader","text","substring","font","Font","ImageLoader","createElementNS","URL","revokeObjectURL","src","blob","createObjectURL","JSONLoader","setTexturePath","parseModel","isBitSet","fi","zLength","colorIndex","normalIndex","uvIndex","isQuad","faceA","faceB","uvLayer","nUvLayers","parseSkin","influencesPerVertex","parseMorphing","dstVertices","srcVertices","morphColors","parseAnimations","outputAnimations","concat","morphAnimationClips","LoadingManager","isLoading","itemsLoaded","itemsTotal","onStart","BufferGeometryLoader","TYPED_ARRAYS","typedArray","drawcalls","offsets","getTexture","roughness","metalness","uniforms","vertexShader","fragmentShader","shading","alphaTest","depthTest","depthWrite","colorWrite","wireframe","wireframeLinewidth","sizeAttenuation","displacementMap","displacementScale","displacementBias","emissiveIntensity","envMap","combine","reflectivity","lightMapIntensity","aoMapIntensity","ObjectLoader","lastIndexOf","parseGeometries","parseImages","parseTextures","parseMaterials","parseObject","geometryLoader","bufferGeometryLoader","widthSegments","heightSegments","depth","depthSegments","segments","thetaStart","thetaLength","radiusTop","radiusBottom","radialSegments","openEnded","phiStart","phiLength","detail","innerRadius","outerRadius","thetaSegments","phiSegments","tube","tubularSegments","arc","loadImage","parseConstant","Texture","mapping","getGeometry","getMaterial","SkinnedMesh","Group","levels","level","addLevel","CubeTextureLoader","urls","CubeTexture","DataTextureLoader","BinaryTextureLoader","_parser","DataTexture","texData","mipmaps","mipmapCount","CompressedTextureLoader","texDatas","CompressedTexture","isCubemap","Material","MaterialIdCount","fog","blendSrc","blendDst","blendEquation","blendSrcAlpha","blendDstAlpha","blendEquationAlpha","depthFunc","clippingPlanes","clipShadows","polygonOffset","polygonOffsetFactor","polygonOffsetUnits","premultipliedAlpha","overdraw","_needsUpdate","setValues","newValue","currentValue","isRoot","srcPlanes","dstPlanes","LineBasicMaterial","linewidth","linecap","linejoin","LineDashedMaterial","dashSize","gapSize","MeshBasicMaterial","refractionRatio","wireframeLinecap","wireframeLinejoin","skinning","MeshDepthMaterial","depthPacking","MeshNormalMaterial","MeshPhongMaterial","MeshStandardMaterial","defines","STANDARD","envMapIntensity","MeshPhysicalMaterial","PHYSICAL","clearCoat","clearCoatRoughness","MultiMaterial","PointsMaterial","ShaderMaterial","clipping","extensions","derivatives","fragDepth","drawBuffers","shaderTextureLOD","defaultAttributeValues","index0AttributeName","UniformsUtils","RawShaderMaterial","SpriteMaterial","ShadowMaterial","UniformsLib","ShaderChunk","encoding","TextureIdCount","sourceFile","DEFAULT_IMAGE","DEFAULT_MAPPING","premultiplyAlpha","flipY","unpackAlignment","getDataURL","canvas","toDataURL","getContext","drawImage","transformUv","DepthTexture","CanvasTexture","VideoTexture","video","readyState","HAVE_CURRENT_DATA","inverseMatrix","testPoint","rayPointDistanceSq","localThresholdSq","intersectPoint","distanceToRay","localThreshold","LineSegments","precisionSq","vStart","vEnd","interSegment","interRay","step","distSq","faceIndex","nbVertices","drawMode","updateMorphTargets","setDrawMode","morphTargetBase","morphTargetInfluences","morphTargetDictionary","ml","getMorphTargetIndexByName","uvIntersection","uv1","uv3","barycoord","checkIntersection","intersectionPointWorld","checkBufferGeometryIntersection","intersection","intersectionPoint","uvA","uvB","uvC","tempA","tempB","tempC","fvA","fvB","fvC","isFaceMaterial","faceMaterial","morphInfluences","tl","influence","targets","uvs_f","Bone","skin","Skeleton","boneInverses","useVertexTexture","identityMatrix","boneTextureWidth","boneTextureHeight","boneMatrices","boneTexture","calculateInverses","bl","pose","offsetMatrix","bindMode","bindMatrix","bindMatrixInverse","gbone","pos","rotq","scl","normalizeSkinWeights","sw","vec","skinWeight","getObjectForDistance","matrixPosition","guessSizeSq","LensFlare","lensFlares","positionScreen","customUpdateCallback","updateLensFlares","flare","vecX","vecY","wantedRotation","overrideMaterial","autoUpdate","Fog","FogExp2","density","merged","uniforms_src","uniforms_dst","parameter_src","common","diffuse","offsetRepeat","flipEnvMap","aomap","lightmap","emissivemap","bumpmap","normalmap","displacementmap","roughnessmap","metalnessmap","fogDensity","fogNear","fogFar","fogColor","ambientLightColor","directionalLights","properties","shadowBias","shadowRadius","shadowMapSize","directionalShadowMap","directionalShadowMatrix","spotLights","coneCos","penumbraCos","spotShadowMap","spotShadowMatrix","pointLights","pointShadowMap","pointShadowMatrix","hemisphereLights","ShaderLib","basic","lambert","phong","standard","dashed","totalSize","tCube","tFlip","equirect","tEquirect","distanceRGBA","lightPos","getTargetPixelRatio","_currentRenderTarget","_pixelRatio","glClearColor","_premultipliedAlpha","state","clearColor","setDefaultGLState","scissor","_currentScissor","_scissor","viewport","_currentViewport","_viewport","_clearColor","_clearAlpha","resetGLState","_currentProgram","_currentCamera","_currentGeometryProgram","_currentMaterialId","onContextLost","preventDefault","onMaterialDispose","deallocateMaterial","releaseMaterialProgramReference","programInfo","program","programCache","releaseProgram","setupVertexAttributes","startIndex","extension","initAttributes","geometryAttributes","programAttributes","getAttributes","materialDefaultAttributeValues","programAttribute","geometryAttribute","_gl","FLOAT","UNSIGNED_SHORT","SHORT","UNSIGNED_INT","INT","BYTE","UNSIGNED_BYTE","getAttributeBuffer","enableAttributeAndDivisor","enableAttribute","bindBuffer","ARRAY_BUFFER","vertexAttribPointer","vertexAttrib2fv","vertexAttrib3fv","vertexAttrib4fv","vertexAttrib1fv","disableUnusedAttributes","absNumericalSort","painterSortStable","reversePainterSortStable","pushRenderItem","transparentObjects","transparentObjectsLastIndex","opaqueObjects","opaqueObjectsLastIndex","renderItem","_vector3","isObjectViewable","_sphere","isSphereViewable","isSpriteViewable","_frustum","numPlanes","_clipping","_this","negRad","projectObject","sprites","ImmediateRenderObject","sortObjects","_projScreenMatrix","groupMaterial","renderObjects","renderList","setMaterial","setProgram","renderBufferImmediate","renderBufferDirect","initMaterial","materialProperties","getParameters","_lights","code","getProgramCode","programChange","shaderID","shader","__webglShader","acquireProgram","numSupportedMorphTargets","maxMorphTargets","numSupportedMorphNormals","maxMorphNormals","numClippingPlanes","uniform","lightsHash","ambient","directional","spot","hemi","progUniforms","getUniforms","uniformsList","WebGLUniforms","seqWithValue","seq","dynamicUniforms","splitDynamic","CULL_FACE","setFlipSided","setBlending","setDepthFunc","setDepthTest","setDepthWrite","setColorWrite","setPolygonOffset","_usedTextureUnits","_clippingEnabled","_localClippingEnabled","useCache","setState","refreshProgram","refreshMaterial","refreshLights","p_uniforms","m_uniforms","useProgram","capabilities","logarithmicDepthBuffer","uCamPos","cameraPosition","setOptional","floatVertexTextures","markUniformsLightsNeedsUpdate","refreshUniformsFog","refreshUniformsCommon","refreshUniformsLine","refreshUniformsDash","refreshUniformsPoints","refreshUniformsLambert","refreshUniformsPhong","refreshUniformsPhysical","refreshUniformsStandard","upload","dynUniforms","evalDynamic","uvScaleMap","WebGLRenderTarget","_canvas","clientHeight","setupShadows","lightShadowsLength","shadows","setupLights","ll","viewMatrix","directionalLength","pointLength","spotLength","hemiLength","lightCache","allocTextureUnit","textureUnit","maxTextures","paramThreeToGL","REPEAT","CLAMP_TO_EDGE","MIRRORED_REPEAT","NEAREST","NEAREST_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR","LINEAR_MIPMAP_NEAREST","LINEAR_MIPMAP_LINEAR","UNSIGNED_SHORT_4_4_4_4","UNSIGNED_SHORT_5_5_5_1","UNSIGNED_SHORT_5_6_5","HALF_FLOAT_OES","ALPHA","RGB","RGBA","LUMINANCE","LUMINANCE_ALPHA","DEPTH_COMPONENT","FUNC_ADD","FUNC_SUBTRACT","FUNC_REVERSE_SUBTRACT","ZERO","ONE","SRC_COLOR","ONE_MINUS_SRC_COLOR","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","DST_ALPHA","ONE_MINUS_DST_ALPHA","DST_COLOR","ONE_MINUS_DST_COLOR","SRC_ALPHA_SATURATE","COMPRESSED_RGB_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT3_EXT","COMPRESSED_RGBA_S3TC_DXT5_EXT","COMPRESSED_RGB_PVRTC_4BPPV1_IMG","COMPRESSED_RGB_PVRTC_2BPPV1_IMG","COMPRESSED_RGBA_PVRTC_4BPPV1_IMG","COMPRESSED_RGBA_PVRTC_2BPPV1_IMG","COMPRESSED_RGB_ETC1_WEBGL","MIN_EXT","MAX_EXT","_context","_alpha","_depth","_stencil","stencil","_antialias","antialias","_preserveDrawingBuffer","preserveDrawingBuffer","autoClear","autoClearColor","autoClearDepth","autoClearStencil","localClippingEnabled","gammaInput","gammaOutput","physicallyCorrectLights","toneMapping","toneMappingExposure","toneMappingWhitePoint","_currentFramebuffer","_currentScissorTest","_width","_height","_scissorTest","WebGLClipping","_infoRender","calls","info","memory","programs","getShaderPrecisionFormat","rangeMin","rangeMax","WebGLExtensions","WebGLCapabilities","WebGLState","WebGLProperties","WebGLTextures","WebGLObjects","WebGLPrograms","WebGLLights","bufferRenderer","WebGLBufferRenderer","indexedBufferRenderer","WebGLIndexedBufferRenderer","backgroundCamera","backgroundCamera2","backgroundPlaneMesh","PlaneBufferGeometry","backgroundBoxShader","backgroundBoxMesh","BoxBufferGeometry","WebGLShadowMap","spritePlugin","SpritePlugin","lensFlarePlugin","LensFlarePlugin","getContextAttributes","forceContextLoss","loseContext","getMaxAnisotropy","getPrecision","getPixelRatio","setPixelRatio","getSize","updateStyle","setViewport","setScissor","setScissorTest","boolean","getClearColor","getClearAlpha","setClearAlpha","bits","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","STENCIL_BUFFER_BIT","clearDepth","clearStencil","clearTarget","buffers","hasPositions","createBuffer","hasNormals","hasUvs","hasColors","bufferData","positionArray","DYNAMIC_DRAW","normalArray","nx","ny","nz","uvArray","colorArray","drawArrays","TRIANGLES","updateBuffers","geometryProgram","activeInfluences","getWireframeAttribute","ELEMENT_ARRAY_BUFFER","dataStart","dataCount","rangeStart","rangeCount","groupStart","groupCount","drawStart","drawEnd","drawCount","setLineWidth","setMode","LINES","TRIANGLE_STRIP","TRIANGLE_FAN","lineWidth","LINE_STRIP","POINTS","renderInstances","forceClear","beginShadows","endShadows","updateRenderTargetMipmap","setFaceCulling","cullFace","frontFaceDirection","setCullFace","setTexture2D","warned","slot","setTexture","setTextureCube","setTextureCubeDynamic","getCurrentRenderTarget","__webglFramebuffer","setupRenderTarget","framebuffer","isCube","renderTargetProperties","scissorTest","bindFramebuffer","FRAMEBUFFER","textureProperties","framebufferTexture2D","COLOR_ATTACHMENT0","TEXTURE_CUBE_MAP_POSITIVE_X","__webglTexture","activeMipMapLevel","readRenderTargetPixels","restore","IMPLEMENTATION_COLOR_READ_FORMAT","IMPLEMENTATION_COLOR_READ_TYPE","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","readPixels","depthBuffer","stencilBuffer","depthTexture","drawArraysInstancedANGLE","resetGlobalState","globalState","numGlobalPlanes","projectPlanes","skipTransform","nPlanes","dstArray","flatSize","viewNormalMatrix","i4","renderingShadows","enableLocalClipping","fromCache","nGlobal","lGlobal","clippingState","drawElements","drawElementsInstancedANGLE","gl","getExtension","maxAnisotropy","MAX_TEXTURE_MAX_ANISOTROPY_EXT","getMaxPrecision","VERTEX_SHADER","HIGH_FLOAT","FRAGMENT_SHADER","MEDIUM_FLOAT","MAX_TEXTURE_IMAGE_UNITS","maxVertexTextures","MAX_VERTEX_TEXTURE_IMAGE_UNITS","maxTextureSize","MAX_TEXTURE_SIZE","maxCubemapSize","MAX_CUBE_MAP_TEXTURE_SIZE","maxAttributes","MAX_VERTEX_ATTRIBS","maxVertexUniforms","MAX_VERTEX_UNIFORM_VECTORS","maxVaryings","MAX_VARYING_VECTORS","maxFragmentUniforms","MAX_FRAGMENT_UNIFORM_VECTORS","vertexTextures","floatFragmentTextures","_maxPrecision","WebGLGeometries","onGeometryDispose","buffergeometry","_bufferGeometry","deleteAttribute","deleteAttributes","property","bufferproperty","__webglBuffer","deleteBuffer","removeAttributeBuffer","updateAttribute","attributeProperties","updateBuffer","usage","STATIC_DRAW","bufferSubData","edges","checkEdge","list","WebGLProgram","getEncodingComponents","getTexelDecodingFunction","functionName","getTexelEncodingFunction","getToneMappingFunction","toneMappingName","generateExtensions","rendererExtensions","envMapCubeUV","flatShading","filterEmptyLine","generateDefines","fetchAttributeLocations","identifiers","getProgramParameter","ACTIVE_ATTRIBUTES","getActiveAttrib","getAttribLocation","replaceLightNums","replace","numDirLights","numSpotLights","numPointLights","numHemiLights","parseIncludes","include","unrollLoops","snippet","unroll","programIdCount","shadowMapTypeDefine","shadowMapType","envMapTypeDefine","envMapModeDefine","envMapBlendingDefine","prefixVertex","prefixFragment","gammaFactorDefine","customExtensions","customDefines","createProgram","supportsVertexTextures","maxBones","doubleSided","flipSided","shadowMapEnabled","useFog","fogExp","outputEncoding","mapEncoding","envMapEncoding","emissiveMapEncoding","vertexGlsl","fragmentGlsl","glVertexShader","WebGLShader","glFragmentShader","attachShader","bindAttribLocation","linkProgram","programLog","getProgramInfoLog","vertexLog","getShaderInfoLog","fragmentLog","runnable","haveDiagnostics","LINK_STATUS","getError","VALIDATE_STATUS","diagnostics","prefix","deleteShader","cachedUniforms","cachedAttributes","destroy","deleteProgram","usedTimes","allocateBones","nVertexUniforms","nVertexMatrices","getTextureEncodingFromMap","gammaOverrideLinear","shaderIDs","parameterNames","nClipPlanes","currentRenderTarget","envMapMode","pl","addLineNumbers","lines","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","_renderer","getDepthMaterial","isPointLight","lightPositionWorld","materialVariants","_depthMaterials","customMaterial","customDepthMaterial","_distanceMaterials","customDistanceMaterial","useMorphing","useSkinning","variantIndex","_MorphingFlag","_SkinningFlag","keyA","keyB","materialsForVariant","_materialCache","cachedMaterial","renderSingleSided","renderReverseSided","shadowCamera","_renderList","_state","_lightShadows","_shadowMapSize","_lookTarget","_lightPositionWorld","_NumberOfMaterialVariants","cubeDirections","cubeUps","cube2DViewPorts","depthMaterialTemplate","distanceShader","distanceUniforms","depthMaterial","distanceMaterial","USE_SHADOWMAP","BLEND","faceCount","vpWidth","vpHeight","pars","shadowMatrix","vpDimensions","clearAlpha","createTexture","bindTexture","texParameteri","TEXTURE_MIN_FILTER","TEXTURE_MAG_FILTER","texImage2D","WebGLColorBuffer","WebGLDepthBuffer","WebGLStencilBuffer","maxVertexAttributes","newAttributes","enabledAttributes","attributeDivisors","compressedTextureFormats","currentBlending","currentBlendEquation","currentBlendSrc","currentBlendDst","currentBlendEquationAlpha","currentBlendSrcAlpha","currentBlendDstAlpha","currentPremultipledAlpha","currentFlipSided","currentCullFace","currentLineWidth","currentPolygonOffsetFactor","currentPolygonOffsetUnits","currentScissorTest","currentTextureSlot","currentBoundTextures","currentScissor","currentViewport","emptyTextures","TEXTURE_2D","TEXTURE_CUBE_MAP","DEPTH_TEST","enableVertexAttribArray","vertexAttribDivisorANGLE","disableVertexAttribArray","getCompressedTextureFormats","formats","COMPRESSED_TEXTURE_FORMATS","blendEquationSeparate","blendFuncSeparate","blendFunc","setMask","setTest","setFunc","setStencilTest","stencilTest","setStencilWrite","stencilWrite","setStencilFunc","stencilFunc","stencilRef","stencilMask","setStencilOp","stencilFail","stencilZFail","stencilZPass","setOp","frontFace","CW","CCW","BACK","FRONT","FRONT_AND_BACK","factor","units","POLYGON_OFFSET_FILL","getScissorTest","SCISSOR_TEST","activeTexture","webglSlot","TEXTURE0","webglType","webglTexture","boundTexture","compressedTexImage2D","setClear","locked","currentColorMask","currentColorClear","colorMask","setLocked","lock","currentDepthMask","currentDepthFunc","currentDepthClear","depthMask","NEVER","ALWAYS","LESS","LEQUAL","EQUAL","GEQUAL","GREATER","NOTEQUAL","currentStencilMask","currentStencilFunc","currentStencilRef","currentStencilFuncMask","currentStencilFail","currentStencilZFail","currentStencilZPass","currentStencilClear","STENCIL_TEST","stencilOp","clampToMaxSize","maxSize","makePowerOfTwo","HTMLImageElement","HTMLCanvasElement","textureNeedsPowerOfTwo","filterFallback","onTextureDispose","deallocateTexture","_infoMemory","onRenderTargetDispose","deallocateRenderTarget","__image__webglTextureCube","deleteTexture","__webglInit","deleteFramebuffer","__webglDepthbuffer","deleteRenderbuffer","__version","complete","uploadTexture","pixelStorei","UNPACK_FLIP_Y_WEBGL","isCompressed","isDataTexture","cubeImage","isPowerOfTwoImage","glFormat","glType","setTextureParameters","mipmap","generateMipmap","textureType","TEXTURE_WRAP_S","TEXTURE_WRAP_T","__currentAnisotropy","texParameterf","TEXTURE_MAX_ANISOTROPY_EXT","UNPACK_PREMULTIPLY_ALPHA_WEBGL","UNPACK_ALIGNMENT","internalFormat","_isWebGL2","DEPTH_COMPONENT32F","DEPTH_COMPONENT16","setupFrameBufferTexture","attachment","textureTarget","setupRenderBufferStorage","renderbuffer","bindRenderbuffer","RENDERBUFFER","renderbufferStorage","framebufferRenderbuffer","DEPTH_ATTACHMENT","DEPTH_STENCIL","DEPTH_STENCIL_ATTACHMENT","RGBA4","setupDepthTexture","webglDepthTexture","setupDepthRenderbuffer","createRenderbuffer","isTargetPowerOfTwo","createFramebuffer","WebGL2RenderingContext","emptyTexture","emptyCubeTexture","UniformContainer","arrayCacheF32","arrayCacheI32","flatten","nBlocks","blockSize","firstElem","allocTexUnits","setValue1f","uniform1f","addr","setValue1i","uniform1i","setValue2fv","uniform2fv","uniform2f","setValue3fv","uniform3f","uniform3fv","setValue4fv","uniform4fv","uniform4f","setValue2fm","uniformMatrix2fv","setValue3fm","uniformMatrix3fv","setValue4fm","uniformMatrix4fv","setValueT1","unit","setValueT6","setValue2iv","uniform2iv","setValue3iv","uniform3iv","setValue4iv","uniform4iv","getSingularSetter","setValue1fv","uniform1fv","setValue1iv","uniform1iv","setValueV2a","setValueV3a","setValueV4a","setValueM2a","setValueM3a","setValueM4a","setValueT1a","setValueT6a","getPureArraySetter","SingleUniform","activeInfo","PureArrayUniform","StructuredUniform","RePathPart","addUniform","container","uniformObject","parseUniform","pathLength","matchEnd","idIsIndex","subscript","next","ACTIVE_UNIFORMS","getActiveUniform","getUniformLocation","flares","vertexBuffer","elementBuffer","tempTexture","occlusionTexture","renderType","occlusionMap","screenPosition","tempPosition","invAspect","halfViewportWidth","halfViewportHeight","screenPositionPixels","validArea","TEXTURE1","copyTexImage2D","uvOffset","uvScale","fogType","fillStyle","fillRect","spritePosition","spriteRotation","spriteScale","oldFogType","sceneFogType","Face4","LineStrip","LinePieces","MeshFaceMaterial","Particle","ParticleSystem","PointCloudMaterial","ParticleBasicMaterial","ParticleSystemMaterial","Vertex","isIntersectionBox","isIntersectionSphere","multiplyVector3","multiplyVector3Array","extractPosition","multiplyVector4","rotateAxis","crossVector","rotateByAxis","isIntersectionLine","isIntersectionPlane","setEulerFromRotationMatrix","setEulerFromQuaternion","getPositionFromMatrix","getScaleFromMatrix","getColumnFromMatrix","getChildByName","renderDepth","eulerOrder","useQuaternion","setLens","onlyShadow","shadowCameraFov","shadowCameraLeft","shadowCameraRight","shadowCameraTop","shadowCameraBottom","shadowCameraNear","shadowCameraFar","shadowCameraVisible","shadowDarkness","shadowMapWidth","shadowMapHeight","addIndex","addDrawCall","indexOffset","clearDrawCalls","computeOffsets","wrapAround","wrapRGB","metal","supportsFloatTextures","supportsHalfFloatTextures","supportsStandardDerivatives","supportsCompressedTextureS3TC","supportsCompressedTexturePVRTC","supportsBlendMinMax","supportsInstancedArrays","enableScissorTest","addPrePlugin","addPostPlugin","updateShadowMap","shadowMapCullFace","audioLoader","getData","GeometryUtils","geometry1","loadTextureCube","loadCompressedTexture","loadCompressedTextureCube","Projector","projectVector","unprojectVector","pickingRay","CanvasRenderer","CurveUtils","tangentQuadraticBezier","tangentCubicBezier","tangentSpline","h00","h10","h01","h11","SceneUtils","createMultiMaterialObject","detach","attach","ShapeUtils","contour","triangulate","snip","verts","px","py","aX","aY","bX","bY","cX","cY","apx","apy","bpx","bpy","cpx","cpy","cCROSSap","bCROSScp","aCROSSbp","vertIndices","nv","triangulateShape","holes","point_in_segment_2D_colin","inSegPt1","inSegPt2","inOtherPt","intersect_segments_2D","inSeg1Pt1","inSeg1Pt2","inSeg2Pt1","inSeg2Pt2","inExcludeAdjacentSegs","seg1dx","seg1dy","seg2dx","seg2dy","seg1seg2dx","seg1seg2dy","perpSeg1","perpSeg2","factorSeg1","seg1Pt","seg2Pt","seg1min","seg1max","seg1minVal","seg1maxVal","seg2min","seg2max","seg2minVal","seg2maxVal","isPointInsideAngle","inVertex","inLegFromPt","inLegToPt","legFromPtX","legFromPtY","legToPtX","legToPtY","otherPtX","otherPtY","from2toAngle","from2otherAngle","other2toAngle","removeHoles","isCutLineInsideAngles","inShapeIdx","inHoleIdx","lastShapeIdx","shape","prevShapeIdx","nextShapeIdx","insideAngle","hole","lastHoleIdx","prevHoleIdx","nextHoleIdx","intersectsShapeEdge","inShapePt","inHolePt","sIdx","nextIdx","intersectsHoleEdge","ihIdx","chkHole","hIdx","indepHoles","holeIndex","shapeIndex","shapePt","holePt","holeIdx","cutKey","tmpShape1","tmpShape2","tmpHole1","tmpHole2","failedCuts","hl","minShapeIndex","counter","h2","allPointsMap","allpoints","shapeWithoutHoles","triangles","isClockWise","pts","b2p0","b2p1","b2p2","b3","b3p0","b3p1","b3p2","b3p3","Curve","getPointAt","getUtoTmapping","getPoints","divisions","getSpacedPoints","lengths","getLengths","cacheArcLengths","current","sum","updateArcLengths","targetArcLength","arcLengths","comparison","lengthBefore","lengthAfter","segmentLength","segmentFraction","getTangent","pt1","pt2","getTangentAt","getPointFunc","CurvePath","curves","autoClose","curve","closePath","startPoint","endPoint","LineCurve","curveLengths","getCurveLengths","lens","cacheLengths","sums","createPointsGeometry","createGeometry","createSpacedPointsGeometry","generateShapes","createPaths","String","resolution","ret","createPath","glyph","glyphs","cpx0","cpy0","cpx1","cpy1","cpx2","cpy2","laste","Path","outline","_cachedOutline","moveTo","lineTo","quadraticCurveTo","bezierCurveTo","ha","shapes","toShapes","fromPoints","args","lastargs","aCPx","aCPy","QuadraticBezierCurve","aCP1x","aCP1y","aCP2x","aCP2y","CubicBezierCurve","splineThru","npts","SplineCurve","lastPoint","aRadius","aStartAngle","aEndAngle","aClockwise","absarc","absellipse","ellipse","xRadius","yRadius","aRotation","EllipseCurve","item","spts","spline","deltaAngle","tdivisions","isCCW","noHoles","extractSubpaths","inActions","subPaths","lastPath","toShapesNoHoles","inSubpaths","tmpPath","tmpShape","Shape","isPointInsidePolygon","inPt","inPolygon","polyLen","inside","edgeLowPt","edgeHighPt","edgeDx","edgeDy","perpEdge","solid","holesFirst","tmpPoints","betterShapeHoles","newShapes","newShapeHoles","mainIdx","ambiguous","toChange","sLen","sho","ho","hole_unassigned","s2Idx","froms","tos","tmpHoles","extrude","ExtrudeGeometry","makeGeometry","ShapeGeometry","getPointsHoles","holesPts","extractAllPoints","extractPoints","tangent","point0","point1","point2","point3","ArcCurve","LineCurve3","QuadraticBezierCurve3","CubicBezierCurve3","SplineCurve3","CatmullRomCurve3","CubicPoly","pz","c0","initNonuniformCatmullRom","x3","dt0","dt1","dt2","initCatmullRom","tension","calc","closed","ClosedSplineCurve3","CubeGeometry","calculateVertexCount","calculateIndexCount","buildPlane","udir","vdir","gridX","gridY","segmentWidth","segmentHeight","widthHalf","heightHalf","depthHalf","gridX1","gridY1","vertexCounter","vertexBufferOffset","uvBufferOffset","numberOfVertices","indexBufferOffset","vertexCount","indexCount","CircleGeometry","CircleBufferGeometry","ii","segment","CylinderBufferGeometry","nbCap","generateTorso","tanTheta","indexRow","halfHeight","indexArray","i3","generateCap","centerIndexStart","centerIndexEnd","cosTheta","sinTheta","CylinderGeometry","ConeBufferGeometry","ConeGeometry","EdgesGeometry","thresholdAngle","sortFunction","thresholdDot","edge","vert1","vert2","face1","face2","addShapeList","addShape","scalePt2","pt","getBevelVec","inPrev","inNext","v_trans_x","v_trans_y","shrink_by","v_prev_x","v_prev_y","v_next_x","v_next_y","v_prev_lensq","collinear0","v_prev_len","v_next_len","ptPrevShift_x","ptPrevShift_y","ptNextShift_x","ptNextShift_y","sf","v_trans_lensq","direction_eq","buildLidFaces","bevelEnabled","layer","vlen","flen","f3","steps","bevelSegments","buildSideFaces","layeroffset","sidewalls","ahole","slen1","slen2","f4","shapesOffset","uvgen","generateTopUV","wallContour","stepIndex","stepsLength","contourIndex1","contourIndex2","generateSideWallUV","extrudePts","splineTube","binormal","position2","amount","bevelThickness","bevelSize","curveSegments","extrudePath","extrudeByPath","UVGenerator","WorldUVGenerator","frames","TubeGeometry","FrenetFrames","shapePoints","reverse","bs","vert","contourMovements","oneHoleMovements","holesMovements","verticesMovements","binormals","indexA","indexB","indexC","indexD","LatheBufferGeometry","base","inverseSegments","n1","n2","LatheGeometry","PlaneGeometry","width_half","height_half","segment_width","segment_height","offset2","RingBufferGeometry","radiusStep","thetaSegmentLevel","RingGeometry","SphereGeometry","SphereBufferGeometry","thetaEnd","verticesRow","v4","TextGeometry","TorusBufferGeometry","TorusGeometry","TorusKnotBufferGeometry","calculatePositionOnCurve","cu","su","quOverP","cs","P1","P2","B","T","N","TorusKnotGeometry","heightScale","taper","NoTaper","ip","jp","uva","uvb","uvc","uvd","grid","numpoints","pos2","tangents","SinusoidalTaper","initialNormal3","smallest","MAX_VALUE","tz","mat","PolyhedronGeometry","prepare","that","azimuth","inclination","make","centroid","azi","correctUV","subdivide","cols","aj","bj","rows","DodecahedronGeometry","IcosahedronGeometry","OctahedronGeometry","TetrahedronGeometry","ParametricGeometry","func","slices","stacks","sliceCount","WireframeGeometry","numEdges","ol","numTris","AxisHelper","ArrowHelper","lineGeometry","coneGeometry","headLength","headWidth","cone","setDirection","setColor","BoxHelper","BoundingBoxHelper","CameraHelper","addLine","addPoint","pointMap","hexFrustum","hexCone","hexUp","hexTarget","hexCross","setPoint","DirectionalLightHelper","lightPlane","targetLine","EdgesHelper","FaceNormalsHelper","nNormals","objGeometry","GridHelper","setColors","HemisphereLightHelper","sphereSize","lightSphere","PointLightHelper","SkeletonHelper","getBoneList","boneList","matrixWorldInv","boneMatrix","SpotLightHelper","vector2","coneLength","coneWidth","VertexNormalsHelper","objPos","objNorm","WireframeHelper","renderCallback","MorphBlendMesh","animationsMap","animationsList","numFrames","startFrame","endFrame","createAnimation","setAnimationWeight","lastFrame","currentFrame","active","directionBackwards","mirroredLoop","autoCreateAnimations","firstAnimation","frameRanges","morph","setAnimationDirectionForward","setAnimationDirectionBackward","setAnimationFPS","setAnimationDuration","setAnimationTime","getAnimationTime","getAnimationDuration","playAnimation","stopAnimation","keyframe","Promise$2","executor","PENDING","deferred","promise","resolve","reject","Promise$1","PromiseObj","Util","Vue","util","debug","config","silent","nextTick","ctx","str","isString","val","isBoolean","isFunction","isObject","isPlainObject","getPrototypeOf","isFormData","FormData","when","fulfilled","rejected","fn","opts","$vm","$options","each","iterator","forEach","_merge","defaults","_assign","deep","query","urlParams","Url","expand","variables","tmpl","expanded","vars","operators","expression","literal","operator","substr","variable","getValues","separator","encodeReserved","modifier","isDefined","encodeValue","isKeyOperator","encodeURIComponent","part","encodeURI","transform","self","transforms","handler","factory","vm","serialize","plain","xdrClient","xdr","XDomainRequest","respondWith","responseText","statusText","abort","getUrl","timeout","onerror","ontimeout","onprogress","getBody","cors","SUPPORTS_CORS","client","emulateHTTP","requestUrl","protocol","ORIGIN_URL","host","emulateJSON","headers","contentType","jsonpClient","script","jsonp","removeChild","createElement","async","before","header","toUpperCase","Http","custom","cancel","clearTimeout","xhrClient","parseHeaders","getAllResponseHeaders","progress","credentials","setRequestHeader","row","Client","reqHandlers","resHandlers","unshift","sendRequest","interceptors","Request","ok","Resource","resource","plugin","installed","http","Promise","$url","$resource","$promise","RESOLVED","REJECTED","all","iterable","resolver","race","p$1","called","notify","reason","onResolved","onRejected","ie","documentMode","escape","href","port","hostname","pathname","search","location","classCallCheck","instance","Constructor","Response","_ref","Blob","CUSTOM_HEADERS","X-Requested-With","COMMON_HEADERS","Accept","JSON_CONTENT_TYPE","Content-Type","put","post","patch","delete","save","global","hasOwn","_isVue","_data","ob","__ob__","convert","dep","vms","_proxy","_digest","del","_unproxy","isLiteral","exp","literalValueRE","isReserved","charCodeAt","_toString","toNumber","parsed","toBoolean","stripQuotes","camelize","camelizeRE","toUpper","hyphenate","hyphenateRE","classify","classifyRE","OBJECT_STRING","def","writable","configurable","_debounce","wait","timestamp","later","arr","cancellable","cancelled","looseEqual","head","tail","_keymap","pushFilter","lastFilterIndex","tokens","filterTokenRE","processFilterArg","arg","reservedArgRE","stripped","parseDirective","hit","cache$1","inSingle","inDouble","curly","square","paren","prev","escapeRegex","regexEscapeRE","compileRegex","delimiters","close","unsafeOpen","unsafeDelimiters","unsafeClose","tagRE","RegExp","htmlRE","parseText","html","first","oneTime","tag","tokensToExp","token","formatToken","single","$eval","inlineFilters","filterRE","appendWithTransition","applyTransition","beforeWithTransition","removeWithTransition","op","transition","__v_trans","hooks","transitionEndEvent","_isCompiled","$parent","querySelector","inDoc","doc","ownerDocument","documentElement","parentNode","nodeType","contains","getAttr","_attr","getBindAttr","hasBindAttr","hasAttribute","insertBefore","after","nextSibling","prepend","firstChild","replaceChild","on","useCapture","off","getClass","classname","className","baseVal","setClass","cls","isIE9","namespaceURI","setAttribute","addClass","classList","cur","removeClass","tar","extractContent","asFragment","rawContent","isTemplate","isFragment","content","hasChildNodes","trimNode","createDocumentFragment","isTrimmable","lastChild","tagName","createAnchor","persist","anchor","createComment","createTextNode","__v_anchor","findRef","hasAttributes","attrs","refRE","mapNodeRange","removeNodeRange","frag","onRemoved","removed","done","nodes","getOuterHTML","outerHTML","cloneNode","innerHTML","checkComponentAttr","hasAttrs","commonTagRE","reservedTagRE","getIsBinding","resolveAsset","is","mergeData","toVal","fromVal","mergeAssets","parentVal","childVal","res","guardArrayAssets","guardComponents","ids","guardProps","props","assets","asset","mergeOptions","mergeField","strat","strats","defaultStrat","mixins","mixin","mixinOptions","warnMissing","camelizedId","Dep","uid$1","subs","withoutConversion","shouldConvert","Observer","augment","hasProto","protoAugment","copyAugment","arrayMethods","arrayKeys","observeArray","walk","__proto__","observe","isExtensible","addVm","defineReactive","getOwnPropertyDescriptor","getter","setter","childOb","depend","newVal","initMixin","_init","$el","$root","$children","$refs","$els","_watchers","_directives","_uid","uid","_events","_eventsCount","_isFragment","_fragment","_fragmentStart","_fragmentEnd","_isDestroyed","_isReady","_isAttached","_isBeingDestroyed","_vForRemoving","_unlinkFn","_scope","_frag","_updateRef","_callHook","_initState","_initEvents","$mount","getPathCharType","ch","formatSubPath","trimmed","maybeUnescapeQuote","nextChar","IN_SINGLE_QUOTE","IN_DOUBLE_QUOTE","newChar","APPEND","typeMap","BEFORE_PATH","subPathDepth","PUSH","INC_SUB_PATH_DEPTH","PUSH_SUB_PATH","IN_SUB_PATH","pathStateMachine","ERROR","AFTER_PATH","raw","parsePath","pathCache","getPath","parseExpression","original","$set","noop","saved","newlineRE","rewrite","allowedKeywordsRE","restoreRE","compileGetter","improperKeywordsRE","saveRE","wsRE","identRE","makeGetterFn","compileSetter","needSet","expressionCache","isSimplePath","pathTestRE","literalValueRE$1","resetBatcherState","queue","userQueue","has","circular","waiting","flushBatcherQueue","_again","runBatcherQueue","devtools","emit","watcher","run","pushWatcher","Watcher","expOrFn","isFn","uid$2","dirty","lazy","deps","newDeps","depIds","_Set","newDepIds","prevError","twoWay","queued","shallow","seen","seenObjects","isA","isO","depId","isRealTemplate","stringToFragment","templateString","cacheKey","templateCache","tagMatch","tagRE$1","entityMatch","entityRE","commentMatch","commentRE","efault","suffix","nodeToFragment","textContent","clonedNode","querySelectorAll","cloned","hasBrokenTemplate","tempClone","hasTextareaCloneBug","parseTemplate","shouldClone","idSelectorCache","Fragment","linker","parentFrag","childFrags","inserted","unlink","childNodes","singleBefore","singleRemove","multiBefore","multiRemove","__v_frag","withTransition","callHook","shouldCallRemove","beforeRemove","FragmentFactory","cid","cacheId","linkerCache","compile","findPrevFrag","previousSibling","forId","findVmFromFrag","__vue__","getTrackByKey","trackByKey","multi","selected","_value","indexOf$1","keyFilter","codes","charCode","keyCodes","keyCode","stopFilter","stopPropagation","preventFilter","selfFilter","currentTarget","prop","propCache","camel","upper","testEl","prefixed","prefixes","kebab","camelPrefixes","normalize$1","_key","callActivateHooks","compileProps","propOptions","attr","names","identRE$1","propBindingModes","ONE_WAY","TWO_WAY","ONE_TIME","optimizedLiteral","parentPath","makePropsLinkFn","_props","inlineProps","propsData","initProp","$get","_bindDir","propDef","Boolean","processPropValue","rawValue","isSimple","getPropDefaultValue","coerceProp","coerced","assertProp","updateProp","required","expectedTypes","assertedType","assertType","expectedType","validator","coerce","pushJob","job","queue$1","flush","offsetHeight","Transition","enterClass","leaveClass","pendingCssEvent","pendingCssCb","pendingJsCb","justEntered","entered","typeCache","isHidden","rect","getBoundingClientRect","getClientRects","partial","nodeLinkFn","_asComponent","compileNode","childLinkFn","terminal","isScript","compileNodeList","dirs","linkAndCapture","makeUnlinkFn","originalDirCount","directiveComparator","_bind","descriptor","priority","DEFAULT_PRIORITY","contextDirs","destroying","teardownDirs","_teardown","compileAndLinkProps","propsLinkFn","propDirs","compileRoot","contextOptions","contextLinkFn","replacerLinkFn","containerAttrs","_containerAttrs","replacerAttrs","_replacerAttrs","compileDirectives","selfDirs","compileTextNode","compileElement","linkFn","checkTerminalDirectives","checkElementDirectives","checkComponent","_skip","removeText","wholeText","processTextToken","makeTextNodeLinkFn","setTokenType","directives","fragClone","nodeList","linkFns","makeChildLinkFn","childrenLinkFn","makeTerminalNodeLinkFn","ref","internalDirectives","modifiers","componentLinkFn","skip","previousElementSibling","matched","dirName","rawName","termDef","modifierRE","dirAttrRE","DEFAULT_TERMINAL_PRIORITY","parseModifiers","pushDir","interpTokens","hasOneTimeToken","hasOneTime","interp","dirDef","transitionRE","bindRE","onRE","makeNodeLinkFn","transclude","extractAttrs","_content","transcludeTemplate","replacer","mergeAttrs","specialCharRE","resolveSlots","contents","_slotContents","extractFragment","stateMixin","makeComputedGetter","owner","newData","_setData","_initProps","_initMeta","_initMethods","_initData","_initComputed","_propsUnlinkFn","dataFn","oldData","removeVm","computed","userDef","methods","metas","_meta","eventsMixin","registerComponentEvents","eventRE","_fromParent","$on","registerCallbacks","register","onAttached","callAttach","onDetached","callDetach","events","watch","_initDOMHooks","hook","$emit","noop$1","Directive","_locked","_bound","_host","lifecycleMixin","refs","_compile","_initElement","rootLinker","contentLinkFn","ctor","_linkerCachable","rootUnlinkFn","contentUnlinkFn","_destroy","deferCleanup","_cleanup","destroyReady","pendingRemoval","cleanupIfPossible","$remove","$destroy","teardown","$off","miscMixin","_applyFilters","oldValue","write","read","_resolveComponent","resolved","requested","pendingCallbacks","cbs","dataAPI","clean","asStatement","$arguments","$delete","$watch","sync","immediate","filterRE$1","$interpolate","$log","domAPI","insert","op1","op2","targetIsDetached","shouldCallHook","append","beforeWithCb","removeWithCb","$nextTick","$appendTo","$prependTo","$before","$after","inDocument","realCb","eventsAPI","modifyListenerCount","hookRE","$once","isSource","shouldPropagate","hasParentCbs","some","$broadcast","$dispatch","lifecycleAPI","$compile","limitBy","filterBy","delimiter","$value","$key","orderBy","baseCompare","sortKeyIndex","sortKey","sortKeys","comparator","firstArg","installGlobalAPI","createClass","elementDirectives","transitions","partials","compiler","parsers","directive","extendOptions","Super","isFirstExtend","_Ctor","Sub","_assetTypes","install","definition","inBrowser","__VUE_DEVTOOLS_GLOBAL_HOOK__","UA","navigator","userAgent","isIE","isAndroid","isIos","iosVersionMatch","iosVersion","hasMutationObserverBug","indexedDB","transitionProp","animationProp","animationEndEvent","isWebkitTrans","ontransitionend","onwebkittransitionend","isWebkitAnim","onanimationend","onwebkitanimationend","nextTickHandler","copies","callbacks","timerFunc","MutationObserver","setImmediate","observer","textNode","characterData","Set","entry","newer","older","returnEntry","freeze","warnExpressionErrors","_delimitersChanged","_propBindingModes","_maxUpdateCount","optionMergeStrategies","instanceData","defaultData","created","attached","detached","beforeCompile","compiled","beforeDestroy","destroyed","activate","addSub","removeSub","addDep","arrayProto","getOwnPropertyNames","items","debounce","IN_PATH","BEFORE_IDENT","IN_IDENT","ws","ident","[","eof",".","0","number","'","\"","]","else","allowedKeywords","improperKeywords","beforeGet","preProcess","postProcess","afterGet","forContext","$forContext","alias","_withLock","$index","text$1","legend","tr","col","td","th","option","optgroup","thead","tbody","colgroup","caption","tfoot","defs","symbol","circle","polygon","polyline","placeholder","swap","_watcher","ON","MODEL","BIND","TRANSITION","EL","COMPONENT","PARTIAL","IF","FOR","SLOT","uid$3","vFor","inMatch","itMatch","isOption","updateRef","updateModel","primitive","convertedFromObject","fromObject","trackBy","oldFrags","frags","getCachedFrag","reused","fresh","removalIndex","totalRemoved","deleteCachedFrag","targetPrev","prevEl","currentPrev","insertionIndex","staggerCb","staggerAnchor","move","parentScope","cacheFrag","model","__v_model","forceUpdate","staggerAmount","getStagger","trans","stagger","_preProcess","_postProcess","vIf","invalid","nextElementSibling","elseEl","elseFrag","elseFactory","show","display","text$2","isRange","composing","focused","rawListener","hasjQuery","jQuery","afterBind","radio","checked","select","multiple","initValue","selectedIndex","checkbox","getBooleanValue","_trueValue","_falseValue","checkFilters","hasRead","hasWrite","_unbind","esc","tab","enter","space","down","on$1","acceptStatement","iframeBind","contentWindow","capture","prevent","importantRE","cssText","handleObject","reduce","handleSingle","isImportant","setProperty","xlinkNS","xlinkRE","disallowedInterpAttrRE","attrWithPropsRE","enumeratedAttrRE","modelProps","true-value","false-value","bind$1","attrValue","modelProp","setAttributeNS","cloak","for","if","vClass","cleanup","prevKeys","keepAlive","inlineTemplate","pendingComponentCb","Component","pendingRemovals","pendingRemovalCb","invalidatePending","resolveComponent","mountComponent","unbuild","childVM","ComponentName","activateHooks","getCached","newComponent","build","waitingFor","extraOptions","_isRouterView","defer","_inactive","transitionMode","bindingModes","childKey","parentKey","parentWatcher","childWatcher","TYPE_TRANSITION","TYPE_ANIMATION","transDurationProp","animDurationProp","raf","waitForTransitionStart","cancelPending","callHookWithCb","enterCancelled","enterNextTick","enterDone","getCssTransitionType","setupCssCb","leave","leaveCancelled","leaveDone","leaveNextTick","hasPending","hidden","css","inlineStyles","computedStyles","getComputedStyle","transDuration","animDuration","onEnd","transition$1","oldId","class","_setupParams","_checkStatement","oldVal","mappedKey","_setupParamWatcher","unwatch","paramWatchers","_paramUnwatchFns","$event","unwatchFns","fallback","elseBlock","digitsRE","indent","capitalize","uppercase","lowercase","currency","_currency","decimals","stringified","toFixed","_int","_float","pluralize","delay"],"mappings":"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","file":"build.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _vue = __webpack_require__(3);\n\t\n\tvar _vue2 = _interopRequireDefault(_vue);\n\t\n\tvar _vueResource = __webpack_require__(2);\n\t\n\tvar _vueResource2 = _interopRequireDefault(_vueResource);\n\t\n\tvar _three = __webpack_require__(1);\n\t\n\tvar _three2 = _interopRequireDefault(_three);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t_vue2.default.use(_vueResource2.default);\n\t\n\tvar AlbumCube = _vue2.default.extend({\n\t  template: ' <div id=\"main\"></div>'\n\t});\n\t\n\t_vue2.default.component('app', AlbumCube);\n\t\n\tnew _vue2.default({\n\t  el: 'body',\n\t  components: { AlbumCube: AlbumCube },\n\t  ready: function ready() {\n\t    var renderer = void 0,\n\t        scene = void 0,\n\t        camera = void 0,\n\t        stats = void 0,\n\t        cameraControl = void 0,\n\t        cube = void 0;\n\t\n\t    function init() {\n\t\n\t      _three2.default.ImageUtils.crossOrigin = '';\n\t\n\t      scene = new _three2.default.Scene();\n\t\n\t      camera = new _three2.default.PerspectiveCamera(35, document.getElementById('main').offsetWidth / window.innerHeight, 0.1, 1000);\n\t\n\t      renderer = new _three2.default.WebGLRenderer();\n\t      renderer.setClearColor(0x000000, 1.0);\n\t      renderer.setSize(document.getElementById('main').offsetWidth, window.innerHeight - 10);\n\t      renderer.shadowMap.enabled = true;\n\t\n\t      document.getElementById('main').appendChild(renderer.domElement);\n\t\n\t      var ambientLight = new _three2.default.AmbientLight(0x000000);\n\t      scene.add(ambientLight);\n\t\n\t      var lights = [];\n\t      lights[0] = new _three2.default.PointLight(0xffffff, 1, 0);\n\t      lights[1] = new _three2.default.PointLight(0xffffff, 1, 0);\n\t      lights[2] = new _three2.default.PointLight(0xffffff, 1, 0);\n\t      lights[0].position.set(0, 200, 0);\n\t      lights[1].position.set(100, 200, 100);\n\t      lights[2].position.set(-100, -200, -100);\n\t\n\t      scene.add(lights[0]);\n\t      scene.add(lights[1]);\n\t      scene.add(lights[2]);\n\t\n\t      var geometry = new _three2.default.BoxGeometry(1, 1, 1);\n\t      var material = new _three2.default.MeshLambertMaterial({ color: 0x6C6C6C, transparent: true, opacity: 0.7 });\n\t      cube = new _three2.default.Mesh(geometry, material);\n\t      scene.add(cube);\n\t      camera.position.z = 5;\n\t\n\t      render();\n\t    }\n\t\n\t    function render() {\n\t      requestAnimationFrame(render);\n\t      cube.rotation.x += 0.01;\n\t      cube.rotation.y += 0.01;\n\t      renderer.render(scene, camera);\n\t    }\n\t\n\t    function handleResize() {\n\t      camera.aspect = document.getElementById('main').offsetWidth / window.innerHeight;\n\t      camera.updateProjectionMatrix();\n\t      renderer.setSize(document.getElementById('main').offsetWidth, window.innerHeight - 10);\n\t    }\n\t\n\t    window.onload = init;\n\t\n\t    window.addEventListener('resize', handleResize, false);\n\t\n\t    function componentToHex(c) {\n\t      var hex = c.toString(16);\n\t      return hex.length == 1 ? \"0\" + hex : hex;\n\t    }\n\t\n\t    function rgbToHex(rgb) {\n\t      var c = '';\n\t      for (var i = 0; i < 3; i++) {\n\t        c += componentToHex(rgb[i]);\n\t      }\n\t      return c;\n\t    }\n\t\n\t    function intervalTexture(datas) {\n\t      var file = datas.shift();\n\t      datas.push(file);\n\t      var loader = new _three2.default.TextureLoader();\n\t      loader.load('http://162.243.40.125/albums/' + file, function (texture) {\n\t        cube.material.map = texture;\n\t        cube.material.needsUpdate = true;\n\t      }, function (xhr) {}, function (xhr) {\n\t        console.log('An error happened');\n\t      });\n\t      var url = 'http://162.243.40.125/albums/' + file;\n\t      var albumColors = new AlbumColors(url);\n\t\n\t      albumColors.getColors(function (colors) {\n\t\n\t        renderer.setClearColor(parseInt(rgbToHex(colors[0]), 16), 1.0);\n\t        document.body.style.background = '#' + rgbToHex(colors[0]);\n\t        document.body.style.color = '#' + rgbToHex(colors[1]);\n\t        document.getElementsByTagName('header')[0].firstElementChild.style.color = '#' + rgbToHex(colors[2]);\n\t      });\n\t    }\n\t\n\t    var APIkey = \"4dff88a0423651b3570253b10b745b2c\",\n\t        Limit = 100,\n\t        Page = 1,\n\t        User = \"fakelbst\";\n\t\n\t    this.$http.get(\"http://ws.audioscrobbler.com/2.0/\", {\n\t      params: {\n\t        method: 'user.gettopalbums',\n\t        format: 'json',\n\t        user: User,\n\t        api_key: APIkey,\n\t        limit: Limit,\n\t        page: 1\n\t      }\n\t    }).then(function (d) {\n\t      var datas = d.json();\n\t      var allCovers = [];\n\t      var albums = datas.topalbums.album;\n\t      var src = albums[0].image[3]['#text'];\n\t      for (var i = 0, j = albums.length; i < j; i++) {\n\t        var title = albums[i].name.split(' ').join('-');\n\t        var ext = albums[i].image[3]['#text'].split('.').pop();\n\t        allCovers.push(title + '.' + ext);\n\t      }\n\t      setInterval(function () {\n\t        intervalTexture(allCovers);\n\t      }, 6000);\n\t    });\n\t  }\n\t});\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;// File:src/Three.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tvar THREE = { REVISION: '78' };\n\t\n\t//\n\t\n\tif ( true ) {\n\t\n\t\t!(__WEBPACK_AMD_DEFINE_FACTORY__ = (THREE), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t\n\t} else if ( 'undefined' !== typeof exports && 'undefined' !== typeof module ) {\n\t\n\t\tmodule.exports = THREE;\n\t\n\t}\n\t\n\t// Polyfills\n\t\n\tif ( Number.EPSILON === undefined ) {\n\t\n\t\tNumber.EPSILON = Math.pow( 2, - 52 );\n\t\n\t}\n\t\n\t//\n\t\n\tif ( Math.sign === undefined ) {\n\t\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\n\t\n\t\tMath.sign = function ( x ) {\n\t\n\t\t\treturn ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;\n\t\n\t\t};\n\t\n\t}\n\t\n\tif ( Function.prototype.name === undefined ) {\n\t\n\t\t// Missing in IE9-11.\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\n\t\n\t\tObject.defineProperty( Function.prototype, 'name', {\n\t\n\t\t\tget: function () {\n\t\n\t\t\t\treturn this.toString().match( /^\\s*function\\s*(\\S*)\\s*\\(/ )[ 1 ];\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t}\n\t\n\tif ( Object.assign === undefined ) {\n\t\n\t\t// Missing in IE.\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n\t\n\t\t( function () {\n\t\n\t\t\tObject.assign = function ( target ) {\n\t\n\t\t\t\t'use strict';\n\t\n\t\t\t\tif ( target === undefined || target === null ) {\n\t\n\t\t\t\t\tthrow new TypeError( 'Cannot convert undefined or null to object' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar output = Object( target );\n\t\n\t\t\t\tfor ( var index = 1; index < arguments.length; index ++ ) {\n\t\n\t\t\t\t\tvar source = arguments[ index ];\n\t\n\t\t\t\t\tif ( source !== undefined && source !== null ) {\n\t\n\t\t\t\t\t\tfor ( var nextKey in source ) {\n\t\n\t\t\t\t\t\t\tif ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {\n\t\n\t\t\t\t\t\t\t\toutput[ nextKey ] = source[ nextKey ];\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn output;\n\t\n\t\t\t};\n\t\n\t\t} )();\n\t\n\t}\n\t\n\t//\n\t\n\tObject.assign( THREE, {\n\t\n\t\t// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button\n\t\n\t\tMOUSE: { LEFT: 0, MIDDLE: 1, RIGHT: 2 },\n\t\n\t\t// GL STATE CONSTANTS\n\t\n\t\tCullFaceNone: 0,\n\t\tCullFaceBack: 1,\n\t\tCullFaceFront: 2,\n\t\tCullFaceFrontBack: 3,\n\t\n\t\tFrontFaceDirectionCW: 0,\n\t\tFrontFaceDirectionCCW: 1,\n\t\n\t\t// SHADOWING TYPES\n\t\n\t\tBasicShadowMap: 0,\n\t\tPCFShadowMap: 1,\n\t\tPCFSoftShadowMap: 2,\n\t\n\t\t// MATERIAL CONSTANTS\n\t\n\t\t// side\n\t\n\t\tFrontSide: 0,\n\t\tBackSide: 1,\n\t\tDoubleSide: 2,\n\t\n\t\t// shading\n\t\n\t\tFlatShading: 1,\n\t\tSmoothShading: 2,\n\t\n\t\t// colors\n\t\n\t\tNoColors: 0,\n\t\tFaceColors: 1,\n\t\tVertexColors: 2,\n\t\n\t\t// blending modes\n\t\n\t\tNoBlending: 0,\n\t\tNormalBlending: 1,\n\t\tAdditiveBlending: 2,\n\t\tSubtractiveBlending: 3,\n\t\tMultiplyBlending: 4,\n\t\tCustomBlending: 5,\n\t\n\t\t// custom blending equations\n\t\t// (numbers start from 100 not to clash with other\n\t\t// mappings to OpenGL constants defined in Texture.js)\n\t\n\t\tAddEquation: 100,\n\t\tSubtractEquation: 101,\n\t\tReverseSubtractEquation: 102,\n\t\tMinEquation: 103,\n\t\tMaxEquation: 104,\n\t\n\t\t// custom blending destination factors\n\t\n\t\tZeroFactor: 200,\n\t\tOneFactor: 201,\n\t\tSrcColorFactor: 202,\n\t\tOneMinusSrcColorFactor: 203,\n\t\tSrcAlphaFactor: 204,\n\t\tOneMinusSrcAlphaFactor: 205,\n\t\tDstAlphaFactor: 206,\n\t\tOneMinusDstAlphaFactor: 207,\n\t\n\t\t// custom blending source factors\n\t\n\t\t//ZeroFactor: 200,\n\t\t//OneFactor: 201,\n\t\t//SrcAlphaFactor: 204,\n\t\t//OneMinusSrcAlphaFactor: 205,\n\t\t//DstAlphaFactor: 206,\n\t\t//OneMinusDstAlphaFactor: 207,\n\t\tDstColorFactor: 208,\n\t\tOneMinusDstColorFactor: 209,\n\t\tSrcAlphaSaturateFactor: 210,\n\t\n\t\t// depth modes\n\t\n\t\tNeverDepth: 0,\n\t\tAlwaysDepth: 1,\n\t\tLessDepth: 2,\n\t\tLessEqualDepth: 3,\n\t\tEqualDepth: 4,\n\t\tGreaterEqualDepth: 5,\n\t\tGreaterDepth: 6,\n\t\tNotEqualDepth: 7,\n\t\n\t\n\t\t// TEXTURE CONSTANTS\n\t\n\t\tMultiplyOperation: 0,\n\t\tMixOperation: 1,\n\t\tAddOperation: 2,\n\t\n\t\t// Tone Mapping modes\n\t\n\t\tNoToneMapping: 0, // do not do any tone mapping, not even exposure (required for special purpose passes.)\n\t\tLinearToneMapping: 1, // only apply exposure.\n\t\tReinhardToneMapping: 2,\n\t\tUncharted2ToneMapping: 3, // John Hable\n\t\tCineonToneMapping: 4, // optimized filmic operator by Jim Hejl and Richard Burgess-Dawson\n\t\n\t\t// Mapping modes\n\t\n\t\tUVMapping: 300,\n\t\n\t\tCubeReflectionMapping: 301,\n\t\tCubeRefractionMapping: 302,\n\t\n\t\tEquirectangularReflectionMapping: 303,\n\t\tEquirectangularRefractionMapping: 304,\n\t\n\t\tSphericalReflectionMapping: 305,\n\t\tCubeUVReflectionMapping: 306,\n\t\tCubeUVRefractionMapping: 307,\n\t\n\t\t// Wrapping modes\n\t\n\t\tRepeatWrapping: 1000,\n\t\tClampToEdgeWrapping: 1001,\n\t\tMirroredRepeatWrapping: 1002,\n\t\n\t\t// Filters\n\t\n\t\tNearestFilter: 1003,\n\t\tNearestMipMapNearestFilter: 1004,\n\t\tNearestMipMapLinearFilter: 1005,\n\t\tLinearFilter: 1006,\n\t\tLinearMipMapNearestFilter: 1007,\n\t\tLinearMipMapLinearFilter: 1008,\n\t\n\t\t// Data types\n\t\n\t\tUnsignedByteType: 1009,\n\t\tByteType: 1010,\n\t\tShortType: 1011,\n\t\tUnsignedShortType: 1012,\n\t\tIntType: 1013,\n\t\tUnsignedIntType: 1014,\n\t\tFloatType: 1015,\n\t\tHalfFloatType: 1025,\n\t\n\t\t// Pixel types\n\t\n\t\t//UnsignedByteType: 1009,\n\t\tUnsignedShort4444Type: 1016,\n\t\tUnsignedShort5551Type: 1017,\n\t\tUnsignedShort565Type: 1018,\n\t\n\t\t// Pixel formats\n\t\n\t\tAlphaFormat: 1019,\n\t\tRGBFormat: 1020,\n\t\tRGBAFormat: 1021,\n\t\tLuminanceFormat: 1022,\n\t\tLuminanceAlphaFormat: 1023,\n\t\t// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders\n\t\tRGBEFormat: THREE.RGBAFormat, //1024;\n\t\tDepthFormat: 1026,\n\t\n\t\t// DDS / ST3C Compressed texture formats\n\t\n\t\tRGB_S3TC_DXT1_Format: 2001,\n\t\tRGBA_S3TC_DXT1_Format: 2002,\n\t\tRGBA_S3TC_DXT3_Format: 2003,\n\t\tRGBA_S3TC_DXT5_Format: 2004,\n\t\n\t\t// PVRTC compressed texture formats\n\t\n\t\tRGB_PVRTC_4BPPV1_Format: 2100,\n\t\tRGB_PVRTC_2BPPV1_Format: 2101,\n\t\tRGBA_PVRTC_4BPPV1_Format: 2102,\n\t\tRGBA_PVRTC_2BPPV1_Format: 2103,\n\t\n\t\t// ETC compressed texture formats\n\t\n\t\tRGB_ETC1_Format: 2151,\n\t\n\t\t// Loop styles for AnimationAction\n\t\n\t\tLoopOnce: 2200,\n\t\tLoopRepeat: 2201,\n\t\tLoopPingPong: 2202,\n\t\n\t\t// Interpolation\n\t\n\t\tInterpolateDiscrete: 2300,\n\t\tInterpolateLinear: 2301,\n\t\tInterpolateSmooth: 2302,\n\t\n\t\t// Interpolant ending modes\n\t\n\t\tZeroCurvatureEnding: 2400,\n\t\tZeroSlopeEnding: 2401,\n\t\tWrapAroundEnding: 2402,\n\t\n\t\t// Triangle Draw modes\n\t\n\t\tTrianglesDrawMode: 0,\n\t\tTriangleStripDrawMode: 1,\n\t\tTriangleFanDrawMode: 2,\n\t\n\t\t// Texture Encodings\n\t\n\t\tLinearEncoding: 3000, // No encoding at all.\n\t\tsRGBEncoding: 3001,\n\t\tGammaEncoding: 3007, // uses GAMMA_FACTOR, for backwards compatibility with WebGLRenderer.gammaInput/gammaOutput\n\t\n\t\t// The following Texture Encodings are for RGB-only (no alpha) HDR light emission sources.\n\t\t// These encodings should not specified as output encodings except in rare situations.\n\t\tRGBEEncoding: 3002, // AKA Radiance.\n\t\tLogLuvEncoding: 3003,\n\t\tRGBM7Encoding: 3004,\n\t\tRGBM16Encoding: 3005,\n\t\tRGBDEncoding: 3006, // MaxRange is 256.\n\t\n\t\t// Depth packing strategies\n\t\n\t\tBasicDepthPacking: 3200, // for writing to float textures for high precision or for visualizing results in RGB buffers\n\t\tRGBADepthPacking: 3201 // for packing into RGBA buffers.\n\t\n\t} );\n\t\n\t// File:src/math/Color.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.Color = function ( r, g, b ) {\n\t\n\t\tif ( g === undefined && b === undefined ) {\n\t\n\t\t\t// r is THREE.Color, hex or string\n\t\t\treturn this.set( r );\n\t\n\t\t}\n\t\n\t\treturn this.setRGB( r, g, b );\n\t\n\t};\n\t\n\tTHREE.Color.prototype = {\n\t\n\t\tconstructor: THREE.Color,\n\t\n\t\tr: 1, g: 1, b: 1,\n\t\n\t\tset: function ( value ) {\n\t\n\t\t\tif ( value instanceof THREE.Color ) {\n\t\n\t\t\t\tthis.copy( value );\n\t\n\t\t\t} else if ( typeof value === 'number' ) {\n\t\n\t\t\t\tthis.setHex( value );\n\t\n\t\t\t} else if ( typeof value === 'string' ) {\n\t\n\t\t\t\tthis.setStyle( value );\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetScalar: function ( scalar ) {\n\t\n\t\t\tthis.r = scalar;\n\t\t\tthis.g = scalar;\n\t\t\tthis.b = scalar;\n\t\n\t\t},\n\t\n\t\tsetHex: function ( hex ) {\n\t\n\t\t\thex = Math.floor( hex );\n\t\n\t\t\tthis.r = ( hex >> 16 & 255 ) / 255;\n\t\t\tthis.g = ( hex >> 8 & 255 ) / 255;\n\t\t\tthis.b = ( hex & 255 ) / 255;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetRGB: function ( r, g, b ) {\n\t\n\t\t\tthis.r = r;\n\t\t\tthis.g = g;\n\t\t\tthis.b = b;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetHSL: function () {\n\t\n\t\t\tfunction hue2rgb( p, q, t ) {\n\t\n\t\t\t\tif ( t < 0 ) t += 1;\n\t\t\t\tif ( t > 1 ) t -= 1;\n\t\t\t\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\n\t\t\t\tif ( t < 1 / 2 ) return q;\n\t\t\t\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\n\t\t\t\treturn p;\n\t\n\t\t\t}\n\t\n\t\t\treturn function setHSL( h, s, l ) {\n\t\n\t\t\t\t// h,s,l ranges are in 0.0 - 1.0\n\t\t\t\th = THREE.Math.euclideanModulo( h, 1 );\n\t\t\t\ts = THREE.Math.clamp( s, 0, 1 );\n\t\t\t\tl = THREE.Math.clamp( l, 0, 1 );\n\t\n\t\t\t\tif ( s === 0 ) {\n\t\n\t\t\t\t\tthis.r = this.g = this.b = l;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tvar p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\n\t\t\t\t\tvar q = ( 2 * l ) - p;\n\t\n\t\t\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\n\t\t\t\t\tthis.g = hue2rgb( q, p, h );\n\t\t\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tsetStyle: function ( style ) {\n\t\n\t\t\tfunction handleAlpha( string ) {\n\t\n\t\t\t\tif ( string === undefined ) return;\n\t\n\t\t\t\tif ( parseFloat( string ) < 1 ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\n\t\t\tvar m;\n\t\n\t\t\tif ( m = /^((?:rgb|hsl)a?)\\(\\s*([^\\)]*)\\)/.exec( style ) ) {\n\t\n\t\t\t\t// rgb / hsl\n\t\n\t\t\t\tvar color;\n\t\t\t\tvar name = m[ 1 ];\n\t\t\t\tvar components = m[ 2 ];\n\t\n\t\t\t\tswitch ( name ) {\n\t\n\t\t\t\t\tcase 'rgb':\n\t\t\t\t\tcase 'rgba':\n\t\n\t\t\t\t\t\tif ( color = /^(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\t\n\t\t\t\t\t\t\t// rgb(255,0,0) rgba(255,0,0,0.5)\n\t\t\t\t\t\t\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\n\t\t\t\t\t\t\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\n\t\t\t\t\t\t\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\n\t\n\t\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\t\n\t\t\t\t\t\t\treturn this;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( color = /^(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\t\n\t\t\t\t\t\t\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\n\t\t\t\t\t\t\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\n\t\t\t\t\t\t\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\n\t\t\t\t\t\t\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\n\t\n\t\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\t\n\t\t\t\t\t\t\treturn this;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'hsl':\n\t\t\t\t\tcase 'hsla':\n\t\n\t\t\t\t\t\tif ( color = /^([0-9]*\\.?[0-9]+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\t\n\t\t\t\t\t\t\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\n\t\t\t\t\t\t\tvar h = parseFloat( color[ 1 ] ) / 360;\n\t\t\t\t\t\t\tvar s = parseInt( color[ 2 ], 10 ) / 100;\n\t\t\t\t\t\t\tvar l = parseInt( color[ 3 ], 10 ) / 100;\n\t\n\t\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\t\n\t\t\t\t\t\t\treturn this.setHSL( h, s, l );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t}\n\t\n\t\t\t} else if ( m = /^\\#([A-Fa-f0-9]+)$/.exec( style ) ) {\n\t\n\t\t\t\t// hex color\n\t\n\t\t\t\tvar hex = m[ 1 ];\n\t\t\t\tvar size = hex.length;\n\t\n\t\t\t\tif ( size === 3 ) {\n\t\n\t\t\t\t\t// #ff0\n\t\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;\n\t\t\t\t\tthis.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;\n\t\t\t\t\tthis.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t} else if ( size === 6 ) {\n\t\n\t\t\t\t\t// #ff0000\n\t\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;\n\t\t\t\t\tthis.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;\n\t\t\t\t\tthis.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif ( style && style.length > 0 ) {\n\t\n\t\t\t\t// color keywords\n\t\t\t\tvar hex = THREE.ColorKeywords[ style ];\n\t\n\t\t\t\tif ( hex !== undefined ) {\n\t\n\t\t\t\t\t// red\n\t\t\t\t\tthis.setHex( hex );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// unknown color\n\t\t\t\t\tconsole.warn( 'THREE.Color: Unknown color ' + style );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor( this.r, this.g, this.b );\n\t\n\t\t},\n\t\n\t\tcopy: function ( color ) {\n\t\n\t\t\tthis.r = color.r;\n\t\t\tthis.g = color.g;\n\t\t\tthis.b = color.b;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tcopyGammaToLinear: function ( color, gammaFactor ) {\n\t\n\t\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\n\t\n\t\t\tthis.r = Math.pow( color.r, gammaFactor );\n\t\t\tthis.g = Math.pow( color.g, gammaFactor );\n\t\t\tthis.b = Math.pow( color.b, gammaFactor );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tcopyLinearToGamma: function ( color, gammaFactor ) {\n\t\n\t\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\n\t\n\t\t\tvar safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;\n\t\n\t\t\tthis.r = Math.pow( color.r, safeInverse );\n\t\t\tthis.g = Math.pow( color.g, safeInverse );\n\t\t\tthis.b = Math.pow( color.b, safeInverse );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tconvertGammaToLinear: function () {\n\t\n\t\t\tvar r = this.r, g = this.g, b = this.b;\n\t\n\t\t\tthis.r = r * r;\n\t\t\tthis.g = g * g;\n\t\t\tthis.b = b * b;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tconvertLinearToGamma: function () {\n\t\n\t\t\tthis.r = Math.sqrt( this.r );\n\t\t\tthis.g = Math.sqrt( this.g );\n\t\t\tthis.b = Math.sqrt( this.b );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tgetHex: function () {\n\t\n\t\t\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\n\t\n\t\t},\n\t\n\t\tgetHexString: function () {\n\t\n\t\t\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\n\t\n\t\t},\n\t\n\t\tgetHSL: function ( optionalTarget ) {\n\t\n\t\t\t// h,s,l ranges are in 0.0 - 1.0\n\t\n\t\t\tvar hsl = optionalTarget || { h: 0, s: 0, l: 0 };\n\t\n\t\t\tvar r = this.r, g = this.g, b = this.b;\n\t\n\t\t\tvar max = Math.max( r, g, b );\n\t\t\tvar min = Math.min( r, g, b );\n\t\n\t\t\tvar hue, saturation;\n\t\t\tvar lightness = ( min + max ) / 2.0;\n\t\n\t\t\tif ( min === max ) {\n\t\n\t\t\t\thue = 0;\n\t\t\t\tsaturation = 0;\n\t\n\t\t\t} else {\n\t\n\t\t\t\tvar delta = max - min;\n\t\n\t\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\n\t\n\t\t\t\tswitch ( max ) {\n\t\n\t\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\n\t\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\n\t\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\n\t\n\t\t\t\t}\n\t\n\t\t\t\thue /= 6;\n\t\n\t\t\t}\n\t\n\t\t\thsl.h = hue;\n\t\t\thsl.s = saturation;\n\t\t\thsl.l = lightness;\n\t\n\t\t\treturn hsl;\n\t\n\t\t},\n\t\n\t\tgetStyle: function () {\n\t\n\t\t\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\n\t\n\t\t},\n\t\n\t\toffsetHSL: function ( h, s, l ) {\n\t\n\t\t\tvar hsl = this.getHSL();\n\t\n\t\t\thsl.h += h; hsl.s += s; hsl.l += l;\n\t\n\t\t\tthis.setHSL( hsl.h, hsl.s, hsl.l );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tadd: function ( color ) {\n\t\n\t\t\tthis.r += color.r;\n\t\t\tthis.g += color.g;\n\t\t\tthis.b += color.b;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\taddColors: function ( color1, color2 ) {\n\t\n\t\t\tthis.r = color1.r + color2.r;\n\t\t\tthis.g = color1.g + color2.g;\n\t\t\tthis.b = color1.b + color2.b;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\taddScalar: function ( s ) {\n\t\n\t\t\tthis.r += s;\n\t\t\tthis.g += s;\n\t\t\tthis.b += s;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmultiply: function ( color ) {\n\t\n\t\t\tthis.r *= color.r;\n\t\t\tthis.g *= color.g;\n\t\t\tthis.b *= color.b;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmultiplyScalar: function ( s ) {\n\t\n\t\t\tthis.r *= s;\n\t\t\tthis.g *= s;\n\t\t\tthis.b *= s;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tlerp: function ( color, alpha ) {\n\t\n\t\t\tthis.r += ( color.r - this.r ) * alpha;\n\t\t\tthis.g += ( color.g - this.g ) * alpha;\n\t\t\tthis.b += ( color.b - this.b ) * alpha;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tequals: function ( c ) {\n\t\n\t\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\n\t\n\t\t},\n\t\n\t\tfromArray: function ( array, offset ) {\n\t\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\tthis.r = array[ offset ];\n\t\t\tthis.g = array[ offset + 1 ];\n\t\t\tthis.b = array[ offset + 2 ];\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\tarray[ offset ] = this.r;\n\t\t\tarray[ offset + 1 ] = this.g;\n\t\t\tarray[ offset + 2 ] = this.b;\n\t\n\t\t\treturn array;\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\n\t'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\n\t'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\n\t'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\n\t'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\n\t'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\n\t'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\n\t'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\n\t'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\n\t'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\n\t'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\n\t'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\n\t'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\n\t'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\n\t'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\n\t'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\n\t'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\n\t'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\n\t'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\n\t'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\n\t'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\n\t'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\n\t'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\n\t'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\n\t\n\t// File:src/math/Quaternion.js\n\t\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author bhouston / http://clara.io\n\t */\n\t\n\tTHREE.Quaternion = function ( x, y, z, w ) {\n\t\n\t\tthis._x = x || 0;\n\t\tthis._y = y || 0;\n\t\tthis._z = z || 0;\n\t\tthis._w = ( w !== undefined ) ? w : 1;\n\t\n\t};\n\t\n\tTHREE.Quaternion.prototype = {\n\t\n\t\tconstructor: THREE.Quaternion,\n\t\n\t\tget x () {\n\t\n\t\t\treturn this._x;\n\t\n\t\t},\n\t\n\t\tset x ( value ) {\n\t\n\t\t\tthis._x = value;\n\t\t\tthis.onChangeCallback();\n\t\n\t\t},\n\t\n\t\tget y () {\n\t\n\t\t\treturn this._y;\n\t\n\t\t},\n\t\n\t\tset y ( value ) {\n\t\n\t\t\tthis._y = value;\n\t\t\tthis.onChangeCallback();\n\t\n\t\t},\n\t\n\t\tget z () {\n\t\n\t\t\treturn this._z;\n\t\n\t\t},\n\t\n\t\tset z ( value ) {\n\t\n\t\t\tthis._z = value;\n\t\t\tthis.onChangeCallback();\n\t\n\t\t},\n\t\n\t\tget w () {\n\t\n\t\t\treturn this._w;\n\t\n\t\t},\n\t\n\t\tset w ( value ) {\n\t\n\t\t\tthis._w = value;\n\t\t\tthis.onChangeCallback();\n\t\n\t\t},\n\t\n\t\tset: function ( x, y, z, w ) {\n\t\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\t\t\tthis._w = w;\n\t\n\t\t\tthis.onChangeCallback();\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor( this._x, this._y, this._z, this._w );\n\t\n\t\t},\n\t\n\t\tcopy: function ( quaternion ) {\n\t\n\t\t\tthis._x = quaternion.x;\n\t\t\tthis._y = quaternion.y;\n\t\t\tthis._z = quaternion.z;\n\t\t\tthis._w = quaternion.w;\n\t\n\t\t\tthis.onChangeCallback();\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetFromEuler: function ( euler, update ) {\n\t\n\t\t\tif ( euler instanceof THREE.Euler === false ) {\n\t\n\t\t\t\tthrow new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\n\t\n\t\t\t}\n\t\n\t\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\n\t\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n\t\t\t//\tcontent/SpinCalc.m\n\t\n\t\t\tvar c1 = Math.cos( euler._x / 2 );\n\t\t\tvar c2 = Math.cos( euler._y / 2 );\n\t\t\tvar c3 = Math.cos( euler._z / 2 );\n\t\t\tvar s1 = Math.sin( euler._x / 2 );\n\t\t\tvar s2 = Math.sin( euler._y / 2 );\n\t\t\tvar s3 = Math.sin( euler._z / 2 );\n\t\n\t\t\tvar order = euler.order;\n\t\n\t\t\tif ( order === 'XYZ' ) {\n\t\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\n\t\t\t} else if ( order === 'YXZ' ) {\n\t\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\n\t\t\t} else if ( order === 'ZXY' ) {\n\t\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\n\t\t\t} else if ( order === 'ZYX' ) {\n\t\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\n\t\t\t} else if ( order === 'YZX' ) {\n\t\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\n\t\t\t} else if ( order === 'XZY' ) {\n\t\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\n\t\t\t}\n\t\n\t\t\tif ( update !== false ) this.onChangeCallback();\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetFromAxisAngle: function ( axis, angle ) {\n\t\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\t\n\t\t\t// assumes axis is normalized\n\t\n\t\t\tvar halfAngle = angle / 2, s = Math.sin( halfAngle );\n\t\n\t\t\tthis._x = axis.x * s;\n\t\t\tthis._y = axis.y * s;\n\t\t\tthis._z = axis.z * s;\n\t\t\tthis._w = Math.cos( halfAngle );\n\t\n\t\t\tthis.onChangeCallback();\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetFromRotationMatrix: function ( m ) {\n\t\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\t\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\t\n\t\t\tvar te = m.elements,\n\t\n\t\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\n\t\n\t\t\t\ttrace = m11 + m22 + m33,\n\t\t\t\ts;\n\t\n\t\t\tif ( trace > 0 ) {\n\t\n\t\t\t\ts = 0.5 / Math.sqrt( trace + 1.0 );\n\t\n\t\t\t\tthis._w = 0.25 / s;\n\t\t\t\tthis._x = ( m32 - m23 ) * s;\n\t\t\t\tthis._y = ( m13 - m31 ) * s;\n\t\t\t\tthis._z = ( m21 - m12 ) * s;\n\t\n\t\t\t} else if ( m11 > m22 && m11 > m33 ) {\n\t\n\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\n\t\n\t\t\t\tthis._w = ( m32 - m23 ) / s;\n\t\t\t\tthis._x = 0.25 * s;\n\t\t\t\tthis._y = ( m12 + m21 ) / s;\n\t\t\t\tthis._z = ( m13 + m31 ) / s;\n\t\n\t\t\t} else if ( m22 > m33 ) {\n\t\n\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\n\t\n\t\t\t\tthis._w = ( m13 - m31 ) / s;\n\t\t\t\tthis._x = ( m12 + m21 ) / s;\n\t\t\t\tthis._y = 0.25 * s;\n\t\t\t\tthis._z = ( m23 + m32 ) / s;\n\t\n\t\t\t} else {\n\t\n\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\n\t\n\t\t\t\tthis._w = ( m21 - m12 ) / s;\n\t\t\t\tthis._x = ( m13 + m31 ) / s;\n\t\t\t\tthis._y = ( m23 + m32 ) / s;\n\t\t\t\tthis._z = 0.25 * s;\n\t\n\t\t\t}\n\t\n\t\t\tthis.onChangeCallback();\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetFromUnitVectors: function () {\n\t\n\t\t\t// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final\n\t\n\t\t\t// assumes direction vectors vFrom and vTo are normalized\n\t\n\t\t\tvar v1, r;\n\t\n\t\t\tvar EPS = 0.000001;\n\t\n\t\t\treturn function setFromUnitVectors( vFrom, vTo ) {\n\t\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\n\t\t\t\tr = vFrom.dot( vTo ) + 1;\n\t\n\t\t\t\tif ( r < EPS ) {\n\t\n\t\t\t\t\tr = 0;\n\t\n\t\t\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\n\t\n\t\t\t\t\t\tv1.set( - vFrom.y, vFrom.x, 0 );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tv1.set( 0, - vFrom.z, vFrom.y );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tv1.crossVectors( vFrom, vTo );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis._x = v1.x;\n\t\t\t\tthis._y = v1.y;\n\t\t\t\tthis._z = v1.z;\n\t\t\t\tthis._w = r;\n\t\n\t\t\t\treturn this.normalize();\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tinverse: function () {\n\t\n\t\t\treturn this.conjugate().normalize();\n\t\n\t\t},\n\t\n\t\tconjugate: function () {\n\t\n\t\t\tthis._x *= - 1;\n\t\t\tthis._y *= - 1;\n\t\t\tthis._z *= - 1;\n\t\n\t\t\tthis.onChangeCallback();\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tdot: function ( v ) {\n\t\n\t\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n\t\n\t\t},\n\t\n\t\tlengthSq: function () {\n\t\n\t\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n\t\n\t\t},\n\t\n\t\tlength: function () {\n\t\n\t\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\n\t\n\t\t},\n\t\n\t\tnormalize: function () {\n\t\n\t\t\tvar l = this.length();\n\t\n\t\t\tif ( l === 0 ) {\n\t\n\t\t\t\tthis._x = 0;\n\t\t\t\tthis._y = 0;\n\t\t\t\tthis._z = 0;\n\t\t\t\tthis._w = 1;\n\t\n\t\t\t} else {\n\t\n\t\t\t\tl = 1 / l;\n\t\n\t\t\t\tthis._x = this._x * l;\n\t\t\t\tthis._y = this._y * l;\n\t\t\t\tthis._z = this._z * l;\n\t\t\t\tthis._w = this._w * l;\n\t\n\t\t\t}\n\t\n\t\t\tthis.onChangeCallback();\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmultiply: function ( q, p ) {\n\t\n\t\t\tif ( p !== undefined ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\n\t\t\t\treturn this.multiplyQuaternions( q, p );\n\t\n\t\t\t}\n\t\n\t\t\treturn this.multiplyQuaternions( this, q );\n\t\n\t\t},\n\t\n\t\tpremultiply: function ( q ) {\n\t\n\t\t\treturn this.multiplyQuaternions( q, this );\n\t\n\t\t},\n\t\n\t\tmultiplyQuaternions: function ( a, b ) {\n\t\n\t\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\t\n\t\t\tvar qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n\t\t\tvar qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n\t\n\t\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n\t\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n\t\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n\t\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\t\n\t\t\tthis.onChangeCallback();\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tslerp: function ( qb, t ) {\n\t\n\t\t\tif ( t === 0 ) return this;\n\t\t\tif ( t === 1 ) return this.copy( qb );\n\t\n\t\t\tvar x = this._x, y = this._y, z = this._z, w = this._w;\n\t\n\t\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\t\n\t\t\tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\t\n\t\t\tif ( cosHalfTheta < 0 ) {\n\t\n\t\t\t\tthis._w = - qb._w;\n\t\t\t\tthis._x = - qb._x;\n\t\t\t\tthis._y = - qb._y;\n\t\t\t\tthis._z = - qb._z;\n\t\n\t\t\t\tcosHalfTheta = - cosHalfTheta;\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.copy( qb );\n\t\n\t\t\t}\n\t\n\t\t\tif ( cosHalfTheta >= 1.0 ) {\n\t\n\t\t\t\tthis._w = w;\n\t\t\t\tthis._x = x;\n\t\t\t\tthis._y = y;\n\t\t\t\tthis._z = z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t\tvar sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\n\t\n\t\t\tif ( Math.abs( sinHalfTheta ) < 0.001 ) {\n\t\n\t\t\t\tthis._w = 0.5 * ( w + this._w );\n\t\t\t\tthis._x = 0.5 * ( x + this._x );\n\t\t\t\tthis._y = 0.5 * ( y + this._y );\n\t\t\t\tthis._z = 0.5 * ( z + this._z );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t\tvar halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\n\t\t\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\n\t\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\n\t\n\t\t\tthis._w = ( w * ratioA + this._w * ratioB );\n\t\t\tthis._x = ( x * ratioA + this._x * ratioB );\n\t\t\tthis._y = ( y * ratioA + this._y * ratioB );\n\t\t\tthis._z = ( z * ratioA + this._z * ratioB );\n\t\n\t\t\tthis.onChangeCallback();\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tequals: function ( quaternion ) {\n\t\n\t\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\n\t\n\t\t},\n\t\n\t\tfromArray: function ( array, offset ) {\n\t\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\tthis._x = array[ offset ];\n\t\t\tthis._y = array[ offset + 1 ];\n\t\t\tthis._z = array[ offset + 2 ];\n\t\t\tthis._w = array[ offset + 3 ];\n\t\n\t\t\tthis.onChangeCallback();\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\tarray[ offset ] = this._x;\n\t\t\tarray[ offset + 1 ] = this._y;\n\t\t\tarray[ offset + 2 ] = this._z;\n\t\t\tarray[ offset + 3 ] = this._w;\n\t\n\t\t\treturn array;\n\t\n\t\t},\n\t\n\t\tonChange: function ( callback ) {\n\t\n\t\t\tthis.onChangeCallback = callback;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tonChangeCallback: function () {}\n\t\n\t};\n\t\n\tObject.assign( THREE.Quaternion, {\n\t\n\t\tslerp: function( qa, qb, qm, t ) {\n\t\n\t\t\treturn qm.copy( qa ).slerp( qb, t );\n\t\n\t\t},\n\t\n\t\tslerpFlat: function(\n\t\t\t\tdst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\n\t\n\t\t\t// fuzz-free, array-based Quaternion SLERP operation\n\t\n\t\t\tvar x0 = src0[ srcOffset0 + 0 ],\n\t\t\t\ty0 = src0[ srcOffset0 + 1 ],\n\t\t\t\tz0 = src0[ srcOffset0 + 2 ],\n\t\t\t\tw0 = src0[ srcOffset0 + 3 ],\n\t\n\t\t\t\tx1 = src1[ srcOffset1 + 0 ],\n\t\t\t\ty1 = src1[ srcOffset1 + 1 ],\n\t\t\t\tz1 = src1[ srcOffset1 + 2 ],\n\t\t\t\tw1 = src1[ srcOffset1 + 3 ];\n\t\n\t\t\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\n\t\n\t\t\t\tvar s = 1 - t,\n\t\n\t\t\t\t\tcos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n\t\n\t\t\t\t\tdir = ( cos >= 0 ? 1 : - 1 ),\n\t\t\t\t\tsqrSin = 1 - cos * cos;\n\t\n\t\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems:\n\t\t\t\tif ( sqrSin > Number.EPSILON ) {\n\t\n\t\t\t\t\tvar sin = Math.sqrt( sqrSin ),\n\t\t\t\t\t\tlen = Math.atan2( sin, cos * dir );\n\t\n\t\t\t\t\ts = Math.sin( s * len ) / sin;\n\t\t\t\t\tt = Math.sin( t * len ) / sin;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar tDir = t * dir;\n\t\n\t\t\t\tx0 = x0 * s + x1 * tDir;\n\t\t\t\ty0 = y0 * s + y1 * tDir;\n\t\t\t\tz0 = z0 * s + z1 * tDir;\n\t\t\t\tw0 = w0 * s + w1 * tDir;\n\t\n\t\t\t\t// Normalize in case we just did a lerp:\n\t\t\t\tif ( s === 1 - t ) {\n\t\n\t\t\t\t\tvar f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\n\t\n\t\t\t\t\tx0 *= f;\n\t\t\t\t\ty0 *= f;\n\t\t\t\t\tz0 *= f;\n\t\t\t\t\tw0 *= f;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tdst[ dstOffset ] = x0;\n\t\t\tdst[ dstOffset + 1 ] = y0;\n\t\t\tdst[ dstOffset + 2 ] = z0;\n\t\t\tdst[ dstOffset + 3 ] = w0;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/math/Vector2.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author philogb / http://blog.thejit.org/\n\t * @author egraether / http://egraether.com/\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t */\n\t\n\tTHREE.Vector2 = function ( x, y ) {\n\t\n\t\tthis.x = x || 0;\n\t\tthis.y = y || 0;\n\t\n\t};\n\t\n\tTHREE.Vector2.prototype = {\n\t\n\t\tconstructor: THREE.Vector2,\n\t\n\t\tget width() {\n\t\n\t\t\treturn this.x;\n\t\n\t\t},\n\t\n\t\tset width( value ) {\n\t\n\t\t\tthis.x = value;\n\t\n\t\t},\n\t\n\t\tget height() {\n\t\n\t\t\treturn this.y;\n\t\n\t\t},\n\t\n\t\tset height( value ) {\n\t\n\t\t\tthis.y = value;\n\t\n\t\t},\n\t\n\t\t//\n\t\n\t\tset: function ( x, y ) {\n\t\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetScalar: function ( scalar ) {\n\t\n\t\t\tthis.x = scalar;\n\t\t\tthis.y = scalar;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetX: function ( x ) {\n\t\n\t\t\tthis.x = x;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetY: function ( y ) {\n\t\n\t\t\tthis.y = y;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetComponent: function ( index, value ) {\n\t\n\t\t\tswitch ( index ) {\n\t\n\t\t\t\tcase 0: this.x = value; break;\n\t\t\t\tcase 1: this.y = value; break;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tgetComponent: function ( index ) {\n\t\n\t\t\tswitch ( index ) {\n\t\n\t\t\t\tcase 0: return this.x;\n\t\t\t\tcase 1: return this.y;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor( this.x, this.y );\n\t\n\t\t},\n\t\n\t\tcopy: function ( v ) {\n\t\n\t\t\tthis.x = v.x;\n\t\t\tthis.y = v.y;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tadd: function ( v, w ) {\n\t\n\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\t\treturn this.addVectors( v, w );\n\t\n\t\t\t}\n\t\n\t\t\tthis.x += v.x;\n\t\t\tthis.y += v.y;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\taddScalar: function ( s ) {\n\t\n\t\t\tthis.x += s;\n\t\t\tthis.y += s;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\taddVectors: function ( a, b ) {\n\t\n\t\t\tthis.x = a.x + b.x;\n\t\t\tthis.y = a.y + b.y;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\taddScaledVector: function ( v, s ) {\n\t\n\t\t\tthis.x += v.x * s;\n\t\t\tthis.y += v.y * s;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsub: function ( v, w ) {\n\t\n\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\t\treturn this.subVectors( v, w );\n\t\n\t\t\t}\n\t\n\t\t\tthis.x -= v.x;\n\t\t\tthis.y -= v.y;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsubScalar: function ( s ) {\n\t\n\t\t\tthis.x -= s;\n\t\t\tthis.y -= s;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsubVectors: function ( a, b ) {\n\t\n\t\t\tthis.x = a.x - b.x;\n\t\t\tthis.y = a.y - b.y;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmultiply: function ( v ) {\n\t\n\t\t\tthis.x *= v.x;\n\t\t\tthis.y *= v.y;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmultiplyScalar: function ( scalar ) {\n\t\n\t\t\tif ( isFinite( scalar ) ) {\n\t\n\t\t\t\tthis.x *= scalar;\n\t\t\t\tthis.y *= scalar;\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.x = 0;\n\t\t\t\tthis.y = 0;\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tdivide: function ( v ) {\n\t\n\t\t\tthis.x /= v.x;\n\t\t\tthis.y /= v.y;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tdivideScalar: function ( scalar ) {\n\t\n\t\t\treturn this.multiplyScalar( 1 / scalar );\n\t\n\t\t},\n\t\n\t\tmin: function ( v ) {\n\t\n\t\t\tthis.x = Math.min( this.x, v.x );\n\t\t\tthis.y = Math.min( this.y, v.y );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmax: function ( v ) {\n\t\n\t\t\tthis.x = Math.max( this.x, v.x );\n\t\t\tthis.y = Math.max( this.y, v.y );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tclamp: function ( min, max ) {\n\t\n\t\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\t\n\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tclampScalar: function () {\n\t\n\t\t\tvar min, max;\n\t\n\t\t\treturn function clampScalar( minVal, maxVal ) {\n\t\n\t\t\t\tif ( min === undefined ) {\n\t\n\t\t\t\t\tmin = new THREE.Vector2();\n\t\t\t\t\tmax = new THREE.Vector2();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tmin.set( minVal, minVal );\n\t\t\t\tmax.set( maxVal, maxVal );\n\t\n\t\t\t\treturn this.clamp( min, max );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tclampLength: function ( min, max ) {\n\t\n\t\t\tvar length = this.length();\n\t\n\t\t\treturn this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\n\t\n\t\t},\n\t\n\t\tfloor: function () {\n\t\n\t\t\tthis.x = Math.floor( this.x );\n\t\t\tthis.y = Math.floor( this.y );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tceil: function () {\n\t\n\t\t\tthis.x = Math.ceil( this.x );\n\t\t\tthis.y = Math.ceil( this.y );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tround: function () {\n\t\n\t\t\tthis.x = Math.round( this.x );\n\t\t\tthis.y = Math.round( this.y );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\troundToZero: function () {\n\t\n\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tnegate: function () {\n\t\n\t\t\tthis.x = - this.x;\n\t\t\tthis.y = - this.y;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tdot: function ( v ) {\n\t\n\t\t\treturn this.x * v.x + this.y * v.y;\n\t\n\t\t},\n\t\n\t\tlengthSq: function () {\n\t\n\t\t\treturn this.x * this.x + this.y * this.y;\n\t\n\t\t},\n\t\n\t\tlength: function () {\n\t\n\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\n\t\n\t\t},\n\t\n\t\tlengthManhattan: function() {\n\t\n\t\t\treturn Math.abs( this.x ) + Math.abs( this.y );\n\t\n\t\t},\n\t\n\t\tnormalize: function () {\n\t\n\t\t\treturn this.divideScalar( this.length() );\n\t\n\t\t},\n\t\n\t\tangle: function () {\n\t\n\t\t\t// computes the angle in radians with respect to the positive x-axis\n\t\n\t\t\tvar angle = Math.atan2( this.y, this.x );\n\t\n\t\t\tif ( angle < 0 ) angle += 2 * Math.PI;\n\t\n\t\t\treturn angle;\n\t\n\t\t},\n\t\n\t\tdistanceTo: function ( v ) {\n\t\n\t\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\t\n\t\t},\n\t\n\t\tdistanceToSquared: function ( v ) {\n\t\n\t\t\tvar dx = this.x - v.x, dy = this.y - v.y;\n\t\t\treturn dx * dx + dy * dy;\n\t\n\t\t},\n\t\n\t\tsetLength: function ( length ) {\n\t\n\t\t\treturn this.multiplyScalar( length / this.length() );\n\t\n\t\t},\n\t\n\t\tlerp: function ( v, alpha ) {\n\t\n\t\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tlerpVectors: function ( v1, v2, alpha ) {\n\t\n\t\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\t\n\t\t},\n\t\n\t\tequals: function ( v ) {\n\t\n\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\n\t\n\t\t},\n\t\n\t\tfromArray: function ( array, offset ) {\n\t\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\tthis.x = array[ offset ];\n\t\t\tthis.y = array[ offset + 1 ];\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\tarray[ offset ] = this.x;\n\t\t\tarray[ offset + 1 ] = this.y;\n\t\n\t\t\treturn array;\n\t\n\t\t},\n\t\n\t\tfromAttribute: function ( attribute, index, offset ) {\n\t\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\tindex = index * attribute.itemSize + offset;\n\t\n\t\t\tthis.x = attribute.array[ index ];\n\t\t\tthis.y = attribute.array[ index + 1 ];\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\trotateAround: function ( center, angle ) {\n\t\n\t\t\tvar c = Math.cos( angle ), s = Math.sin( angle );\n\t\n\t\t\tvar x = this.x - center.x;\n\t\t\tvar y = this.y - center.y;\n\t\n\t\t\tthis.x = x * c - y * s + center.x;\n\t\t\tthis.y = x * s + y * c + center.y;\n\t\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/math/Vector3.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author *kile / http://kile.stravaganza.org/\n\t * @author philogb / http://blog.thejit.org/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author egraether / http://egraether.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\t\n\tTHREE.Vector3 = function ( x, y, z ) {\n\t\n\t\tthis.x = x || 0;\n\t\tthis.y = y || 0;\n\t\tthis.z = z || 0;\n\t\n\t};\n\t\n\tTHREE.Vector3.prototype = {\n\t\n\t\tconstructor: THREE.Vector3,\n\t\n\t\tset: function ( x, y, z ) {\n\t\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetScalar: function ( scalar ) {\n\t\n\t\t\tthis.x = scalar;\n\t\t\tthis.y = scalar;\n\t\t\tthis.z = scalar;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetX: function ( x ) {\n\t\n\t\t\tthis.x = x;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetY: function ( y ) {\n\t\n\t\t\tthis.y = y;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetZ: function ( z ) {\n\t\n\t\t\tthis.z = z;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetComponent: function ( index, value ) {\n\t\n\t\t\tswitch ( index ) {\n\t\n\t\t\t\tcase 0: this.x = value; break;\n\t\t\t\tcase 1: this.y = value; break;\n\t\t\t\tcase 2: this.z = value; break;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tgetComponent: function ( index ) {\n\t\n\t\t\tswitch ( index ) {\n\t\n\t\t\t\tcase 0: return this.x;\n\t\t\t\tcase 1: return this.y;\n\t\t\t\tcase 2: return this.z;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor( this.x, this.y, this.z );\n\t\n\t\t},\n\t\n\t\tcopy: function ( v ) {\n\t\n\t\t\tthis.x = v.x;\n\t\t\tthis.y = v.y;\n\t\t\tthis.z = v.z;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tadd: function ( v, w ) {\n\t\n\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\t\treturn this.addVectors( v, w );\n\t\n\t\t\t}\n\t\n\t\t\tthis.x += v.x;\n\t\t\tthis.y += v.y;\n\t\t\tthis.z += v.z;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\taddScalar: function ( s ) {\n\t\n\t\t\tthis.x += s;\n\t\t\tthis.y += s;\n\t\t\tthis.z += s;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\taddVectors: function ( a, b ) {\n\t\n\t\t\tthis.x = a.x + b.x;\n\t\t\tthis.y = a.y + b.y;\n\t\t\tthis.z = a.z + b.z;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\taddScaledVector: function ( v, s ) {\n\t\n\t\t\tthis.x += v.x * s;\n\t\t\tthis.y += v.y * s;\n\t\t\tthis.z += v.z * s;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsub: function ( v, w ) {\n\t\n\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\t\treturn this.subVectors( v, w );\n\t\n\t\t\t}\n\t\n\t\t\tthis.x -= v.x;\n\t\t\tthis.y -= v.y;\n\t\t\tthis.z -= v.z;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsubScalar: function ( s ) {\n\t\n\t\t\tthis.x -= s;\n\t\t\tthis.y -= s;\n\t\t\tthis.z -= s;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsubVectors: function ( a, b ) {\n\t\n\t\t\tthis.x = a.x - b.x;\n\t\t\tthis.y = a.y - b.y;\n\t\t\tthis.z = a.z - b.z;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmultiply: function ( v, w ) {\n\t\n\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\n\t\t\t\treturn this.multiplyVectors( v, w );\n\t\n\t\t\t}\n\t\n\t\t\tthis.x *= v.x;\n\t\t\tthis.y *= v.y;\n\t\t\tthis.z *= v.z;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmultiplyScalar: function ( scalar ) {\n\t\n\t\t\tif ( isFinite( scalar ) ) {\n\t\n\t\t\t\tthis.x *= scalar;\n\t\t\t\tthis.y *= scalar;\n\t\t\t\tthis.z *= scalar;\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.x = 0;\n\t\t\t\tthis.y = 0;\n\t\t\t\tthis.z = 0;\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmultiplyVectors: function ( a, b ) {\n\t\n\t\t\tthis.x = a.x * b.x;\n\t\t\tthis.y = a.y * b.y;\n\t\t\tthis.z = a.z * b.z;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tapplyEuler: function () {\n\t\n\t\t\tvar quaternion;\n\t\n\t\t\treturn function applyEuler( euler ) {\n\t\n\t\t\t\tif ( euler instanceof THREE.Euler === false ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( quaternion === undefined ) quaternion = new THREE.Quaternion();\n\t\n\t\t\t\treturn this.applyQuaternion( quaternion.setFromEuler( euler ) );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tapplyAxisAngle: function () {\n\t\n\t\t\tvar quaternion;\n\t\n\t\t\treturn function applyAxisAngle( axis, angle ) {\n\t\n\t\t\t\tif ( quaternion === undefined ) quaternion = new THREE.Quaternion();\n\t\n\t\t\t\treturn this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tapplyMatrix3: function ( m ) {\n\t\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\tvar e = m.elements;\n\t\n\t\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\n\t\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\n\t\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tapplyMatrix4: function ( m ) {\n\t\n\t\t\t// input: THREE.Matrix4 affine matrix\n\t\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\tvar e = m.elements;\n\t\n\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];\n\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];\n\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tapplyProjection: function ( m ) {\n\t\n\t\t\t// input: THREE.Matrix4 projection matrix\n\t\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\tvar e = m.elements;\n\t\t\tvar d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide\n\t\n\t\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;\n\t\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;\n\t\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tapplyQuaternion: function ( q ) {\n\t\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\tvar qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n\t\n\t\t\t// calculate quat * vector\n\t\n\t\t\tvar ix =  qw * x + qy * z - qz * y;\n\t\t\tvar iy =  qw * y + qz * x - qx * z;\n\t\t\tvar iz =  qw * z + qx * y - qy * x;\n\t\t\tvar iw = - qx * x - qy * y - qz * z;\n\t\n\t\t\t// calculate result * inverse quat\n\t\n\t\t\tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\n\t\t\tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\n\t\t\tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tproject: function () {\n\t\n\t\t\tvar matrix;\n\t\n\t\t\treturn function project( camera ) {\n\t\n\t\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\n\t\n\t\t\t\tmatrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );\n\t\t\t\treturn this.applyProjection( matrix );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tunproject: function () {\n\t\n\t\t\tvar matrix;\n\t\n\t\t\treturn function unproject( camera ) {\n\t\n\t\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\n\t\n\t\t\t\tmatrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );\n\t\t\t\treturn this.applyProjection( matrix );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\ttransformDirection: function ( m ) {\n\t\n\t\t\t// input: THREE.Matrix4 affine matrix\n\t\t\t// vector interpreted as a direction\n\t\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\tvar e = m.elements;\n\t\n\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;\n\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;\n\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\n\t\n\t\t\treturn this.normalize();\n\t\n\t\t},\n\t\n\t\tdivide: function ( v ) {\n\t\n\t\t\tthis.x /= v.x;\n\t\t\tthis.y /= v.y;\n\t\t\tthis.z /= v.z;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tdivideScalar: function ( scalar ) {\n\t\n\t\t\treturn this.multiplyScalar( 1 / scalar );\n\t\n\t\t},\n\t\n\t\tmin: function ( v ) {\n\t\n\t\t\tthis.x = Math.min( this.x, v.x );\n\t\t\tthis.y = Math.min( this.y, v.y );\n\t\t\tthis.z = Math.min( this.z, v.z );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmax: function ( v ) {\n\t\n\t\t\tthis.x = Math.max( this.x, v.x );\n\t\t\tthis.y = Math.max( this.y, v.y );\n\t\t\tthis.z = Math.max( this.z, v.z );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tclamp: function ( min, max ) {\n\t\n\t\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\t\n\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tclampScalar: function () {\n\t\n\t\t\tvar min, max;\n\t\n\t\t\treturn function clampScalar( minVal, maxVal ) {\n\t\n\t\t\t\tif ( min === undefined ) {\n\t\n\t\t\t\t\tmin = new THREE.Vector3();\n\t\t\t\t\tmax = new THREE.Vector3();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tmin.set( minVal, minVal, minVal );\n\t\t\t\tmax.set( maxVal, maxVal, maxVal );\n\t\n\t\t\t\treturn this.clamp( min, max );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tclampLength: function ( min, max ) {\n\t\n\t\t\tvar length = this.length();\n\t\n\t\t\treturn this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\n\t\n\t\t},\n\t\n\t\tfloor: function () {\n\t\n\t\t\tthis.x = Math.floor( this.x );\n\t\t\tthis.y = Math.floor( this.y );\n\t\t\tthis.z = Math.floor( this.z );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tceil: function () {\n\t\n\t\t\tthis.x = Math.ceil( this.x );\n\t\t\tthis.y = Math.ceil( this.y );\n\t\t\tthis.z = Math.ceil( this.z );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tround: function () {\n\t\n\t\t\tthis.x = Math.round( this.x );\n\t\t\tthis.y = Math.round( this.y );\n\t\t\tthis.z = Math.round( this.z );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\troundToZero: function () {\n\t\n\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tnegate: function () {\n\t\n\t\t\tthis.x = - this.x;\n\t\t\tthis.y = - this.y;\n\t\t\tthis.z = - this.z;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tdot: function ( v ) {\n\t\n\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\n\t\n\t\t},\n\t\n\t\tlengthSq: function () {\n\t\n\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\n\t\n\t\t},\n\t\n\t\tlength: function () {\n\t\n\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\n\t\n\t\t},\n\t\n\t\tlengthManhattan: function () {\n\t\n\t\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\n\t\n\t\t},\n\t\n\t\tnormalize: function () {\n\t\n\t\t\treturn this.divideScalar( this.length() );\n\t\n\t\t},\n\t\n\t\tsetLength: function ( length ) {\n\t\n\t\t\treturn this.multiplyScalar( length / this.length() );\n\t\n\t\t},\n\t\n\t\tlerp: function ( v, alpha ) {\n\t\n\t\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\t\tthis.z += ( v.z - this.z ) * alpha;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tlerpVectors: function ( v1, v2, alpha ) {\n\t\n\t\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\t\n\t\t},\n\t\n\t\tcross: function ( v, w ) {\n\t\n\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\n\t\t\t\treturn this.crossVectors( v, w );\n\t\n\t\t\t}\n\t\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\n\t\t\tthis.x = y * v.z - z * v.y;\n\t\t\tthis.y = z * v.x - x * v.z;\n\t\t\tthis.z = x * v.y - y * v.x;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tcrossVectors: function ( a, b ) {\n\t\n\t\t\tvar ax = a.x, ay = a.y, az = a.z;\n\t\t\tvar bx = b.x, by = b.y, bz = b.z;\n\t\n\t\t\tthis.x = ay * bz - az * by;\n\t\t\tthis.y = az * bx - ax * bz;\n\t\t\tthis.z = ax * by - ay * bx;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tprojectOnVector: function ( vector ) {\n\t\n\t\t\tvar scalar = vector.dot( this ) / vector.lengthSq();\n\t\t\n\t\t\treturn this.copy( vector ).multiplyScalar( scalar );\n\t\t\n\t\t},\n\t\n\t\tprojectOnPlane: function () {\n\t\n\t\t\tvar v1;\n\t\n\t\t\treturn function projectOnPlane( planeNormal ) {\n\t\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\n\t\t\t\tv1.copy( this ).projectOnVector( planeNormal );\n\t\n\t\t\t\treturn this.sub( v1 );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\treflect: function () {\n\t\n\t\t\t// reflect incident vector off plane orthogonal to normal\n\t\t\t// normal is assumed to have unit length\n\t\n\t\t\tvar v1;\n\t\n\t\t\treturn function reflect( normal ) {\n\t\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\n\t\t\t\treturn this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tangleTo: function ( v ) {\n\t\n\t\t\tvar theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );\n\t\n\t\t\t// clamp, to handle numerical problems\n\t\n\t\t\treturn Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );\n\t\n\t\t},\n\t\n\t\tdistanceTo: function ( v ) {\n\t\n\t\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\t\n\t\t},\n\t\n\t\tdistanceToSquared: function ( v ) {\n\t\n\t\t\tvar dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n\t\n\t\t\treturn dx * dx + dy * dy + dz * dz;\n\t\n\t\t},\n\t\n\t\tsetFromSpherical: function( s ) {\n\t\n\t\t\tvar sinPhiRadius = Math.sin( s.phi ) * s.radius;\n\t\n\t\t\tthis.x = sinPhiRadius * Math.sin( s.theta );\n\t\t\tthis.y = Math.cos( s.phi ) * s.radius;\n\t\t\tthis.z = sinPhiRadius * Math.cos( s.theta );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetFromMatrixPosition: function ( m ) {\n\t\n\t\t\treturn this.setFromMatrixColumn( m, 3 );\n\t\n\t\t},\n\t\n\t\tsetFromMatrixScale: function ( m ) {\n\t\n\t\t\tvar sx = this.setFromMatrixColumn( m, 0 ).length();\n\t\t\tvar sy = this.setFromMatrixColumn( m, 1 ).length();\n\t\t\tvar sz = this.setFromMatrixColumn( m, 2 ).length();\n\t\n\t\t\tthis.x = sx;\n\t\t\tthis.y = sy;\n\t\t\tthis.z = sz;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetFromMatrixColumn: function ( m, index ) {\n\t\n\t\t\tif ( typeof m === 'number' ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).' );\n\t\t\t\tvar temp = m\n\t\t\t\tm = index;\n\t\t\t\tindex = temp;\n\t\n\t\t\t}\n\t\n\t\t\treturn this.fromArray( m.elements, index * 4 );\n\t\n\t\t},\n\t\n\t\tequals: function ( v ) {\n\t\n\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\n\t\n\t\t},\n\t\n\t\tfromArray: function ( array, offset ) {\n\t\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\tthis.x = array[ offset ];\n\t\t\tthis.y = array[ offset + 1 ];\n\t\t\tthis.z = array[ offset + 2 ];\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\tarray[ offset ] = this.x;\n\t\t\tarray[ offset + 1 ] = this.y;\n\t\t\tarray[ offset + 2 ] = this.z;\n\t\n\t\t\treturn array;\n\t\n\t\t},\n\t\n\t\tfromAttribute: function ( attribute, index, offset ) {\n\t\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\tindex = index * attribute.itemSize + offset;\n\t\n\t\t\tthis.x = attribute.array[ index ];\n\t\t\tthis.y = attribute.array[ index + 1 ];\n\t\t\tthis.z = attribute.array[ index + 2 ];\n\t\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/math/Vector4.js\n\t\n\t/**\n\t * @author supereggbert / http://www.paulbrunt.co.uk/\n\t * @author philogb / http://blog.thejit.org/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author egraether / http://egraether.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\t\n\tTHREE.Vector4 = function ( x, y, z, w ) {\n\t\n\t\tthis.x = x || 0;\n\t\tthis.y = y || 0;\n\t\tthis.z = z || 0;\n\t\tthis.w = ( w !== undefined ) ? w : 1;\n\t\n\t};\n\t\n\tTHREE.Vector4.prototype = {\n\t\n\t\tconstructor: THREE.Vector4,\n\t\n\t\tset: function ( x, y, z, w ) {\n\t\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t\tthis.w = w;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetScalar: function ( scalar ) {\n\t\n\t\t\tthis.x = scalar;\n\t\t\tthis.y = scalar;\n\t\t\tthis.z = scalar;\n\t\t\tthis.w = scalar;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetX: function ( x ) {\n\t\n\t\t\tthis.x = x;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetY: function ( y ) {\n\t\n\t\t\tthis.y = y;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetZ: function ( z ) {\n\t\n\t\t\tthis.z = z;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetW: function ( w ) {\n\t\n\t\t\tthis.w = w;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetComponent: function ( index, value ) {\n\t\n\t\t\tswitch ( index ) {\n\t\n\t\t\t\tcase 0: this.x = value; break;\n\t\t\t\tcase 1: this.y = value; break;\n\t\t\t\tcase 2: this.z = value; break;\n\t\t\t\tcase 3: this.w = value; break;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tgetComponent: function ( index ) {\n\t\n\t\t\tswitch ( index ) {\n\t\n\t\t\t\tcase 0: return this.x;\n\t\t\t\tcase 1: return this.y;\n\t\t\t\tcase 2: return this.z;\n\t\t\t\tcase 3: return this.w;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor( this.x, this.y, this.z, this.w );\n\t\n\t\t},\n\t\n\t\tcopy: function ( v ) {\n\t\n\t\t\tthis.x = v.x;\n\t\t\tthis.y = v.y;\n\t\t\tthis.z = v.z;\n\t\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tadd: function ( v, w ) {\n\t\n\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\t\treturn this.addVectors( v, w );\n\t\n\t\t\t}\n\t\n\t\t\tthis.x += v.x;\n\t\t\tthis.y += v.y;\n\t\t\tthis.z += v.z;\n\t\t\tthis.w += v.w;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\taddScalar: function ( s ) {\n\t\n\t\t\tthis.x += s;\n\t\t\tthis.y += s;\n\t\t\tthis.z += s;\n\t\t\tthis.w += s;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\taddVectors: function ( a, b ) {\n\t\n\t\t\tthis.x = a.x + b.x;\n\t\t\tthis.y = a.y + b.y;\n\t\t\tthis.z = a.z + b.z;\n\t\t\tthis.w = a.w + b.w;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\taddScaledVector: function ( v, s ) {\n\t\n\t\t\tthis.x += v.x * s;\n\t\t\tthis.y += v.y * s;\n\t\t\tthis.z += v.z * s;\n\t\t\tthis.w += v.w * s;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsub: function ( v, w ) {\n\t\n\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\t\treturn this.subVectors( v, w );\n\t\n\t\t\t}\n\t\n\t\t\tthis.x -= v.x;\n\t\t\tthis.y -= v.y;\n\t\t\tthis.z -= v.z;\n\t\t\tthis.w -= v.w;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsubScalar: function ( s ) {\n\t\n\t\t\tthis.x -= s;\n\t\t\tthis.y -= s;\n\t\t\tthis.z -= s;\n\t\t\tthis.w -= s;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsubVectors: function ( a, b ) {\n\t\n\t\t\tthis.x = a.x - b.x;\n\t\t\tthis.y = a.y - b.y;\n\t\t\tthis.z = a.z - b.z;\n\t\t\tthis.w = a.w - b.w;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmultiplyScalar: function ( scalar ) {\n\t\n\t\t\tif ( isFinite( scalar ) ) {\n\t\n\t\t\t\tthis.x *= scalar;\n\t\t\t\tthis.y *= scalar;\n\t\t\t\tthis.z *= scalar;\n\t\t\t\tthis.w *= scalar;\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.x = 0;\n\t\t\t\tthis.y = 0;\n\t\t\t\tthis.z = 0;\n\t\t\t\tthis.w = 0;\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tapplyMatrix4: function ( m ) {\n\t\n\t\t\tvar x = this.x, y = this.y, z = this.z, w = this.w;\n\t\t\tvar e = m.elements;\n\t\n\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\n\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\n\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\n\t\t\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tdivideScalar: function ( scalar ) {\n\t\n\t\t\treturn this.multiplyScalar( 1 / scalar );\n\t\n\t\t},\n\t\n\t\tsetAxisAngleFromQuaternion: function ( q ) {\n\t\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\t\n\t\t\t// q is assumed to be normalized\n\t\n\t\t\tthis.w = 2 * Math.acos( q.w );\n\t\n\t\t\tvar s = Math.sqrt( 1 - q.w * q.w );\n\t\n\t\t\tif ( s < 0.0001 ) {\n\t\n\t\t\t\t this.x = 1;\n\t\t\t\t this.y = 0;\n\t\t\t\t this.z = 0;\n\t\n\t\t\t} else {\n\t\n\t\t\t\t this.x = q.x / s;\n\t\t\t\t this.y = q.y / s;\n\t\t\t\t this.z = q.z / s;\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetAxisAngleFromRotationMatrix: function ( m ) {\n\t\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\t\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\t\n\t\t\tvar angle, x, y, z,\t\t// variables for result\n\t\t\t\tepsilon = 0.01,\t\t// margin to allow for rounding errors\n\t\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\n\t\n\t\t\t\tte = m.elements,\n\t\n\t\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\t\n\t\t\tif ( ( Math.abs( m12 - m21 ) < epsilon ) &&\n\t\t\t     ( Math.abs( m13 - m31 ) < epsilon ) &&\n\t\t\t     ( Math.abs( m23 - m32 ) < epsilon ) ) {\n\t\n\t\t\t\t// singularity found\n\t\t\t\t// first check for identity matrix which must have +1 for all terms\n\t\t\t\t// in leading diagonal and zero in other terms\n\t\n\t\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&\n\t\t\t\t     ( Math.abs( m13 + m31 ) < epsilon2 ) &&\n\t\t\t\t     ( Math.abs( m23 + m32 ) < epsilon2 ) &&\n\t\t\t\t     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\n\t\n\t\t\t\t\t// this singularity is identity matrix so angle = 0\n\t\n\t\t\t\t\tthis.set( 1, 0, 0, 0 );\n\t\n\t\t\t\t\treturn this; // zero angle, arbitrary axis\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// otherwise this singularity is angle = 180\n\t\n\t\t\t\tangle = Math.PI;\n\t\n\t\t\t\tvar xx = ( m11 + 1 ) / 2;\n\t\t\t\tvar yy = ( m22 + 1 ) / 2;\n\t\t\t\tvar zz = ( m33 + 1 ) / 2;\n\t\t\t\tvar xy = ( m12 + m21 ) / 4;\n\t\t\t\tvar xz = ( m13 + m31 ) / 4;\n\t\t\t\tvar yz = ( m23 + m32 ) / 4;\n\t\n\t\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) {\n\t\n\t\t\t\t\t// m11 is the largest diagonal term\n\t\n\t\t\t\t\tif ( xx < epsilon ) {\n\t\n\t\t\t\t\t\tx = 0;\n\t\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\t\tz = 0.707106781;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tx = Math.sqrt( xx );\n\t\t\t\t\t\ty = xy / x;\n\t\t\t\t\t\tz = xz / x;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( yy > zz ) {\n\t\n\t\t\t\t\t// m22 is the largest diagonal term\n\t\n\t\t\t\t\tif ( yy < epsilon ) {\n\t\n\t\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\t\ty = 0;\n\t\t\t\t\t\tz = 0.707106781;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\ty = Math.sqrt( yy );\n\t\t\t\t\t\tx = xy / y;\n\t\t\t\t\t\tz = yz / y;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// m33 is the largest diagonal term so base result on this\n\t\n\t\t\t\t\tif ( zz < epsilon ) {\n\t\n\t\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\t\tz = 0;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tz = Math.sqrt( zz );\n\t\t\t\t\t\tx = xz / z;\n\t\t\t\t\t\ty = yz / z;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.set( x, y, z, angle );\n\t\n\t\t\t\treturn this; // return 180 deg rotation\n\t\n\t\t\t}\n\t\n\t\t\t// as we have reached here there are no singularities so we can handle normally\n\t\n\t\t\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +\n\t\t\t                   ( m13 - m31 ) * ( m13 - m31 ) +\n\t\t\t                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\n\t\n\t\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\n\t\n\t\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\n\t\t\t// caught by singularity test above, but I've left it in just in case\n\t\n\t\t\tthis.x = ( m32 - m23 ) / s;\n\t\t\tthis.y = ( m13 - m31 ) / s;\n\t\t\tthis.z = ( m21 - m12 ) / s;\n\t\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmin: function ( v ) {\n\t\n\t\t\tthis.x = Math.min( this.x, v.x );\n\t\t\tthis.y = Math.min( this.y, v.y );\n\t\t\tthis.z = Math.min( this.z, v.z );\n\t\t\tthis.w = Math.min( this.w, v.w );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmax: function ( v ) {\n\t\n\t\t\tthis.x = Math.max( this.x, v.x );\n\t\t\tthis.y = Math.max( this.y, v.y );\n\t\t\tthis.z = Math.max( this.z, v.z );\n\t\t\tthis.w = Math.max( this.w, v.w );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tclamp: function ( min, max ) {\n\t\n\t\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\t\n\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\t\t\tthis.w = Math.max( min.w, Math.min( max.w, this.w ) );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tclampScalar: function () {\n\t\n\t\t\tvar min, max;\n\t\n\t\t\treturn function clampScalar( minVal, maxVal ) {\n\t\n\t\t\t\tif ( min === undefined ) {\n\t\n\t\t\t\t\tmin = new THREE.Vector4();\n\t\t\t\t\tmax = new THREE.Vector4();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tmin.set( minVal, minVal, minVal, minVal );\n\t\t\t\tmax.set( maxVal, maxVal, maxVal, maxVal );\n\t\n\t\t\t\treturn this.clamp( min, max );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tfloor: function () {\n\t\n\t\t\tthis.x = Math.floor( this.x );\n\t\t\tthis.y = Math.floor( this.y );\n\t\t\tthis.z = Math.floor( this.z );\n\t\t\tthis.w = Math.floor( this.w );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tceil: function () {\n\t\n\t\t\tthis.x = Math.ceil( this.x );\n\t\t\tthis.y = Math.ceil( this.y );\n\t\t\tthis.z = Math.ceil( this.z );\n\t\t\tthis.w = Math.ceil( this.w );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tround: function () {\n\t\n\t\t\tthis.x = Math.round( this.x );\n\t\t\tthis.y = Math.round( this.y );\n\t\t\tthis.z = Math.round( this.z );\n\t\t\tthis.w = Math.round( this.w );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\troundToZero: function () {\n\t\n\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\t\t\tthis.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tnegate: function () {\n\t\n\t\t\tthis.x = - this.x;\n\t\t\tthis.y = - this.y;\n\t\t\tthis.z = - this.z;\n\t\t\tthis.w = - this.w;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tdot: function ( v ) {\n\t\n\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n\t\n\t\t},\n\t\n\t\tlengthSq: function () {\n\t\n\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\t\n\t\t},\n\t\n\t\tlength: function () {\n\t\n\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\n\t\n\t\t},\n\t\n\t\tlengthManhattan: function () {\n\t\n\t\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\n\t\n\t\t},\n\t\n\t\tnormalize: function () {\n\t\n\t\t\treturn this.divideScalar( this.length() );\n\t\n\t\t},\n\t\n\t\tsetLength: function ( length ) {\n\t\n\t\t\treturn this.multiplyScalar( length / this.length() );\n\t\n\t\t},\n\t\n\t\tlerp: function ( v, alpha ) {\n\t\n\t\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\t\tthis.z += ( v.z - this.z ) * alpha;\n\t\t\tthis.w += ( v.w - this.w ) * alpha;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tlerpVectors: function ( v1, v2, alpha ) {\n\t\n\t\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\t\n\t\t},\n\t\n\t\tequals: function ( v ) {\n\t\n\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\n\t\n\t\t},\n\t\n\t\tfromArray: function ( array, offset ) {\n\t\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\tthis.x = array[ offset ];\n\t\t\tthis.y = array[ offset + 1 ];\n\t\t\tthis.z = array[ offset + 2 ];\n\t\t\tthis.w = array[ offset + 3 ];\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\tarray[ offset ] = this.x;\n\t\t\tarray[ offset + 1 ] = this.y;\n\t\t\tarray[ offset + 2 ] = this.z;\n\t\t\tarray[ offset + 3 ] = this.w;\n\t\n\t\t\treturn array;\n\t\n\t\t},\n\t\n\t\tfromAttribute: function ( attribute, index, offset ) {\n\t\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\tindex = index * attribute.itemSize + offset;\n\t\n\t\t\tthis.x = attribute.array[ index ];\n\t\t\tthis.y = attribute.array[ index + 1 ];\n\t\t\tthis.z = attribute.array[ index + 2 ];\n\t\t\tthis.w = attribute.array[ index + 3 ];\n\t\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/math/Euler.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author bhouston / http://clara.io\n\t */\n\t\n\tTHREE.Euler = function ( x, y, z, order ) {\n\t\n\t\tthis._x = x || 0;\n\t\tthis._y = y || 0;\n\t\tthis._z = z || 0;\n\t\tthis._order = order || THREE.Euler.DefaultOrder;\n\t\n\t};\n\t\n\tTHREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\n\t\n\tTHREE.Euler.DefaultOrder = 'XYZ';\n\t\n\tTHREE.Euler.prototype = {\n\t\n\t\tconstructor: THREE.Euler,\n\t\n\t\tget x () {\n\t\n\t\t\treturn this._x;\n\t\n\t\t},\n\t\n\t\tset x ( value ) {\n\t\n\t\t\tthis._x = value;\n\t\t\tthis.onChangeCallback();\n\t\n\t\t},\n\t\n\t\tget y () {\n\t\n\t\t\treturn this._y;\n\t\n\t\t},\n\t\n\t\tset y ( value ) {\n\t\n\t\t\tthis._y = value;\n\t\t\tthis.onChangeCallback();\n\t\n\t\t},\n\t\n\t\tget z () {\n\t\n\t\t\treturn this._z;\n\t\n\t\t},\n\t\n\t\tset z ( value ) {\n\t\n\t\t\tthis._z = value;\n\t\t\tthis.onChangeCallback();\n\t\n\t\t},\n\t\n\t\tget order () {\n\t\n\t\t\treturn this._order;\n\t\n\t\t},\n\t\n\t\tset order ( value ) {\n\t\n\t\t\tthis._order = value;\n\t\t\tthis.onChangeCallback();\n\t\n\t\t},\n\t\n\t\tset: function ( x, y, z, order ) {\n\t\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\t\t\tthis._order = order || this._order;\n\t\n\t\t\tthis.onChangeCallback();\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor( this._x, this._y, this._z, this._order );\n\t\n\t\t},\n\t\n\t\tcopy: function ( euler ) {\n\t\n\t\t\tthis._x = euler._x;\n\t\t\tthis._y = euler._y;\n\t\t\tthis._z = euler._z;\n\t\t\tthis._order = euler._order;\n\t\n\t\t\tthis.onChangeCallback();\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetFromRotationMatrix: function ( m, order, update ) {\n\t\n\t\t\tvar clamp = THREE.Math.clamp;\n\t\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\t\n\t\t\tvar te = m.elements;\n\t\t\tvar m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\n\t\t\tvar m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\n\t\t\tvar m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\t\n\t\t\torder = order || this._order;\n\t\n\t\t\tif ( order === 'XYZ' ) {\n\t\n\t\t\t\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\n\t\n\t\t\t\tif ( Math.abs( m13 ) < 0.99999 ) {\n\t\n\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\t\tthis._z = Math.atan2( - m12, m11 );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\t\tthis._z = 0;\n\t\n\t\t\t\t}\n\t\n\t\t\t} else if ( order === 'YXZ' ) {\n\t\n\t\t\t\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\n\t\n\t\t\t\tif ( Math.abs( m23 ) < 0.99999 ) {\n\t\n\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\t\t\t\t\tthis._z = Math.atan2( m21, m22 );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\t\t\t\t\tthis._z = 0;\n\t\n\t\t\t\t}\n\t\n\t\t\t} else if ( order === 'ZXY' ) {\n\t\n\t\t\t\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\n\t\n\t\t\t\tif ( Math.abs( m32 ) < 0.99999 ) {\n\t\n\t\t\t\t\tthis._y = Math.atan2( - m31, m33 );\n\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis._y = 0;\n\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\t\n\t\t\t\t}\n\t\n\t\t\t} else if ( order === 'ZYX' ) {\n\t\n\t\t\t\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\n\t\n\t\t\t\tif ( Math.abs( m31 ) < 0.99999 ) {\n\t\n\t\t\t\t\tthis._x = Math.atan2( m32, m33 );\n\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis._x = 0;\n\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\t\n\t\t\t\t}\n\t\n\t\t\t} else if ( order === 'YZX' ) {\n\t\n\t\t\t\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\n\t\n\t\t\t\tif ( Math.abs( m21 ) < 0.99999 ) {\n\t\n\t\t\t\t\tthis._x = Math.atan2( - m23, m22 );\n\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis._x = 0;\n\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\t\n\t\t\t\t}\n\t\n\t\t\t} else if ( order === 'XZY' ) {\n\t\n\t\t\t\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\n\t\n\t\t\t\tif ( Math.abs( m12 ) < 0.99999 ) {\n\t\n\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\t\tthis._y = Math.atan2( m13, m11 );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\t\tthis._y = 0;\n\t\n\t\t\t\t}\n\t\n\t\t\t} else {\n\t\n\t\t\t\tconsole.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );\n\t\n\t\t\t}\n\t\n\t\t\tthis._order = order;\n\t\n\t\t\tif ( update !== false ) this.onChangeCallback();\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetFromQuaternion: function () {\n\t\n\t\t\tvar matrix;\n\t\n\t\t\treturn function setFromQuaternion( q, order, update ) {\n\t\n\t\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\n\t\n\t\t\t\tmatrix.makeRotationFromQuaternion( q );\n\t\n\t\t\t\treturn this.setFromRotationMatrix( matrix, order, update );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tsetFromVector3: function ( v, order ) {\n\t\n\t\t\treturn this.set( v.x, v.y, v.z, order || this._order );\n\t\n\t\t},\n\t\n\t\treorder: function () {\n\t\n\t\t\t// WARNING: this discards revolution information -bhouston\n\t\n\t\t\tvar q = new THREE.Quaternion();\n\t\n\t\t\treturn function reorder( newOrder ) {\n\t\n\t\t\t\tq.setFromEuler( this );\n\t\t\t\t\n\t\t\t\treturn this.setFromQuaternion( q, newOrder );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tequals: function ( euler ) {\n\t\n\t\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\n\t\n\t\t},\n\t\n\t\tfromArray: function ( array ) {\n\t\n\t\t\tthis._x = array[ 0 ];\n\t\t\tthis._y = array[ 1 ];\n\t\t\tthis._z = array[ 2 ];\n\t\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\n\t\n\t\t\tthis.onChangeCallback();\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\tarray[ offset ] = this._x;\n\t\t\tarray[ offset + 1 ] = this._y;\n\t\t\tarray[ offset + 2 ] = this._z;\n\t\t\tarray[ offset + 3 ] = this._order;\n\t\n\t\t\treturn array;\n\t\n\t\t},\n\t\n\t\ttoVector3: function ( optionalResult ) {\n\t\n\t\t\tif ( optionalResult ) {\n\t\n\t\t\t\treturn optionalResult.set( this._x, this._y, this._z );\n\t\n\t\t\t} else {\n\t\n\t\t\t\treturn new THREE.Vector3( this._x, this._y, this._z );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tonChange: function ( callback ) {\n\t\n\t\t\tthis.onChangeCallback = callback;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tonChangeCallback: function () {}\n\t\n\t};\n\t\n\t// File:src/math/Line3.js\n\t\n\t/**\n\t * @author bhouston / http://clara.io\n\t */\n\t\n\tTHREE.Line3 = function ( start, end ) {\n\t\n\t\tthis.start = ( start !== undefined ) ? start : new THREE.Vector3();\n\t\tthis.end = ( end !== undefined ) ? end : new THREE.Vector3();\n\t\n\t};\n\t\n\tTHREE.Line3.prototype = {\n\t\n\t\tconstructor: THREE.Line3,\n\t\n\t\tset: function ( start, end ) {\n\t\n\t\t\tthis.start.copy( start );\n\t\t\tthis.end.copy( end );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t},\n\t\n\t\tcopy: function ( line ) {\n\t\n\t\t\tthis.start.copy( line.start );\n\t\t\tthis.end.copy( line.end );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tcenter: function ( optionalTarget ) {\n\t\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\t\treturn result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\n\t\n\t\t},\n\t\n\t\tdelta: function ( optionalTarget ) {\n\t\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\t\treturn result.subVectors( this.end, this.start );\n\t\n\t\t},\n\t\n\t\tdistanceSq: function () {\n\t\n\t\t\treturn this.start.distanceToSquared( this.end );\n\t\n\t\t},\n\t\n\t\tdistance: function () {\n\t\n\t\t\treturn this.start.distanceTo( this.end );\n\t\n\t\t},\n\t\n\t\tat: function ( t, optionalTarget ) {\n\t\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\n\t\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\n\t\n\t\t},\n\t\n\t\tclosestPointToPointParameter: function () {\n\t\n\t\t\tvar startP = new THREE.Vector3();\n\t\t\tvar startEnd = new THREE.Vector3();\n\t\n\t\t\treturn function closestPointToPointParameter( point, clampToLine ) {\n\t\n\t\t\t\tstartP.subVectors( point, this.start );\n\t\t\t\tstartEnd.subVectors( this.end, this.start );\n\t\n\t\t\t\tvar startEnd2 = startEnd.dot( startEnd );\n\t\t\t\tvar startEnd_startP = startEnd.dot( startP );\n\t\n\t\t\t\tvar t = startEnd_startP / startEnd2;\n\t\n\t\t\t\tif ( clampToLine ) {\n\t\n\t\t\t\t\tt = THREE.Math.clamp( t, 0, 1 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn t;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tclosestPointToPoint: function ( point, clampToLine, optionalTarget ) {\n\t\n\t\t\tvar t = this.closestPointToPointParameter( point, clampToLine );\n\t\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\n\t\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\n\t\n\t\t},\n\t\n\t\tapplyMatrix4: function ( matrix ) {\n\t\n\t\t\tthis.start.applyMatrix4( matrix );\n\t\t\tthis.end.applyMatrix4( matrix );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tequals: function ( line ) {\n\t\n\t\t\treturn line.start.equals( this.start ) && line.end.equals( this.end );\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/math/Box2.js\n\t\n\t/**\n\t * @author bhouston / http://clara.io\n\t */\n\t\n\tTHREE.Box2 = function ( min, max ) {\n\t\n\t\tthis.min = ( min !== undefined ) ? min : new THREE.Vector2( + Infinity, + Infinity );\n\t\tthis.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );\n\t\n\t};\n\t\n\tTHREE.Box2.prototype = {\n\t\n\t\tconstructor: THREE.Box2,\n\t\n\t\tset: function ( min, max ) {\n\t\n\t\t\tthis.min.copy( min );\n\t\t\tthis.max.copy( max );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetFromPoints: function ( points ) {\n\t\n\t\t\tthis.makeEmpty();\n\t\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\t\n\t\t\t\tthis.expandByPoint( points[ i ] );\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetFromCenterAndSize: function () {\n\t\n\t\t\tvar v1 = new THREE.Vector2();\n\t\n\t\t\treturn function setFromCenterAndSize( center, size ) {\n\t\n\t\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\t\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\t\tthis.max.copy( center ).add( halfSize );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t},\n\t\n\t\tcopy: function ( box ) {\n\t\n\t\t\tthis.min.copy( box.min );\n\t\t\tthis.max.copy( box.max );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmakeEmpty: function () {\n\t\n\t\t\tthis.min.x = this.min.y = + Infinity;\n\t\t\tthis.max.x = this.max.y = - Infinity;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tisEmpty: function () {\n\t\n\t\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\t\n\t\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\n\t\n\t\t},\n\t\n\t\tcenter: function ( optionalTarget ) {\n\t\n\t\t\tvar result = optionalTarget || new THREE.Vector2();\n\t\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\t\n\t\t},\n\t\n\t\tsize: function ( optionalTarget ) {\n\t\n\t\t\tvar result = optionalTarget || new THREE.Vector2();\n\t\t\treturn result.subVectors( this.max, this.min );\n\t\n\t\t},\n\t\n\t\texpandByPoint: function ( point ) {\n\t\n\t\t\tthis.min.min( point );\n\t\t\tthis.max.max( point );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\texpandByVector: function ( vector ) {\n\t\n\t\t\tthis.min.sub( vector );\n\t\t\tthis.max.add( vector );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\texpandByScalar: function ( scalar ) {\n\t\n\t\t\tthis.min.addScalar( - scalar );\n\t\t\tthis.max.addScalar( scalar );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tcontainsPoint: function ( point ) {\n\t\n\t\t\tif ( point.x < this.min.x || point.x > this.max.x ||\n\t\t\t     point.y < this.min.y || point.y > this.max.y ) {\n\t\n\t\t\t\treturn false;\n\t\n\t\t\t}\n\t\n\t\t\treturn true;\n\t\n\t\t},\n\t\n\t\tcontainsBox: function ( box ) {\n\t\n\t\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\n\t\t\t     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {\n\t\n\t\t\t\treturn true;\n\t\n\t\t\t}\n\t\n\t\t\treturn false;\n\t\n\t\t},\n\t\n\t\tgetParameter: function ( point, optionalTarget ) {\n\t\n\t\t\t// This can potentially have a divide by zero if the box\n\t\t\t// has a size dimension of 0.\n\t\n\t\t\tvar result = optionalTarget || new THREE.Vector2();\n\t\n\t\t\treturn result.set(\n\t\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\n\t\t\t);\n\t\n\t\t},\n\t\n\t\tintersectsBox: function ( box ) {\n\t\n\t\t\t// using 6 splitting planes to rule out intersections.\n\t\n\t\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\t     box.max.y < this.min.y || box.min.y > this.max.y ) {\n\t\n\t\t\t\treturn false;\n\t\n\t\t\t}\n\t\n\t\t\treturn true;\n\t\n\t\t},\n\t\n\t\tclampPoint: function ( point, optionalTarget ) {\n\t\n\t\t\tvar result = optionalTarget || new THREE.Vector2();\n\t\t\treturn result.copy( point ).clamp( this.min, this.max );\n\t\n\t\t},\n\t\n\t\tdistanceToPoint: function () {\n\t\n\t\t\tvar v1 = new THREE.Vector2();\n\t\n\t\t\treturn function distanceToPoint( point ) {\n\t\n\t\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\t\treturn clampedPoint.sub( point ).length();\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tintersect: function ( box ) {\n\t\n\t\t\tthis.min.max( box.min );\n\t\t\tthis.max.min( box.max );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tunion: function ( box ) {\n\t\n\t\t\tthis.min.min( box.min );\n\t\t\tthis.max.max( box.max );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\ttranslate: function ( offset ) {\n\t\n\t\t\tthis.min.add( offset );\n\t\t\tthis.max.add( offset );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tequals: function ( box ) {\n\t\n\t\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/math/Box3.js\n\t\n\t/**\n\t * @author bhouston / http://clara.io\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\t\n\tTHREE.Box3 = function ( min, max ) {\n\t\n\t\tthis.min = ( min !== undefined ) ? min : new THREE.Vector3( + Infinity, + Infinity, + Infinity );\n\t\tthis.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );\n\t\n\t};\n\t\n\tTHREE.Box3.prototype = {\n\t\n\t\tconstructor: THREE.Box3,\n\t\n\t\tset: function ( min, max ) {\n\t\n\t\t\tthis.min.copy( min );\n\t\t\tthis.max.copy( max );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetFromArray: function ( array ) {\n\t\n\t\t\tvar minX = + Infinity;\n\t\t\tvar minY = + Infinity;\n\t\t\tvar minZ = + Infinity;\n\t\n\t\t\tvar maxX = - Infinity;\n\t\t\tvar maxY = - Infinity;\n\t\t\tvar maxZ = - Infinity;\n\t\n\t\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\n\t\n\t\t\t\tvar x = array[ i ];\n\t\t\t\tvar y = array[ i + 1 ];\n\t\t\t\tvar z = array[ i + 2 ];\n\t\n\t\t\t\tif ( x < minX ) minX = x;\n\t\t\t\tif ( y < minY ) minY = y;\n\t\t\t\tif ( z < minZ ) minZ = z;\n\t\n\t\t\t\tif ( x > maxX ) maxX = x;\n\t\t\t\tif ( y > maxY ) maxY = y;\n\t\t\t\tif ( z > maxZ ) maxZ = z;\n\t\n\t\t\t}\n\t\n\t\t\tthis.min.set( minX, minY, minZ );\n\t\t\tthis.max.set( maxX, maxY, maxZ );\n\t\n\t\t},\n\t\n\t\tsetFromPoints: function ( points ) {\n\t\n\t\t\tthis.makeEmpty();\n\t\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\t\n\t\t\t\tthis.expandByPoint( points[ i ] );\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetFromCenterAndSize: function () {\n\t\n\t\t\tvar v1 = new THREE.Vector3();\n\t\n\t\t\treturn function setFromCenterAndSize( center, size ) {\n\t\n\t\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\t\n\t\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\t\tthis.max.copy( center ).add( halfSize );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tsetFromObject: function () {\n\t\n\t\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\n\t\t\t// accounting for both the object's, and children's, world transforms\n\t\n\t\t\tvar v1 = new THREE.Vector3();\n\t\n\t\t\treturn function setFromObject( object ) {\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tobject.updateMatrixWorld( true );\n\t\n\t\t\t\tthis.makeEmpty();\n\t\n\t\t\t\tobject.traverse( function ( node ) {\n\t\n\t\t\t\t\tvar geometry = node.geometry;\n\t\n\t\t\t\t\tif ( geometry !== undefined ) {\n\t\n\t\t\t\t\t\tif ( geometry instanceof THREE.Geometry ) {\n\t\n\t\t\t\t\t\t\tvar vertices = geometry.vertices;\n\t\n\t\t\t\t\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\t\t\tv1.copy( vertices[ i ] );\n\t\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\n\t\n\t\t\t\t\t\t\t\tscope.expandByPoint( v1 );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else if ( geometry instanceof THREE.BufferGeometry && geometry.attributes[ 'position' ] !== undefined ) {\n\t\n\t\t\t\t\t\t\tvar positions = geometry.attributes[ 'position' ].array;\n\t\n\t\t\t\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 3 ) {\n\t\n\t\t\t\t\t\t\t\tv1.fromArray( positions, i );\n\t\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\n\t\n\t\t\t\t\t\t\t\tscope.expandByPoint( v1 );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t},\n\t\n\t\tcopy: function ( box ) {\n\t\n\t\t\tthis.min.copy( box.min );\n\t\t\tthis.max.copy( box.max );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmakeEmpty: function () {\n\t\n\t\t\tthis.min.x = this.min.y = this.min.z = + Infinity;\n\t\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tisEmpty: function () {\n\t\n\t\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\t\n\t\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\n\t\n\t\t},\n\t\n\t\tcenter: function ( optionalTarget ) {\n\t\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\t\n\t\t},\n\t\n\t\tsize: function ( optionalTarget ) {\n\t\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\t\treturn result.subVectors( this.max, this.min );\n\t\n\t\t},\n\t\n\t\texpandByPoint: function ( point ) {\n\t\n\t\t\tthis.min.min( point );\n\t\t\tthis.max.max( point );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\texpandByVector: function ( vector ) {\n\t\n\t\t\tthis.min.sub( vector );\n\t\t\tthis.max.add( vector );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\texpandByScalar: function ( scalar ) {\n\t\n\t\t\tthis.min.addScalar( - scalar );\n\t\t\tthis.max.addScalar( scalar );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tcontainsPoint: function ( point ) {\n\t\n\t\t\tif ( point.x < this.min.x || point.x > this.max.x ||\n\t\t\t\t\t point.y < this.min.y || point.y > this.max.y ||\n\t\t\t\t\t point.z < this.min.z || point.z > this.max.z ) {\n\t\n\t\t\t\treturn false;\n\t\n\t\t\t}\n\t\n\t\t\treturn true;\n\t\n\t\t},\n\t\n\t\tcontainsBox: function ( box ) {\n\t\n\t\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\n\t\t\t\t ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&\n\t\t\t\t ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {\n\t\n\t\t\t\treturn true;\n\t\n\t\t\t}\n\t\n\t\t\treturn false;\n\t\n\t\t},\n\t\n\t\tgetParameter: function ( point, optionalTarget ) {\n\t\n\t\t\t// This can potentially have a divide by zero if the box\n\t\t\t// has a size dimension of 0.\n\t\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\n\t\t\treturn result.set(\n\t\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\n\t\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\n\t\t\t);\n\t\n\t\t},\n\t\n\t\tintersectsBox: function ( box ) {\n\t\n\t\t\t// using 6 splitting planes to rule out intersections.\n\t\n\t\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\t\t\t box.max.y < this.min.y || box.min.y > this.max.y ||\n\t\t\t\t\t box.max.z < this.min.z || box.min.z > this.max.z ) {\n\t\n\t\t\t\treturn false;\n\t\n\t\t\t}\n\t\n\t\t\treturn true;\n\t\n\t\t},\n\t\n\t\tintersectsSphere: ( function () {\n\t\n\t\t\tvar closestPoint;\n\t\n\t\t\treturn function intersectsSphere( sphere ) {\n\t\n\t\t\t\tif ( closestPoint === undefined ) closestPoint = new THREE.Vector3();\n\t\n\t\t\t\t// Find the point on the AABB closest to the sphere center.\n\t\t\t\tthis.clampPoint( sphere.center, closestPoint );\n\t\n\t\t\t\t// If that point is inside the sphere, the AABB and sphere intersect.\n\t\t\t\treturn closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\n\t\n\t\t\t};\n\t\n\t\t} )(),\n\t\n\t\tintersectsPlane: function ( plane ) {\n\t\n\t\t\t// We compute the minimum and maximum dot product values. If those values\n\t\t\t// are on the same side (back or front) of the plane, then there is no intersection.\n\t\n\t\t\tvar min, max;\n\t\n\t\t\tif ( plane.normal.x > 0 ) {\n\t\n\t\t\t\tmin = plane.normal.x * this.min.x;\n\t\t\t\tmax = plane.normal.x * this.max.x;\n\t\n\t\t\t} else {\n\t\n\t\t\t\tmin = plane.normal.x * this.max.x;\n\t\t\t\tmax = plane.normal.x * this.min.x;\n\t\n\t\t\t}\n\t\n\t\t\tif ( plane.normal.y > 0 ) {\n\t\n\t\t\t\tmin += plane.normal.y * this.min.y;\n\t\t\t\tmax += plane.normal.y * this.max.y;\n\t\n\t\t\t} else {\n\t\n\t\t\t\tmin += plane.normal.y * this.max.y;\n\t\t\t\tmax += plane.normal.y * this.min.y;\n\t\n\t\t\t}\n\t\n\t\t\tif ( plane.normal.z > 0 ) {\n\t\n\t\t\t\tmin += plane.normal.z * this.min.z;\n\t\t\t\tmax += plane.normal.z * this.max.z;\n\t\n\t\t\t} else {\n\t\n\t\t\t\tmin += plane.normal.z * this.max.z;\n\t\t\t\tmax += plane.normal.z * this.min.z;\n\t\n\t\t\t}\n\t\n\t\t\treturn ( min <= plane.constant && max >= plane.constant );\n\t\n\t\t},\n\t\n\t\tclampPoint: function ( point, optionalTarget ) {\n\t\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\t\treturn result.copy( point ).clamp( this.min, this.max );\n\t\n\t\t},\n\t\n\t\tdistanceToPoint: function () {\n\t\n\t\t\tvar v1 = new THREE.Vector3();\n\t\n\t\t\treturn function distanceToPoint( point ) {\n\t\n\t\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\t\treturn clampedPoint.sub( point ).length();\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tgetBoundingSphere: function () {\n\t\n\t\t\tvar v1 = new THREE.Vector3();\n\t\n\t\t\treturn function getBoundingSphere( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new THREE.Sphere();\n\t\n\t\t\t\tresult.center = this.center();\n\t\t\t\tresult.radius = this.size( v1 ).length() * 0.5;\n\t\n\t\t\t\treturn result;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tintersect: function ( box ) {\n\t\n\t\t\tthis.min.max( box.min );\n\t\t\tthis.max.min( box.max );\n\t\n\t\t\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n\t\t\tif( this.isEmpty() ) this.makeEmpty();\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tunion: function ( box ) {\n\t\n\t\t\tthis.min.min( box.min );\n\t\t\tthis.max.max( box.max );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tapplyMatrix4: function () {\n\t\n\t\t\tvar points = [\n\t\t\t\tnew THREE.Vector3(),\n\t\t\t\tnew THREE.Vector3(),\n\t\t\t\tnew THREE.Vector3(),\n\t\t\t\tnew THREE.Vector3(),\n\t\t\t\tnew THREE.Vector3(),\n\t\t\t\tnew THREE.Vector3(),\n\t\t\t\tnew THREE.Vector3(),\n\t\t\t\tnew THREE.Vector3()\n\t\t\t];\n\t\n\t\t\treturn function applyMatrix4( matrix ) {\n\t\n\t\t\t\t// transform of empty box is an empty box.\n\t\t\t\tif( this.isEmpty() ) return this;\n\t\n\t\t\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\n\t\t\t\tpoints[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\n\t\t\t\tpoints[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\n\t\t\t\tpoints[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\n\t\t\t\tpoints[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\n\t\t\t\tpoints[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\n\t\t\t\tpoints[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\n\t\t\t\tpoints[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\n\t\t\t\tpoints[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );\t// 111\n\t\n\t\t\t\tthis.setFromPoints( points );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\ttranslate: function ( offset ) {\n\t\n\t\t\tthis.min.add( offset );\n\t\t\tthis.max.add( offset );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tequals: function ( box ) {\n\t\n\t\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/math/Matrix3.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author bhouston / http://clara.io\n\t * @author tschw\n\t */\n\t\n\tTHREE.Matrix3 = function () {\n\t\n\t\tthis.elements = new Float32Array( [\n\t\n\t\t\t1, 0, 0,\n\t\t\t0, 1, 0,\n\t\t\t0, 0, 1\n\t\n\t\t] );\n\t\n\t\tif ( arguments.length > 0 ) {\n\t\n\t\t\tconsole.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.Matrix3.prototype = {\n\t\n\t\tconstructor: THREE.Matrix3,\n\t\n\t\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\t\n\t\t\tvar te = this.elements;\n\t\n\t\t\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\n\t\t\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\n\t\t\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tidentity: function () {\n\t\n\t\t\tthis.set(\n\t\n\t\t\t\t1, 0, 0,\n\t\t\t\t0, 1, 0,\n\t\t\t\t0, 0, 1\n\t\n\t\t\t);\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor().fromArray( this.elements );\n\t\n\t\t},\n\t\n\t\tcopy: function ( m ) {\n\t\n\t\t\tvar me = m.elements;\n\t\n\t\t\tthis.set(\n\t\n\t\t\t\tme[ 0 ], me[ 3 ], me[ 6 ],\n\t\t\t\tme[ 1 ], me[ 4 ], me[ 7 ],\n\t\t\t\tme[ 2 ], me[ 5 ], me[ 8 ]\n\t\n\t\t\t);\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetFromMatrix4: function( m ) {\n\t\n\t\t\tvar me = m.elements;\n\t\n\t\t\tthis.set(\n\t\n\t\t\t\tme[ 0 ], me[ 4 ], me[  8 ],\n\t\t\t\tme[ 1 ], me[ 5 ], me[  9 ],\n\t\t\t\tme[ 2 ], me[ 6 ], me[ 10 ]\n\t\n\t\t\t);\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tapplyToVector3Array: function () {\n\t\n\t\t\tvar v1;\n\t\n\t\t\treturn function applyToVector3Array( array, offset, length ) {\n\t\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\t\tif ( length === undefined ) length = array.length;\n\t\n\t\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\n\t\n\t\t\t\t\tv1.fromArray( array, j );\n\t\t\t\t\tv1.applyMatrix3( this );\n\t\t\t\t\tv1.toArray( array, j );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn array;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tapplyToBuffer: function () {\n\t\n\t\t\tvar v1;\n\t\n\t\t\treturn function applyToBuffer( buffer, offset, length ) {\n\t\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\t\tif ( length === undefined ) length = buffer.length / buffer.itemSize;\n\t\n\t\t\t\tfor ( var i = 0, j = offset; i < length; i ++, j ++ ) {\n\t\n\t\t\t\t\tv1.x = buffer.getX( j );\n\t\t\t\t\tv1.y = buffer.getY( j );\n\t\t\t\t\tv1.z = buffer.getZ( j );\n\t\n\t\t\t\t\tv1.applyMatrix3( this );\n\t\n\t\t\t\t\tbuffer.setXYZ( v1.x, v1.y, v1.z );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn buffer;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tmultiplyScalar: function ( s ) {\n\t\n\t\t\tvar te = this.elements;\n\t\n\t\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\n\t\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\n\t\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tdeterminant: function () {\n\t\n\t\t\tvar te = this.elements;\n\t\n\t\t\tvar a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\n\t\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\n\t\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\n\t\n\t\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n\t\n\t\t},\n\t\n\t\tgetInverse: function ( matrix, throwOnDegenerate ) {\n\t\n\t\t\tif ( matrix instanceof THREE.Matrix4 ) {\n\t\n\t\t\t\tconsole.error( \"THREE.Matrix3.getInverse no longer takes a Matrix4 argument.\" );\n\t\n\t\t\t}\n\t\n\t\t\tvar me = matrix.elements,\n\t\t\t\tte = this.elements,\n\t\n\t\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],\n\t\t\t\tn12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],\n\t\t\t\tn13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],\n\t\n\t\t\t\tt11 = n33 * n22 - n32 * n23,\n\t\t\t\tt12 = n32 * n13 - n33 * n12,\n\t\t\t\tt13 = n23 * n12 - n22 * n13,\n\t\n\t\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\n\t\n\t\t\tif ( det === 0 ) {\n\t\n\t\t\t\tvar msg = \"THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0\";\n\t\n\t\t\t\tif ( throwOnDegenerate || false ) {\n\t\n\t\t\t\t\tthrow new Error( msg );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tconsole.warn( msg );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this.identity();\n\t\t\t}\n\t\t\t\n\t\t\tvar detInv = 1 / det;\n\t\n\t\t\tte[ 0 ] = t11 * detInv;\n\t\t\tte[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;\n\t\t\tte[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;\n\t\n\t\t\tte[ 3 ] = t12 * detInv;\n\t\t\tte[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;\n\t\t\tte[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;\n\t\n\t\t\tte[ 6 ] = t13 * detInv;\n\t\t\tte[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;\n\t\t\tte[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\ttranspose: function () {\n\t\n\t\t\tvar tmp, m = this.elements;\n\t\n\t\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\n\t\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\n\t\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tflattenToArrayOffset: function ( array, offset ) {\n\t\n\t\t\tconsole.warn( \"THREE.Matrix3: .flattenToArrayOffset is deprecated \" +\n\t\t\t\t\t\"- just use .toArray instead.\" );\n\t\n\t\t\treturn this.toArray( array, offset );\n\t\n\t\t},\n\t\n\t\tgetNormalMatrix: function ( matrix4 ) {\n\t\n\t\t\treturn this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();\n\t\n\t\t},\n\t\n\t\ttransposeIntoArray: function ( r ) {\n\t\n\t\t\tvar m = this.elements;\n\t\n\t\t\tr[ 0 ] = m[ 0 ];\n\t\t\tr[ 1 ] = m[ 3 ];\n\t\t\tr[ 2 ] = m[ 6 ];\n\t\t\tr[ 3 ] = m[ 1 ];\n\t\t\tr[ 4 ] = m[ 4 ];\n\t\t\tr[ 5 ] = m[ 7 ];\n\t\t\tr[ 6 ] = m[ 2 ];\n\t\t\tr[ 7 ] = m[ 5 ];\n\t\t\tr[ 8 ] = m[ 8 ];\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tfromArray: function ( array ) {\n\t\n\t\t\tthis.elements.set( array );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\tvar te = this.elements;\n\t\n\t\t\tarray[ offset ] = te[ 0 ];\n\t\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\t\tarray[ offset + 2 ] = te[ 2 ];\n\t\n\t\t\tarray[ offset + 3 ] = te[ 3 ];\n\t\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\t\tarray[ offset + 5 ] = te[ 5 ];\n\t\n\t\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\t\tarray[ offset + 7 ] = te[ 7 ];\n\t\t\tarray[ offset + 8 ]  = te[ 8 ];\n\t\n\t\t\treturn array;\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/math/Matrix4.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author supereggbert / http://www.paulbrunt.co.uk/\n\t * @author philogb / http://blog.thejit.org/\n\t * @author jordi_ros / http://plattsoft.com\n\t * @author D1plo1d / http://github.com/D1plo1d\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author timknip / http://www.floorplanner.com/\n\t * @author bhouston / http://clara.io\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\t\n\tTHREE.Matrix4 = function () {\n\t\n\t\tthis.elements = new Float32Array( [\n\t\n\t\t\t1, 0, 0, 0,\n\t\t\t0, 1, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\t\n\t\t] );\n\t\n\t\tif ( arguments.length > 0 ) {\n\t\n\t\t\tconsole.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.Matrix4.prototype = {\n\t\n\t\tconstructor: THREE.Matrix4,\n\t\n\t\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\t\n\t\t\tvar te = this.elements;\n\t\n\t\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\n\t\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\n\t\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\n\t\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tidentity: function () {\n\t\n\t\t\tthis.set(\n\t\n\t\t\t\t1, 0, 0, 0,\n\t\t\t\t0, 1, 0, 0,\n\t\t\t\t0, 0, 1, 0,\n\t\t\t\t0, 0, 0, 1\n\t\n\t\t\t);\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new THREE.Matrix4().fromArray( this.elements );\n\t\n\t\t},\n\t\n\t\tcopy: function ( m ) {\n\t\n\t\t\tthis.elements.set( m.elements );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tcopyPosition: function ( m ) {\n\t\n\t\t\tvar te = this.elements;\n\t\t\tvar me = m.elements;\n\t\n\t\t\tte[ 12 ] = me[ 12 ];\n\t\t\tte[ 13 ] = me[ 13 ];\n\t\t\tte[ 14 ] = me[ 14 ];\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\textractBasis: function ( xAxis, yAxis, zAxis ) {\n\t\n\t\t\txAxis.setFromMatrixColumn( this, 0 );\n\t\t\tyAxis.setFromMatrixColumn( this, 1 );\n\t\t\tzAxis.setFromMatrixColumn( this, 2 );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmakeBasis: function ( xAxis, yAxis, zAxis ) {\n\t\n\t\t\tthis.set(\n\t\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\n\t\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\n\t\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\n\t\t\t\t0,       0,       0,       1\n\t\t\t);\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\textractRotation: function () {\n\t\n\t\t\tvar v1;\n\t\n\t\t\treturn function extractRotation( m ) {\n\t\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\n\t\t\t\tvar te = this.elements;\n\t\t\t\tvar me = m.elements;\n\t\n\t\t\t\tvar scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();\n\t\t\t\tvar scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();\n\t\t\t\tvar scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();\n\t\n\t\t\t\tte[ 0 ] = me[ 0 ] * scaleX;\n\t\t\t\tte[ 1 ] = me[ 1 ] * scaleX;\n\t\t\t\tte[ 2 ] = me[ 2 ] * scaleX;\n\t\n\t\t\t\tte[ 4 ] = me[ 4 ] * scaleY;\n\t\t\t\tte[ 5 ] = me[ 5 ] * scaleY;\n\t\t\t\tte[ 6 ] = me[ 6 ] * scaleY;\n\t\n\t\t\t\tte[ 8 ] = me[ 8 ] * scaleZ;\n\t\t\t\tte[ 9 ] = me[ 9 ] * scaleZ;\n\t\t\t\tte[ 10 ] = me[ 10 ] * scaleZ;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tmakeRotationFromEuler: function ( euler ) {\n\t\n\t\t\tif ( euler instanceof THREE.Euler === false ) {\n\t\n\t\t\t\tconsole.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\n\t\n\t\t\t}\n\t\n\t\t\tvar te = this.elements;\n\t\n\t\t\tvar x = euler.x, y = euler.y, z = euler.z;\n\t\t\tvar a = Math.cos( x ), b = Math.sin( x );\n\t\t\tvar c = Math.cos( y ), d = Math.sin( y );\n\t\t\tvar e = Math.cos( z ), f = Math.sin( z );\n\t\n\t\t\tif ( euler.order === 'XYZ' ) {\n\t\n\t\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\t\n\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\tte[ 4 ] = - c * f;\n\t\t\t\tte[ 8 ] = d;\n\t\n\t\t\t\tte[ 1 ] = af + be * d;\n\t\t\t\tte[ 5 ] = ae - bf * d;\n\t\t\t\tte[ 9 ] = - b * c;\n\t\n\t\t\t\tte[ 2 ] = bf - ae * d;\n\t\t\t\tte[ 6 ] = be + af * d;\n\t\t\t\tte[ 10 ] = a * c;\n\t\n\t\t\t} else if ( euler.order === 'YXZ' ) {\n\t\n\t\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\t\n\t\t\t\tte[ 0 ] = ce + df * b;\n\t\t\t\tte[ 4 ] = de * b - cf;\n\t\t\t\tte[ 8 ] = a * d;\n\t\n\t\t\t\tte[ 1 ] = a * f;\n\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\tte[ 9 ] = - b;\n\t\n\t\t\t\tte[ 2 ] = cf * b - de;\n\t\t\t\tte[ 6 ] = df + ce * b;\n\t\t\t\tte[ 10 ] = a * c;\n\t\n\t\t\t} else if ( euler.order === 'ZXY' ) {\n\t\n\t\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\t\n\t\t\t\tte[ 0 ] = ce - df * b;\n\t\t\t\tte[ 4 ] = - a * f;\n\t\t\t\tte[ 8 ] = de + cf * b;\n\t\n\t\t\t\tte[ 1 ] = cf + de * b;\n\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\tte[ 9 ] = df - ce * b;\n\t\n\t\t\t\tte[ 2 ] = - a * d;\n\t\t\t\tte[ 6 ] = b;\n\t\t\t\tte[ 10 ] = a * c;\n\t\n\t\t\t} else if ( euler.order === 'ZYX' ) {\n\t\n\t\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\t\n\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\tte[ 4 ] = be * d - af;\n\t\t\t\tte[ 8 ] = ae * d + bf;\n\t\n\t\t\t\tte[ 1 ] = c * f;\n\t\t\t\tte[ 5 ] = bf * d + ae;\n\t\t\t\tte[ 9 ] = af * d - be;\n\t\n\t\t\t\tte[ 2 ] = - d;\n\t\t\t\tte[ 6 ] = b * c;\n\t\t\t\tte[ 10 ] = a * c;\n\t\n\t\t\t} else if ( euler.order === 'YZX' ) {\n\t\n\t\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\t\n\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\tte[ 4 ] = bd - ac * f;\n\t\t\t\tte[ 8 ] = bc * f + ad;\n\t\n\t\t\t\tte[ 1 ] = f;\n\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\tte[ 9 ] = - b * e;\n\t\n\t\t\t\tte[ 2 ] = - d * e;\n\t\t\t\tte[ 6 ] = ad * f + bc;\n\t\t\t\tte[ 10 ] = ac - bd * f;\n\t\n\t\t\t} else if ( euler.order === 'XZY' ) {\n\t\n\t\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\t\n\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\tte[ 4 ] = - f;\n\t\t\t\tte[ 8 ] = d * e;\n\t\n\t\t\t\tte[ 1 ] = ac * f + bd;\n\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\tte[ 9 ] = ad * f - bc;\n\t\n\t\t\t\tte[ 2 ] = bc * f - ad;\n\t\t\t\tte[ 6 ] = b * e;\n\t\t\t\tte[ 10 ] = bd * f + ac;\n\t\n\t\t\t}\n\t\n\t\t\t// last column\n\t\t\tte[ 3 ] = 0;\n\t\t\tte[ 7 ] = 0;\n\t\t\tte[ 11 ] = 0;\n\t\n\t\t\t// bottom row\n\t\t\tte[ 12 ] = 0;\n\t\t\tte[ 13 ] = 0;\n\t\t\tte[ 14 ] = 0;\n\t\t\tte[ 15 ] = 1;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmakeRotationFromQuaternion: function ( q ) {\n\t\n\t\t\tvar te = this.elements;\n\t\n\t\t\tvar x = q.x, y = q.y, z = q.z, w = q.w;\n\t\t\tvar x2 = x + x, y2 = y + y, z2 = z + z;\n\t\t\tvar xx = x * x2, xy = x * y2, xz = x * z2;\n\t\t\tvar yy = y * y2, yz = y * z2, zz = z * z2;\n\t\t\tvar wx = w * x2, wy = w * y2, wz = w * z2;\n\t\n\t\t\tte[ 0 ] = 1 - ( yy + zz );\n\t\t\tte[ 4 ] = xy - wz;\n\t\t\tte[ 8 ] = xz + wy;\n\t\n\t\t\tte[ 1 ] = xy + wz;\n\t\t\tte[ 5 ] = 1 - ( xx + zz );\n\t\t\tte[ 9 ] = yz - wx;\n\t\n\t\t\tte[ 2 ] = xz - wy;\n\t\t\tte[ 6 ] = yz + wx;\n\t\t\tte[ 10 ] = 1 - ( xx + yy );\n\t\n\t\t\t// last column\n\t\t\tte[ 3 ] = 0;\n\t\t\tte[ 7 ] = 0;\n\t\t\tte[ 11 ] = 0;\n\t\n\t\t\t// bottom row\n\t\t\tte[ 12 ] = 0;\n\t\t\tte[ 13 ] = 0;\n\t\t\tte[ 14 ] = 0;\n\t\t\tte[ 15 ] = 1;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tlookAt: function () {\n\t\n\t\t\tvar x, y, z;\n\t\n\t\t\treturn function lookAt( eye, target, up ) {\n\t\n\t\t\t\tif ( x === undefined ) {\n\t\n\t\t\t\t\tx = new THREE.Vector3();\n\t\t\t\t\ty = new THREE.Vector3();\n\t\t\t\t\tz = new THREE.Vector3();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tz.subVectors( eye, target ).normalize();\n\t\n\t\t\t\tif ( z.lengthSq() === 0 ) {\n\t\n\t\t\t\t\tz.z = 1;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tx.crossVectors( up, z ).normalize();\n\t\n\t\t\t\tif ( x.lengthSq() === 0 ) {\n\t\n\t\t\t\t\tz.z += 0.0001;\n\t\t\t\t\tx.crossVectors( up, z ).normalize();\n\t\n\t\t\t\t}\n\t\n\t\t\t\ty.crossVectors( z, x );\n\t\n\t\n\t\t\t\tte[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;\n\t\t\t\tte[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;\n\t\t\t\tte[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tmultiply: function ( m, n ) {\n\t\n\t\t\tif ( n !== undefined ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\n\t\t\t\treturn this.multiplyMatrices( m, n );\n\t\n\t\t\t}\n\t\n\t\t\treturn this.multiplyMatrices( this, m );\n\t\n\t\t},\n\t\n\t\tpremultiply: function ( m ) {\n\t\n\t\t\treturn this.multiplyMatrices( m, this );\n\t\n\t\t},\n\t\n\t\tmultiplyMatrices: function ( a, b ) {\n\t\n\t\t\tvar ae = a.elements;\n\t\t\tvar be = b.elements;\n\t\t\tvar te = this.elements;\n\t\n\t\t\tvar a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\n\t\t\tvar a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\n\t\t\tvar a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\n\t\t\tvar a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\n\t\n\t\t\tvar b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\n\t\t\tvar b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\n\t\t\tvar b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\n\t\t\tvar b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\n\t\n\t\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n\t\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n\t\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n\t\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\t\n\t\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n\t\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n\t\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n\t\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\t\n\t\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n\t\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n\t\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n\t\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\t\n\t\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n\t\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n\t\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n\t\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmultiplyToArray: function ( a, b, r ) {\n\t\n\t\t\tvar te = this.elements;\n\t\n\t\t\tthis.multiplyMatrices( a, b );\n\t\n\t\t\tr[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];\n\t\t\tr[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];\n\t\t\tr[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];\n\t\t\tr[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmultiplyScalar: function ( s ) {\n\t\n\t\t\tvar te = this.elements;\n\t\n\t\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\n\t\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\n\t\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\n\t\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tapplyToVector3Array: function () {\n\t\n\t\t\tvar v1;\n\t\n\t\t\treturn function applyToVector3Array( array, offset, length ) {\n\t\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\t\tif ( length === undefined ) length = array.length;\n\t\n\t\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\n\t\n\t\t\t\t\tv1.fromArray( array, j );\n\t\t\t\t\tv1.applyMatrix4( this );\n\t\t\t\t\tv1.toArray( array, j );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn array;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tapplyToBuffer: function () {\n\t\n\t\t\tvar v1;\n\t\n\t\t\treturn function applyToBuffer( buffer, offset, length ) {\n\t\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\t\tif ( length === undefined ) length = buffer.length / buffer.itemSize;\n\t\n\t\t\t\tfor ( var i = 0, j = offset; i < length; i ++, j ++ ) {\n\t\n\t\t\t\t\tv1.x = buffer.getX( j );\n\t\t\t\t\tv1.y = buffer.getY( j );\n\t\t\t\t\tv1.z = buffer.getZ( j );\n\t\n\t\t\t\t\tv1.applyMatrix4( this );\n\t\n\t\t\t\t\tbuffer.setXYZ( v1.x, v1.y, v1.z );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn buffer;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tdeterminant: function () {\n\t\n\t\t\tvar te = this.elements;\n\t\n\t\t\tvar n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\n\t\t\tvar n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\n\t\t\tvar n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\n\t\t\tvar n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\n\t\n\t\t\t//TODO: make this more efficient\n\t\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\t\n\t\t\treturn (\n\t\t\t\tn41 * (\n\t\t\t\t\t+ n14 * n23 * n32\n\t\t\t\t\t - n13 * n24 * n32\n\t\t\t\t\t - n14 * n22 * n33\n\t\t\t\t\t + n12 * n24 * n33\n\t\t\t\t\t + n13 * n22 * n34\n\t\t\t\t\t - n12 * n23 * n34\n\t\t\t\t) +\n\t\t\t\tn42 * (\n\t\t\t\t\t+ n11 * n23 * n34\n\t\t\t\t\t - n11 * n24 * n33\n\t\t\t\t\t + n14 * n21 * n33\n\t\t\t\t\t - n13 * n21 * n34\n\t\t\t\t\t + n13 * n24 * n31\n\t\t\t\t\t - n14 * n23 * n31\n\t\t\t\t) +\n\t\t\t\tn43 * (\n\t\t\t\t\t+ n11 * n24 * n32\n\t\t\t\t\t - n11 * n22 * n34\n\t\t\t\t\t - n14 * n21 * n32\n\t\t\t\t\t + n12 * n21 * n34\n\t\t\t\t\t + n14 * n22 * n31\n\t\t\t\t\t - n12 * n24 * n31\n\t\t\t\t) +\n\t\t\t\tn44 * (\n\t\t\t\t\t- n13 * n22 * n31\n\t\t\t\t\t - n11 * n23 * n32\n\t\t\t\t\t + n11 * n22 * n33\n\t\t\t\t\t + n13 * n21 * n32\n\t\t\t\t\t - n12 * n21 * n33\n\t\t\t\t\t + n12 * n23 * n31\n\t\t\t\t)\n\t\n\t\t\t);\n\t\n\t\t},\n\t\n\t\ttranspose: function () {\n\t\n\t\t\tvar te = this.elements;\n\t\t\tvar tmp;\n\t\n\t\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\n\t\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\n\t\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\n\t\n\t\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\n\t\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\n\t\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tflattenToArrayOffset: function ( array, offset ) {\n\t\n\t\t\tconsole.warn( \"THREE.Matrix3: .flattenToArrayOffset is deprecated \" +\n\t\t\t\t\t\"- just use .toArray instead.\" );\n\t\n\t\t\treturn this.toArray( array, offset );\n\t\n\t\t},\n\t\n\t\tgetPosition: function () {\n\t\n\t\t\tvar v1;\n\t\n\t\t\treturn function getPosition() {\n\t\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );\n\t\n\t\t\t\treturn v1.setFromMatrixColumn( this, 3 );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tsetPosition: function ( v ) {\n\t\n\t\t\tvar te = this.elements;\n\t\n\t\t\tte[ 12 ] = v.x;\n\t\t\tte[ 13 ] = v.y;\n\t\t\tte[ 14 ] = v.z;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tgetInverse: function ( m, throwOnDegenerate ) {\n\t\n\t\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n\t\t\tvar te = this.elements,\n\t\t\t\tme = m.elements,\n\t\n\t\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],\n\t\t\t\tn12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],\n\t\t\t\tn13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],\n\t\t\t\tn14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],\n\t\n\t\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\n\t\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\n\t\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\n\t\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n\t\n\t\t\tvar det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n\t\n\t\t\tif ( det === 0 ) {\n\t\n\t\t\t\tvar msg = \"THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0\";\n\t\n\t\t\t\tif ( throwOnDegenerate || false ) {\n\t\n\t\t\t\t\tthrow new Error( msg );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tconsole.warn( msg );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this.identity();\n\t\n\t\t\t}\n\t\t\t\n\t\t\tvar detInv = 1 / det;\n\t\n\t\t\tte[ 0 ] = t11 * detInv;\n\t\t\tte[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;\n\t\t\tte[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;\n\t\t\tte[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;\n\t\n\t\t\tte[ 4 ] = t12 * detInv;\n\t\t\tte[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;\n\t\t\tte[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;\n\t\t\tte[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;\n\t\n\t\t\tte[ 8 ] = t13 * detInv;\n\t\t\tte[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;\n\t\t\tte[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;\n\t\t\tte[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;\n\t\n\t\t\tte[ 12 ] = t14 * detInv;\n\t\t\tte[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;\n\t\t\tte[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;\n\t\t\tte[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tscale: function ( v ) {\n\t\n\t\t\tvar te = this.elements;\n\t\t\tvar x = v.x, y = v.y, z = v.z;\n\t\n\t\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\n\t\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\n\t\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\n\t\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tgetMaxScaleOnAxis: function () {\n\t\n\t\t\tvar te = this.elements;\n\t\n\t\t\tvar scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\n\t\t\tvar scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\n\t\t\tvar scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\n\t\n\t\t\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\n\t\n\t\t},\n\t\n\t\tmakeTranslation: function ( x, y, z ) {\n\t\n\t\t\tthis.set(\n\t\n\t\t\t\t1, 0, 0, x,\n\t\t\t\t0, 1, 0, y,\n\t\t\t\t0, 0, 1, z,\n\t\t\t\t0, 0, 0, 1\n\t\n\t\t\t);\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmakeRotationX: function ( theta ) {\n\t\n\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\t\n\t\t\tthis.set(\n\t\n\t\t\t\t1, 0,  0, 0,\n\t\t\t\t0, c, - s, 0,\n\t\t\t\t0, s,  c, 0,\n\t\t\t\t0, 0,  0, 1\n\t\n\t\t\t);\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmakeRotationY: function ( theta ) {\n\t\n\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\t\n\t\t\tthis.set(\n\t\n\t\t\t\t c, 0, s, 0,\n\t\t\t\t 0, 1, 0, 0,\n\t\t\t\t- s, 0, c, 0,\n\t\t\t\t 0, 0, 0, 1\n\t\n\t\t\t);\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmakeRotationZ: function ( theta ) {\n\t\n\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\t\n\t\t\tthis.set(\n\t\n\t\t\t\tc, - s, 0, 0,\n\t\t\t\ts,  c, 0, 0,\n\t\t\t\t0,  0, 1, 0,\n\t\t\t\t0,  0, 0, 1\n\t\n\t\t\t);\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmakeRotationAxis: function ( axis, angle ) {\n\t\n\t\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\n\t\n\t\t\tvar c = Math.cos( angle );\n\t\t\tvar s = Math.sin( angle );\n\t\t\tvar t = 1 - c;\n\t\t\tvar x = axis.x, y = axis.y, z = axis.z;\n\t\t\tvar tx = t * x, ty = t * y;\n\t\n\t\t\tthis.set(\n\t\n\t\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\n\t\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\n\t\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\n\t\t\t\t0, 0, 0, 1\n\t\n\t\t\t);\n\t\n\t\t\t return this;\n\t\n\t\t},\n\t\n\t\tmakeScale: function ( x, y, z ) {\n\t\n\t\t\tthis.set(\n\t\n\t\t\t\tx, 0, 0, 0,\n\t\t\t\t0, y, 0, 0,\n\t\t\t\t0, 0, z, 0,\n\t\t\t\t0, 0, 0, 1\n\t\n\t\t\t);\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tcompose: function ( position, quaternion, scale ) {\n\t\n\t\t\tthis.makeRotationFromQuaternion( quaternion );\n\t\t\tthis.scale( scale );\n\t\t\tthis.setPosition( position );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tdecompose: function () {\n\t\n\t\t\tvar vector, matrix;\n\t\n\t\t\treturn function decompose( position, quaternion, scale ) {\n\t\n\t\t\t\tif ( vector === undefined ) {\n\t\n\t\t\t\t\tvector = new THREE.Vector3();\n\t\t\t\t\tmatrix = new THREE.Matrix4();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tvar sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\n\t\t\t\tvar sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\n\t\t\t\tvar sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\n\t\n\t\t\t\t// if determine is negative, we need to invert one scale\n\t\t\t\tvar det = this.determinant();\n\t\t\t\tif ( det < 0 ) {\n\t\n\t\t\t\t\tsx = - sx;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tposition.x = te[ 12 ];\n\t\t\t\tposition.y = te[ 13 ];\n\t\t\t\tposition.z = te[ 14 ];\n\t\n\t\t\t\t// scale the rotation part\n\t\n\t\t\t\tmatrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()\n\t\n\t\t\t\tvar invSX = 1 / sx;\n\t\t\t\tvar invSY = 1 / sy;\n\t\t\t\tvar invSZ = 1 / sz;\n\t\n\t\t\t\tmatrix.elements[ 0 ] *= invSX;\n\t\t\t\tmatrix.elements[ 1 ] *= invSX;\n\t\t\t\tmatrix.elements[ 2 ] *= invSX;\n\t\n\t\t\t\tmatrix.elements[ 4 ] *= invSY;\n\t\t\t\tmatrix.elements[ 5 ] *= invSY;\n\t\t\t\tmatrix.elements[ 6 ] *= invSY;\n\t\n\t\t\t\tmatrix.elements[ 8 ] *= invSZ;\n\t\t\t\tmatrix.elements[ 9 ] *= invSZ;\n\t\t\t\tmatrix.elements[ 10 ] *= invSZ;\n\t\n\t\t\t\tquaternion.setFromRotationMatrix( matrix );\n\t\n\t\t\t\tscale.x = sx;\n\t\t\t\tscale.y = sy;\n\t\t\t\tscale.z = sz;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tmakeFrustum: function ( left, right, bottom, top, near, far ) {\n\t\n\t\t\tvar te = this.elements;\n\t\t\tvar x = 2 * near / ( right - left );\n\t\t\tvar y = 2 * near / ( top - bottom );\n\t\n\t\t\tvar a = ( right + left ) / ( right - left );\n\t\t\tvar b = ( top + bottom ) / ( top - bottom );\n\t\t\tvar c = - ( far + near ) / ( far - near );\n\t\t\tvar d = - 2 * far * near / ( far - near );\n\t\n\t\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a;\tte[ 12 ] = 0;\n\t\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b;\tte[ 13 ] = 0;\n\t\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c;\tte[ 14 ] = d;\n\t\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = - 1;\tte[ 15 ] = 0;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmakePerspective: function ( fov, aspect, near, far ) {\n\t\n\t\t\tvar ymax = near * Math.tan( THREE.Math.DEG2RAD * fov * 0.5 );\n\t\t\tvar ymin = - ymax;\n\t\t\tvar xmin = ymin * aspect;\n\t\t\tvar xmax = ymax * aspect;\n\t\n\t\t\treturn this.makeFrustum( xmin, xmax, ymin, ymax, near, far );\n\t\n\t\t},\n\t\n\t\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\n\t\n\t\t\tvar te = this.elements;\n\t\t\tvar w = 1.0 / ( right - left );\n\t\t\tvar h = 1.0 / ( top - bottom );\n\t\t\tvar p = 1.0 / ( far - near );\n\t\n\t\t\tvar x = ( right + left ) * w;\n\t\t\tvar y = ( top + bottom ) * h;\n\t\t\tvar z = ( far + near ) * p;\n\t\n\t\t\tte[ 0 ] = 2 * w;\tte[ 4 ] = 0;\tte[ 8 ] = 0;\tte[ 12 ] = - x;\n\t\t\tte[ 1 ] = 0;\tte[ 5 ] = 2 * h;\tte[ 9 ] = 0;\tte[ 13 ] = - y;\n\t\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = - 2 * p;\tte[ 14 ] = - z;\n\t\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = 0;\tte[ 15 ] = 1;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tequals: function ( matrix ) {\n\t\n\t\t\tvar te = this.elements;\n\t\t\tvar me = matrix.elements;\n\t\n\t\t\tfor ( var i = 0; i < 16; i ++ ) {\n\t\n\t\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\t\n\t\t\t}\n\t\n\t\t\treturn true;\n\t\n\t\t},\n\t\n\t\tfromArray: function ( array ) {\n\t\n\t\t\tthis.elements.set( array );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\tvar te = this.elements;\n\t\n\t\t\tarray[ offset ] = te[ 0 ];\n\t\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\t\tarray[ offset + 2 ] = te[ 2 ];\n\t\t\tarray[ offset + 3 ] = te[ 3 ];\n\t\n\t\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\t\tarray[ offset + 5 ] = te[ 5 ];\n\t\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\t\tarray[ offset + 7 ] = te[ 7 ];\n\t\n\t\t\tarray[ offset + 8 ]  = te[ 8 ];\n\t\t\tarray[ offset + 9 ]  = te[ 9 ];\n\t\t\tarray[ offset + 10 ] = te[ 10 ];\n\t\t\tarray[ offset + 11 ] = te[ 11 ];\n\t\n\t\t\tarray[ offset + 12 ] = te[ 12 ];\n\t\t\tarray[ offset + 13 ] = te[ 13 ];\n\t\t\tarray[ offset + 14 ] = te[ 14 ];\n\t\t\tarray[ offset + 15 ] = te[ 15 ];\n\t\n\t\t\treturn array;\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/math/Ray.js\n\t\n\t/**\n\t * @author bhouston / http://clara.io\n\t */\n\t\n\tTHREE.Ray = function ( origin, direction ) {\n\t\n\t\tthis.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();\n\t\tthis.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();\n\t\n\t};\n\t\n\tTHREE.Ray.prototype = {\n\t\n\t\tconstructor: THREE.Ray,\n\t\n\t\tset: function ( origin, direction ) {\n\t\n\t\t\tthis.origin.copy( origin );\n\t\t\tthis.direction.copy( direction );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t},\n\t\n\t\tcopy: function ( ray ) {\n\t\n\t\t\tthis.origin.copy( ray.origin );\n\t\t\tthis.direction.copy( ray.direction );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tat: function ( t, optionalTarget ) {\n\t\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\n\t\t\treturn result.copy( this.direction ).multiplyScalar( t ).add( this.origin );\n\t\n\t\t},\n\t\n\t\tlookAt: function ( v ) {\n\t\n\t\t\tthis.direction.copy( v ).sub( this.origin ).normalize();\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\trecast: function () {\n\t\n\t\t\tvar v1 = new THREE.Vector3();\n\t\n\t\t\treturn function recast( t ) {\n\t\n\t\t\t\tthis.origin.copy( this.at( t, v1 ) );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tclosestPointToPoint: function ( point, optionalTarget ) {\n\t\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\t\tresult.subVectors( point, this.origin );\n\t\t\tvar directionDistance = result.dot( this.direction );\n\t\n\t\t\tif ( directionDistance < 0 ) {\n\t\n\t\t\t\treturn result.copy( this.origin );\n\t\n\t\t\t}\n\t\n\t\t\treturn result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\t\n\t\t},\n\t\n\t\tdistanceToPoint: function ( point ) {\n\t\n\t\t\treturn Math.sqrt( this.distanceSqToPoint( point ) );\n\t\n\t\t},\n\t\n\t\tdistanceSqToPoint: function () {\n\t\n\t\t\tvar v1 = new THREE.Vector3();\n\t\n\t\t\treturn function distanceSqToPoint( point ) {\n\t\n\t\t\t\tvar directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\n\t\n\t\t\t\t// point behind the ray\n\t\n\t\t\t\tif ( directionDistance < 0 ) {\n\t\n\t\t\t\t\treturn this.origin.distanceToSquared( point );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tv1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\t\n\t\t\t\treturn v1.distanceToSquared( point );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tdistanceSqToSegment: function () {\n\t\n\t\t\tvar segCenter = new THREE.Vector3();\n\t\t\tvar segDir = new THREE.Vector3();\n\t\t\tvar diff = new THREE.Vector3();\n\t\n\t\t\treturn function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\n\t\n\t\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\n\t\t\t\t// It returns the min distance between the ray and the segment\n\t\t\t\t// defined by v0 and v1\n\t\t\t\t// It can also set two optional targets :\n\t\t\t\t// - The closest point on the ray\n\t\t\t\t// - The closest point on the segment\n\t\n\t\t\t\tsegCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\n\t\t\t\tsegDir.copy( v1 ).sub( v0 ).normalize();\n\t\t\t\tdiff.copy( this.origin ).sub( segCenter );\n\t\n\t\t\t\tvar segExtent = v0.distanceTo( v1 ) * 0.5;\n\t\t\t\tvar a01 = - this.direction.dot( segDir );\n\t\t\t\tvar b0 = diff.dot( this.direction );\n\t\t\t\tvar b1 = - diff.dot( segDir );\n\t\t\t\tvar c = diff.lengthSq();\n\t\t\t\tvar det = Math.abs( 1 - a01 * a01 );\n\t\t\t\tvar s0, s1, sqrDist, extDet;\n\t\n\t\t\t\tif ( det > 0 ) {\n\t\n\t\t\t\t\t// The ray and segment are not parallel.\n\t\n\t\t\t\t\ts0 = a01 * b1 - b0;\n\t\t\t\t\ts1 = a01 * b0 - b1;\n\t\t\t\t\textDet = segExtent * det;\n\t\n\t\t\t\t\tif ( s0 >= 0 ) {\n\t\n\t\t\t\t\t\tif ( s1 >= - extDet ) {\n\t\n\t\t\t\t\t\t\tif ( s1 <= extDet ) {\n\t\n\t\t\t\t\t\t\t\t// region 0\n\t\t\t\t\t\t\t\t// Minimum at interior points of ray and segment.\n\t\n\t\t\t\t\t\t\t\tvar invDet = 1 / det;\n\t\t\t\t\t\t\t\ts0 *= invDet;\n\t\t\t\t\t\t\t\ts1 *= invDet;\n\t\t\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t// region 1\n\t\n\t\t\t\t\t\t\t\ts1 = segExtent;\n\t\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t// region 5\n\t\n\t\t\t\t\t\t\ts1 = - segExtent;\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tif ( s1 <= - extDet ) {\n\t\n\t\t\t\t\t\t\t// region 4\n\t\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\n\t\t\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\t\n\t\t\t\t\t\t} else if ( s1 <= extDet ) {\n\t\n\t\t\t\t\t\t\t// region 3\n\t\n\t\t\t\t\t\t\ts0 = 0;\n\t\t\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t// region 2\n\t\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\n\t\t\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// Ray and segment are parallel.\n\t\n\t\t\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( optionalPointOnRay ) {\n\t\n\t\t\t\t\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( optionalPointOnSegment ) {\n\t\n\t\t\t\t\toptionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn sqrDist;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tintersectSphere: function () {\n\t\n\t\t\tvar v1 = new THREE.Vector3();\n\t\n\t\t\treturn function intersectSphere( sphere, optionalTarget ) {\n\t\n\t\t\t\tv1.subVectors( sphere.center, this.origin );\n\t\t\t\tvar tca = v1.dot( this.direction );\n\t\t\t\tvar d2 = v1.dot( v1 ) - tca * tca;\n\t\t\t\tvar radius2 = sphere.radius * sphere.radius;\n\t\n\t\t\t\tif ( d2 > radius2 ) return null;\n\t\n\t\t\t\tvar thc = Math.sqrt( radius2 - d2 );\n\t\n\t\t\t\t// t0 = first intersect point - entrance on front of sphere\n\t\t\t\tvar t0 = tca - thc;\n\t\n\t\t\t\t// t1 = second intersect point - exit point on back of sphere\n\t\t\t\tvar t1 = tca + thc;\n\t\n\t\t\t\t// test to see if both t0 and t1 are behind the ray - if so, return null\n\t\t\t\tif ( t0 < 0 && t1 < 0 ) return null;\n\t\n\t\t\t\t// test to see if t0 is behind the ray:\n\t\t\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n\t\t\t\t// in order to always return an intersect point that is in front of the ray.\n\t\t\t\tif ( t0 < 0 ) return this.at( t1, optionalTarget );\n\t\n\t\t\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\n\t\t\t\treturn this.at( t0, optionalTarget );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tintersectsSphere: function ( sphere ) {\n\t\n\t\t\treturn this.distanceToPoint( sphere.center ) <= sphere.radius;\n\t\n\t\t},\n\t\n\t\tdistanceToPlane: function ( plane ) {\n\t\n\t\t\tvar denominator = plane.normal.dot( this.direction );\n\t\n\t\t\tif ( denominator === 0 ) {\n\t\n\t\t\t\t// line is coplanar, return origin\n\t\t\t\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\n\t\n\t\t\t\t\treturn 0;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\n\t\n\t\t\t\treturn null;\n\t\n\t\t\t}\n\t\n\t\t\tvar t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\n\t\n\t\t\t// Return if the ray never intersects the plane\n\t\n\t\t\treturn t >= 0 ? t :  null;\n\t\n\t\t},\n\t\n\t\tintersectPlane: function ( plane, optionalTarget ) {\n\t\n\t\t\tvar t = this.distanceToPlane( plane );\n\t\n\t\t\tif ( t === null ) {\n\t\n\t\t\t\treturn null;\n\t\n\t\t\t}\n\t\n\t\t\treturn this.at( t, optionalTarget );\n\t\n\t\t},\n\t\n\t\n\t\n\t\tintersectsPlane: function ( plane ) {\n\t\n\t\t\t// check if the ray lies on the plane first\n\t\n\t\t\tvar distToPoint = plane.distanceToPoint( this.origin );\n\t\n\t\t\tif ( distToPoint === 0 ) {\n\t\n\t\t\t\treturn true;\n\t\n\t\t\t}\n\t\n\t\t\tvar denominator = plane.normal.dot( this.direction );\n\t\n\t\t\tif ( denominator * distToPoint < 0 ) {\n\t\n\t\t\t\treturn true;\n\t\n\t\t\t}\n\t\n\t\t\t// ray origin is behind the plane (and is pointing behind it)\n\t\n\t\t\treturn false;\n\t\n\t\t},\n\t\n\t\tintersectBox: function ( box, optionalTarget ) {\n\t\n\t\t\tvar tmin, tmax, tymin, tymax, tzmin, tzmax;\n\t\n\t\t\tvar invdirx = 1 / this.direction.x,\n\t\t\t\tinvdiry = 1 / this.direction.y,\n\t\t\t\tinvdirz = 1 / this.direction.z;\n\t\n\t\t\tvar origin = this.origin;\n\t\n\t\t\tif ( invdirx >= 0 ) {\n\t\n\t\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\n\t\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\n\t\n\t\t\t} else {\n\t\n\t\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\n\t\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\n\t\n\t\t\t}\n\t\n\t\t\tif ( invdiry >= 0 ) {\n\t\n\t\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\n\t\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\n\t\n\t\t\t} else {\n\t\n\t\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\n\t\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\n\t\n\t\t\t}\n\t\n\t\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\n\t\n\t\t\t// These lines also handle the case where tmin or tmax is NaN\n\t\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\n\t\n\t\t\tif ( tymin > tmin || tmin !== tmin ) tmin = tymin;\n\t\n\t\t\tif ( tymax < tmax || tmax !== tmax ) tmax = tymax;\n\t\n\t\t\tif ( invdirz >= 0 ) {\n\t\n\t\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\n\t\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\n\t\n\t\t\t} else {\n\t\n\t\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\n\t\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\n\t\n\t\t\t}\n\t\n\t\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\n\t\n\t\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\t\n\t\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\t\n\t\t\t//return point closest to the ray (positive side)\n\t\n\t\t\tif ( tmax < 0 ) return null;\n\t\n\t\t\treturn this.at( tmin >= 0 ? tmin : tmax, optionalTarget );\n\t\n\t\t},\n\t\n\t\tintersectsBox: ( function () {\n\t\n\t\t\tvar v = new THREE.Vector3();\n\t\n\t\t\treturn function intersectsBox( box ) {\n\t\n\t\t\t\treturn this.intersectBox( box, v ) !== null;\n\t\n\t\t\t};\n\t\n\t\t} )(),\n\t\n\t\tintersectTriangle: function () {\n\t\n\t\t\t// Compute the offset origin, edges, and normal.\n\t\t\tvar diff = new THREE.Vector3();\n\t\t\tvar edge1 = new THREE.Vector3();\n\t\t\tvar edge2 = new THREE.Vector3();\n\t\t\tvar normal = new THREE.Vector3();\n\t\n\t\t\treturn function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {\n\t\n\t\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n\t\n\t\t\t\tedge1.subVectors( b, a );\n\t\t\t\tedge2.subVectors( c, a );\n\t\t\t\tnormal.crossVectors( edge1, edge2 );\n\t\n\t\t\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n\t\t\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n\t\t\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n\t\t\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n\t\t\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\t\t\t\tvar DdN = this.direction.dot( normal );\n\t\t\t\tvar sign;\n\t\n\t\t\t\tif ( DdN > 0 ) {\n\t\n\t\t\t\t\tif ( backfaceCulling ) return null;\n\t\t\t\t\tsign = 1;\n\t\n\t\t\t\t} else if ( DdN < 0 ) {\n\t\n\t\t\t\t\tsign = - 1;\n\t\t\t\t\tDdN = - DdN;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\treturn null;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tdiff.subVectors( this.origin, a );\n\t\t\t\tvar DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );\n\t\n\t\t\t\t// b1 < 0, no intersection\n\t\t\t\tif ( DdQxE2 < 0 ) {\n\t\n\t\t\t\t\treturn null;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );\n\t\n\t\t\t\t// b2 < 0, no intersection\n\t\t\t\tif ( DdE1xQ < 0 ) {\n\t\n\t\t\t\t\treturn null;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// b1+b2 > 1, no intersection\n\t\t\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\n\t\n\t\t\t\t\treturn null;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// Line intersects triangle, check if ray does.\n\t\t\t\tvar QdN = - sign * diff.dot( normal );\n\t\n\t\t\t\t// t < 0, no intersection\n\t\t\t\tif ( QdN < 0 ) {\n\t\n\t\t\t\t\treturn null;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// Ray intersects triangle.\n\t\t\t\treturn this.at( QdN / DdN, optionalTarget );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tapplyMatrix4: function ( matrix4 ) {\n\t\n\t\t\tthis.direction.add( this.origin ).applyMatrix4( matrix4 );\n\t\t\tthis.origin.applyMatrix4( matrix4 );\n\t\t\tthis.direction.sub( this.origin );\n\t\t\tthis.direction.normalize();\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tequals: function ( ray ) {\n\t\n\t\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/math/Sphere.js\n\t\n\t/**\n\t * @author bhouston / http://clara.io\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.Sphere = function ( center, radius ) {\n\t\n\t\tthis.center = ( center !== undefined ) ? center : new THREE.Vector3();\n\t\tthis.radius = ( radius !== undefined ) ? radius : 0;\n\t\n\t};\n\t\n\tTHREE.Sphere.prototype = {\n\t\n\t\tconstructor: THREE.Sphere,\n\t\n\t\tset: function ( center, radius ) {\n\t\n\t\t\tthis.center.copy( center );\n\t\t\tthis.radius = radius;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetFromPoints: function () {\n\t\n\t\t\tvar box = new THREE.Box3();\n\t\n\t\t\treturn function setFromPoints( points, optionalCenter ) {\n\t\n\t\t\t\tvar center = this.center;\n\t\n\t\t\t\tif ( optionalCenter !== undefined ) {\n\t\n\t\t\t\t\tcenter.copy( optionalCenter );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tbox.setFromPoints( points ).center( center );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar maxRadiusSq = 0;\n\t\n\t\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.radius = Math.sqrt( maxRadiusSq );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t},\n\t\n\t\tcopy: function ( sphere ) {\n\t\n\t\t\tthis.center.copy( sphere.center );\n\t\t\tthis.radius = sphere.radius;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tempty: function () {\n\t\n\t\t\treturn ( this.radius <= 0 );\n\t\n\t\t},\n\t\n\t\tcontainsPoint: function ( point ) {\n\t\n\t\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\n\t\n\t\t},\n\t\n\t\tdistanceToPoint: function ( point ) {\n\t\n\t\t\treturn ( point.distanceTo( this.center ) - this.radius );\n\t\n\t\t},\n\t\n\t\tintersectsSphere: function ( sphere ) {\n\t\n\t\t\tvar radiusSum = this.radius + sphere.radius;\n\t\n\t\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\n\t\n\t\t},\n\t\n\t\tintersectsBox: function ( box ) {\n\t\n\t\t\treturn box.intersectsSphere( this );\n\t\n\t\t},\n\t\n\t\tintersectsPlane: function ( plane ) {\n\t\n\t\t\t// We use the following equation to compute the signed distance from\n\t\t\t// the center of the sphere to the plane.\n\t\t\t//\n\t\t\t// distance = q * n - d\n\t\t\t//\n\t\t\t// If this distance is greater than the radius of the sphere,\n\t\t\t// then there is no intersection.\n\t\n\t\t\treturn Math.abs( this.center.dot( plane.normal ) - plane.constant ) <= this.radius;\n\t\n\t\t},\n\t\n\t\tclampPoint: function ( point, optionalTarget ) {\n\t\n\t\t\tvar deltaLengthSq = this.center.distanceToSquared( point );\n\t\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\n\t\t\tresult.copy( point );\n\t\n\t\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\n\t\n\t\t\t\tresult.sub( this.center ).normalize();\n\t\t\t\tresult.multiplyScalar( this.radius ).add( this.center );\n\t\n\t\t\t}\n\t\n\t\t\treturn result;\n\t\n\t\t},\n\t\n\t\tgetBoundingBox: function ( optionalTarget ) {\n\t\n\t\t\tvar box = optionalTarget || new THREE.Box3();\n\t\n\t\t\tbox.set( this.center, this.center );\n\t\t\tbox.expandByScalar( this.radius );\n\t\n\t\t\treturn box;\n\t\n\t\t},\n\t\n\t\tapplyMatrix4: function ( matrix ) {\n\t\n\t\t\tthis.center.applyMatrix4( matrix );\n\t\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\ttranslate: function ( offset ) {\n\t\n\t\t\tthis.center.add( offset );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tequals: function ( sphere ) {\n\t\n\t\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/math/Frustum.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author bhouston / http://clara.io\n\t */\n\t\n\tTHREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {\n\t\n\t\tthis.planes = [\n\t\n\t\t\t( p0 !== undefined ) ? p0 : new THREE.Plane(),\n\t\t\t( p1 !== undefined ) ? p1 : new THREE.Plane(),\n\t\t\t( p2 !== undefined ) ? p2 : new THREE.Plane(),\n\t\t\t( p3 !== undefined ) ? p3 : new THREE.Plane(),\n\t\t\t( p4 !== undefined ) ? p4 : new THREE.Plane(),\n\t\t\t( p5 !== undefined ) ? p5 : new THREE.Plane()\n\t\n\t\t];\n\t\n\t};\n\t\n\tTHREE.Frustum.prototype = {\n\t\n\t\tconstructor: THREE.Frustum,\n\t\n\t\tset: function ( p0, p1, p2, p3, p4, p5 ) {\n\t\n\t\t\tvar planes = this.planes;\n\t\n\t\t\tplanes[ 0 ].copy( p0 );\n\t\t\tplanes[ 1 ].copy( p1 );\n\t\t\tplanes[ 2 ].copy( p2 );\n\t\t\tplanes[ 3 ].copy( p3 );\n\t\t\tplanes[ 4 ].copy( p4 );\n\t\t\tplanes[ 5 ].copy( p5 );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t},\n\t\n\t\tcopy: function ( frustum ) {\n\t\n\t\t\tvar planes = this.planes;\n\t\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\tplanes[ i ].copy( frustum.planes[ i ] );\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetFromMatrix: function ( m ) {\n\t\n\t\t\tvar planes = this.planes;\n\t\t\tvar me = m.elements;\n\t\t\tvar me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\n\t\t\tvar me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\n\t\t\tvar me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\n\t\t\tvar me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\n\t\n\t\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\n\t\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\n\t\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\n\t\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\n\t\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\n\t\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tintersectsObject: function () {\n\t\n\t\t\tvar sphere = new THREE.Sphere();\n\t\n\t\t\treturn function intersectsObject( object ) {\n\t\n\t\t\t\tvar geometry = object.geometry;\n\t\n\t\t\t\tif ( geometry.boundingSphere === null )\n\t\t\t\t\tgeometry.computeBoundingSphere();\n\t\n\t\t\t\tsphere.copy( geometry.boundingSphere )\n\t\t\t\t\t.applyMatrix4( object.matrixWorld );\n\t\n\t\t\t\treturn this.intersectsSphere( sphere );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tintersectsSprite: function () {\n\t\n\t\t\tvar sphere = new THREE.Sphere();\n\t\n\t\t\treturn function intersectsSprite( sprite ) {\n\t\n\t\t\t\tsphere.center.set( 0, 0, 0 );\n\t\t\t\tsphere.radius = 0.7071067811865476;\n\t\t\t\tsphere.applyMatrix4( sprite.matrixWorld );\n\t\n\t\t\t\treturn this.intersectsSphere( sphere );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tintersectsSphere: function ( sphere ) {\n\t\n\t\t\tvar planes = this.planes;\n\t\t\tvar center = sphere.center;\n\t\t\tvar negRadius = - sphere.radius;\n\t\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\tvar distance = planes[ i ].distanceToPoint( center );\n\t\n\t\t\t\tif ( distance < negRadius ) {\n\t\n\t\t\t\t\treturn false;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn true;\n\t\n\t\t},\n\t\n\t\tintersectsBox: function () {\n\t\n\t\t\tvar p1 = new THREE.Vector3(),\n\t\t\t\tp2 = new THREE.Vector3();\n\t\n\t\t\treturn function intersectsBox( box ) {\n\t\n\t\t\t\tvar planes = this.planes;\n\t\n\t\t\t\tfor ( var i = 0; i < 6 ; i ++ ) {\n\t\n\t\t\t\t\tvar plane = planes[ i ];\n\t\n\t\t\t\t\tp1.x = plane.normal.x > 0 ? box.min.x : box.max.x;\n\t\t\t\t\tp2.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n\t\t\t\t\tp1.y = plane.normal.y > 0 ? box.min.y : box.max.y;\n\t\t\t\t\tp2.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n\t\t\t\t\tp1.z = plane.normal.z > 0 ? box.min.z : box.max.z;\n\t\t\t\t\tp2.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n\t\n\t\t\t\t\tvar d1 = plane.distanceToPoint( p1 );\n\t\t\t\t\tvar d2 = plane.distanceToPoint( p2 );\n\t\n\t\t\t\t\t// if both outside plane, no intersection\n\t\n\t\t\t\t\tif ( d1 < 0 && d2 < 0 ) {\n\t\n\t\t\t\t\t\treturn false;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn true;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\n\t\tcontainsPoint: function ( point ) {\n\t\n\t\t\tvar planes = this.planes;\n\t\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\n\t\n\t\t\t\t\treturn false;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn true;\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/math/Plane.js\n\t\n\t/**\n\t * @author bhouston / http://clara.io\n\t */\n\t\n\tTHREE.Plane = function ( normal, constant ) {\n\t\n\t\tthis.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );\n\t\tthis.constant = ( constant !== undefined ) ? constant : 0;\n\t\n\t};\n\t\n\tTHREE.Plane.prototype = {\n\t\n\t\tconstructor: THREE.Plane,\n\t\n\t\tset: function ( normal, constant ) {\n\t\n\t\t\tthis.normal.copy( normal );\n\t\t\tthis.constant = constant;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetComponents: function ( x, y, z, w ) {\n\t\n\t\t\tthis.normal.set( x, y, z );\n\t\t\tthis.constant = w;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\n\t\n\t\t\tthis.normal.copy( normal );\n\t\t\tthis.constant = - point.dot( this.normal );\t// must be this.normal, not normal, as this.normal is normalized\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetFromCoplanarPoints: function () {\n\t\n\t\t\tvar v1 = new THREE.Vector3();\n\t\t\tvar v2 = new THREE.Vector3();\n\t\n\t\t\treturn function setFromCoplanarPoints( a, b, c ) {\n\t\n\t\t\t\tvar normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\n\t\n\t\t\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\t\n\t\t\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t},\n\t\n\t\tcopy: function ( plane ) {\n\t\n\t\t\tthis.normal.copy( plane.normal );\n\t\t\tthis.constant = plane.constant;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tnormalize: function () {\n\t\n\t\t\t// Note: will lead to a divide by zero if the plane is invalid.\n\t\n\t\t\tvar inverseNormalLength = 1.0 / this.normal.length();\n\t\t\tthis.normal.multiplyScalar( inverseNormalLength );\n\t\t\tthis.constant *= inverseNormalLength;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tnegate: function () {\n\t\n\t\t\tthis.constant *= - 1;\n\t\t\tthis.normal.negate();\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tdistanceToPoint: function ( point ) {\n\t\n\t\t\treturn this.normal.dot( point ) + this.constant;\n\t\n\t\t},\n\t\n\t\tdistanceToSphere: function ( sphere ) {\n\t\n\t\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\n\t\n\t\t},\n\t\n\t\tprojectPoint: function ( point, optionalTarget ) {\n\t\n\t\t\treturn this.orthoPoint( point, optionalTarget ).sub( point ).negate();\n\t\n\t\t},\n\t\n\t\torthoPoint: function ( point, optionalTarget ) {\n\t\n\t\t\tvar perpendicularMagnitude = this.distanceToPoint( point );\n\t\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\t\treturn result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );\n\t\n\t\t},\n\t\n\t\tintersectLine: function () {\n\t\n\t\t\tvar v1 = new THREE.Vector3();\n\t\n\t\t\treturn function intersectLine( line, optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\n\t\t\t\tvar direction = line.delta( v1 );\n\t\n\t\t\t\tvar denominator = this.normal.dot( direction );\n\t\n\t\t\t\tif ( denominator === 0 ) {\n\t\n\t\t\t\t\t// line is coplanar, return origin\n\t\t\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\n\t\n\t\t\t\t\t\treturn result.copy( line.start );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Unsure if this is the correct method to handle this case.\n\t\t\t\t\treturn undefined;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\n\t\n\t\t\t\tif ( t < 0 || t > 1 ) {\n\t\n\t\t\t\t\treturn undefined;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn result.copy( direction ).multiplyScalar( t ).add( line.start );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tintersectsLine: function ( line ) {\n\t\n\t\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\t\n\t\t\tvar startSign = this.distanceToPoint( line.start );\n\t\t\tvar endSign = this.distanceToPoint( line.end );\n\t\n\t\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\n\t\n\t\t},\n\t\n\t\tintersectsBox: function ( box ) {\n\t\n\t\t\treturn box.intersectsPlane( this );\n\t\n\t\t},\n\t\n\t\tintersectsSphere: function ( sphere ) {\n\t\n\t\t\treturn sphere.intersectsPlane( this );\n\t\n\t\t},\n\t\n\t\tcoplanarPoint: function ( optionalTarget ) {\n\t\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\t\treturn result.copy( this.normal ).multiplyScalar( - this.constant );\n\t\n\t\t},\n\t\n\t\tapplyMatrix4: function () {\n\t\n\t\t\tvar v1 = new THREE.Vector3();\n\t\t\tvar m1 = new THREE.Matrix3();\n\t\n\t\t\treturn function applyMatrix4( matrix, optionalNormalMatrix ) {\n\t\n\t\t\t\tvar referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );\n\t\n\t\t\t\t// transform normal based on theory here:\n\t\t\t\t// http://www.songho.ca/opengl/gl_normaltransform.html\n\t\t\t\tvar normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );\n\t\t\t\tvar normal = this.normal.applyMatrix3( normalMatrix ).normalize();\n\t\n\t\t\t\t// recalculate constant (like in setFromNormalAndCoplanarPoint)\n\t\t\t\tthis.constant = - referencePoint.dot( normal );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\ttranslate: function ( offset ) {\n\t\n\t\t\tthis.constant = this.constant - offset.dot( this.normal );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tequals: function ( plane ) {\n\t\n\t\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/math/Spherical.js\n\t\n\t/**\n\t * @author bhouston / http://clara.io\n\t * @author WestLangley / http://github.com/WestLangley\n\t *\n\t * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\n\t *\n\t * The poles (phi) are at the positive and negative y axis.\n\t * The equator starts at positive z.\n\t */\n\t\n\tTHREE.Spherical = function ( radius, phi, theta ) {\n\t\n\t\tthis.radius = ( radius !== undefined ) ? radius : 1.0;\n\t\tthis.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole\n\t\tthis.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere\n\t\n\t\treturn this;\n\t\n\t};\n\t\n\tTHREE.Spherical.prototype = {\n\t\n\t\tconstructor: THREE.Spherical,\n\t\n\t\tset: function ( radius, phi, theta ) {\n\t\n\t\t\tthis.radius = radius;\n\t\t\tthis.phi = phi;\n\t\t\tthis.theta = theta;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t},\n\t\n\t\tcopy: function ( other ) {\n\t\n\t\t\tthis.radius.copy( other.radius );\n\t\t\tthis.phi.copy( other.phi );\n\t\t\tthis.theta.copy( other.theta );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\t// restrict phi to be betwee EPS and PI-EPS\n\t\tmakeSafe: function() {\n\t\n\t\t\tvar EPS = 0.000001;\n\t\t\tthis.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetFromVector3: function( vec3 ) {\n\t\n\t\t\tthis.radius = vec3.length();\n\t\n\t\t\tif ( this.radius === 0 ) {\n\t\n\t\t\t\tthis.theta = 0;\n\t\t\t\tthis.phi = 0;\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis\n\t\t\t\tthis.phi = Math.acos( THREE.Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t};\n\t\n\t// File:src/math/Math.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.Math = {\n\t\n\t\tDEG2RAD: Math.PI / 180,\n\t\tRAD2DEG: 180 / Math.PI,\n\t\n\t\tgenerateUUID: function () {\n\t\n\t\t\t// http://www.broofa.com/Tools/Math.uuid.htm\n\t\n\t\t\tvar chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );\n\t\t\tvar uuid = new Array( 36 );\n\t\t\tvar rnd = 0, r;\n\t\n\t\t\treturn function generateUUID() {\n\t\n\t\t\t\tfor ( var i = 0; i < 36; i ++ ) {\n\t\n\t\t\t\t\tif ( i === 8 || i === 13 || i === 18 || i === 23 ) {\n\t\n\t\t\t\t\t\tuuid[ i ] = '-';\n\t\n\t\t\t\t\t} else if ( i === 14 ) {\n\t\n\t\t\t\t\t\tuuid[ i ] = '4';\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tif ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;\n\t\t\t\t\t\tr = rnd & 0xf;\n\t\t\t\t\t\trnd = rnd >> 4;\n\t\t\t\t\t\tuuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn uuid.join( '' );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tclamp: function ( value, min, max ) {\n\t\n\t\t\treturn Math.max( min, Math.min( max, value ) );\n\t\n\t\t},\n\t\n\t\t// compute euclidian modulo of m % n\n\t\t// https://en.wikipedia.org/wiki/Modulo_operation\n\t\n\t\teuclideanModulo: function ( n, m ) {\n\t\n\t\t\treturn ( ( n % m ) + m ) % m;\n\t\n\t\t},\n\t\n\t\t// Linear mapping from range <a1, a2> to range <b1, b2>\n\t\n\t\tmapLinear: function ( x, a1, a2, b1, b2 ) {\n\t\n\t\t\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\t\n\t\t},\n\t\n\t\t// http://en.wikipedia.org/wiki/Smoothstep\n\t\n\t\tsmoothstep: function ( x, min, max ) {\n\t\n\t\t\tif ( x <= min ) return 0;\n\t\t\tif ( x >= max ) return 1;\n\t\n\t\t\tx = ( x - min ) / ( max - min );\n\t\n\t\t\treturn x * x * ( 3 - 2 * x );\n\t\n\t\t},\n\t\n\t\tsmootherstep: function ( x, min, max ) {\n\t\n\t\t\tif ( x <= min ) return 0;\n\t\t\tif ( x >= max ) return 1;\n\t\n\t\t\tx = ( x - min ) / ( max - min );\n\t\n\t\t\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\n\t\n\t\t},\n\t\n\t\trandom16: function () {\n\t\n\t\t\tconsole.warn( 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' );\n\t\t\treturn Math.random();\n\t\n\t\t},\n\t\n\t\t// Random integer from <low, high> interval\n\t\n\t\trandInt: function ( low, high ) {\n\t\n\t\t\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\n\t\n\t\t},\n\t\n\t\t// Random float from <low, high> interval\n\t\n\t\trandFloat: function ( low, high ) {\n\t\n\t\t\treturn low + Math.random() * ( high - low );\n\t\n\t\t},\n\t\n\t\t// Random float from <-range/2, range/2> interval\n\t\n\t\trandFloatSpread: function ( range ) {\n\t\n\t\t\treturn range * ( 0.5 - Math.random() );\n\t\n\t\t},\n\t\n\t\tdegToRad: function ( degrees ) {\n\t\n\t\t\treturn degrees * THREE.Math.DEG2RAD;\n\t\n\t\t},\n\t\n\t\tradToDeg: function ( radians ) {\n\t\n\t\t\treturn radians * THREE.Math.RAD2DEG;\n\t\n\t\t},\n\t\n\t\tisPowerOfTwo: function ( value ) {\n\t\n\t\t\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\n\t\n\t\t},\n\t\n\t\tnearestPowerOfTwo: function ( value ) {\n\t\n\t\t\treturn Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );\n\t\n\t\t},\n\t\n\t\tnextPowerOfTwo: function ( value ) {\n\t\n\t\t\tvalue --;\n\t\t\tvalue |= value >> 1;\n\t\t\tvalue |= value >> 2;\n\t\t\tvalue |= value >> 4;\n\t\t\tvalue |= value >> 8;\n\t\t\tvalue |= value >> 16;\n\t\t\tvalue ++;\n\t\n\t\t\treturn value;\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/math/Spline.js\n\t\n\t/**\n\t * Spline from Tween.js, slightly optimized (and trashed)\n\t * http://sole.github.com/tween.js/examples/05_spline.html\n\t *\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.Spline = function ( points ) {\n\t\n\t\tthis.points = points;\n\t\n\t\tvar c = [], v3 = { x: 0, y: 0, z: 0 },\n\t\tpoint, intPoint, weight, w2, w3,\n\t\tpa, pb, pc, pd;\n\t\n\t\tthis.initFromArray = function ( a ) {\n\t\n\t\t\tthis.points = [];\n\t\n\t\t\tfor ( var i = 0; i < a.length; i ++ ) {\n\t\n\t\t\t\tthis.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.getPoint = function ( k ) {\n\t\n\t\t\tpoint = ( this.points.length - 1 ) * k;\n\t\t\tintPoint = Math.floor( point );\n\t\t\tweight = point - intPoint;\n\t\n\t\t\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\n\t\t\tc[ 1 ] = intPoint;\n\t\t\tc[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;\n\t\t\tc[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;\n\t\n\t\t\tpa = this.points[ c[ 0 ] ];\n\t\t\tpb = this.points[ c[ 1 ] ];\n\t\t\tpc = this.points[ c[ 2 ] ];\n\t\t\tpd = this.points[ c[ 3 ] ];\n\t\n\t\t\tw2 = weight * weight;\n\t\t\tw3 = weight * w2;\n\t\n\t\t\tv3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );\n\t\t\tv3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );\n\t\t\tv3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );\n\t\n\t\t\treturn v3;\n\t\n\t\t};\n\t\n\t\tthis.getControlPointsArray = function () {\n\t\n\t\t\tvar i, p, l = this.points.length,\n\t\t\t\tcoords = [];\n\t\n\t\t\tfor ( i = 0; i < l; i ++ ) {\n\t\n\t\t\t\tp = this.points[ i ];\n\t\t\t\tcoords[ i ] = [ p.x, p.y, p.z ];\n\t\n\t\t\t}\n\t\n\t\t\treturn coords;\n\t\n\t\t};\n\t\n\t\t// approximate length by summing linear segments\n\t\n\t\tthis.getLength = function ( nSubDivisions ) {\n\t\n\t\t\tvar i, index, nSamples, position,\n\t\t\t\tpoint = 0, intPoint = 0, oldIntPoint = 0,\n\t\t\t\toldPosition = new THREE.Vector3(),\n\t\t\t\ttmpVec = new THREE.Vector3(),\n\t\t\t\tchunkLengths = [],\n\t\t\t\ttotalLength = 0;\n\t\n\t\t\t// first point has 0 length\n\t\n\t\t\tchunkLengths[ 0 ] = 0;\n\t\n\t\t\tif ( ! nSubDivisions ) nSubDivisions = 100;\n\t\n\t\t\tnSamples = this.points.length * nSubDivisions;\n\t\n\t\t\toldPosition.copy( this.points[ 0 ] );\n\t\n\t\t\tfor ( i = 1; i < nSamples; i ++ ) {\n\t\n\t\t\t\tindex = i / nSamples;\n\t\n\t\t\t\tposition = this.getPoint( index );\n\t\t\t\ttmpVec.copy( position );\n\t\n\t\t\t\ttotalLength += tmpVec.distanceTo( oldPosition );\n\t\n\t\t\t\toldPosition.copy( position );\n\t\n\t\t\t\tpoint = ( this.points.length - 1 ) * index;\n\t\t\t\tintPoint = Math.floor( point );\n\t\n\t\t\t\tif ( intPoint !== oldIntPoint ) {\n\t\n\t\t\t\t\tchunkLengths[ intPoint ] = totalLength;\n\t\t\t\t\toldIntPoint = intPoint;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// last point ends with total length\n\t\n\t\t\tchunkLengths[ chunkLengths.length ] = totalLength;\n\t\n\t\t\treturn { chunks: chunkLengths, total: totalLength };\n\t\n\t\t};\n\t\n\t\tthis.reparametrizeByArcLength = function ( samplingCoef ) {\n\t\n\t\t\tvar i, j,\n\t\t\t\tindex, indexCurrent, indexNext,\n\t\t\t\trealDistance,\n\t\t\t\tsampling, position,\n\t\t\t\tnewpoints = [],\n\t\t\t\ttmpVec = new THREE.Vector3(),\n\t\t\t\tsl = this.getLength();\n\t\n\t\t\tnewpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );\n\t\n\t\t\tfor ( i = 1; i < this.points.length; i ++ ) {\n\t\n\t\t\t\t//tmpVec.copy( this.points[ i - 1 ] );\n\t\t\t\t//linearDistance = tmpVec.distanceTo( this.points[ i ] );\n\t\n\t\t\t\trealDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];\n\t\n\t\t\t\tsampling = Math.ceil( samplingCoef * realDistance / sl.total );\n\t\n\t\t\t\tindexCurrent = ( i - 1 ) / ( this.points.length - 1 );\n\t\t\t\tindexNext = i / ( this.points.length - 1 );\n\t\n\t\t\t\tfor ( j = 1; j < sampling - 1; j ++ ) {\n\t\n\t\t\t\t\tindex = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );\n\t\n\t\t\t\t\tposition = this.getPoint( index );\n\t\t\t\t\tnewpoints.push( tmpVec.copy( position ).clone() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tnewpoints.push( tmpVec.copy( this.points[ i ] ).clone() );\n\t\n\t\t\t}\n\t\n\t\t\tthis.points = newpoints;\n\t\n\t\t};\n\t\n\t\t// Catmull-Rom\n\t\n\t\tfunction interpolate( p0, p1, p2, p3, t, t2, t3 ) {\n\t\n\t\t\tvar v0 = ( p2 - p0 ) * 0.5,\n\t\t\t\tv1 = ( p3 - p1 ) * 0.5;\n\t\n\t\t\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/math/Triangle.js\n\t\n\t/**\n\t * @author bhouston / http://clara.io\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.Triangle = function ( a, b, c ) {\n\t\n\t\tthis.a = ( a !== undefined ) ? a : new THREE.Vector3();\n\t\tthis.b = ( b !== undefined ) ? b : new THREE.Vector3();\n\t\tthis.c = ( c !== undefined ) ? c : new THREE.Vector3();\n\t\n\t};\n\t\n\tTHREE.Triangle.normal = function () {\n\t\n\t\tvar v0 = new THREE.Vector3();\n\t\n\t\treturn function normal( a, b, c, optionalTarget ) {\n\t\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\n\t\t\tresult.subVectors( c, b );\n\t\t\tv0.subVectors( a, b );\n\t\t\tresult.cross( v0 );\n\t\n\t\t\tvar resultLengthSq = result.lengthSq();\n\t\t\tif ( resultLengthSq > 0 ) {\n\t\n\t\t\t\treturn result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );\n\t\n\t\t\t}\n\t\n\t\t\treturn result.set( 0, 0, 0 );\n\t\n\t\t};\n\t\n\t}();\n\t\n\t// static/instance method to calculate barycentric coordinates\n\t// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n\tTHREE.Triangle.barycoordFromPoint = function () {\n\t\n\t\tvar v0 = new THREE.Vector3();\n\t\tvar v1 = new THREE.Vector3();\n\t\tvar v2 = new THREE.Vector3();\n\t\n\t\treturn function barycoordFromPoint( point, a, b, c, optionalTarget ) {\n\t\n\t\t\tv0.subVectors( c, a );\n\t\t\tv1.subVectors( b, a );\n\t\t\tv2.subVectors( point, a );\n\t\n\t\t\tvar dot00 = v0.dot( v0 );\n\t\t\tvar dot01 = v0.dot( v1 );\n\t\t\tvar dot02 = v0.dot( v2 );\n\t\t\tvar dot11 = v1.dot( v1 );\n\t\t\tvar dot12 = v1.dot( v2 );\n\t\n\t\t\tvar denom = ( dot00 * dot11 - dot01 * dot01 );\n\t\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\n\t\t\t// collinear or singular triangle\n\t\t\tif ( denom === 0 ) {\n\t\n\t\t\t\t// arbitrary location outside of triangle?\n\t\t\t\t// not sure if this is the best idea, maybe should be returning undefined\n\t\t\t\treturn result.set( - 2, - 1, - 1 );\n\t\n\t\t\t}\n\t\n\t\t\tvar invDenom = 1 / denom;\n\t\t\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\n\t\t\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\n\t\n\t\t\t// barycentric coordinates must always sum to 1\n\t\t\treturn result.set( 1 - u - v, v, u );\n\t\n\t\t};\n\t\n\t}();\n\t\n\tTHREE.Triangle.containsPoint = function () {\n\t\n\t\tvar v1 = new THREE.Vector3();\n\t\n\t\treturn function containsPoint( point, a, b, c ) {\n\t\n\t\t\tvar result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );\n\t\n\t\t\treturn ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );\n\t\n\t\t};\n\t\n\t}();\n\t\n\tTHREE.Triangle.prototype = {\n\t\n\t\tconstructor: THREE.Triangle,\n\t\n\t\tset: function ( a, b, c ) {\n\t\n\t\t\tthis.a.copy( a );\n\t\t\tthis.b.copy( b );\n\t\t\tthis.c.copy( c );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\n\t\n\t\t\tthis.a.copy( points[ i0 ] );\n\t\t\tthis.b.copy( points[ i1 ] );\n\t\t\tthis.c.copy( points[ i2 ] );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t},\n\t\n\t\tcopy: function ( triangle ) {\n\t\n\t\t\tthis.a.copy( triangle.a );\n\t\t\tthis.b.copy( triangle.b );\n\t\t\tthis.c.copy( triangle.c );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tarea: function () {\n\t\n\t\t\tvar v0 = new THREE.Vector3();\n\t\t\tvar v1 = new THREE.Vector3();\n\t\n\t\t\treturn function area() {\n\t\n\t\t\t\tv0.subVectors( this.c, this.b );\n\t\t\t\tv1.subVectors( this.a, this.b );\n\t\n\t\t\t\treturn v0.cross( v1 ).length() * 0.5;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tmidpoint: function ( optionalTarget ) {\n\t\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\t\treturn result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\n\t\n\t\t},\n\t\n\t\tnormal: function ( optionalTarget ) {\n\t\n\t\t\treturn THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );\n\t\n\t\t},\n\t\n\t\tplane: function ( optionalTarget ) {\n\t\n\t\t\tvar result = optionalTarget || new THREE.Plane();\n\t\n\t\t\treturn result.setFromCoplanarPoints( this.a, this.b, this.c );\n\t\n\t\t},\n\t\n\t\tbarycoordFromPoint: function ( point, optionalTarget ) {\n\t\n\t\t\treturn THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );\n\t\n\t\t},\n\t\n\t\tcontainsPoint: function ( point ) {\n\t\n\t\t\treturn THREE.Triangle.containsPoint( point, this.a, this.b, this.c );\n\t\n\t\t},\n\t\n\t\tclosestPointToPoint: function () {\n\t\n\t\t\tvar plane, edgeList, projectedPoint, closestPoint;\n\t\n\t\t\treturn function closestPointToPoint( point, optionalTarget ) {\n\t\n\t\t\t\tif ( plane === undefined ) {\n\t\n\t\t\t\t\tplane = new THREE.Plane();\n\t\t\t\t\tedgeList = [ new THREE.Line3(), new THREE.Line3(), new THREE.Line3() ];\n\t\t\t\t\tprojectedPoint = new THREE.Vector3();\n\t\t\t\t\tclosestPoint = new THREE.Vector3();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\t\t\tvar minDistance = Infinity;\n\t\n\t\t\t\t// project the point onto the plane of the triangle\n\t\n\t\t\t\tplane.setFromCoplanarPoints( this.a, this.b, this.c );\n\t\t\t\tplane.projectPoint( point, projectedPoint );\n\t\n\t\t\t\t// check if the projection lies within the triangle\n\t\n\t\t\t\tif( this.containsPoint( projectedPoint ) === true ) {\n\t\n\t\t\t\t\t// if so, this is the closest point\n\t\n\t\t\t\t\tresult.copy( projectedPoint );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices\n\t\n\t\t\t\t\tedgeList[ 0 ].set( this.a, this.b );\n\t\t\t\t\tedgeList[ 1 ].set( this.b, this.c );\n\t\t\t\t\tedgeList[ 2 ].set( this.c, this.a );\n\t\n\t\t\t\t\tfor( var i = 0; i < edgeList.length; i ++ ) {\n\t\n\t\t\t\t\t\tedgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );\n\t\n\t\t\t\t\t\tvar distance = projectedPoint.distanceToSquared( closestPoint );\n\t\n\t\t\t\t\t\tif( distance < minDistance ) {\n\t\n\t\t\t\t\t\t\tminDistance = distance;\n\t\n\t\t\t\t\t\t\tresult.copy( closestPoint );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn result;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tequals: function ( triangle ) {\n\t\n\t\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/math/Interpolant.js\n\t\n\t/**\n\t * Abstract base class of interpolants over parametric samples.\n\t *\n\t * The parameter domain is one dimensional, typically the time or a path\n\t * along a curve defined by the data.\n\t *\n\t * The sample values can have any dimensionality and derived classes may\n\t * apply special interpretations to the data.\n\t *\n\t * This class provides the interval seek in a Template Method, deferring\n\t * the actual interpolation to derived classes.\n\t *\n\t * Time complexity is O(1) for linear access crossing at most two points\n\t * and O(log N) for random access, where N is the number of positions.\n\t *\n\t * References:\n\t *\n\t * \t\thttp://www.oodesign.com/template-method-pattern.html\n\t *\n\t * @author tschw\n\t */\n\t\n\tTHREE.Interpolant = function(\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\t\n\t\tthis.parameterPositions = parameterPositions;\n\t\tthis._cachedIndex = 0;\n\t\n\t\tthis.resultBuffer = resultBuffer !== undefined ?\n\t\t\t\tresultBuffer : new sampleValues.constructor( sampleSize );\n\t\tthis.sampleValues = sampleValues;\n\t\tthis.valueSize = sampleSize;\n\t\n\t};\n\t\n\tTHREE.Interpolant.prototype = {\n\t\n\t\tconstructor: THREE.Interpolant,\n\t\n\t\tevaluate: function( t ) {\n\t\n\t\t\tvar pp = this.parameterPositions,\n\t\t\t\ti1 = this._cachedIndex,\n\t\n\t\t\t\tt1 = pp[   i1   ],\n\t\t\t\tt0 = pp[ i1 - 1 ];\n\t\n\t\t\tvalidate_interval: {\n\t\n\t\t\t\tseek: {\n\t\n\t\t\t\t\tvar right;\n\t\n\t\t\t\t\tlinear_scan: {\n\t//- See http://jsperf.com/comparison-to-undefined/3\n\t//- slower code:\n\t//-\n\t//- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\n\t\t\t\t\t\tforward_scan: if ( ! ( t < t1 ) ) {\n\t\n\t\t\t\t\t\t\tfor ( var giveUpAt = i1 + 2; ;) {\n\t\n\t\t\t\t\t\t\t\tif ( t1 === undefined ) {\n\t\n\t\t\t\t\t\t\t\t\tif ( t < t0 ) break forward_scan;\n\t\n\t\t\t\t\t\t\t\t\t// after end\n\t\n\t\t\t\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t, t0 );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\t\n\t\t\t\t\t\t\t\tt0 = t1;\n\t\t\t\t\t\t\t\tt1 = pp[ ++ i1 ];\n\t\n\t\t\t\t\t\t\t\tif ( t < t1 ) {\n\t\n\t\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\t\tbreak seek;\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// prepare binary search on the right side of the index\n\t\t\t\t\t\t\tright = pp.length;\n\t\t\t\t\t\t\tbreak linear_scan;\n\t\n\t\t\t\t\t\t}\n\t\n\t//- slower code:\n\t//-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\n\t\t\t\t\t\tif ( ! ( t >= t0 ) ) {\n\t\n\t\t\t\t\t\t\t// looping?\n\t\n\t\t\t\t\t\t\tvar t1global = pp[ 1 ];\n\t\n\t\t\t\t\t\t\tif ( t < t1global ) {\n\t\n\t\t\t\t\t\t\t\ti1 = 2; // + 1, using the scan for the details\n\t\t\t\t\t\t\t\tt0 = t1global;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// linear reverse scan\n\t\n\t\t\t\t\t\t\tfor ( var giveUpAt = i1 - 2; ;) {\n\t\n\t\t\t\t\t\t\t\tif ( t0 === undefined ) {\n\t\n\t\t\t\t\t\t\t\t\t// before start\n\t\n\t\t\t\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\t\n\t\t\t\t\t\t\t\tt1 = t0;\n\t\t\t\t\t\t\t\tt0 = pp[ -- i1 - 1 ];\n\t\n\t\t\t\t\t\t\t\tif ( t >= t0 ) {\n\t\n\t\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\t\tbreak seek;\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// prepare binary search on the left side of the index\n\t\t\t\t\t\t\tright = i1;\n\t\t\t\t\t\t\ti1 = 0;\n\t\t\t\t\t\t\tbreak linear_scan;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// the interval is valid\n\t\n\t\t\t\t\t\tbreak validate_interval;\n\t\n\t\t\t\t\t} // linear scan\n\t\n\t\t\t\t\t// binary search\n\t\n\t\t\t\t\twhile ( i1 < right ) {\n\t\n\t\t\t\t\t\tvar mid = ( i1 + right ) >>> 1;\n\t\n\t\t\t\t\t\tif ( t < pp[ mid ] ) {\n\t\n\t\t\t\t\t\t\tright = mid;\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\ti1 = mid + 1;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tt1 = pp[   i1   ];\n\t\t\t\t\tt0 = pp[ i1 - 1 ];\n\t\n\t\t\t\t\t// check boundary cases, again\n\t\n\t\t\t\t\tif ( t0 === undefined ) {\n\t\n\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( t1 === undefined ) {\n\t\n\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t0, t );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} // seek\n\t\n\t\t\t\tthis._cachedIndex = i1;\n\t\n\t\t\t\tthis.intervalChanged_( i1, t0, t1 );\n\t\n\t\t\t} // validate_interval\n\t\n\t\t\treturn this.interpolate_( i1, t0, t, t1 );\n\t\n\t\t},\n\t\n\t\tsettings: null, // optional, subclass-specific settings structure\n\t\t// Note: The indirection allows central control of many interpolants.\n\t\n\t\t// --- Protected interface\n\t\n\t\tDefaultSettings_: {},\n\t\n\t\tgetSettings_: function() {\n\t\n\t\t\treturn this.settings || this.DefaultSettings_;\n\t\n\t\t},\n\t\n\t\tcopySampleValue_: function( index ) {\n\t\n\t\t\t// copies a sample value to the result buffer\n\t\n\t\t\tvar result = this.resultBuffer,\n\t\t\t\tvalues = this.sampleValues,\n\t\t\t\tstride = this.valueSize,\n\t\t\t\toffset = index * stride;\n\t\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\t\n\t\t\t\tresult[ i ] = values[ offset + i ];\n\t\n\t\t\t}\n\t\n\t\t\treturn result;\n\t\n\t\t},\n\t\n\t\t// Template methods for derived classes:\n\t\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\t\n\t\t\tthrow new Error( \"call to abstract method\" );\n\t\t\t// implementations shall return this.resultBuffer\n\t\n\t\t},\n\t\n\t\tintervalChanged_: function( i1, t0, t1 ) {\n\t\n\t\t\t// empty\n\t\n\t\t}\n\t\n\t};\n\t\n\tObject.assign( THREE.Interpolant.prototype, {\n\t\n\t\tbeforeStart_: //( 0, t, t0 ), returns this.resultBuffer\n\t\t\tTHREE.Interpolant.prototype.copySampleValue_,\n\t\n\t\tafterEnd_: //( N-1, tN-1, t ), returns this.resultBuffer\n\t\t\tTHREE.Interpolant.prototype.copySampleValue_\n\t\n\t} );\n\t\n\t// File:src/math/interpolants/CubicInterpolant.js\n\t\n\t/**\n\t * Fast and simple cubic spline interpolant.\n\t *\n\t * It was derived from a Hermitian construction setting the first derivative\n\t * at each sample position to the linear slope between neighboring positions\n\t * over their parameter interval.\n\t *\n\t * @author tschw\n\t */\n\t\n\tTHREE.CubicInterpolant = function(\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\t\n\t\tTHREE.Interpolant.call(\n\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\t\n\t\tthis._weightPrev = -0;\n\t\tthis._offsetPrev = -0;\n\t\tthis._weightNext = -0;\n\t\tthis._offsetNext = -0;\n\t\n\t};\n\t\n\tTHREE.CubicInterpolant.prototype =\n\t\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\n\t\n\t\tconstructor: THREE.CubicInterpolant,\n\t\n\t\tDefaultSettings_: {\n\t\n\t\t\tendingStart: \tTHREE.ZeroCurvatureEnding,\n\t\t\tendingEnd:\t\tTHREE.ZeroCurvatureEnding\n\t\n\t\t},\n\t\n\t\tintervalChanged_: function( i1, t0, t1 ) {\n\t\n\t\t\tvar pp = this.parameterPositions,\n\t\t\t\tiPrev = i1 - 2,\n\t\t\t\tiNext = i1 + 1,\n\t\n\t\t\t\ttPrev = pp[ iPrev ],\n\t\t\t\ttNext = pp[ iNext ];\n\t\n\t\t\tif ( tPrev === undefined ) {\n\t\n\t\t\t\tswitch ( this.getSettings_().endingStart ) {\n\t\n\t\t\t\t\tcase THREE.ZeroSlopeEnding:\n\t\n\t\t\t\t\t\t// f'(t0) = 0\n\t\t\t\t\t\tiPrev = i1;\n\t\t\t\t\t\ttPrev = 2 * t0 - t1;\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase THREE.WrapAroundEnding:\n\t\n\t\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\t\tiPrev = pp.length - 2;\n\t\t\t\t\t\ttPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tdefault: // ZeroCurvatureEnding\n\t\n\t\t\t\t\t\t// f''(t0) = 0 a.k.a. Natural Spline\n\t\t\t\t\t\tiPrev = i1;\n\t\t\t\t\t\ttPrev = t1;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif ( tNext === undefined ) {\n\t\n\t\t\t\tswitch ( this.getSettings_().endingEnd ) {\n\t\n\t\t\t\t\tcase THREE.ZeroSlopeEnding:\n\t\n\t\t\t\t\t\t// f'(tN) = 0\n\t\t\t\t\t\tiNext = i1;\n\t\t\t\t\t\ttNext = 2 * t1 - t0;\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase THREE.WrapAroundEnding:\n\t\n\t\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\t\tiNext = 1;\n\t\t\t\t\t\ttNext = t1 + pp[ 1 ] - pp[ 0 ];\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tdefault: // ZeroCurvatureEnding\n\t\n\t\t\t\t\t\t// f''(tN) = 0, a.k.a. Natural Spline\n\t\t\t\t\t\tiNext = i1 - 1;\n\t\t\t\t\t\ttNext = t0;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tvar halfDt = ( t1 - t0 ) * 0.5,\n\t\t\t\tstride = this.valueSize;\n\t\n\t\t\tthis._weightPrev = halfDt / ( t0 - tPrev );\n\t\t\tthis._weightNext = halfDt / ( tNext - t1 );\n\t\t\tthis._offsetPrev = iPrev * stride;\n\t\t\tthis._offsetNext = iNext * stride;\n\t\n\t\t},\n\t\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\t\n\t\t\tvar result = this.resultBuffer,\n\t\t\t\tvalues = this.sampleValues,\n\t\t\t\tstride = this.valueSize,\n\t\n\t\t\t\to1 = i1 * stride,\t\to0 = o1 - stride,\n\t\t\t\toP = this._offsetPrev, \toN = this._offsetNext,\n\t\t\t\twP = this._weightPrev,\twN = this._weightNext,\n\t\n\t\t\t\tp = ( t - t0 ) / ( t1 - t0 ),\n\t\t\t\tpp = p * p,\n\t\t\t\tppp = pp * p;\n\t\n\t\t\t// evaluate polynomials\n\t\n\t\t\tvar sP =     - wP   * ppp   +         2 * wP    * pp    -          wP   * p;\n\t\t\tvar s0 = ( 1 + wP ) * ppp   + (-1.5 - 2 * wP )  * pp    + ( -0.5 + wP ) * p     + 1;\n\t\t\tvar s1 = (-1 - wN ) * ppp   + ( 1.5 +   wN   )  * pp    +    0.5        * p;\n\t\t\tvar sN =       wN   * ppp   -           wN      * pp;\n\t\n\t\t\t// combine data linearly\n\t\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\t\n\t\t\t\tresult[ i ] =\n\t\t\t\t\t\tsP * values[ oP + i ] +\n\t\t\t\t\t\ts0 * values[ o0 + i ] +\n\t\t\t\t\t\ts1 * values[ o1 + i ] +\n\t\t\t\t\t\tsN * values[ oN + i ];\n\t\n\t\t\t}\n\t\n\t\t\treturn result;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/math/interpolants/DiscreteInterpolant.js\n\t\n\t/**\n\t *\n\t * Interpolant that evaluates to the sample value at the position preceeding\n\t * the parameter.\n\t *\n\t * @author tschw\n\t */\n\t\n\tTHREE.DiscreteInterpolant = function(\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\t\n\t\tTHREE.Interpolant.call(\n\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\t\n\t};\n\t\n\tTHREE.DiscreteInterpolant.prototype =\n\t\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\n\t\n\t\tconstructor: THREE.DiscreteInterpolant,\n\t\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\t\n\t\t\treturn this.copySampleValue_( i1 - 1 );\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/math/interpolants/LinearInterpolant.js\n\t\n\t/**\n\t * @author tschw\n\t */\n\t\n\tTHREE.LinearInterpolant = function(\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\t\n\t\tTHREE.Interpolant.call(\n\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\t\n\t};\n\t\n\tTHREE.LinearInterpolant.prototype =\n\t\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\n\t\n\t\tconstructor: THREE.LinearInterpolant,\n\t\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\t\n\t\t\tvar result = this.resultBuffer,\n\t\t\t\tvalues = this.sampleValues,\n\t\t\t\tstride = this.valueSize,\n\t\n\t\t\t\toffset1 = i1 * stride,\n\t\t\t\toffset0 = offset1 - stride,\n\t\n\t\t\t\tweight1 = ( t - t0 ) / ( t1 - t0 ),\n\t\t\t\tweight0 = 1 - weight1;\n\t\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\t\n\t\t\t\tresult[ i ] =\n\t\t\t\t\t\tvalues[ offset0 + i ] * weight0 +\n\t\t\t\t\t\tvalues[ offset1 + i ] * weight1;\n\t\n\t\t\t}\n\t\n\t\t\treturn result;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/math/interpolants/QuaternionLinearInterpolant.js\n\t\n\t/**\n\t * Spherical linear unit quaternion interpolant.\n\t *\n\t * @author tschw\n\t */\n\t\n\tTHREE.QuaternionLinearInterpolant = function(\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\t\n\t\tTHREE.Interpolant.call(\n\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\t\n\t};\n\t\n\tTHREE.QuaternionLinearInterpolant.prototype =\n\t\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\n\t\n\t\tconstructor: THREE.QuaternionLinearInterpolant,\n\t\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\t\n\t\t\tvar result = this.resultBuffer,\n\t\t\t\tvalues = this.sampleValues,\n\t\t\t\tstride = this.valueSize,\n\t\n\t\t\t\toffset = i1 * stride,\n\t\n\t\t\t\talpha = ( t - t0 ) / ( t1 - t0 );\n\t\n\t\t\tfor ( var end = offset + stride; offset !== end; offset += 4 ) {\n\t\n\t\t\t\tTHREE.Quaternion.slerpFlat( result, 0,\n\t\t\t\t\t\tvalues, offset - stride, values, offset, alpha );\n\t\n\t\t\t}\n\t\n\t\t\treturn result;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/core/Clock.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.Clock = function ( autoStart ) {\n\t\n\t\tthis.autoStart = ( autoStart !== undefined ) ? autoStart : true;\n\t\n\t\tthis.startTime = 0;\n\t\tthis.oldTime = 0;\n\t\tthis.elapsedTime = 0;\n\t\n\t\tthis.running = false;\n\t\n\t};\n\t\n\tTHREE.Clock.prototype = {\n\t\n\t\tconstructor: THREE.Clock,\n\t\n\t\tstart: function () {\n\t\n\t\t\tthis.startTime = ( performance || Date ).now();\n\t\n\t\t\tthis.oldTime = this.startTime;\n\t\t\tthis.running = true;\n\t\n\t\t},\n\t\n\t\tstop: function () {\n\t\n\t\t\tthis.getElapsedTime();\n\t\t\tthis.running = false;\n\t\n\t\t},\n\t\n\t\tgetElapsedTime: function () {\n\t\n\t\t\tthis.getDelta();\n\t\t\treturn this.elapsedTime;\n\t\n\t\t},\n\t\n\t\tgetDelta: function () {\n\t\n\t\t\tvar diff = 0;\n\t\n\t\t\tif ( this.autoStart && ! this.running ) {\n\t\n\t\t\t\tthis.start();\n\t\n\t\t\t}\n\t\n\t\t\tif ( this.running ) {\n\t\n\t\t\t\tvar newTime = ( performance || Date ).now();\n\t\n\t\t\t\tdiff = ( newTime - this.oldTime ) / 1000;\n\t\t\t\tthis.oldTime = newTime;\n\t\n\t\t\t\tthis.elapsedTime += diff;\n\t\n\t\t\t}\n\t\n\t\t\treturn diff;\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/core/EventDispatcher.js\n\t\n\t/**\n\t * https://github.com/mrdoob/eventdispatcher.js/\n\t */\n\t\n\tTHREE.EventDispatcher = function () {};\n\t\n\tObject.assign( THREE.EventDispatcher.prototype, {\n\t\n\t\taddEventListener: function ( type, listener ) {\n\t\n\t\t\tif ( this._listeners === undefined ) this._listeners = {};\n\t\n\t\t\tvar listeners = this._listeners;\n\t\n\t\t\tif ( listeners[ type ] === undefined ) {\n\t\n\t\t\t\tlisteners[ type ] = [];\n\t\n\t\t\t}\n\t\n\t\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\n\t\n\t\t\t\tlisteners[ type ].push( listener );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\thasEventListener: function ( type, listener ) {\n\t\n\t\t\tif ( this._listeners === undefined ) return false;\n\t\n\t\t\tvar listeners = this._listeners;\n\t\n\t\t\tif ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {\n\t\n\t\t\t\treturn true;\n\t\n\t\t\t}\n\t\n\t\t\treturn false;\n\t\n\t\t},\n\t\n\t\tremoveEventListener: function ( type, listener ) {\n\t\n\t\t\tif ( this._listeners === undefined ) return;\n\t\n\t\t\tvar listeners = this._listeners;\n\t\t\tvar listenerArray = listeners[ type ];\n\t\n\t\t\tif ( listenerArray !== undefined ) {\n\t\n\t\t\t\tvar index = listenerArray.indexOf( listener );\n\t\n\t\t\t\tif ( index !== - 1 ) {\n\t\n\t\t\t\t\tlistenerArray.splice( index, 1 );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tdispatchEvent: function ( event ) {\n\t\n\t\t\tif ( this._listeners === undefined ) return;\n\t\n\t\t\tvar listeners = this._listeners;\n\t\t\tvar listenerArray = listeners[ event.type ];\n\t\n\t\t\tif ( listenerArray !== undefined ) {\n\t\n\t\t\t\tevent.target = this;\n\t\n\t\t\t\tvar array = [], i = 0;\n\t\t\t\tvar length = listenerArray.length;\n\t\n\t\t\t\tfor ( i = 0; i < length; i ++ ) {\n\t\n\t\t\t\t\tarray[ i ] = listenerArray[ i ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( i = 0; i < length; i ++ ) {\n\t\n\t\t\t\t\tarray[ i ].call( this, event );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/core/Layers.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.Layers = function () {\n\t\n\t\tthis.mask = 1;\n\t\n\t};\n\t\n\tTHREE.Layers.prototype = {\n\t\n\t\tconstructor: THREE.Layers,\n\t\n\t\tset: function ( channel ) {\n\t\n\t\t\tthis.mask = 1 << channel;\n\t\n\t\t},\n\t\n\t\tenable: function ( channel ) {\n\t\n\t\t\tthis.mask |= 1 << channel;\n\t\n\t\t},\n\t\n\t\ttoggle: function ( channel ) {\n\t\n\t\t\tthis.mask ^= 1 << channel;\n\t\n\t\t},\n\t\n\t\tdisable: function ( channel ) {\n\t\n\t\t\tthis.mask &= ~ ( 1 << channel );\n\t\n\t\t},\n\t\n\t\ttest: function ( layers ) {\n\t\n\t\t\treturn ( this.mask & layers.mask ) !== 0;\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/core/Raycaster.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author bhouston / http://clara.io/\n\t * @author stephomi / http://stephaneginier.com/\n\t */\n\t\n\t( function ( THREE ) {\n\t\n\t\tTHREE.Raycaster = function ( origin, direction, near, far ) {\n\t\n\t\t\tthis.ray = new THREE.Ray( origin, direction );\n\t\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\t\n\t\t\tthis.near = near || 0;\n\t\t\tthis.far = far || Infinity;\n\t\n\t\t\tthis.params = {\n\t\t\t\tMesh: {},\n\t\t\t\tLine: {},\n\t\t\t\tLOD: {},\n\t\t\t\tPoints: { threshold: 1 },\n\t\t\t\tSprite: {}\n\t\t\t};\n\t\n\t\t\tObject.defineProperties( this.params, {\n\t\t\t\tPointCloud: {\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\tconsole.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );\n\t\t\t\t\t\treturn this.Points;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\t\n\t\t};\n\t\n\t\tfunction ascSort( a, b ) {\n\t\n\t\t\treturn a.distance - b.distance;\n\t\n\t\t}\n\t\n\t\tfunction intersectObject( object, raycaster, intersects, recursive ) {\n\t\n\t\t\tif ( object.visible === false ) return;\n\t\n\t\t\tobject.raycast( raycaster, intersects );\n\t\n\t\t\tif ( recursive === true ) {\n\t\n\t\t\t\tvar children = object.children;\n\t\n\t\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tintersectObject( children[ i ], raycaster, intersects, true );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t//\n\t\n\t\tTHREE.Raycaster.prototype = {\n\t\n\t\t\tconstructor: THREE.Raycaster,\n\t\n\t\t\tlinePrecision: 1,\n\t\n\t\t\tset: function ( origin, direction ) {\n\t\n\t\t\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\t\n\t\t\t\tthis.ray.set( origin, direction );\n\t\n\t\t\t},\n\t\n\t\t\tsetFromCamera: function ( coords, camera ) {\n\t\n\t\t\t\tif ( camera instanceof THREE.PerspectiveCamera ) {\n\t\n\t\t\t\t\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\n\t\n\t\t\t\t} else if ( camera instanceof THREE.OrthographicCamera ) {\n\t\n\t\t\t\t\tthis.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera\n\t\t\t\t\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tconsole.error( 'THREE.Raycaster: Unsupported camera type.' );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tintersectObject: function ( object, recursive ) {\n\t\n\t\t\t\tvar intersects = [];\n\t\n\t\t\t\tintersectObject( object, this, intersects, recursive );\n\t\n\t\t\t\tintersects.sort( ascSort );\n\t\n\t\t\t\treturn intersects;\n\t\n\t\t\t},\n\t\n\t\t\tintersectObjects: function ( objects, recursive ) {\n\t\n\t\t\t\tvar intersects = [];\n\t\n\t\t\t\tif ( Array.isArray( objects ) === false ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );\n\t\t\t\t\treturn intersects;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tintersectObject( objects[ i ], this, intersects, recursive );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tintersects.sort( ascSort );\n\t\n\t\t\t\treturn intersects;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t}( THREE ) );\n\t\n\t// File:src/core/Object3D.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author elephantatwork / www.elephantatwork.ch\n\t */\n\t\n\tTHREE.Object3D = function () {\n\t\n\t\tObject.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );\n\t\n\t\tthis.uuid = THREE.Math.generateUUID();\n\t\n\t\tthis.name = '';\n\t\tthis.type = 'Object3D';\n\t\n\t\tthis.parent = null;\n\t\tthis.children = [];\n\t\n\t\tthis.up = THREE.Object3D.DefaultUp.clone();\n\t\n\t\tvar position = new THREE.Vector3();\n\t\tvar rotation = new THREE.Euler();\n\t\tvar quaternion = new THREE.Quaternion();\n\t\tvar scale = new THREE.Vector3( 1, 1, 1 );\n\t\n\t\tfunction onRotationChange() {\n\t\n\t\t\tquaternion.setFromEuler( rotation, false );\n\t\n\t\t}\n\t\n\t\tfunction onQuaternionChange() {\n\t\n\t\t\trotation.setFromQuaternion( quaternion, undefined, false );\n\t\n\t\t}\n\t\n\t\trotation.onChange( onRotationChange );\n\t\tquaternion.onChange( onQuaternionChange );\n\t\n\t\tObject.defineProperties( this, {\n\t\t\tposition: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: position\n\t\t\t},\n\t\t\trotation: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: rotation\n\t\t\t},\n\t\t\tquaternion: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: quaternion\n\t\t\t},\n\t\t\tscale: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: scale\n\t\t\t},\n\t\t\tmodelViewMatrix: {\n\t\t\t\tvalue: new THREE.Matrix4()\n\t\t\t},\n\t\t\tnormalMatrix: {\n\t\t\t\tvalue: new THREE.Matrix3()\n\t\t\t}\n\t\t} );\n\t\n\t\tthis.matrix = new THREE.Matrix4();\n\t\tthis.matrixWorld = new THREE.Matrix4();\n\t\n\t\tthis.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate;\n\t\tthis.matrixWorldNeedsUpdate = false;\n\t\n\t\tthis.layers = new THREE.Layers();\n\t\tthis.visible = true;\n\t\n\t\tthis.castShadow = false;\n\t\tthis.receiveShadow = false;\n\t\n\t\tthis.frustumCulled = true;\n\t\tthis.renderOrder = 0;\n\t\n\t\tthis.userData = {};\n\t\n\t};\n\t\n\tTHREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );\n\tTHREE.Object3D.DefaultMatrixAutoUpdate = true;\n\t\n\tObject.assign( THREE.Object3D.prototype, THREE.EventDispatcher.prototype, {\n\t\n\t\tapplyMatrix: function ( matrix ) {\n\t\n\t\t\tthis.matrix.multiplyMatrices( matrix, this.matrix );\n\t\n\t\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\n\t\n\t\t},\n\t\n\t\tsetRotationFromAxisAngle: function ( axis, angle ) {\n\t\n\t\t\t// assumes axis is normalized\n\t\n\t\t\tthis.quaternion.setFromAxisAngle( axis, angle );\n\t\n\t\t},\n\t\n\t\tsetRotationFromEuler: function ( euler ) {\n\t\n\t\t\tthis.quaternion.setFromEuler( euler, true );\n\t\n\t\t},\n\t\n\t\tsetRotationFromMatrix: function ( m ) {\n\t\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\t\n\t\t\tthis.quaternion.setFromRotationMatrix( m );\n\t\n\t\t},\n\t\n\t\tsetRotationFromQuaternion: function ( q ) {\n\t\n\t\t\t// assumes q is normalized\n\t\n\t\t\tthis.quaternion.copy( q );\n\t\n\t\t},\n\t\n\t\trotateOnAxis: function () {\n\t\n\t\t\t// rotate object on axis in object space\n\t\t\t// axis is assumed to be normalized\n\t\n\t\t\tvar q1 = new THREE.Quaternion();\n\t\n\t\t\treturn function rotateOnAxis( axis, angle ) {\n\t\n\t\t\t\tq1.setFromAxisAngle( axis, angle );\n\t\n\t\t\t\tthis.quaternion.multiply( q1 );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\trotateX: function () {\n\t\n\t\t\tvar v1 = new THREE.Vector3( 1, 0, 0 );\n\t\n\t\t\treturn function rotateX( angle ) {\n\t\n\t\t\t\treturn this.rotateOnAxis( v1, angle );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\trotateY: function () {\n\t\n\t\t\tvar v1 = new THREE.Vector3( 0, 1, 0 );\n\t\n\t\t\treturn function rotateY( angle ) {\n\t\n\t\t\t\treturn this.rotateOnAxis( v1, angle );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\trotateZ: function () {\n\t\n\t\t\tvar v1 = new THREE.Vector3( 0, 0, 1 );\n\t\n\t\t\treturn function rotateZ( angle ) {\n\t\n\t\t\t\treturn this.rotateOnAxis( v1, angle );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\ttranslateOnAxis: function () {\n\t\n\t\t\t// translate object by distance along axis in object space\n\t\t\t// axis is assumed to be normalized\n\t\n\t\t\tvar v1 = new THREE.Vector3();\n\t\n\t\t\treturn function translateOnAxis( axis, distance ) {\n\t\n\t\t\t\tv1.copy( axis ).applyQuaternion( this.quaternion );\n\t\n\t\t\t\tthis.position.add( v1.multiplyScalar( distance ) );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\ttranslateX: function () {\n\t\n\t\t\tvar v1 = new THREE.Vector3( 1, 0, 0 );\n\t\n\t\t\treturn function translateX( distance ) {\n\t\n\t\t\t\treturn this.translateOnAxis( v1, distance );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\ttranslateY: function () {\n\t\n\t\t\tvar v1 = new THREE.Vector3( 0, 1, 0 );\n\t\n\t\t\treturn function translateY( distance ) {\n\t\n\t\t\t\treturn this.translateOnAxis( v1, distance );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\ttranslateZ: function () {\n\t\n\t\t\tvar v1 = new THREE.Vector3( 0, 0, 1 );\n\t\n\t\t\treturn function translateZ( distance ) {\n\t\n\t\t\t\treturn this.translateOnAxis( v1, distance );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tlocalToWorld: function ( vector ) {\n\t\n\t\t\treturn vector.applyMatrix4( this.matrixWorld );\n\t\n\t\t},\n\t\n\t\tworldToLocal: function () {\n\t\n\t\t\tvar m1 = new THREE.Matrix4();\n\t\n\t\t\treturn function worldToLocal( vector ) {\n\t\n\t\t\t\treturn vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tlookAt: function () {\n\t\n\t\t\t// This routine does not support objects with rotated and/or translated parent(s)\n\t\n\t\t\tvar m1 = new THREE.Matrix4();\n\t\n\t\t\treturn function lookAt( vector ) {\n\t\n\t\t\t\tm1.lookAt( vector, this.position, this.up );\n\t\n\t\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tadd: function ( object ) {\n\t\n\t\t\tif ( arguments.length > 1 ) {\n\t\n\t\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\n\t\n\t\t\t\t\tthis.add( arguments[ i ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t\tif ( object === this ) {\n\t\n\t\t\t\tconsole.error( \"THREE.Object3D.add: object can't be added as a child of itself.\", object );\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t\tif ( object instanceof THREE.Object3D ) {\n\t\n\t\t\t\tif ( object.parent !== null ) {\n\t\n\t\t\t\t\tobject.parent.remove( object );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tobject.parent = this;\n\t\t\t\tobject.dispatchEvent( { type: 'added' } );\n\t\n\t\t\t\tthis.children.push( object );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tconsole.error( \"THREE.Object3D.add: object not an instance of THREE.Object3D.\", object );\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tremove: function ( object ) {\n\t\n\t\t\tif ( arguments.length > 1 ) {\n\t\n\t\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\n\t\n\t\t\t\t\tthis.remove( arguments[ i ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tvar index = this.children.indexOf( object );\n\t\n\t\t\tif ( index !== - 1 ) {\n\t\n\t\t\t\tobject.parent = null;\n\t\n\t\t\t\tobject.dispatchEvent( { type: 'removed' } );\n\t\n\t\t\t\tthis.children.splice( index, 1 );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tgetObjectById: function ( id ) {\n\t\n\t\t\treturn this.getObjectByProperty( 'id', id );\n\t\n\t\t},\n\t\n\t\tgetObjectByName: function ( name ) {\n\t\n\t\t\treturn this.getObjectByProperty( 'name', name );\n\t\n\t\t},\n\t\n\t\tgetObjectByProperty: function ( name, value ) {\n\t\n\t\t\tif ( this[ name ] === value ) return this;\n\t\n\t\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar child = this.children[ i ];\n\t\t\t\tvar object = child.getObjectByProperty( name, value );\n\t\n\t\t\t\tif ( object !== undefined ) {\n\t\n\t\t\t\t\treturn object;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn undefined;\n\t\n\t\t},\n\t\n\t\tgetWorldPosition: function ( optionalTarget ) {\n\t\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\n\t\t\tthis.updateMatrixWorld( true );\n\t\n\t\t\treturn result.setFromMatrixPosition( this.matrixWorld );\n\t\n\t\t},\n\t\n\t\tgetWorldQuaternion: function () {\n\t\n\t\t\tvar position = new THREE.Vector3();\n\t\t\tvar scale = new THREE.Vector3();\n\t\n\t\t\treturn function getWorldQuaternion( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new THREE.Quaternion();\n\t\n\t\t\t\tthis.updateMatrixWorld( true );\n\t\n\t\t\t\tthis.matrixWorld.decompose( position, result, scale );\n\t\n\t\t\t\treturn result;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tgetWorldRotation: function () {\n\t\n\t\t\tvar quaternion = new THREE.Quaternion();\n\t\n\t\t\treturn function getWorldRotation( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new THREE.Euler();\n\t\n\t\t\t\tthis.getWorldQuaternion( quaternion );\n\t\n\t\t\t\treturn result.setFromQuaternion( quaternion, this.rotation.order, false );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tgetWorldScale: function () {\n\t\n\t\t\tvar position = new THREE.Vector3();\n\t\t\tvar quaternion = new THREE.Quaternion();\n\t\n\t\t\treturn function getWorldScale( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\n\t\t\t\tthis.updateMatrixWorld( true );\n\t\n\t\t\t\tthis.matrixWorld.decompose( position, quaternion, result );\n\t\n\t\t\t\treturn result;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tgetWorldDirection: function () {\n\t\n\t\t\tvar quaternion = new THREE.Quaternion();\n\t\n\t\t\treturn function getWorldDirection( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\n\t\t\t\tthis.getWorldQuaternion( quaternion );\n\t\n\t\t\t\treturn result.set( 0, 0, 1 ).applyQuaternion( quaternion );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\traycast: function () {},\n\t\n\t\ttraverse: function ( callback ) {\n\t\n\t\t\tcallback( this );\n\t\n\t\t\tvar children = this.children;\n\t\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\t\n\t\t\t\tchildren[ i ].traverse( callback );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\ttraverseVisible: function ( callback ) {\n\t\n\t\t\tif ( this.visible === false ) return;\n\t\n\t\t\tcallback( this );\n\t\n\t\t\tvar children = this.children;\n\t\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\t\n\t\t\t\tchildren[ i ].traverseVisible( callback );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\ttraverseAncestors: function ( callback ) {\n\t\n\t\t\tvar parent = this.parent;\n\t\n\t\t\tif ( parent !== null ) {\n\t\n\t\t\t\tcallback( parent );\n\t\n\t\t\t\tparent.traverseAncestors( callback );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tupdateMatrix: function () {\n\t\n\t\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\n\t\n\t\t\tthis.matrixWorldNeedsUpdate = true;\n\t\n\t\t},\n\t\n\t\tupdateMatrixWorld: function ( force ) {\n\t\n\t\t\tif ( this.matrixAutoUpdate === true ) this.updateMatrix();\n\t\n\t\t\tif ( this.matrixWorldNeedsUpdate === true || force === true ) {\n\t\n\t\t\t\tif ( this.parent === null ) {\n\t\n\t\t\t\t\tthis.matrixWorld.copy( this.matrix );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.matrixWorldNeedsUpdate = false;\n\t\n\t\t\t\tforce = true;\n\t\n\t\t\t}\n\t\n\t\t\t// update children\n\t\n\t\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\t\n\t\t\t\tthis.children[ i ].updateMatrixWorld( force );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\ttoJSON: function ( meta ) {\n\t\n\t\t\t// meta is '' when called from JSON.stringify\n\t\t\tvar isRootObject = ( meta === undefined || meta === '' );\n\t\n\t\t\tvar output = {};\n\t\n\t\t\t// meta is a hash used to collect geometries, materials.\n\t\t\t// not providing it implies that this is the root object\n\t\t\t// being serialized.\n\t\t\tif ( isRootObject ) {\n\t\n\t\t\t\t// initialize meta obj\n\t\t\t\tmeta = {\n\t\t\t\t\tgeometries: {},\n\t\t\t\t\tmaterials: {},\n\t\t\t\t\ttextures: {},\n\t\t\t\t\timages: {}\n\t\t\t\t};\n\t\n\t\t\t\toutput.metadata = {\n\t\t\t\t\tversion: 4.4,\n\t\t\t\t\ttype: 'Object',\n\t\t\t\t\tgenerator: 'Object3D.toJSON'\n\t\t\t\t};\n\t\n\t\t\t}\n\t\n\t\t\t// standard Object3D serialization\n\t\n\t\t\tvar object = {};\n\t\n\t\t\tobject.uuid = this.uuid;\n\t\t\tobject.type = this.type;\n\t\n\t\t\tif ( this.name !== '' ) object.name = this.name;\n\t\t\tif ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;\n\t\t\tif ( this.castShadow === true ) object.castShadow = true;\n\t\t\tif ( this.receiveShadow === true ) object.receiveShadow = true;\n\t\t\tif ( this.visible === false ) object.visible = false;\n\t\n\t\t\tobject.matrix = this.matrix.toArray();\n\t\n\t\t\t//\n\t\n\t\t\tif ( this.geometry !== undefined ) {\n\t\n\t\t\t\tif ( meta.geometries[ this.geometry.uuid ] === undefined ) {\n\t\n\t\t\t\t\tmeta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tobject.geometry = this.geometry.uuid;\n\t\n\t\t\t}\n\t\n\t\t\tif ( this.material !== undefined ) {\n\t\n\t\t\t\tif ( meta.materials[ this.material.uuid ] === undefined ) {\n\t\n\t\t\t\t\tmeta.materials[ this.material.uuid ] = this.material.toJSON( meta );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tobject.material = this.material.uuid;\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tif ( this.children.length > 0 ) {\n\t\n\t\t\t\tobject.children = [];\n\t\n\t\t\t\tfor ( var i = 0; i < this.children.length; i ++ ) {\n\t\n\t\t\t\t\tobject.children.push( this.children[ i ].toJSON( meta ).object );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif ( isRootObject ) {\n\t\n\t\t\t\tvar geometries = extractFromCache( meta.geometries );\n\t\t\t\tvar materials = extractFromCache( meta.materials );\n\t\t\t\tvar textures = extractFromCache( meta.textures );\n\t\t\t\tvar images = extractFromCache( meta.images );\n\t\n\t\t\t\tif ( geometries.length > 0 ) output.geometries = geometries;\n\t\t\t\tif ( materials.length > 0 ) output.materials = materials;\n\t\t\t\tif ( textures.length > 0 ) output.textures = textures;\n\t\t\t\tif ( images.length > 0 ) output.images = images;\n\t\n\t\t\t}\n\t\n\t\t\toutput.object = object;\n\t\n\t\t\treturn output;\n\t\n\t\t\t// extract data from the cache hash\n\t\t\t// remove metadata on each item\n\t\t\t// and return as array\n\t\t\tfunction extractFromCache ( cache ) {\n\t\n\t\t\t\tvar values = [];\n\t\t\t\tfor ( var key in cache ) {\n\t\n\t\t\t\t\tvar data = cache[ key ];\n\t\t\t\t\tdelete data.metadata;\n\t\t\t\t\tvalues.push( data );\n\t\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tclone: function ( recursive ) {\n\t\n\t\t\treturn new this.constructor().copy( this, recursive );\n\t\n\t\t},\n\t\n\t\tcopy: function ( source, recursive ) {\n\t\n\t\t\tif ( recursive === undefined ) recursive = true;\n\t\n\t\t\tthis.name = source.name;\n\t\n\t\t\tthis.up.copy( source.up );\n\t\n\t\t\tthis.position.copy( source.position );\n\t\t\tthis.quaternion.copy( source.quaternion );\n\t\t\tthis.scale.copy( source.scale );\n\t\n\t\t\tthis.matrix.copy( source.matrix );\n\t\t\tthis.matrixWorld.copy( source.matrixWorld );\n\t\n\t\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\t\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n\t\n\t\t\tthis.visible = source.visible;\n\t\n\t\t\tthis.castShadow = source.castShadow;\n\t\t\tthis.receiveShadow = source.receiveShadow;\n\t\n\t\t\tthis.frustumCulled = source.frustumCulled;\n\t\t\tthis.renderOrder = source.renderOrder;\n\t\n\t\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\t\n\t\t\tif ( recursive === true ) {\n\t\n\t\t\t\tfor ( var i = 0; i < source.children.length; i ++ ) {\n\t\n\t\t\t\t\tvar child = source.children[ i ];\n\t\t\t\t\tthis.add( child.clone() );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t} );\n\t\n\tTHREE.Object3DIdCount = 0;\n\t\n\t// File:src/core/Face3.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {\n\t\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\t\n\t\tthis.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();\n\t\tthis.vertexNormals = Array.isArray( normal ) ? normal : [];\n\t\n\t\tthis.color = color instanceof THREE.Color ? color : new THREE.Color();\n\t\tthis.vertexColors = Array.isArray( color ) ? color : [];\n\t\n\t\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\n\t\n\t};\n\t\n\tTHREE.Face3.prototype = {\n\t\n\t\tconstructor: THREE.Face3,\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t},\n\t\n\t\tcopy: function ( source ) {\n\t\n\t\t\tthis.a = source.a;\n\t\t\tthis.b = source.b;\n\t\t\tthis.c = source.c;\n\t\n\t\t\tthis.normal.copy( source.normal );\n\t\t\tthis.color.copy( source.color );\n\t\n\t\t\tthis.materialIndex = source.materialIndex;\n\t\n\t\t\tfor ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {\n\t\n\t\t\t\tthis.vertexNormals[ i ] = source.vertexNormals[ i ].clone();\n\t\n\t\t\t}\n\t\n\t\t\tfor ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {\n\t\n\t\t\t\tthis.vertexColors[ i ] = source.vertexColors[ i ].clone();\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/core/BufferAttribute.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.BufferAttribute = function ( array, itemSize, normalized ) {\n\t\n\t\tthis.uuid = THREE.Math.generateUUID();\n\t\n\t\tthis.array = array;\n\t\tthis.itemSize = itemSize;\n\t\n\t\tthis.dynamic = false;\n\t\tthis.updateRange = { offset: 0, count: - 1 };\n\t\n\t\tthis.version = 0;\n\t\tthis.normalized = normalized === true;\n\t\n\t};\n\t\n\tTHREE.BufferAttribute.prototype = {\n\t\n\t\tconstructor: THREE.BufferAttribute,\n\t\n\t\tget count() {\n\t\n\t\t\treturn this.array.length / this.itemSize;\n\t\n\t\t},\n\t\n\t\tset needsUpdate( value ) {\n\t\n\t\t\tif ( value === true ) this.version ++;\n\t\n\t\t},\n\t\n\t\tsetDynamic: function ( value ) {\n\t\n\t\t\tthis.dynamic = value;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tcopy: function ( source ) {\n\t\n\t\t\tthis.array = new source.array.constructor( source.array );\n\t\t\tthis.itemSize = source.itemSize;\n\t\n\t\t\tthis.dynamic = source.dynamic;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tcopyAt: function ( index1, attribute, index2 ) {\n\t\n\t\t\tindex1 *= this.itemSize;\n\t\t\tindex2 *= attribute.itemSize;\n\t\n\t\t\tfor ( var i = 0, l = this.itemSize; i < l; i ++ ) {\n\t\n\t\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tcopyArray: function ( array ) {\n\t\n\t\t\tthis.array.set( array );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tcopyColorsArray: function ( colors ) {\n\t\n\t\t\tvar array = this.array, offset = 0;\n\t\n\t\t\tfor ( var i = 0, l = colors.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar color = colors[ i ];\n\t\n\t\t\t\tif ( color === undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );\n\t\t\t\t\tcolor = new THREE.Color();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tarray[ offset ++ ] = color.r;\n\t\t\t\tarray[ offset ++ ] = color.g;\n\t\t\t\tarray[ offset ++ ] = color.b;\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tcopyIndicesArray: function ( indices ) {\n\t\n\t\t\tvar array = this.array, offset = 0;\n\t\n\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar index = indices[ i ];\n\t\n\t\t\t\tarray[ offset ++ ] = index.a;\n\t\t\t\tarray[ offset ++ ] = index.b;\n\t\t\t\tarray[ offset ++ ] = index.c;\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tcopyVector2sArray: function ( vectors ) {\n\t\n\t\t\tvar array = this.array, offset = 0;\n\t\n\t\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar vector = vectors[ i ];\n\t\n\t\t\t\tif ( vector === undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );\n\t\t\t\t\tvector = new THREE.Vector2();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\t\tarray[ offset ++ ] = vector.y;\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tcopyVector3sArray: function ( vectors ) {\n\t\n\t\t\tvar array = this.array, offset = 0;\n\t\n\t\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar vector = vectors[ i ];\n\t\n\t\t\t\tif ( vector === undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );\n\t\t\t\t\tvector = new THREE.Vector3();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\t\tarray[ offset ++ ] = vector.y;\n\t\t\t\tarray[ offset ++ ] = vector.z;\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tcopyVector4sArray: function ( vectors ) {\n\t\n\t\t\tvar array = this.array, offset = 0;\n\t\n\t\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar vector = vectors[ i ];\n\t\n\t\t\t\tif ( vector === undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );\n\t\t\t\t\tvector = new THREE.Vector4();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\t\tarray[ offset ++ ] = vector.y;\n\t\t\t\tarray[ offset ++ ] = vector.z;\n\t\t\t\tarray[ offset ++ ] = vector.w;\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tset: function ( value, offset ) {\n\t\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\tthis.array.set( value, offset );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tgetX: function ( index ) {\n\t\n\t\t\treturn this.array[ index * this.itemSize ];\n\t\n\t\t},\n\t\n\t\tsetX: function ( index, x ) {\n\t\n\t\t\tthis.array[ index * this.itemSize ] = x;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tgetY: function ( index ) {\n\t\n\t\t\treturn this.array[ index * this.itemSize + 1 ];\n\t\n\t\t},\n\t\n\t\tsetY: function ( index, y ) {\n\t\n\t\t\tthis.array[ index * this.itemSize + 1 ] = y;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tgetZ: function ( index ) {\n\t\n\t\t\treturn this.array[ index * this.itemSize + 2 ];\n\t\n\t\t},\n\t\n\t\tsetZ: function ( index, z ) {\n\t\n\t\t\tthis.array[ index * this.itemSize + 2 ] = z;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tgetW: function ( index ) {\n\t\n\t\t\treturn this.array[ index * this.itemSize + 3 ];\n\t\n\t\t},\n\t\n\t\tsetW: function ( index, w ) {\n\t\n\t\t\tthis.array[ index * this.itemSize + 3 ] = w;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetXY: function ( index, x, y ) {\n\t\n\t\t\tindex *= this.itemSize;\n\t\n\t\t\tthis.array[ index + 0 ] = x;\n\t\t\tthis.array[ index + 1 ] = y;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetXYZ: function ( index, x, y, z ) {\n\t\n\t\t\tindex *= this.itemSize;\n\t\n\t\t\tthis.array[ index + 0 ] = x;\n\t\t\tthis.array[ index + 1 ] = y;\n\t\t\tthis.array[ index + 2 ] = z;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetXYZW: function ( index, x, y, z, w ) {\n\t\n\t\t\tindex *= this.itemSize;\n\t\n\t\t\tthis.array[ index + 0 ] = x;\n\t\t\tthis.array[ index + 1 ] = y;\n\t\t\tthis.array[ index + 2 ] = z;\n\t\t\tthis.array[ index + 3 ] = w;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t}\n\t\n\t};\n\t\n\t//\n\t\n\tTHREE.Int8Attribute = function ( array, itemSize ) {\n\t\n\t\treturn new THREE.BufferAttribute( new Int8Array( array ), itemSize );\n\t\n\t};\n\t\n\tTHREE.Uint8Attribute = function ( array, itemSize ) {\n\t\n\t\treturn new THREE.BufferAttribute( new Uint8Array( array ), itemSize );\n\t\n\t};\n\t\n\tTHREE.Uint8ClampedAttribute = function ( array, itemSize ) {\n\t\n\t\treturn new THREE.BufferAttribute( new Uint8ClampedArray( array ), itemSize );\n\t\n\t};\n\t\n\tTHREE.Int16Attribute = function ( array, itemSize ) {\n\t\n\t\treturn new THREE.BufferAttribute( new Int16Array( array ), itemSize );\n\t\n\t};\n\t\n\tTHREE.Uint16Attribute = function ( array, itemSize ) {\n\t\n\t\treturn new THREE.BufferAttribute( new Uint16Array( array ), itemSize );\n\t\n\t};\n\t\n\tTHREE.Int32Attribute = function ( array, itemSize ) {\n\t\n\t\treturn new THREE.BufferAttribute( new Int32Array( array ), itemSize );\n\t\n\t};\n\t\n\tTHREE.Uint32Attribute = function ( array, itemSize ) {\n\t\n\t\treturn new THREE.BufferAttribute( new Uint32Array( array ), itemSize );\n\t\n\t};\n\t\n\tTHREE.Float32Attribute = function ( array, itemSize ) {\n\t\n\t\treturn new THREE.BufferAttribute( new Float32Array( array ), itemSize );\n\t\n\t};\n\t\n\tTHREE.Float64Attribute = function ( array, itemSize ) {\n\t\n\t\treturn new THREE.BufferAttribute( new Float64Array( array ), itemSize );\n\t\n\t};\n\t\n\t\n\t// Deprecated\n\t\n\tTHREE.DynamicBufferAttribute = function ( array, itemSize ) {\n\t\n\t\tconsole.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );\n\t\treturn new THREE.BufferAttribute( array, itemSize ).setDynamic( true );\n\t\n\t};\n\t\n\t// File:src/core/InstancedBufferAttribute.js\n\t\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\t\n\tTHREE.InstancedBufferAttribute = function ( array, itemSize, meshPerAttribute ) {\n\t\n\t\tTHREE.BufferAttribute.call( this, array, itemSize );\n\t\n\t\tthis.meshPerAttribute = meshPerAttribute || 1;\n\t\n\t};\n\t\n\tTHREE.InstancedBufferAttribute.prototype = Object.create( THREE.BufferAttribute.prototype );\n\tTHREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute;\n\t\n\tTHREE.InstancedBufferAttribute.prototype.copy = function ( source ) {\n\t\n\t\tTHREE.BufferAttribute.prototype.copy.call( this, source );\n\t\n\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\t\n\t\treturn this;\n\t\n\t};\n\t\n\t// File:src/core/InterleavedBuffer.js\n\t\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\t\n\tTHREE.InterleavedBuffer = function ( array, stride ) {\n\t\n\t\tthis.uuid = THREE.Math.generateUUID();\n\t\n\t\tthis.array = array;\n\t\tthis.stride = stride;\n\t\n\t\tthis.dynamic = false;\n\t\tthis.updateRange = { offset: 0, count: - 1 };\n\t\n\t\tthis.version = 0;\n\t\n\t};\n\t\n\tTHREE.InterleavedBuffer.prototype = {\n\t\n\t\tconstructor: THREE.InterleavedBuffer,\n\t\n\t\tget length () {\n\t\n\t\t\treturn this.array.length;\n\t\n\t\t},\n\t\n\t\tget count () {\n\t\n\t\t\treturn this.array.length / this.stride;\n\t\n\t\t},\n\t\n\t\tset needsUpdate( value ) {\n\t\n\t\t\tif ( value === true ) this.version ++;\n\t\n\t\t},\n\t\n\t\tsetDynamic: function ( value ) {\n\t\n\t\t\tthis.dynamic = value;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tcopy: function ( source ) {\n\t\n\t\t\tthis.array = new source.array.constructor( source.array );\n\t\t\tthis.stride = source.stride;\n\t\t\tthis.dynamic = source.dynamic;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tcopyAt: function ( index1, attribute, index2 ) {\n\t\n\t\t\tindex1 *= this.stride;\n\t\t\tindex2 *= attribute.stride;\n\t\n\t\t\tfor ( var i = 0, l = this.stride; i < l; i ++ ) {\n\t\n\t\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tset: function ( value, offset ) {\n\t\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\tthis.array.set( value, offset );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/core/InstancedInterleavedBuffer.js\n\t\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\t\n\tTHREE.InstancedInterleavedBuffer = function ( array, stride, meshPerAttribute ) {\n\t\n\t\tTHREE.InterleavedBuffer.call( this, array, stride );\n\t\n\t\tthis.meshPerAttribute = meshPerAttribute || 1;\n\t\n\t};\n\t\n\tTHREE.InstancedInterleavedBuffer.prototype = Object.create( THREE.InterleavedBuffer.prototype );\n\tTHREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer;\n\t\n\tTHREE.InstancedInterleavedBuffer.prototype.copy = function ( source ) {\n\t\n\t\tTHREE.InterleavedBuffer.prototype.copy.call( this, source );\n\t\n\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\t\n\t\treturn this;\n\t\n\t};\n\t\n\t// File:src/core/InterleavedBufferAttribute.js\n\t\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\t\n\tTHREE.InterleavedBufferAttribute = function ( interleavedBuffer, itemSize, offset ) {\n\t\n\t\tthis.uuid = THREE.Math.generateUUID();\n\t\n\t\tthis.data = interleavedBuffer;\n\t\tthis.itemSize = itemSize;\n\t\tthis.offset = offset;\n\t\n\t};\n\t\n\t\n\tTHREE.InterleavedBufferAttribute.prototype = {\n\t\n\t\tconstructor: THREE.InterleavedBufferAttribute,\n\t\n\t\tget length() {\n\t\n\t\t\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );\n\t\t\treturn this.array.length;\n\t\n\t\t},\n\t\n\t\tget count() {\n\t\n\t\t\treturn this.data.count;\n\t\n\t\t},\n\t\n\t\tsetX: function ( index, x ) {\n\t\n\t\t\tthis.data.array[ index * this.data.stride + this.offset ] = x;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetY: function ( index, y ) {\n\t\n\t\t\tthis.data.array[ index * this.data.stride + this.offset + 1 ] = y;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetZ: function ( index, z ) {\n\t\n\t\t\tthis.data.array[ index * this.data.stride + this.offset + 2 ] = z;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetW: function ( index, w ) {\n\t\n\t\t\tthis.data.array[ index * this.data.stride + this.offset + 3 ] = w;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tgetX: function ( index ) {\n\t\n\t\t\treturn this.data.array[ index * this.data.stride + this.offset ];\n\t\n\t\t},\n\t\n\t\tgetY: function ( index ) {\n\t\n\t\t\treturn this.data.array[ index * this.data.stride + this.offset + 1 ];\n\t\n\t\t},\n\t\n\t\tgetZ: function ( index ) {\n\t\n\t\t\treturn this.data.array[ index * this.data.stride + this.offset + 2 ];\n\t\n\t\t},\n\t\n\t\tgetW: function ( index ) {\n\t\n\t\t\treturn this.data.array[ index * this.data.stride + this.offset + 3 ];\n\t\n\t\t},\n\t\n\t\tsetXY: function ( index, x, y ) {\n\t\n\t\t\tindex = index * this.data.stride + this.offset;\n\t\n\t\t\tthis.data.array[ index + 0 ] = x;\n\t\t\tthis.data.array[ index + 1 ] = y;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetXYZ: function ( index, x, y, z ) {\n\t\n\t\t\tindex = index * this.data.stride + this.offset;\n\t\n\t\t\tthis.data.array[ index + 0 ] = x;\n\t\t\tthis.data.array[ index + 1 ] = y;\n\t\t\tthis.data.array[ index + 2 ] = z;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetXYZW: function ( index, x, y, z, w ) {\n\t\n\t\t\tindex = index * this.data.stride + this.offset;\n\t\n\t\t\tthis.data.array[ index + 0 ] = x;\n\t\t\tthis.data.array[ index + 1 ] = y;\n\t\t\tthis.data.array[ index + 2 ] = z;\n\t\t\tthis.data.array[ index + 3 ] = w;\n\t\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/core/Geometry.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author kile / http://kile.stravaganza.org/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * @author bhouston / http://clara.io\n\t */\n\t\n\tTHREE.Geometry = function () {\n\t\n\t\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\n\t\n\t\tthis.uuid = THREE.Math.generateUUID();\n\t\n\t\tthis.name = '';\n\t\tthis.type = 'Geometry';\n\t\n\t\tthis.vertices = [];\n\t\tthis.colors = [];\n\t\tthis.faces = [];\n\t\tthis.faceVertexUvs = [ [] ];\n\t\n\t\tthis.morphTargets = [];\n\t\tthis.morphNormals = [];\n\t\n\t\tthis.skinWeights = [];\n\t\tthis.skinIndices = [];\n\t\n\t\tthis.lineDistances = [];\n\t\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\t\n\t\t// update flags\n\t\n\t\tthis.verticesNeedUpdate = false;\n\t\tthis.elementsNeedUpdate = false;\n\t\tthis.uvsNeedUpdate = false;\n\t\tthis.normalsNeedUpdate = false;\n\t\tthis.colorsNeedUpdate = false;\n\t\tthis.lineDistancesNeedUpdate = false;\n\t\tthis.groupsNeedUpdate = false;\n\t\n\t};\n\t\n\tObject.assign( THREE.Geometry.prototype, THREE.EventDispatcher.prototype, {\n\t\n\t\tapplyMatrix: function ( matrix ) {\n\t\n\t\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\n\t\n\t\t\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\n\t\n\t\t\t\tvar vertex = this.vertices[ i ];\n\t\t\t\tvertex.applyMatrix4( matrix );\n\t\n\t\t\t}\n\t\n\t\t\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\n\t\n\t\t\t\tvar face = this.faces[ i ];\n\t\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\n\t\n\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif ( this.boundingBox !== null ) {\n\t\n\t\t\t\tthis.computeBoundingBox();\n\t\n\t\t\t}\n\t\n\t\t\tif ( this.boundingSphere !== null ) {\n\t\n\t\t\t\tthis.computeBoundingSphere();\n\t\n\t\t\t}\n\t\n\t\t\tthis.verticesNeedUpdate = true;\n\t\t\tthis.normalsNeedUpdate = true;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\trotateX: function () {\n\t\n\t\t\t// rotate geometry around world x-axis\n\t\n\t\t\tvar m1;\n\t\n\t\t\treturn function rotateX( angle ) {\n\t\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\t\n\t\t\t\tm1.makeRotationX( angle );\n\t\n\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\trotateY: function () {\n\t\n\t\t\t// rotate geometry around world y-axis\n\t\n\t\t\tvar m1;\n\t\n\t\t\treturn function rotateY( angle ) {\n\t\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\t\n\t\t\t\tm1.makeRotationY( angle );\n\t\n\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\trotateZ: function () {\n\t\n\t\t\t// rotate geometry around world z-axis\n\t\n\t\t\tvar m1;\n\t\n\t\t\treturn function rotateZ( angle ) {\n\t\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\t\n\t\t\t\tm1.makeRotationZ( angle );\n\t\n\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\ttranslate: function () {\n\t\n\t\t\t// translate geometry\n\t\n\t\t\tvar m1;\n\t\n\t\t\treturn function translate( x, y, z ) {\n\t\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\t\n\t\t\t\tm1.makeTranslation( x, y, z );\n\t\n\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tscale: function () {\n\t\n\t\t\t// scale geometry\n\t\n\t\t\tvar m1;\n\t\n\t\t\treturn function scale( x, y, z ) {\n\t\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\t\n\t\t\t\tm1.makeScale( x, y, z );\n\t\n\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tlookAt: function () {\n\t\n\t\t\tvar obj;\n\t\n\t\t\treturn function lookAt( vector ) {\n\t\n\t\t\t\tif ( obj === undefined ) obj = new THREE.Object3D();\n\t\n\t\t\t\tobj.lookAt( vector );\n\t\n\t\t\t\tobj.updateMatrix();\n\t\n\t\t\t\tthis.applyMatrix( obj.matrix );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tfromBufferGeometry: function ( geometry ) {\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\tvar indices = geometry.index !== null ? geometry.index.array : undefined;\n\t\t\tvar attributes = geometry.attributes;\n\t\n\t\t\tvar positions = attributes.position.array;\n\t\t\tvar normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\n\t\t\tvar colors = attributes.color !== undefined ? attributes.color.array : undefined;\n\t\t\tvar uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\n\t\t\tvar uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;\n\t\n\t\t\tif ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];\n\t\n\t\t\tvar tempNormals = [];\n\t\t\tvar tempUVs = [];\n\t\t\tvar tempUVs2 = [];\n\t\n\t\t\tfor ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {\n\t\n\t\t\t\tscope.vertices.push( new THREE.Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );\n\t\n\t\t\t\tif ( normals !== undefined ) {\n\t\n\t\t\t\t\ttempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( colors !== undefined ) {\n\t\n\t\t\t\t\tscope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( uvs !== undefined ) {\n\t\n\t\t\t\t\ttempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( uvs2 !== undefined ) {\n\t\n\t\t\t\t\ttempUVs2.push( new THREE.Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction addFace( a, b, c, materialIndex ) {\n\t\n\t\t\t\tvar vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];\n\t\t\t\tvar vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];\n\t\n\t\t\t\tvar face = new THREE.Face3( a, b, c, vertexNormals, vertexColors, materialIndex );\n\t\n\t\t\t\tscope.faces.push( face );\n\t\n\t\t\t\tif ( uvs !== undefined ) {\n\t\n\t\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( uvs2 !== undefined ) {\n\t\n\t\t\t\t\tscope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif ( indices !== undefined ) {\n\t\n\t\t\t\tvar groups = geometry.groups;\n\t\n\t\t\t\tif ( groups.length > 0 ) {\n\t\n\t\t\t\t\tfor ( var i = 0; i < groups.length; i ++ ) {\n\t\n\t\t\t\t\t\tvar group = groups[ i ];\n\t\n\t\t\t\t\t\tvar start = group.start;\n\t\t\t\t\t\tvar count = group.count;\n\t\n\t\t\t\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\n\t\n\t\t\t\t\t\t\taddFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex  );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\n\t\n\t\t\t\t\t\taddFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t} else {\n\t\n\t\t\t\tfor ( var i = 0; i < positions.length / 3; i += 3 ) {\n\t\n\t\t\t\t\taddFace( i, i + 1, i + 2 );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tthis.computeFaceNormals();\n\t\n\t\t\tif ( geometry.boundingBox !== null ) {\n\t\n\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\t\n\t\t\t}\n\t\n\t\t\tif ( geometry.boundingSphere !== null ) {\n\t\n\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tcenter: function () {\n\t\n\t\t\tthis.computeBoundingBox();\n\t\n\t\t\tvar offset = this.boundingBox.center().negate();\n\t\n\t\t\tthis.translate( offset.x, offset.y, offset.z );\n\t\n\t\t\treturn offset;\n\t\n\t\t},\n\t\n\t\tnormalize: function () {\n\t\n\t\t\tthis.computeBoundingSphere();\n\t\n\t\t\tvar center = this.boundingSphere.center;\n\t\t\tvar radius = this.boundingSphere.radius;\n\t\n\t\t\tvar s = radius === 0 ? 1 : 1.0 / radius;\n\t\n\t\t\tvar matrix = new THREE.Matrix4();\n\t\t\tmatrix.set(\n\t\t\t\ts, 0, 0, - s * center.x,\n\t\t\t\t0, s, 0, - s * center.y,\n\t\t\t\t0, 0, s, - s * center.z,\n\t\t\t\t0, 0, 0, 1\n\t\t\t);\n\t\n\t\t\tthis.applyMatrix( matrix );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tcomputeFaceNormals: function () {\n\t\n\t\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\n\t\n\t\t\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\tvar face = this.faces[ f ];\n\t\n\t\t\t\tvar vA = this.vertices[ face.a ];\n\t\t\t\tvar vB = this.vertices[ face.b ];\n\t\t\t\tvar vC = this.vertices[ face.c ];\n\t\n\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\tcb.cross( ab );\n\t\n\t\t\t\tcb.normalize();\n\t\n\t\t\t\tface.normal.copy( cb );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tcomputeVertexNormals: function ( areaWeighted ) {\n\t\n\t\t\tif ( areaWeighted === undefined ) areaWeighted = true;\n\t\n\t\t\tvar v, vl, f, fl, face, vertices;\n\t\n\t\t\tvertices = new Array( this.vertices.length );\n\t\n\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\t\n\t\t\t\tvertices[ v ] = new THREE.Vector3();\n\t\n\t\t\t}\n\t\n\t\t\tif ( areaWeighted ) {\n\t\n\t\t\t\t// vertex normals weighted by triangle areas\n\t\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\n\t\n\t\t\t\tvar vA, vB, vC;\n\t\t\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\n\t\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\tface = this.faces[ f ];\n\t\n\t\t\t\t\tvA = this.vertices[ face.a ];\n\t\t\t\t\tvB = this.vertices[ face.b ];\n\t\t\t\t\tvC = this.vertices[ face.c ];\n\t\n\t\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\t\tcb.cross( ab );\n\t\n\t\t\t\t\tvertices[ face.a ].add( cb );\n\t\t\t\t\tvertices[ face.b ].add( cb );\n\t\t\t\t\tvertices[ face.c ].add( cb );\n\t\n\t\t\t\t}\n\t\n\t\t\t} else {\n\t\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\tface = this.faces[ f ];\n\t\n\t\t\t\t\tvertices[ face.a ].add( face.normal );\n\t\t\t\t\tvertices[ face.b ].add( face.normal );\n\t\t\t\t\tvertices[ face.c ].add( face.normal );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\t\n\t\t\t\tvertices[ v ].normalize();\n\t\n\t\t\t}\n\t\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\tface = this.faces[ f ];\n\t\n\t\t\t\tvar vertexNormals = face.vertexNormals;\n\t\n\t\t\t\tif ( vertexNormals.length === 3 ) {\n\t\n\t\t\t\t\tvertexNormals[ 0 ].copy( vertices[ face.a ] );\n\t\t\t\t\tvertexNormals[ 1 ].copy( vertices[ face.b ] );\n\t\t\t\t\tvertexNormals[ 2 ].copy( vertices[ face.c ] );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tvertexNormals[ 0 ] = vertices[ face.a ].clone();\n\t\t\t\t\tvertexNormals[ 1 ] = vertices[ face.b ].clone();\n\t\t\t\t\tvertexNormals[ 2 ] = vertices[ face.c ].clone();\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif ( this.faces.length > 0 ) {\n\t\n\t\t\t\tthis.normalsNeedUpdate = true;\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tcomputeMorphNormals: function () {\n\t\n\t\t\tvar i, il, f, fl, face;\n\t\n\t\t\t// save original normals\n\t\t\t// - create temp variables on first access\n\t\t\t//   otherwise just copy (for faster repeated calls)\n\t\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\tface = this.faces[ f ];\n\t\n\t\t\t\tif ( ! face.__originalFaceNormal ) {\n\t\n\t\t\t\t\tface.__originalFaceNormal = face.normal.clone();\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tface.__originalFaceNormal.copy( face.normal );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\n\t\n\t\t\t\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\n\t\n\t\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// use temp geometry to compute face and vertex normals for each morph\n\t\n\t\t\tvar tmpGeo = new THREE.Geometry();\n\t\t\ttmpGeo.faces = this.faces;\n\t\n\t\t\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\n\t\n\t\t\t\t// create on first access\n\t\n\t\t\t\tif ( ! this.morphNormals[ i ] ) {\n\t\n\t\t\t\t\tthis.morphNormals[ i ] = {};\n\t\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\n\t\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\n\t\n\t\t\t\t\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\n\t\t\t\t\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\n\t\n\t\t\t\t\tvar faceNormal, vertexNormals;\n\t\n\t\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\t\tfaceNormal = new THREE.Vector3();\n\t\t\t\t\t\tvertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };\n\t\n\t\t\t\t\t\tdstNormalsFace.push( faceNormal );\n\t\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar morphNormals = this.morphNormals[ i ];\n\t\n\t\t\t\t// set vertices to morph target\n\t\n\t\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\n\t\n\t\t\t\t// compute morph normals\n\t\n\t\t\t\ttmpGeo.computeFaceNormals();\n\t\t\t\ttmpGeo.computeVertexNormals();\n\t\n\t\t\t\t// store morph normals\n\t\n\t\t\t\tvar faceNormal, vertexNormals;\n\t\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\tface = this.faces[ f ];\n\t\n\t\t\t\t\tfaceNormal = morphNormals.faceNormals[ f ];\n\t\t\t\t\tvertexNormals = morphNormals.vertexNormals[ f ];\n\t\n\t\t\t\t\tfaceNormal.copy( face.normal );\n\t\n\t\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\n\t\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\n\t\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// restore original normals\n\t\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\tface = this.faces[ f ];\n\t\n\t\t\t\tface.normal = face.__originalFaceNormal;\n\t\t\t\tface.vertexNormals = face.__originalVertexNormals;\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tcomputeTangents: function () {\n\t\n\t\t\tconsole.warn( 'THREE.Geometry: .computeTangents() has been removed.' );\n\t\n\t\t},\n\t\n\t\tcomputeLineDistances: function () {\n\t\n\t\t\tvar d = 0;\n\t\t\tvar vertices = this.vertices;\n\t\n\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\t\n\t\t\t\tif ( i > 0 ) {\n\t\n\t\t\t\t\td += vertices[ i ].distanceTo( vertices[ i - 1 ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.lineDistances[ i ] = d;\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tcomputeBoundingBox: function () {\n\t\n\t\t\tif ( this.boundingBox === null ) {\n\t\n\t\t\t\tthis.boundingBox = new THREE.Box3();\n\t\n\t\t\t}\n\t\n\t\t\tthis.boundingBox.setFromPoints( this.vertices );\n\t\n\t\t},\n\t\n\t\tcomputeBoundingSphere: function () {\n\t\n\t\t\tif ( this.boundingSphere === null ) {\n\t\n\t\t\t\tthis.boundingSphere = new THREE.Sphere();\n\t\n\t\t\t}\n\t\n\t\t\tthis.boundingSphere.setFromPoints( this.vertices );\n\t\n\t\t},\n\t\n\t\tmerge: function ( geometry, matrix, materialIndexOffset ) {\n\t\n\t\t\tif ( geometry instanceof THREE.Geometry === false ) {\n\t\n\t\t\t\tconsole.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );\n\t\t\t\treturn;\n\t\n\t\t\t}\n\t\n\t\t\tvar normalMatrix,\n\t\t\tvertexOffset = this.vertices.length,\n\t\t\tvertices1 = this.vertices,\n\t\t\tvertices2 = geometry.vertices,\n\t\t\tfaces1 = this.faces,\n\t\t\tfaces2 = geometry.faces,\n\t\t\tuvs1 = this.faceVertexUvs[ 0 ],\n\t\t\tuvs2 = geometry.faceVertexUvs[ 0 ];\n\t\n\t\t\tif ( materialIndexOffset === undefined ) materialIndexOffset = 0;\n\t\n\t\t\tif ( matrix !== undefined ) {\n\t\n\t\t\t\tnormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\n\t\n\t\t\t}\n\t\n\t\t\t// vertices\n\t\n\t\t\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\n\t\n\t\t\t\tvar vertex = vertices2[ i ];\n\t\n\t\t\t\tvar vertexCopy = vertex.clone();\n\t\n\t\t\t\tif ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\n\t\n\t\t\t\tvertices1.push( vertexCopy );\n\t\n\t\t\t}\n\t\n\t\t\t// faces\n\t\n\t\t\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\n\t\n\t\t\t\tvar face = faces2[ i ], faceCopy, normal, color,\n\t\t\t\tfaceVertexNormals = face.vertexNormals,\n\t\t\t\tfaceVertexColors = face.vertexColors;\n\t\n\t\t\t\tfaceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\n\t\t\t\tfaceCopy.normal.copy( face.normal );\n\t\n\t\t\t\tif ( normalMatrix !== undefined ) {\n\t\n\t\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\tnormal = faceVertexNormals[ j ].clone();\n\t\n\t\t\t\t\tif ( normalMatrix !== undefined ) {\n\t\n\t\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfaceCopy.vertexNormals.push( normal );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfaceCopy.color.copy( face.color );\n\t\n\t\t\t\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\tcolor = faceVertexColors[ j ];\n\t\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n\t\n\t\t\t\tfaces1.push( faceCopy );\n\t\n\t\t\t}\n\t\n\t\t\t// uvs\n\t\n\t\t\tfor ( i = 0, il = uvs2.length; i < il; i ++ ) {\n\t\n\t\t\t\tvar uv = uvs2[ i ], uvCopy = [];\n\t\n\t\t\t\tif ( uv === undefined ) {\n\t\n\t\t\t\t\tcontinue;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\tuvCopy.push( uv[ j ].clone() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tuvs1.push( uvCopy );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tmergeMesh: function ( mesh ) {\n\t\n\t\t\tif ( mesh instanceof THREE.Mesh === false ) {\n\t\n\t\t\t\tconsole.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );\n\t\t\t\treturn;\n\t\n\t\t\t}\n\t\n\t\t\tmesh.matrixAutoUpdate && mesh.updateMatrix();\n\t\n\t\t\tthis.merge( mesh.geometry, mesh.matrix );\n\t\n\t\t},\n\t\n\t\t/*\n\t\t * Checks for duplicate vertices with hashmap.\n\t\t * Duplicated vertices are removed\n\t\t * and faces' vertices are updated.\n\t\t */\n\t\n\t\tmergeVertices: function () {\n\t\n\t\t\tvar verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n\t\t\tvar unique = [], changes = [];\n\t\n\t\t\tvar v, key;\n\t\t\tvar precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n\t\t\tvar precision = Math.pow( 10, precisionPoints );\n\t\t\tvar i, il, face;\n\t\t\tvar indices, j, jl;\n\t\n\t\t\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\n\t\n\t\t\t\tv = this.vertices[ i ];\n\t\t\t\tkey = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\n\t\n\t\t\t\tif ( verticesMap[ key ] === undefined ) {\n\t\n\t\t\t\t\tverticesMap[ key ] = i;\n\t\t\t\t\tunique.push( this.vertices[ i ] );\n\t\t\t\t\tchanges[ i ] = unique.length - 1;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n\t\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\n\t\t\t// if faces are completely degenerate after merging vertices, we\n\t\t\t// have to remove them from the geometry.\n\t\t\tvar faceIndicesToRemove = [];\n\t\n\t\t\tfor ( i = 0, il = this.faces.length; i < il; i ++ ) {\n\t\n\t\t\t\tface = this.faces[ i ];\n\t\n\t\t\t\tface.a = changes[ face.a ];\n\t\t\t\tface.b = changes[ face.b ];\n\t\t\t\tface.c = changes[ face.c ];\n\t\n\t\t\t\tindices = [ face.a, face.b, face.c ];\n\t\n\t\t\t\tvar dupIndex = - 1;\n\t\n\t\t\t\t// if any duplicate vertices are found in a Face3\n\t\t\t\t// we have to remove the face as nothing can be saved\n\t\t\t\tfor ( var n = 0; n < 3; n ++ ) {\n\t\n\t\t\t\t\tif ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {\n\t\n\t\t\t\t\t\tdupIndex = n;\n\t\t\t\t\t\tfaceIndicesToRemove.push( i );\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\n\t\n\t\t\t\tvar idx = faceIndicesToRemove[ i ];\n\t\n\t\t\t\tthis.faces.splice( idx, 1 );\n\t\n\t\t\t\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\tthis.faceVertexUvs[ j ].splice( idx, 1 );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// Use unique set of vertices\n\t\n\t\t\tvar diff = this.vertices.length - unique.length;\n\t\t\tthis.vertices = unique;\n\t\t\treturn diff;\n\t\n\t\t},\n\t\n\t\tsortFacesByMaterialIndex: function () {\n\t\n\t\t\tvar faces = this.faces;\n\t\t\tvar length = faces.length;\n\t\n\t\t\t// tag faces\n\t\n\t\t\tfor ( var i = 0; i < length; i ++ ) {\n\t\n\t\t\t\tfaces[ i ]._id = i;\n\t\n\t\t\t}\n\t\n\t\t\t// sort faces\n\t\n\t\t\tfunction materialIndexSort( a, b ) {\n\t\n\t\t\t\treturn a.materialIndex - b.materialIndex;\n\t\n\t\t\t}\n\t\n\t\t\tfaces.sort( materialIndexSort );\n\t\n\t\t\t// sort uvs\n\t\n\t\t\tvar uvs1 = this.faceVertexUvs[ 0 ];\n\t\t\tvar uvs2 = this.faceVertexUvs[ 1 ];\n\t\n\t\t\tvar newUvs1, newUvs2;\n\t\n\t\t\tif ( uvs1 && uvs1.length === length ) newUvs1 = [];\n\t\t\tif ( uvs2 && uvs2.length === length ) newUvs2 = [];\n\t\n\t\t\tfor ( var i = 0; i < length; i ++ ) {\n\t\n\t\t\t\tvar id = faces[ i ]._id;\n\t\n\t\t\t\tif ( newUvs1 ) newUvs1.push( uvs1[ id ] );\n\t\t\t\tif ( newUvs2 ) newUvs2.push( uvs2[ id ] );\n\t\n\t\t\t}\n\t\n\t\t\tif ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;\n\t\t\tif ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;\n\t\n\t\t},\n\t\n\t\ttoJSON: function () {\n\t\n\t\t\tvar data = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.4,\n\t\t\t\t\ttype: 'Geometry',\n\t\t\t\t\tgenerator: 'Geometry.toJSON'\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\t// standard Geometry serialization\n\t\n\t\t\tdata.uuid = this.uuid;\n\t\t\tdata.type = this.type;\n\t\t\tif ( this.name !== '' ) data.name = this.name;\n\t\n\t\t\tif ( this.parameters !== undefined ) {\n\t\n\t\t\t\tvar parameters = this.parameters;\n\t\n\t\t\t\tfor ( var key in parameters ) {\n\t\n\t\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn data;\n\t\n\t\t\t}\n\t\n\t\t\tvar vertices = [];\n\t\n\t\t\tfor ( var i = 0; i < this.vertices.length; i ++ ) {\n\t\n\t\t\t\tvar vertex = this.vertices[ i ];\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t}\n\t\n\t\t\tvar faces = [];\n\t\t\tvar normals = [];\n\t\t\tvar normalsHash = {};\n\t\t\tvar colors = [];\n\t\t\tvar colorsHash = {};\n\t\t\tvar uvs = [];\n\t\t\tvar uvsHash = {};\n\t\n\t\t\tfor ( var i = 0; i < this.faces.length; i ++ ) {\n\t\n\t\t\t\tvar face = this.faces[ i ];\n\t\n\t\t\t\tvar hasMaterial = true;\n\t\t\t\tvar hasFaceUv = false; // deprecated\n\t\t\t\tvar hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\n\t\t\t\tvar hasFaceNormal = face.normal.length() > 0;\n\t\t\t\tvar hasFaceVertexNormal = face.vertexNormals.length > 0;\n\t\t\t\tvar hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n\t\t\t\tvar hasFaceVertexColor = face.vertexColors.length > 0;\n\t\n\t\t\t\tvar faceType = 0;\n\t\n\t\t\t\tfaceType = setBit( faceType, 0, 0 ); // isQuad\n\t\t\t\tfaceType = setBit( faceType, 1, hasMaterial );\n\t\t\t\tfaceType = setBit( faceType, 2, hasFaceUv );\n\t\t\t\tfaceType = setBit( faceType, 3, hasFaceVertexUv );\n\t\t\t\tfaceType = setBit( faceType, 4, hasFaceNormal );\n\t\t\t\tfaceType = setBit( faceType, 5, hasFaceVertexNormal );\n\t\t\t\tfaceType = setBit( faceType, 6, hasFaceColor );\n\t\t\t\tfaceType = setBit( faceType, 7, hasFaceVertexColor );\n\t\n\t\t\t\tfaces.push( faceType );\n\t\t\t\tfaces.push( face.a, face.b, face.c );\n\t\t\t\tfaces.push( face.materialIndex );\n\t\n\t\t\t\tif ( hasFaceVertexUv ) {\n\t\n\t\t\t\t\tvar faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\n\t\n\t\t\t\t\tfaces.push(\n\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 0 ] ),\n\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 1 ] ),\n\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 2 ] )\n\t\t\t\t\t);\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( hasFaceNormal ) {\n\t\n\t\t\t\t\tfaces.push( getNormalIndex( face.normal ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( hasFaceVertexNormal ) {\n\t\n\t\t\t\t\tvar vertexNormals = face.vertexNormals;\n\t\n\t\t\t\t\tfaces.push(\n\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 0 ] ),\n\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 1 ] ),\n\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 2 ] )\n\t\t\t\t\t);\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( hasFaceColor ) {\n\t\n\t\t\t\t\tfaces.push( getColorIndex( face.color ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( hasFaceVertexColor ) {\n\t\n\t\t\t\t\tvar vertexColors = face.vertexColors;\n\t\n\t\t\t\t\tfaces.push(\n\t\t\t\t\t\tgetColorIndex( vertexColors[ 0 ] ),\n\t\t\t\t\t\tgetColorIndex( vertexColors[ 1 ] ),\n\t\t\t\t\t\tgetColorIndex( vertexColors[ 2 ] )\n\t\t\t\t\t);\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction setBit( value, position, enabled ) {\n\t\n\t\t\t\treturn enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );\n\t\n\t\t\t}\n\t\n\t\t\tfunction getNormalIndex( normal ) {\n\t\n\t\t\t\tvar hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n\t\n\t\t\t\tif ( normalsHash[ hash ] !== undefined ) {\n\t\n\t\t\t\t\treturn normalsHash[ hash ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tnormalsHash[ hash ] = normals.length / 3;\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\t\n\t\t\t\treturn normalsHash[ hash ];\n\t\n\t\t\t}\n\t\n\t\t\tfunction getColorIndex( color ) {\n\t\n\t\t\t\tvar hash = color.r.toString() + color.g.toString() + color.b.toString();\n\t\n\t\t\t\tif ( colorsHash[ hash ] !== undefined ) {\n\t\n\t\t\t\t\treturn colorsHash[ hash ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tcolorsHash[ hash ] = colors.length;\n\t\t\t\tcolors.push( color.getHex() );\n\t\n\t\t\t\treturn colorsHash[ hash ];\n\t\n\t\t\t}\n\t\n\t\t\tfunction getUvIndex( uv ) {\n\t\n\t\t\t\tvar hash = uv.x.toString() + uv.y.toString();\n\t\n\t\t\t\tif ( uvsHash[ hash ] !== undefined ) {\n\t\n\t\t\t\t\treturn uvsHash[ hash ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tuvsHash[ hash ] = uvs.length / 2;\n\t\t\t\tuvs.push( uv.x, uv.y );\n\t\n\t\t\t\treturn uvsHash[ hash ];\n\t\n\t\t\t}\n\t\n\t\t\tdata.data = {};\n\t\n\t\t\tdata.data.vertices = vertices;\n\t\t\tdata.data.normals = normals;\n\t\t\tif ( colors.length > 0 ) data.data.colors = colors;\n\t\t\tif ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility\n\t\t\tdata.data.faces = faces;\n\t\n\t\t\treturn data;\n\t\n\t\t},\n\t\n\t\tclone: function () {\n\t\n\t\t\t/*\n\t\t\t// Handle primitives\n\t\n\t\t\tvar parameters = this.parameters;\n\t\n\t\t\tif ( parameters !== undefined ) {\n\t\n\t\t\t\tvar values = [];\n\t\n\t\t\t\tfor ( var key in parameters ) {\n\t\n\t\t\t\t\tvalues.push( parameters[ key ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar geometry = Object.create( this.constructor.prototype );\n\t\t\t\tthis.constructor.apply( geometry, values );\n\t\t\t\treturn geometry;\n\t\n\t\t\t}\n\t\n\t\t\treturn new this.constructor().copy( this );\n\t\t\t*/\n\t\n\t\t\treturn new THREE.Geometry().copy( this );\n\t\n\t\t},\n\t\n\t\tcopy: function ( source ) {\n\t\n\t\t\tthis.vertices = [];\n\t\t\tthis.faces = [];\n\t\t\tthis.faceVertexUvs = [ [] ];\n\t\n\t\t\tvar vertices = source.vertices;\n\t\n\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\t\n\t\t\t\tthis.vertices.push( vertices[ i ].clone() );\n\t\n\t\t\t}\n\t\n\t\t\tvar faces = source.faces;\n\t\n\t\t\tfor ( var i = 0, il = faces.length; i < il; i ++ ) {\n\t\n\t\t\t\tthis.faces.push( faces[ i ].clone() );\n\t\n\t\t\t}\n\t\n\t\t\tfor ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {\n\t\n\t\t\t\tvar faceVertexUvs = source.faceVertexUvs[ i ];\n\t\n\t\t\t\tif ( this.faceVertexUvs[ i ] === undefined ) {\n\t\n\t\t\t\t\tthis.faceVertexUvs[ i ] = [];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\tvar uvs = faceVertexUvs[ j ], uvsCopy = [];\n\t\n\t\t\t\t\tfor ( var k = 0, kl = uvs.length; k < kl; k ++ ) {\n\t\n\t\t\t\t\t\tvar uv = uvs[ k ];\n\t\n\t\t\t\t\t\tuvsCopy.push( uv.clone() );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.faceVertexUvs[ i ].push( uvsCopy );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tdispose: function () {\n\t\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\t\n\t\t}\n\t\n\t} );\n\t\n\tTHREE.GeometryIdCount = 0;\n\t\n\t// File:src/core/DirectGeometry.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.DirectGeometry = function () {\n\t\n\t\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\n\t\n\t\tthis.uuid = THREE.Math.generateUUID();\n\t\n\t\tthis.name = '';\n\t\tthis.type = 'DirectGeometry';\n\t\n\t\tthis.indices = [];\n\t\tthis.vertices = [];\n\t\tthis.normals = [];\n\t\tthis.colors = [];\n\t\tthis.uvs = [];\n\t\tthis.uvs2 = [];\n\t\n\t\tthis.groups = [];\n\t\n\t\tthis.morphTargets = {};\n\t\n\t\tthis.skinWeights = [];\n\t\tthis.skinIndices = [];\n\t\n\t\t// this.lineDistances = [];\n\t\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\t\n\t\t// update flags\n\t\n\t\tthis.verticesNeedUpdate = false;\n\t\tthis.normalsNeedUpdate = false;\n\t\tthis.colorsNeedUpdate = false;\n\t\tthis.uvsNeedUpdate = false;\n\t\tthis.groupsNeedUpdate = false;\n\t\n\t};\n\t\n\tObject.assign( THREE.DirectGeometry.prototype, THREE.EventDispatcher.prototype, {\n\t\n\t\tcomputeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,\n\t\tcomputeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,\n\t\n\t\tcomputeFaceNormals: function () {\n\t\n\t\t\tconsole.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );\n\t\n\t\t},\n\t\n\t\tcomputeVertexNormals: function () {\n\t\n\t\t\tconsole.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );\n\t\n\t\t},\n\t\n\t\tcomputeGroups: function ( geometry ) {\n\t\n\t\t\tvar group;\n\t\t\tvar groups = [];\n\t\t\tvar materialIndex;\n\t\n\t\t\tvar faces = geometry.faces;\n\t\n\t\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\t\n\t\t\t\tvar face = faces[ i ];\n\t\n\t\t\t\t// materials\n\t\n\t\t\t\tif ( face.materialIndex !== materialIndex ) {\n\t\n\t\t\t\t\tmaterialIndex = face.materialIndex;\n\t\n\t\t\t\t\tif ( group !== undefined ) {\n\t\n\t\t\t\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\t\t\t\tgroups.push( group );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgroup = {\n\t\t\t\t\t\tstart: i * 3,\n\t\t\t\t\t\tmaterialIndex: materialIndex\n\t\t\t\t\t};\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif ( group !== undefined ) {\n\t\n\t\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\t\tgroups.push( group );\n\t\n\t\t\t}\n\t\n\t\t\tthis.groups = groups;\n\t\n\t\t},\n\t\n\t\tfromGeometry: function ( geometry ) {\n\t\n\t\t\tvar faces = geometry.faces;\n\t\t\tvar vertices = geometry.vertices;\n\t\t\tvar faceVertexUvs = geometry.faceVertexUvs;\n\t\n\t\t\tvar hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;\n\t\t\tvar hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;\n\t\n\t\t\t// morphs\n\t\n\t\t\tvar morphTargets = geometry.morphTargets;\n\t\t\tvar morphTargetsLength = morphTargets.length;\n\t\n\t\t\tvar morphTargetsPosition;\n\t\n\t\t\tif ( morphTargetsLength > 0 ) {\n\t\n\t\t\t\tmorphTargetsPosition = [];\n\t\n\t\t\t\tfor ( var i = 0; i < morphTargetsLength; i ++ ) {\n\t\n\t\t\t\t\tmorphTargetsPosition[ i ] = [];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.morphTargets.position = morphTargetsPosition;\n\t\n\t\t\t}\n\t\n\t\t\tvar morphNormals = geometry.morphNormals;\n\t\t\tvar morphNormalsLength = morphNormals.length;\n\t\n\t\t\tvar morphTargetsNormal;\n\t\n\t\t\tif ( morphNormalsLength > 0 ) {\n\t\n\t\t\t\tmorphTargetsNormal = [];\n\t\n\t\t\t\tfor ( var i = 0; i < morphNormalsLength; i ++ ) {\n\t\n\t\t\t\t\tmorphTargetsNormal[ i ] = [];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.morphTargets.normal = morphTargetsNormal;\n\t\n\t\t\t}\n\t\n\t\t\t// skins\n\t\n\t\t\tvar skinIndices = geometry.skinIndices;\n\t\t\tvar skinWeights = geometry.skinWeights;\n\t\n\t\t\tvar hasSkinIndices = skinIndices.length === vertices.length;\n\t\t\tvar hasSkinWeights = skinWeights.length === vertices.length;\n\t\n\t\t\t//\n\t\n\t\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\t\n\t\t\t\tvar face = faces[ i ];\n\t\n\t\t\t\tthis.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );\n\t\n\t\t\t\tvar vertexNormals = face.vertexNormals;\n\t\n\t\t\t\tif ( vertexNormals.length === 3 ) {\n\t\n\t\t\t\t\tthis.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tvar normal = face.normal;\n\t\n\t\t\t\t\tthis.normals.push( normal, normal, normal );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar vertexColors = face.vertexColors;\n\t\n\t\t\t\tif ( vertexColors.length === 3 ) {\n\t\n\t\t\t\t\tthis.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tvar color = face.color;\n\t\n\t\t\t\t\tthis.colors.push( color, color, color );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( hasFaceVertexUv === true ) {\n\t\n\t\t\t\t\tvar vertexUvs = faceVertexUvs[ 0 ][ i ];\n\t\n\t\t\t\t\tif ( vertexUvs !== undefined ) {\n\t\n\t\t\t\t\t\tthis.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );\n\t\n\t\t\t\t\t\tthis.uvs.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( hasFaceVertexUv2 === true ) {\n\t\n\t\t\t\t\tvar vertexUvs = faceVertexUvs[ 1 ][ i ];\n\t\n\t\t\t\t\tif ( vertexUvs !== undefined ) {\n\t\n\t\t\t\t\t\tthis.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );\n\t\n\t\t\t\t\t\tthis.uvs2.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// morphs\n\t\n\t\t\t\tfor ( var j = 0; j < morphTargetsLength; j ++ ) {\n\t\n\t\t\t\t\tvar morphTarget = morphTargets[ j ].vertices;\n\t\n\t\t\t\t\tmorphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var j = 0; j < morphNormalsLength; j ++ ) {\n\t\n\t\t\t\t\tvar morphNormal = morphNormals[ j ].vertexNormals[ i ];\n\t\n\t\t\t\t\tmorphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// skins\n\t\n\t\t\t\tif ( hasSkinIndices ) {\n\t\n\t\t\t\t\tthis.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( hasSkinWeights ) {\n\t\n\t\t\t\t\tthis.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tthis.computeGroups( geometry );\n\t\n\t\t\tthis.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\t\tthis.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\t\tthis.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\t\tthis.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\t\tthis.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tdispose: function () {\n\t\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/core/BufferGeometry.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.BufferGeometry = function () {\n\t\n\t\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\n\t\n\t\tthis.uuid = THREE.Math.generateUUID();\n\t\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\t\n\t\tthis.index = null;\n\t\tthis.attributes = {};\n\t\n\t\tthis.morphAttributes = {};\n\t\n\t\tthis.groups = [];\n\t\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\t\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\t\n\t};\n\t\n\tObject.assign( THREE.BufferGeometry.prototype, THREE.EventDispatcher.prototype, {\n\t\n\t\tgetIndex: function () {\n\t\n\t\t\treturn this.index;\n\t\n\t\t},\n\t\n\t\tsetIndex: function ( index ) {\n\t\n\t\t\tthis.index = index;\n\t\n\t\t},\n\t\n\t\taddAttribute: function ( name, attribute ) {\n\t\n\t\t\tif ( attribute instanceof THREE.BufferAttribute === false && attribute instanceof THREE.InterleavedBufferAttribute === false ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );\n\t\n\t\t\t\tthis.addAttribute( name, new THREE.BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );\n\t\n\t\t\t\treturn;\n\t\n\t\t\t}\n\t\n\t\t\tif ( name === 'index' ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );\n\t\t\t\tthis.setIndex( attribute );\n\t\n\t\t\t\treturn;\n\t\n\t\t\t}\n\t\n\t\t\tthis.attributes[ name ] = attribute;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tgetAttribute: function ( name ) {\n\t\n\t\t\treturn this.attributes[ name ];\n\t\n\t\t},\n\t\n\t\tremoveAttribute: function ( name ) {\n\t\n\t\t\tdelete this.attributes[ name ];\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\taddGroup: function ( start, count, materialIndex ) {\n\t\n\t\t\tthis.groups.push( {\n\t\n\t\t\t\tstart: start,\n\t\t\t\tcount: count,\n\t\t\t\tmaterialIndex: materialIndex !== undefined ? materialIndex : 0\n\t\n\t\t\t} );\n\t\n\t\t},\n\t\n\t\tclearGroups: function () {\n\t\n\t\t\tthis.groups = [];\n\t\n\t\t},\n\t\n\t\tsetDrawRange: function ( start, count ) {\n\t\n\t\t\tthis.drawRange.start = start;\n\t\t\tthis.drawRange.count = count;\n\t\n\t\t},\n\t\n\t\tapplyMatrix: function ( matrix ) {\n\t\n\t\t\tvar position = this.attributes.position;\n\t\n\t\t\tif ( position !== undefined ) {\n\t\n\t\t\t\tmatrix.applyToVector3Array( position.array );\n\t\t\t\tposition.needsUpdate = true;\n\t\n\t\t\t}\n\t\n\t\t\tvar normal = this.attributes.normal;\n\t\n\t\t\tif ( normal !== undefined ) {\n\t\n\t\t\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\n\t\n\t\t\t\tnormalMatrix.applyToVector3Array( normal.array );\n\t\t\t\tnormal.needsUpdate = true;\n\t\n\t\t\t}\n\t\n\t\t\tif ( this.boundingBox !== null ) {\n\t\n\t\t\t\tthis.computeBoundingBox();\n\t\n\t\t\t}\n\t\n\t\t\tif ( this.boundingSphere !== null ) {\n\t\n\t\t\t\tthis.computeBoundingSphere();\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\trotateX: function () {\n\t\n\t\t\t// rotate geometry around world x-axis\n\t\n\t\t\tvar m1;\n\t\n\t\t\treturn function rotateX( angle ) {\n\t\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\t\n\t\t\t\tm1.makeRotationX( angle );\n\t\n\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\trotateY: function () {\n\t\n\t\t\t// rotate geometry around world y-axis\n\t\n\t\t\tvar m1;\n\t\n\t\t\treturn function rotateY( angle ) {\n\t\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\t\n\t\t\t\tm1.makeRotationY( angle );\n\t\n\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\trotateZ: function () {\n\t\n\t\t\t// rotate geometry around world z-axis\n\t\n\t\t\tvar m1;\n\t\n\t\t\treturn function rotateZ( angle ) {\n\t\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\t\n\t\t\t\tm1.makeRotationZ( angle );\n\t\n\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\ttranslate: function () {\n\t\n\t\t\t// translate geometry\n\t\n\t\t\tvar m1;\n\t\n\t\t\treturn function translate( x, y, z ) {\n\t\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\t\n\t\t\t\tm1.makeTranslation( x, y, z );\n\t\n\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tscale: function () {\n\t\n\t\t\t// scale geometry\n\t\n\t\t\tvar m1;\n\t\n\t\t\treturn function scale( x, y, z ) {\n\t\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\t\n\t\t\t\tm1.makeScale( x, y, z );\n\t\n\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tlookAt: function () {\n\t\n\t\t\tvar obj;\n\t\n\t\t\treturn function lookAt( vector ) {\n\t\n\t\t\t\tif ( obj === undefined ) obj = new THREE.Object3D();\n\t\n\t\t\t\tobj.lookAt( vector );\n\t\n\t\t\t\tobj.updateMatrix();\n\t\n\t\t\t\tthis.applyMatrix( obj.matrix );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tcenter: function () {\n\t\n\t\t\tthis.computeBoundingBox();\n\t\n\t\t\tvar offset = this.boundingBox.center().negate();\n\t\n\t\t\tthis.translate( offset.x, offset.y, offset.z );\n\t\n\t\t\treturn offset;\n\t\n\t\t},\n\t\n\t\tsetFromObject: function ( object ) {\n\t\n\t\t\t// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );\n\t\n\t\t\tvar geometry = object.geometry;\n\t\n\t\t\tif ( object instanceof THREE.Points || object instanceof THREE.Line ) {\n\t\n\t\t\t\tvar positions = new THREE.Float32Attribute( geometry.vertices.length * 3, 3 );\n\t\t\t\tvar colors = new THREE.Float32Attribute( geometry.colors.length * 3, 3 );\n\t\n\t\t\t\tthis.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );\n\t\t\t\tthis.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );\n\t\n\t\t\t\tif ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {\n\t\n\t\t\t\t\tvar lineDistances = new THREE.Float32Attribute( geometry.lineDistances.length, 1 );\n\t\n\t\t\t\t\tthis.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.boundingSphere !== null ) {\n\t\n\t\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.boundingBox !== null ) {\n\t\n\t\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\t\n\t\t\t\t}\n\t\n\t\t\t} else if ( object instanceof THREE.Mesh ) {\n\t\n\t\t\t\tif ( geometry instanceof THREE.Geometry ) {\n\t\n\t\t\t\t\tthis.fromGeometry( geometry );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tupdateFromObject: function ( object ) {\n\t\n\t\t\tvar geometry = object.geometry;\n\t\n\t\t\tif ( object instanceof THREE.Mesh ) {\n\t\n\t\t\t\tvar direct = geometry.__directGeometry;\n\t\n\t\t\t\tif ( direct === undefined ) {\n\t\n\t\t\t\t\treturn this.fromGeometry( geometry );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tdirect.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\t\t\tdirect.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\t\t\tdirect.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\t\t\tdirect.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\t\t\tdirect.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\t\n\t\t\t\tgeometry.verticesNeedUpdate = false;\n\t\t\t\tgeometry.normalsNeedUpdate = false;\n\t\t\t\tgeometry.colorsNeedUpdate = false;\n\t\t\t\tgeometry.uvsNeedUpdate = false;\n\t\t\t\tgeometry.groupsNeedUpdate = false;\n\t\n\t\t\t\tgeometry = direct;\n\t\n\t\t\t}\n\t\n\t\t\tif ( geometry.verticesNeedUpdate === true ) {\n\t\n\t\t\t\tvar attribute = this.attributes.position;\n\t\n\t\t\t\tif ( attribute !== undefined ) {\n\t\n\t\t\t\t\tattribute.copyVector3sArray( geometry.vertices );\n\t\t\t\t\tattribute.needsUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tgeometry.verticesNeedUpdate = false;\n\t\n\t\t\t}\n\t\n\t\t\tif ( geometry.normalsNeedUpdate === true ) {\n\t\n\t\t\t\tvar attribute = this.attributes.normal;\n\t\n\t\t\t\tif ( attribute !== undefined ) {\n\t\n\t\t\t\t\tattribute.copyVector3sArray( geometry.normals );\n\t\t\t\t\tattribute.needsUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tgeometry.normalsNeedUpdate = false;\n\t\n\t\t\t}\n\t\n\t\t\tif ( geometry.colorsNeedUpdate === true ) {\n\t\n\t\t\t\tvar attribute = this.attributes.color;\n\t\n\t\t\t\tif ( attribute !== undefined ) {\n\t\n\t\t\t\t\tattribute.copyColorsArray( geometry.colors );\n\t\t\t\t\tattribute.needsUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tgeometry.colorsNeedUpdate = false;\n\t\n\t\t\t}\n\t\n\t\t\tif ( geometry.uvsNeedUpdate ) {\n\t\n\t\t\t\tvar attribute = this.attributes.uv;\n\t\n\t\t\t\tif ( attribute !== undefined ) {\n\t\n\t\t\t\t\tattribute.copyVector2sArray( geometry.uvs );\n\t\t\t\t\tattribute.needsUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tgeometry.uvsNeedUpdate = false;\n\t\n\t\t\t}\n\t\n\t\t\tif ( geometry.lineDistancesNeedUpdate ) {\n\t\n\t\t\t\tvar attribute = this.attributes.lineDistance;\n\t\n\t\t\t\tif ( attribute !== undefined ) {\n\t\n\t\t\t\t\tattribute.copyArray( geometry.lineDistances );\n\t\t\t\t\tattribute.needsUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tgeometry.lineDistancesNeedUpdate = false;\n\t\n\t\t\t}\n\t\n\t\t\tif ( geometry.groupsNeedUpdate ) {\n\t\n\t\t\t\tgeometry.computeGroups( object.geometry );\n\t\t\t\tthis.groups = geometry.groups;\n\t\n\t\t\t\tgeometry.groupsNeedUpdate = false;\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tfromGeometry: function ( geometry ) {\n\t\n\t\t\tgeometry.__directGeometry = new THREE.DirectGeometry().fromGeometry( geometry );\n\t\n\t\t\treturn this.fromDirectGeometry( geometry.__directGeometry );\n\t\n\t\t},\n\t\n\t\tfromDirectGeometry: function ( geometry ) {\n\t\n\t\t\tvar positions = new Float32Array( geometry.vertices.length * 3 );\n\t\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\n\t\n\t\t\tif ( geometry.normals.length > 0 ) {\n\t\n\t\t\t\tvar normals = new Float32Array( geometry.normals.length * 3 );\n\t\t\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\n\t\n\t\t\t}\n\t\n\t\t\tif ( geometry.colors.length > 0 ) {\n\t\n\t\t\t\tvar colors = new Float32Array( geometry.colors.length * 3 );\n\t\t\t\tthis.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\n\t\n\t\t\t}\n\t\n\t\t\tif ( geometry.uvs.length > 0 ) {\n\t\n\t\t\t\tvar uvs = new Float32Array( geometry.uvs.length * 2 );\n\t\t\t\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\n\t\n\t\t\t}\n\t\n\t\t\tif ( geometry.uvs2.length > 0 ) {\n\t\n\t\t\t\tvar uvs2 = new Float32Array( geometry.uvs2.length * 2 );\n\t\t\t\tthis.addAttribute( 'uv2', new THREE.BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\n\t\n\t\t\t}\n\t\n\t\t\tif ( geometry.indices.length > 0 ) {\n\t\n\t\t\t\tvar TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;\n\t\t\t\tvar indices = new TypeArray( geometry.indices.length * 3 );\n\t\t\t\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );\n\t\n\t\t\t}\n\t\n\t\t\t// groups\n\t\n\t\t\tthis.groups = geometry.groups;\n\t\n\t\t\t// morphs\n\t\n\t\t\tfor ( var name in geometry.morphTargets ) {\n\t\n\t\t\t\tvar array = [];\n\t\t\t\tvar morphTargets = geometry.morphTargets[ name ];\n\t\n\t\t\t\tfor ( var i = 0, l = morphTargets.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar morphTarget = morphTargets[ i ];\n\t\n\t\t\t\t\tvar attribute = new THREE.Float32Attribute( morphTarget.length * 3, 3 );\n\t\n\t\t\t\t\tarray.push( attribute.copyVector3sArray( morphTarget ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.morphAttributes[ name ] = array;\n\t\n\t\t\t}\n\t\n\t\t\t// skinning\n\t\n\t\t\tif ( geometry.skinIndices.length > 0 ) {\n\t\n\t\t\t\tvar skinIndices = new THREE.Float32Attribute( geometry.skinIndices.length * 4, 4 );\n\t\t\t\tthis.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );\n\t\n\t\t\t}\n\t\n\t\t\tif ( geometry.skinWeights.length > 0 ) {\n\t\n\t\t\t\tvar skinWeights = new THREE.Float32Attribute( geometry.skinWeights.length * 4, 4 );\n\t\t\t\tthis.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tif ( geometry.boundingSphere !== null ) {\n\t\n\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\t\n\t\t\t}\n\t\n\t\t\tif ( geometry.boundingBox !== null ) {\n\t\n\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tcomputeBoundingBox: function () {\n\t\n\t\t\tif ( this.boundingBox === null ) {\n\t\n\t\t\t\tthis.boundingBox = new THREE.Box3();\n\t\n\t\t\t}\n\t\n\t\t\tvar positions = this.attributes.position.array;\n\t\n\t\t\tif ( positions !== undefined ) {\n\t\n\t\t\t\tthis.boundingBox.setFromArray( positions );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.boundingBox.makeEmpty();\n\t\n\t\t\t}\n\t\n\t\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\t\n\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tcomputeBoundingSphere: function () {\n\t\n\t\t\tvar box = new THREE.Box3();\n\t\t\tvar vector = new THREE.Vector3();\n\t\n\t\t\treturn function computeBoundingSphere() {\n\t\n\t\t\t\tif ( this.boundingSphere === null ) {\n\t\n\t\t\t\t\tthis.boundingSphere = new THREE.Sphere();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar positions = this.attributes.position;\n\t\n\t\t\t\tif ( positions ) {\n\t\n\t\t\t\t\tvar array = positions.array;\n\t\t\t\t\tvar center = this.boundingSphere.center;\n\t\n\t\t\t\t\tbox.setFromArray( array );\n\t\t\t\t\tbox.center( center );\n\t\n\t\t\t\t\t// hoping to find a boundingSphere with a radius smaller than the\n\t\t\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\t\n\t\t\t\t\tvar maxRadiusSq = 0;\n\t\n\t\t\t\t\tfor ( var i = 0, il = array.length; i < il; i += 3 ) {\n\t\n\t\t\t\t\t\tvector.fromArray( array, i );\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\t\n\t\t\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\t\n\t\t\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tcomputeFaceNormals: function () {\n\t\n\t\t\t// backwards compatibility\n\t\n\t\t},\n\t\n\t\tcomputeVertexNormals: function () {\n\t\n\t\t\tvar index = this.index;\n\t\t\tvar attributes = this.attributes;\n\t\t\tvar groups = this.groups;\n\t\n\t\t\tif ( attributes.position ) {\n\t\n\t\t\t\tvar positions = attributes.position.array;\n\t\n\t\t\t\tif ( attributes.normal === undefined ) {\n\t\n\t\t\t\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// reset existing normals to zero\n\t\n\t\t\t\t\tvar array = attributes.normal.array;\n\t\n\t\t\t\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\tarray[ i ] = 0;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar normals = attributes.normal.array;\n\t\n\t\t\t\tvar vA, vB, vC,\n\t\n\t\t\t\tpA = new THREE.Vector3(),\n\t\t\t\tpB = new THREE.Vector3(),\n\t\t\t\tpC = new THREE.Vector3(),\n\t\n\t\t\t\tcb = new THREE.Vector3(),\n\t\t\t\tab = new THREE.Vector3();\n\t\n\t\t\t\t// indexed elements\n\t\n\t\t\t\tif ( index ) {\n\t\n\t\t\t\t\tvar indices = index.array;\n\t\n\t\t\t\t\tif ( groups.length === 0 ) {\n\t\n\t\t\t\t\t\tthis.addGroup( 0, indices.length );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( var j = 0, jl = groups.length; j < jl; ++ j ) {\n\t\n\t\t\t\t\t\tvar group = groups[ j ];\n\t\n\t\t\t\t\t\tvar start = group.start;\n\t\t\t\t\t\tvar count = group.count;\n\t\n\t\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\n\t\n\t\t\t\t\t\t\tvA = indices[ i + 0 ] * 3;\n\t\t\t\t\t\t\tvB = indices[ i + 1 ] * 3;\n\t\t\t\t\t\t\tvC = indices[ i + 2 ] * 3;\n\t\n\t\t\t\t\t\t\tpA.fromArray( positions, vA );\n\t\t\t\t\t\t\tpB.fromArray( positions, vB );\n\t\t\t\t\t\t\tpC.fromArray( positions, vC );\n\t\n\t\t\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\t\t\tcb.cross( ab );\n\t\n\t\t\t\t\t\t\tnormals[ vA ] += cb.x;\n\t\t\t\t\t\t\tnormals[ vA + 1 ] += cb.y;\n\t\t\t\t\t\t\tnormals[ vA + 2 ] += cb.z;\n\t\n\t\t\t\t\t\t\tnormals[ vB ] += cb.x;\n\t\t\t\t\t\t\tnormals[ vB + 1 ] += cb.y;\n\t\t\t\t\t\t\tnormals[ vB + 2 ] += cb.z;\n\t\n\t\t\t\t\t\t\tnormals[ vC ] += cb.x;\n\t\t\t\t\t\t\tnormals[ vC + 1 ] += cb.y;\n\t\t\t\t\t\t\tnormals[ vC + 2 ] += cb.z;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\t\n\t\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 9 ) {\n\t\n\t\t\t\t\t\tpA.fromArray( positions, i );\n\t\t\t\t\t\tpB.fromArray( positions, i + 3 );\n\t\t\t\t\t\tpC.fromArray( positions, i + 6 );\n\t\n\t\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\t\tcb.cross( ab );\n\t\n\t\t\t\t\t\tnormals[ i ] = cb.x;\n\t\t\t\t\t\tnormals[ i + 1 ] = cb.y;\n\t\t\t\t\t\tnormals[ i + 2 ] = cb.z;\n\t\n\t\t\t\t\t\tnormals[ i + 3 ] = cb.x;\n\t\t\t\t\t\tnormals[ i + 4 ] = cb.y;\n\t\t\t\t\t\tnormals[ i + 5 ] = cb.z;\n\t\n\t\t\t\t\t\tnormals[ i + 6 ] = cb.x;\n\t\t\t\t\t\tnormals[ i + 7 ] = cb.y;\n\t\t\t\t\t\tnormals[ i + 8 ] = cb.z;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.normalizeNormals();\n\t\n\t\t\t\tattributes.normal.needsUpdate = true;\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tmerge: function ( geometry, offset ) {\n\t\n\t\t\tif ( geometry instanceof THREE.BufferGeometry === false ) {\n\t\n\t\t\t\tconsole.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\n\t\t\t\treturn;\n\t\n\t\t\t}\n\t\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\tvar attributes = this.attributes;\n\t\n\t\t\tfor ( var key in attributes ) {\n\t\n\t\t\t\tif ( geometry.attributes[ key ] === undefined ) continue;\n\t\n\t\t\t\tvar attribute1 = attributes[ key ];\n\t\t\t\tvar attributeArray1 = attribute1.array;\n\t\n\t\t\t\tvar attribute2 = geometry.attributes[ key ];\n\t\t\t\tvar attributeArray2 = attribute2.array;\n\t\n\t\t\t\tvar attributeSize = attribute2.itemSize;\n\t\n\t\t\t\tfor ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {\n\t\n\t\t\t\t\tattributeArray1[ j ] = attributeArray2[ i ];\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tnormalizeNormals: function () {\n\t\n\t\t\tvar normals = this.attributes.normal.array;\n\t\n\t\t\tvar x, y, z, n;\n\t\n\t\t\tfor ( var i = 0, il = normals.length; i < il; i += 3 ) {\n\t\n\t\t\t\tx = normals[ i ];\n\t\t\t\ty = normals[ i + 1 ];\n\t\t\t\tz = normals[ i + 2 ];\n\t\n\t\t\t\tn = 1.0 / Math.sqrt( x * x + y * y + z * z );\n\t\n\t\t\t\tnormals[ i ] *= n;\n\t\t\t\tnormals[ i + 1 ] *= n;\n\t\t\t\tnormals[ i + 2 ] *= n;\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\ttoNonIndexed: function () {\n\t\n\t\t\tif ( this.index === null ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t\tvar geometry2 = new THREE.BufferGeometry();\n\t\n\t\t\tvar indices = this.index.array;\n\t\t\tvar attributes = this.attributes;\n\t\n\t\t\tfor ( var name in attributes ) {\n\t\n\t\t\t\tvar attribute = attributes[ name ];\n\t\n\t\t\t\tvar array = attribute.array;\n\t\t\t\tvar itemSize = attribute.itemSize;\n\t\n\t\t\t\tvar array2 = new array.constructor( indices.length * itemSize );\n\t\n\t\t\t\tvar index = 0, index2 = 0;\n\t\n\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tindex = indices[ i ] * itemSize;\n\t\n\t\t\t\t\tfor ( var j = 0; j < itemSize; j ++ ) {\n\t\n\t\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tgeometry2.addAttribute( name, new THREE.BufferAttribute( array2, itemSize ) );\n\t\n\t\t\t}\n\t\n\t\t\treturn geometry2;\n\t\n\t\t},\n\t\n\t\ttoJSON: function () {\n\t\n\t\t\tvar data = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.4,\n\t\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\t// standard BufferGeometry serialization\n\t\n\t\t\tdata.uuid = this.uuid;\n\t\t\tdata.type = this.type;\n\t\t\tif ( this.name !== '' ) data.name = this.name;\n\t\n\t\t\tif ( this.parameters !== undefined ) {\n\t\n\t\t\t\tvar parameters = this.parameters;\n\t\n\t\t\t\tfor ( var key in parameters ) {\n\t\n\t\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn data;\n\t\n\t\t\t}\n\t\n\t\t\tdata.data = { attributes: {} };\n\t\n\t\t\tvar index = this.index;\n\t\n\t\t\tif ( index !== null ) {\n\t\n\t\t\t\tvar array = Array.prototype.slice.call( index.array );\n\t\n\t\t\t\tdata.data.index = {\n\t\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\t\tarray: array\n\t\t\t\t};\n\t\n\t\t\t}\n\t\n\t\t\tvar attributes = this.attributes;\n\t\n\t\t\tfor ( var key in attributes ) {\n\t\n\t\t\t\tvar attribute = attributes[ key ];\n\t\n\t\t\t\tvar array = Array.prototype.slice.call( attribute.array );\n\t\n\t\t\t\tdata.data.attributes[ key ] = {\n\t\t\t\t\titemSize: attribute.itemSize,\n\t\t\t\t\ttype: attribute.array.constructor.name,\n\t\t\t\t\tarray: array,\n\t\t\t\t\tnormalized: attribute.normalized\n\t\t\t\t};\n\t\n\t\t\t}\n\t\n\t\t\tvar groups = this.groups;\n\t\n\t\t\tif ( groups.length > 0 ) {\n\t\n\t\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\n\t\n\t\t\t}\n\t\n\t\t\tvar boundingSphere = this.boundingSphere;\n\t\n\t\t\tif ( boundingSphere !== null ) {\n\t\n\t\t\t\tdata.data.boundingSphere = {\n\t\t\t\t\tcenter: boundingSphere.center.toArray(),\n\t\t\t\t\tradius: boundingSphere.radius\n\t\t\t\t};\n\t\n\t\t\t}\n\t\n\t\t\treturn data;\n\t\n\t\t},\n\t\n\t\tclone: function () {\n\t\n\t\t\t/*\n\t\t\t// Handle primitives\n\t\n\t\t\tvar parameters = this.parameters;\n\t\n\t\t\tif ( parameters !== undefined ) {\n\t\n\t\t\t\tvar values = [];\n\t\n\t\t\t\tfor ( var key in parameters ) {\n\t\n\t\t\t\t\tvalues.push( parameters[ key ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar geometry = Object.create( this.constructor.prototype );\n\t\t\t\tthis.constructor.apply( geometry, values );\n\t\t\t\treturn geometry;\n\t\n\t\t\t}\n\t\n\t\t\treturn new this.constructor().copy( this );\n\t\t\t*/\n\t\n\t\t\treturn new THREE.BufferGeometry().copy( this );\n\t\n\t\t},\n\t\n\t\tcopy: function ( source ) {\n\t\n\t\t\tvar index = source.index;\n\t\n\t\t\tif ( index !== null ) {\n\t\n\t\t\t\tthis.setIndex( index.clone() );\n\t\n\t\t\t}\n\t\n\t\t\tvar attributes = source.attributes;\n\t\n\t\t\tfor ( var name in attributes ) {\n\t\n\t\t\t\tvar attribute = attributes[ name ];\n\t\t\t\tthis.addAttribute( name, attribute.clone() );\n\t\n\t\t\t}\n\t\n\t\t\tvar groups = source.groups;\n\t\n\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar group = groups[ i ];\n\t\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tdispose: function () {\n\t\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\t\n\t\t}\n\t\n\t} );\n\t\n\tTHREE.BufferGeometry.MaxIndex = 65535;\n\t\n\t// File:src/core/InstancedBufferGeometry.js\n\t\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\t\n\tTHREE.InstancedBufferGeometry = function () {\n\t\n\t\tTHREE.BufferGeometry.call( this );\n\t\n\t\tthis.type = 'InstancedBufferGeometry';\n\t\tthis.maxInstancedCount = undefined;\n\t\n\t};\n\t\n\tTHREE.InstancedBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\n\tTHREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry;\n\t\n\tTHREE.InstancedBufferGeometry.prototype.addGroup = function ( start, count, instances ) {\n\t\n\t\tthis.groups.push( {\n\t\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tinstances: instances\n\t\n\t\t} );\n\t\n\t};\n\t\n\tTHREE.InstancedBufferGeometry.prototype.copy = function ( source ) {\n\t\n\t\tvar index = source.index;\n\t\n\t\tif ( index !== null ) {\n\t\n\t\t\tthis.setIndex( index.clone() );\n\t\n\t\t}\n\t\n\t\tvar attributes = source.attributes;\n\t\n\t\tfor ( var name in attributes ) {\n\t\n\t\t\tvar attribute = attributes[ name ];\n\t\t\tthis.addAttribute( name, attribute.clone() );\n\t\n\t\t}\n\t\n\t\tvar groups = source.groups;\n\t\n\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\t\n\t\t\tvar group = groups[ i ];\n\t\t\tthis.addGroup( group.start, group.count, group.instances );\n\t\n\t\t}\n\t\n\t\treturn this;\n\t\n\t};\n\t\n\t// File:src/core/Uniform.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.Uniform = function ( value ) {\n\t\n\t\tif ( typeof value === 'string' ) {\n\t\n\t\t\tconsole.warn( 'THREE.Uniform: Type parameter is no longer needed.' );\n\t\t\tvalue = arguments[ 1 ];\n\t\n\t\t}\n\t\n\t\tthis.value = value;\n\t\n\t\tthis.dynamic = false;\n\t\n\t};\n\t\n\tTHREE.Uniform.prototype = {\n\t\n\t\tconstructor: THREE.Uniform,\n\t\n\t\tonUpdate: function ( callback ) {\n\t\n\t\t\tthis.dynamic = true;\n\t\t\tthis.onUpdateCallback = callback;\n\t\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/animation/AnimationAction.js\n\t\n\t/**\n\t *\n\t * Action provided by AnimationMixer for scheduling clip playback on specific\n\t * objects.\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t *\n\t */\n\t\n\tTHREE.AnimationAction = function() {\n\t\n\t\tthrow new Error( \"THREE.AnimationAction: \" +\n\t\t\t\t\"Use mixer.clipAction for construction.\" );\n\t\n\t};\n\t\n\tTHREE.AnimationAction._new =\n\t\t\tfunction AnimationAction( mixer, clip, localRoot ) {\n\t\n\t\tthis._mixer = mixer;\n\t\tthis._clip = clip;\n\t\tthis._localRoot = localRoot || null;\n\t\n\t\tvar tracks = clip.tracks,\n\t\t\tnTracks = tracks.length,\n\t\t\tinterpolants = new Array( nTracks );\n\t\n\t\tvar interpolantSettings = {\n\t\t\t\tendingStart: \tTHREE.ZeroCurvatureEnding,\n\t\t\t\tendingEnd:\t\tTHREE.ZeroCurvatureEnding\n\t\t};\n\t\n\t\tfor ( var i = 0; i !== nTracks; ++ i ) {\n\t\n\t\t\tvar interpolant = tracks[ i ].createInterpolant( null );\n\t\t\tinterpolants[ i ] = interpolant;\n\t\t\tinterpolant.settings = interpolantSettings;\n\t\n\t\t}\n\t\n\t\tthis._interpolantSettings = interpolantSettings;\n\t\n\t\tthis._interpolants = interpolants;\t// bound by the mixer\n\t\n\t\t// inside: PropertyMixer (managed by the mixer)\n\t\tthis._propertyBindings = new Array( nTracks );\n\t\n\t\tthis._cacheIndex = null;\t\t\t// for the memory manager\n\t\tthis._byClipCacheIndex = null;\t\t// for the memory manager\n\t\n\t\tthis._timeScaleInterpolant = null;\n\t\tthis._weightInterpolant = null;\n\t\n\t\tthis.loop = THREE.LoopRepeat;\n\t\tthis._loopCount = -1;\n\t\n\t\t// global mixer time when the action is to be started\n\t\t// it's set back to 'null' upon start of the action\n\t\tthis._startTime = null;\n\t\n\t\t// scaled local time of the action\n\t\t// gets clamped or wrapped to 0..clip.duration according to loop\n\t\tthis.time = 0;\n\t\n\t\tthis.timeScale = 1;\n\t\tthis._effectiveTimeScale = 1;\n\t\n\t\tthis.weight = 1;\n\t\tthis._effectiveWeight = 1;\n\t\n\t\tthis.repetitions = Infinity; \t\t// no. of repetitions when looping\n\t\n\t\tthis.paused = false;\t\t\t\t// false -> zero effective time scale\n\t\tthis.enabled = true;\t\t\t\t// true -> zero effective weight\n\t\n\t\tthis.clampWhenFinished \t= false;\t// keep feeding the last frame?\n\t\n\t\tthis.zeroSlopeAtStart \t= true;\t\t// for smooth interpolation w/o separate\n\t\tthis.zeroSlopeAtEnd\t\t= true;\t\t// clips for start, loop and end\n\t\n\t};\n\t\n\tTHREE.AnimationAction._new.prototype = {\n\t\n\t\tconstructor: THREE.AnimationAction._new,\n\t\n\t\t// State & Scheduling\n\t\n\t\tplay: function() {\n\t\n\t\t\tthis._mixer._activateAction( this );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tstop: function() {\n\t\n\t\t\tthis._mixer._deactivateAction( this );\n\t\n\t\t\treturn this.reset();\n\t\n\t\t},\n\t\n\t\treset: function() {\n\t\n\t\t\tthis.paused = false;\n\t\t\tthis.enabled = true;\n\t\n\t\t\tthis.time = 0;\t\t\t// restart clip\n\t\t\tthis._loopCount = -1;\t// forget previous loops\n\t\t\tthis._startTime = null;\t// forget scheduling\n\t\n\t\t\treturn this.stopFading().stopWarping();\n\t\n\t\t},\n\t\n\t\tisRunning: function() {\n\t\n\t\t\tvar start = this._startTime;\n\t\n\t\t\treturn this.enabled && ! this.paused && this.timeScale !== 0 &&\n\t\t\t\t\tthis._startTime === null && this._mixer._isActiveAction( this );\n\t\n\t\t},\n\t\n\t\t// return true when play has been called\n\t\tisScheduled: function() {\n\t\n\t\t\treturn this._mixer._isActiveAction( this );\n\t\n\t\t},\n\t\n\t\tstartAt: function( time ) {\n\t\n\t\t\tthis._startTime = time;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetLoop: function( mode, repetitions ) {\n\t\n\t\t\tthis.loop = mode;\n\t\t\tthis.repetitions = repetitions;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\t// Weight\n\t\n\t\t// set the weight stopping any scheduled fading\n\t\t// although .enabled = false yields an effective weight of zero, this\n\t\t// method does *not* change .enabled, because it would be confusing\n\t\tsetEffectiveWeight: function( weight ) {\n\t\n\t\t\tthis.weight = weight;\n\t\n\t\t\t// note: same logic as when updated at runtime\n\t\t\tthis._effectiveWeight = this.enabled ? weight : 0;\n\t\n\t\t\treturn this.stopFading();\n\t\n\t\t},\n\t\n\t\t// return the weight considering fading and .enabled\n\t\tgetEffectiveWeight: function() {\n\t\n\t\t\treturn this._effectiveWeight;\n\t\n\t\t},\n\t\n\t\tfadeIn: function( duration ) {\n\t\n\t\t\treturn this._scheduleFading( duration, 0, 1 );\n\t\n\t\t},\n\t\n\t\tfadeOut: function( duration ) {\n\t\n\t\t\treturn this._scheduleFading( duration, 1, 0 );\n\t\n\t\t},\n\t\n\t\tcrossFadeFrom: function( fadeOutAction, duration, warp ) {\n\t\n\t\t\tvar mixer = this._mixer;\n\t\n\t\t\tfadeOutAction.fadeOut( duration );\n\t\t\tthis.fadeIn( duration );\n\t\n\t\t\tif( warp ) {\n\t\n\t\t\t\tvar fadeInDuration = this._clip.duration,\n\t\t\t\t\tfadeOutDuration = fadeOutAction._clip.duration,\n\t\n\t\t\t\t\tstartEndRatio = fadeOutDuration / fadeInDuration,\n\t\t\t\t\tendStartRatio = fadeInDuration / fadeOutDuration;\n\t\n\t\t\t\tfadeOutAction.warp( 1.0, startEndRatio, duration );\n\t\t\t\tthis.warp( endStartRatio, 1.0, duration );\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tcrossFadeTo: function( fadeInAction, duration, warp ) {\n\t\n\t\t\treturn fadeInAction.crossFadeFrom( this, duration, warp );\n\t\n\t\t},\n\t\n\t\tstopFading: function() {\n\t\n\t\t\tvar weightInterpolant = this._weightInterpolant;\n\t\n\t\t\tif ( weightInterpolant !== null ) {\n\t\n\t\t\t\tthis._weightInterpolant = null;\n\t\t\t\tthis._mixer._takeBackControlInterpolant( weightInterpolant );\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\t// Time Scale Control\n\t\n\t\t// set the weight stopping any scheduled warping\n\t\t// although .paused = true yields an effective time scale of zero, this\n\t\t// method does *not* change .paused, because it would be confusing\n\t\tsetEffectiveTimeScale: function( timeScale ) {\n\t\n\t\t\tthis.timeScale = timeScale;\n\t\t\tthis._effectiveTimeScale = this.paused ? 0 :timeScale;\n\t\n\t\t\treturn this.stopWarping();\n\t\n\t\t},\n\t\n\t\t// return the time scale considering warping and .paused\n\t\tgetEffectiveTimeScale: function() {\n\t\n\t\t\treturn this._effectiveTimeScale;\n\t\n\t\t},\n\t\n\t\tsetDuration: function( duration ) {\n\t\n\t\t\tthis.timeScale = this._clip.duration / duration;\n\t\n\t\t\treturn this.stopWarping();\n\t\n\t\t},\n\t\n\t\tsyncWith: function( action ) {\n\t\n\t\t\tthis.time = action.time;\n\t\t\tthis.timeScale = action.timeScale;\n\t\n\t\t\treturn this.stopWarping();\n\t\n\t\t},\n\t\n\t\thalt: function( duration ) {\n\t\n\t\t\treturn this.warp( this._effectiveTimeScale, 0, duration );\n\t\n\t\t},\n\t\n\t\twarp: function( startTimeScale, endTimeScale, duration ) {\n\t\n\t\t\tvar mixer = this._mixer, now = mixer.time,\n\t\t\t\tinterpolant = this._timeScaleInterpolant,\n\t\n\t\t\t\ttimeScale = this.timeScale;\n\t\n\t\t\tif ( interpolant === null ) {\n\t\n\t\t\t\tinterpolant = mixer._lendControlInterpolant(),\n\t\t\t\tthis._timeScaleInterpolant = interpolant;\n\t\n\t\t\t}\n\t\n\t\t\tvar times = interpolant.parameterPositions,\n\t\t\t\tvalues = interpolant.sampleValues;\n\t\n\t\t\ttimes[ 0 ] = now;\n\t\t\ttimes[ 1 ] = now + duration;\n\t\n\t\t\tvalues[ 0 ] = startTimeScale / timeScale;\n\t\t\tvalues[ 1 ] = endTimeScale / timeScale;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tstopWarping: function() {\n\t\n\t\t\tvar timeScaleInterpolant = this._timeScaleInterpolant;\n\t\n\t\t\tif ( timeScaleInterpolant !== null ) {\n\t\n\t\t\t\tthis._timeScaleInterpolant = null;\n\t\t\t\tthis._mixer._takeBackControlInterpolant( timeScaleInterpolant );\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\t// Object Accessors\n\t\n\t\tgetMixer: function() {\n\t\n\t\t\treturn this._mixer;\n\t\n\t\t},\n\t\n\t\tgetClip: function() {\n\t\n\t\t\treturn this._clip;\n\t\n\t\t},\n\t\n\t\tgetRoot: function() {\n\t\n\t\t\treturn this._localRoot || this._mixer._root;\n\t\n\t\t},\n\t\n\t\t// Interna\n\t\n\t\t_update: function( time, deltaTime, timeDirection, accuIndex ) {\n\t\t\t// called by the mixer\n\t\n\t\t\tvar startTime = this._startTime;\n\t\n\t\t\tif ( startTime !== null ) {\n\t\n\t\t\t\t// check for scheduled start of action\n\t\n\t\t\t\tvar timeRunning = ( time - startTime ) * timeDirection;\n\t\t\t\tif ( timeRunning < 0 || timeDirection === 0 ) {\n\t\n\t\t\t\t\treturn; // yet to come / don't decide when delta = 0\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// start\n\t\n\t\t\t\tthis._startTime = null; // unschedule\n\t\t\t\tdeltaTime = timeDirection * timeRunning;\n\t\n\t\t\t}\n\t\n\t\t\t// apply time scale and advance time\n\t\n\t\t\tdeltaTime *= this._updateTimeScale( time );\n\t\t\tvar clipTime = this._updateTime( deltaTime );\n\t\n\t\t\t// note: _updateTime may disable the action resulting in\n\t\t\t// an effective weight of 0\n\t\n\t\t\tvar weight = this._updateWeight( time );\n\t\n\t\t\tif ( weight > 0 ) {\n\t\n\t\t\t\tvar interpolants = this._interpolants;\n\t\t\t\tvar propertyMixers = this._propertyBindings;\n\t\n\t\t\t\tfor ( var j = 0, m = interpolants.length; j !== m; ++ j ) {\n\t\n\t\t\t\t\tinterpolants[ j ].evaluate( clipTime );\n\t\t\t\t\tpropertyMixers[ j ].accumulate( accuIndex, weight );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\t_updateWeight: function( time ) {\n\t\n\t\t\tvar weight = 0;\n\t\n\t\t\tif ( this.enabled ) {\n\t\n\t\t\t\tweight = this.weight;\n\t\t\t\tvar interpolant = this._weightInterpolant;\n\t\n\t\t\t\tif ( interpolant !== null ) {\n\t\n\t\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\n\t\n\t\t\t\t\tweight *= interpolantValue;\n\t\n\t\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\t\n\t\t\t\t\t\tthis.stopFading();\n\t\n\t\t\t\t\t\tif ( interpolantValue === 0 ) {\n\t\n\t\t\t\t\t\t\t// faded out, disable\n\t\t\t\t\t\t\tthis.enabled = false;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tthis._effectiveWeight = weight;\n\t\t\treturn weight;\n\t\n\t\t},\n\t\n\t\t_updateTimeScale: function( time ) {\n\t\n\t\t\tvar timeScale = 0;\n\t\n\t\t\tif ( ! this.paused ) {\n\t\n\t\t\t\ttimeScale = this.timeScale;\n\t\n\t\t\t\tvar interpolant = this._timeScaleInterpolant;\n\t\n\t\t\t\tif ( interpolant !== null ) {\n\t\n\t\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\n\t\n\t\t\t\t\ttimeScale *= interpolantValue;\n\t\n\t\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\t\n\t\t\t\t\t\tthis.stopWarping();\n\t\n\t\t\t\t\t\tif ( timeScale === 0 ) {\n\t\n\t\t\t\t\t\t\t// motion has halted, pause\n\t\t\t\t\t\t\tthis.paused = true;\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t// warp done - apply final time scale\n\t\t\t\t\t\t\tthis.timeScale = timeScale;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tthis._effectiveTimeScale = timeScale;\n\t\t\treturn timeScale;\n\t\n\t\t},\n\t\n\t\t_updateTime: function( deltaTime ) {\n\t\n\t\t\tvar time = this.time + deltaTime;\n\t\n\t\t\tif ( deltaTime === 0 ) return time;\n\t\n\t\t\tvar duration = this._clip.duration,\n\t\n\t\t\t\tloop = this.loop,\n\t\t\t\tloopCount = this._loopCount;\n\t\n\t\t\tif ( loop === THREE.LoopOnce ) {\n\t\n\t\t\t\tif ( loopCount === -1 ) {\n\t\t\t\t\t// just started\n\t\n\t\t\t\t\tthis.loopCount = 0;\n\t\t\t\t\tthis._setEndings( true, true, false );\n\t\n\t\t\t\t}\n\t\n\t\t\t\thandle_stop: {\n\t\n\t\t\t\t\tif ( time >= duration ) {\n\t\n\t\t\t\t\t\ttime = duration;\n\t\n\t\t\t\t\t} else if ( time < 0 ) {\n\t\n\t\t\t\t\t\ttime = 0;\n\t\n\t\t\t\t\t} else break handle_stop;\n\t\n\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\t\telse this.enabled = false;\n\t\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\t\tdirection: deltaTime < 0 ? -1 : 1\n\t\t\t\t\t} );\n\t\n\t\t\t\t}\n\t\n\t\t\t} else { // repetitive Repeat or PingPong\n\t\n\t\t\t\tvar pingPong = ( loop === THREE.LoopPingPong );\n\t\n\t\t\t\tif ( loopCount === -1 ) {\n\t\t\t\t\t// just started\n\t\n\t\t\t\t\tif ( deltaTime >= 0 ) {\n\t\n\t\t\t\t\t\tloopCount = 0;\n\t\n\t\t\t\t\t\tthis._setEndings(\n\t\t\t\t\t\t\t\ttrue, this.repetitions === 0, pingPong );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// when looping in reverse direction, the initial\n\t\t\t\t\t\t// transition through zero counts as a repetition,\n\t\t\t\t\t\t// so leave loopCount at -1\n\t\n\t\t\t\t\t\tthis._setEndings(\n\t\t\t\t\t\t\t\tthis.repetitions === 0, true, pingPong );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( time >= duration || time < 0 ) {\n\t\t\t\t\t// wrap around\n\t\n\t\t\t\t\tvar loopDelta = Math.floor( time / duration ); // signed\n\t\t\t\t\ttime -= duration * loopDelta;\n\t\n\t\t\t\t\tloopCount += Math.abs( loopDelta );\n\t\n\t\t\t\t\tvar pending = this.repetitions - loopCount;\n\t\n\t\t\t\t\tif ( pending < 0 ) {\n\t\t\t\t\t\t// have to stop (switch state, clamp time, fire event)\n\t\n\t\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\t\t\telse this.enabled = false;\n\t\n\t\t\t\t\t\ttime = deltaTime > 0 ? duration : 0;\n\t\n\t\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\t\t\tdirection: deltaTime > 0 ? 1 : -1\n\t\t\t\t\t\t} );\n\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// keep running\n\t\n\t\t\t\t\t\tif ( pending === 0 ) {\n\t\t\t\t\t\t\t// entering the last round\n\t\n\t\t\t\t\t\t\tvar atStart = deltaTime < 0;\n\t\t\t\t\t\t\tthis._setEndings( atStart, ! atStart, pingPong );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tthis._setEndings( false, false, pingPong );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tthis._loopCount = loopCount;\n\t\n\t\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\t\ttype: 'loop', action: this, loopDelta: loopDelta\n\t\t\t\t\t\t} );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( pingPong && ( loopCount & 1 ) === 1 ) {\n\t\t\t\t\t// invert time for the \"pong round\"\n\t\n\t\t\t\t\tthis.time = time;\n\t\t\t\t\treturn duration - time;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tthis.time = time;\n\t\t\treturn time;\n\t\n\t\t},\n\t\n\t\t_setEndings: function( atStart, atEnd, pingPong ) {\n\t\n\t\t\tvar settings = this._interpolantSettings;\n\t\n\t\t\tif ( pingPong ) {\n\t\n\t\t\t\tsettings.endingStart \t= THREE.ZeroSlopeEnding;\n\t\t\t\tsettings.endingEnd\t\t= THREE.ZeroSlopeEnding;\n\t\n\t\t\t} else {\n\t\n\t\t\t\t// assuming for LoopOnce atStart == atEnd == true\n\t\n\t\t\t\tif ( atStart ) {\n\t\n\t\t\t\t\tsettings.endingStart = this.zeroSlopeAtStart ?\n\t\t\t\t\t\t\tTHREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tsettings.endingStart = THREE.WrapAroundEnding;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( atEnd ) {\n\t\n\t\t\t\t\tsettings.endingEnd = this.zeroSlopeAtEnd ?\n\t\t\t\t\t\t\tTHREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tsettings.endingEnd \t = THREE.WrapAroundEnding;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\t_scheduleFading: function( duration, weightNow, weightThen ) {\n\t\n\t\t\tvar mixer = this._mixer, now = mixer.time,\n\t\t\t\tinterpolant = this._weightInterpolant;\n\t\n\t\t\tif ( interpolant === null ) {\n\t\n\t\t\t\tinterpolant = mixer._lendControlInterpolant(),\n\t\t\t\tthis._weightInterpolant = interpolant;\n\t\n\t\t\t}\n\t\n\t\t\tvar times = interpolant.parameterPositions,\n\t\t\t\tvalues = interpolant.sampleValues;\n\t\n\t\t\ttimes[ 0 ] = now; \t\t\t\tvalues[ 0 ] = weightNow;\n\t\t\ttimes[ 1 ] = now + duration;\tvalues[ 1 ] = weightThen;\n\t\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t};\n\t\n\t\n\t// File:src/animation/AnimationClip.js\n\t\n\t/**\n\t *\n\t * Reusable set of Tracks that represent an animation.\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t */\n\t\n\tTHREE.AnimationClip = function ( name, duration, tracks ) {\n\t\n\t\tthis.name = name;\n\t\tthis.tracks = tracks;\n\t\tthis.duration = ( duration !== undefined ) ? duration : -1;\n\t\n\t\tthis.uuid = THREE.Math.generateUUID();\n\t\n\t\t// this means it should figure out its duration by scanning the tracks\n\t\tif ( this.duration < 0 ) {\n\t\n\t\t\tthis.resetDuration();\n\t\n\t\t}\n\t\n\t\t// maybe only do these on demand, as doing them here could potentially slow down loading\n\t\t// but leaving these here during development as this ensures a lot of testing of these functions\n\t\tthis.trim();\n\t\tthis.optimize();\n\t\n\t};\n\t\n\tTHREE.AnimationClip.prototype = {\n\t\n\t\tconstructor: THREE.AnimationClip,\n\t\n\t\tresetDuration: function() {\n\t\n\t\t\tvar tracks = this.tracks,\n\t\t\t\tduration = 0;\n\t\n\t\t\tfor ( var i = 0, n = tracks.length; i !== n; ++ i ) {\n\t\n\t\t\t\tvar track = this.tracks[ i ];\n\t\n\t\t\t\tduration = Math.max(\n\t\t\t\t\t\tduration, track.times[ track.times.length - 1 ] );\n\t\n\t\t\t}\n\t\n\t\t\tthis.duration = duration;\n\t\n\t\t},\n\t\n\t\ttrim: function() {\n\t\n\t\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\t\n\t\t\t\tthis.tracks[ i ].trim( 0, this.duration );\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\toptimize: function() {\n\t\n\t\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\t\n\t\t\t\tthis.tracks[ i ].optimize();\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t};\n\t\n\t// Static methods:\n\t\n\tObject.assign( THREE.AnimationClip, {\n\t\n\t\tparse: function( json ) {\n\t\n\t\t\tvar tracks = [],\n\t\t\t\tjsonTracks = json.tracks,\n\t\t\t\tframeTime = 1.0 / ( json.fps || 1.0 );\n\t\n\t\t\tfor ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {\n\t\n\t\t\t\ttracks.push( THREE.KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );\n\t\n\t\t\t}\n\t\n\t\t\treturn new THREE.AnimationClip( json.name, json.duration, tracks );\n\t\n\t\t},\n\t\n\t\n\t\ttoJSON: function( clip ) {\n\t\n\t\t\tvar tracks = [],\n\t\t\t\tclipTracks = clip.tracks;\n\t\n\t\t\tvar json = {\n\t\n\t\t\t\t'name': clip.name,\n\t\t\t\t'duration': clip.duration,\n\t\t\t\t'tracks': tracks\n\t\n\t\t\t};\n\t\n\t\t\tfor ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {\n\t\n\t\t\t\ttracks.push( THREE.KeyframeTrack.toJSON( clipTracks[ i ] ) );\n\t\n\t\t\t}\n\t\n\t\t\treturn json;\n\t\n\t\t},\n\t\n\t\n\t\tCreateFromMorphTargetSequence: function( name, morphTargetSequence, fps, noLoop ) {\n\t\n\t\t\tvar numMorphTargets = morphTargetSequence.length;\n\t\t\tvar tracks = [];\n\t\n\t\t\tfor ( var i = 0; i < numMorphTargets; i ++ ) {\n\t\n\t\t\t\tvar times = [];\n\t\t\t\tvar values = [];\n\t\n\t\t\t\ttimes.push(\n\t\t\t\t\t\t( i + numMorphTargets - 1 ) % numMorphTargets,\n\t\t\t\t\t\ti,\n\t\t\t\t\t\t( i + 1 ) % numMorphTargets );\n\t\n\t\t\t\tvalues.push( 0, 1, 0 );\n\t\n\t\t\t\tvar order = THREE.AnimationUtils.getKeyframeOrder( times );\n\t\t\t\ttimes = THREE.AnimationUtils.sortedArray( times, 1, order );\n\t\t\t\tvalues = THREE.AnimationUtils.sortedArray( values, 1, order );\n\t\n\t\t\t\t// if there is a key at the first frame, duplicate it as the\n\t\t\t\t// last frame as well for perfect loop.\n\t\t\t\tif ( ! noLoop && times[ 0 ] === 0 ) {\n\t\n\t\t\t\t\ttimes.push( numMorphTargets );\n\t\t\t\t\tvalues.push( values[ 0 ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\ttracks.push(\n\t\t\t\t\t\tnew THREE.NumberKeyframeTrack(\n\t\t\t\t\t\t\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\n\t\t\t\t\t\t\ttimes, values\n\t\t\t\t\t\t).scale( 1.0 / fps ) );\n\t\t\t}\n\t\n\t\t\treturn new THREE.AnimationClip( name, -1, tracks );\n\t\n\t\t},\n\t\n\t\tfindByName: function( objectOrClipArray, name ) {\n\t\n\t\t\tvar clipArray = objectOrClipArray;\n\t\n\t\t\tif ( ! Array.isArray( objectOrClipArray ) ) {\n\t\n\t\t\t\tvar o = objectOrClipArray;\n\t\t\t\tclipArray = o.geometry && o.geometry.animations || o.animations;\n\t\n\t\t\t}\n\t\n\t\t\tfor ( var i = 0; i < clipArray.length; i ++ ) {\n\t\n\t\t\t\tif ( clipArray[ i ].name === name ) {\n\t\n\t\t\t\t\treturn clipArray[ i ];\n\t\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn null;\n\t\n\t\t},\n\t\n\t\tCreateClipsFromMorphTargetSequences: function( morphTargets, fps, noLoop ) {\n\t\n\t\t\tvar animationToMorphTargets = {};\n\t\n\t\t\t// tested with https://regex101.com/ on trick sequences\n\t\t\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n\t\t\tvar pattern = /^([\\w-]*?)([\\d]+)$/;\n\t\n\t\t\t// sort morph target names into animation groups based\n\t\t\t// patterns like Walk_001, Walk_002, Run_001, Run_002\n\t\t\tfor ( var i = 0, il = morphTargets.length; i < il; i ++ ) {\n\t\n\t\t\t\tvar morphTarget = morphTargets[ i ];\n\t\t\t\tvar parts = morphTarget.name.match( pattern );\n\t\n\t\t\t\tif ( parts && parts.length > 1 ) {\n\t\n\t\t\t\t\tvar name = parts[ 1 ];\n\t\n\t\t\t\t\tvar animationMorphTargets = animationToMorphTargets[ name ];\n\t\t\t\t\tif ( ! animationMorphTargets ) {\n\t\n\t\t\t\t\t\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tanimationMorphTargets.push( morphTarget );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tvar clips = [];\n\t\n\t\t\tfor ( var name in animationToMorphTargets ) {\n\t\n\t\t\t\tclips.push( THREE.AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\n\t\n\t\t\t}\n\t\n\t\t\treturn clips;\n\t\n\t\t},\n\t\n\t\t// parse the animation.hierarchy format\n\t\tparseAnimation: function( animation, bones, nodeName ) {\n\t\n\t\t\tif ( ! animation ) {\n\t\n\t\t\t\tconsole.error( \"  no animation in JSONLoader data\" );\n\t\t\t\treturn null;\n\t\n\t\t\t}\n\t\n\t\t\tvar addNonemptyTrack = function(\n\t\t\t\t\ttrackType, trackName, animationKeys, propertyName, destTracks ) {\n\t\n\t\t\t\t// only return track if there are actually keys.\n\t\t\t\tif ( animationKeys.length !== 0 ) {\n\t\n\t\t\t\t\tvar times = [];\n\t\t\t\t\tvar values = [];\n\t\n\t\t\t\t\tTHREE.AnimationUtils.flattenJSON(\n\t\t\t\t\t\t\tanimationKeys, times, values, propertyName );\n\t\n\t\t\t\t\t// empty keys are filtered out, so check again\n\t\t\t\t\tif ( times.length !== 0 ) {\n\t\n\t\t\t\t\t\tdestTracks.push( new trackType( trackName, times, values ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t\tvar tracks = [];\n\t\n\t\t\tvar clipName = animation.name || 'default';\n\t\t\t// automatic length determination in AnimationClip.\n\t\t\tvar duration = animation.length || -1;\n\t\t\tvar fps = animation.fps || 30;\n\t\n\t\t\tvar hierarchyTracks = animation.hierarchy || [];\n\t\n\t\t\tfor ( var h = 0; h < hierarchyTracks.length; h ++ ) {\n\t\n\t\t\t\tvar animationKeys = hierarchyTracks[ h ].keys;\n\t\n\t\t\t\t// skip empty tracks\n\t\t\t\tif ( ! animationKeys || animationKeys.length === 0 ) continue;\n\t\n\t\t\t\t// process morph targets in a way exactly compatible\n\t\t\t\t// with AnimationHandler.init( animation )\n\t\t\t\tif ( animationKeys[0].morphTargets ) {\n\t\n\t\t\t\t\t// figure out all morph targets used in this track\n\t\t\t\t\tvar morphTargetNames = {};\n\t\t\t\t\tfor ( var k = 0; k < animationKeys.length; k ++ ) {\n\t\n\t\t\t\t\t\tif ( animationKeys[k].morphTargets ) {\n\t\n\t\t\t\t\t\t\tfor ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {\n\t\n\t\t\t\t\t\t\t\tmorphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// create a track for each morph target with all zero\n\t\t\t\t\t// morphTargetInfluences except for the keys in which\n\t\t\t\t\t// the morphTarget is named.\n\t\t\t\t\tfor ( var morphTargetName in morphTargetNames ) {\n\t\n\t\t\t\t\t\tvar times = [];\n\t\t\t\t\t\tvar values = [];\n\t\n\t\t\t\t\t\tfor ( var m = 0;\n\t\t\t\t\t\t\t\tm !== animationKeys[k].morphTargets.length; ++ m ) {\n\t\n\t\t\t\t\t\t\tvar animationKey = animationKeys[k];\n\t\n\t\t\t\t\t\t\ttimes.push( animationKey.time );\n\t\t\t\t\t\t\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\ttracks.push( new THREE.NumberKeyframeTrack(\n\t\t\t\t\t\t\t\t'.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tduration = morphTargetNames.length * ( fps || 1.0 );\n\t\n\t\t\t\t} else {\n\t\t\t\t\t// ...assume skeletal animation\n\t\n\t\t\t\t\tvar boneName = '.bones[' + bones[ h ].name + ']';\n\t\n\t\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\t\tTHREE.VectorKeyframeTrack, boneName + '.position',\n\t\t\t\t\t\t\tanimationKeys, 'pos', tracks );\n\t\n\t\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\t\tTHREE.QuaternionKeyframeTrack, boneName + '.quaternion',\n\t\t\t\t\t\t\tanimationKeys, 'rot', tracks );\n\t\n\t\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\t\tTHREE.VectorKeyframeTrack, boneName + '.scale',\n\t\t\t\t\t\t\tanimationKeys, 'scl', tracks );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif ( tracks.length === 0 ) {\n\t\n\t\t\t\treturn null;\n\t\n\t\t\t}\n\t\n\t\t\tvar clip = new THREE.AnimationClip( clipName, duration, tracks );\n\t\n\t\t\treturn clip;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/animation/AnimationMixer.js\n\t\n\t/**\n\t *\n\t * Player for AnimationClips.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\t\n\tTHREE.AnimationMixer = function( root ) {\n\t\n\t\tthis._root = root;\n\t\tthis._initMemoryManager();\n\t\tthis._accuIndex = 0;\n\t\n\t\tthis.time = 0;\n\t\n\t\tthis.timeScale = 1.0;\n\t\n\t};\n\t\n\tObject.assign( THREE.AnimationMixer.prototype, THREE.EventDispatcher.prototype, {\n\t\n\t\t// return an action for a clip optionally using a custom root target\n\t\t// object (this method allocates a lot of dynamic memory in case a\n\t\t// previously unknown clip/root combination is specified)\n\t\tclipAction: function( clip, optionalRoot ) {\n\t\n\t\t\tvar root = optionalRoot || this._root,\n\t\t\t\trootUuid = root.uuid,\n\t\n\t\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\t\t\tTHREE.AnimationClip.findByName( root, clip ) : clip,\n\t\n\t\t\t\tclipUuid = clipObject !== null ? clipObject.uuid : clip,\n\t\n\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ],\n\t\t\t\tprototypeAction = null;\n\t\n\t\t\tif ( actionsForClip !== undefined ) {\n\t\n\t\t\t\tvar existingAction =\n\t\t\t\t\t\tactionsForClip.actionByRoot[ rootUuid ];\n\t\n\t\t\t\tif ( existingAction !== undefined ) {\n\t\n\t\t\t\t\treturn existingAction;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// we know the clip, so we don't have to parse all\n\t\t\t\t// the bindings again but can just copy\n\t\t\t\tprototypeAction = actionsForClip.knownActions[ 0 ];\n\t\n\t\t\t\t// also, take the clip from the prototype action\n\t\t\t\tif ( clipObject === null )\n\t\t\t\t\tclipObject = prototypeAction._clip;\n\t\n\t\t\t}\n\t\n\t\t\t// clip must be known when specified via string\n\t\t\tif ( clipObject === null ) return null;\n\t\n\t\t\t// allocate all resources required to run it\n\t\t\tvar newAction = new THREE.\n\t\t\t\t\tAnimationMixer._Action( this, clipObject, optionalRoot );\n\t\n\t\t\tthis._bindAction( newAction, prototypeAction );\n\t\n\t\t\t// and make the action known to the memory manager\n\t\t\tthis._addInactiveAction( newAction, clipUuid, rootUuid );\n\t\n\t\t\treturn newAction;\n\t\n\t\t},\n\t\n\t\t// get an existing action\n\t\texistingAction: function( clip, optionalRoot ) {\n\t\n\t\t\tvar root = optionalRoot || this._root,\n\t\t\t\trootUuid = root.uuid,\n\t\n\t\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\t\t\tTHREE.AnimationClip.findByName( root, clip ) : clip,\n\t\n\t\t\t\tclipUuid = clipObject ? clipObject.uuid : clip,\n\t\n\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\t\n\t\t\tif ( actionsForClip !== undefined ) {\n\t\n\t\t\t\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\n\t\n\t\t\t}\n\t\n\t\t\treturn null;\n\t\n\t\t},\n\t\n\t\t// deactivates all previously scheduled actions\n\t\tstopAllAction: function() {\n\t\n\t\t\tvar actions = this._actions,\n\t\t\t\tnActions = this._nActiveActions,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tnBindings = this._nActiveBindings;\n\t\n\t\t\tthis._nActiveActions = 0;\n\t\t\tthis._nActiveBindings = 0;\n\t\n\t\t\tfor ( var i = 0; i !== nActions; ++ i ) {\n\t\n\t\t\t\tactions[ i ].reset();\n\t\n\t\t\t}\n\t\n\t\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\n\t\n\t\t\t\tbindings[ i ].useCount = 0;\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\t// advance the time and update apply the animation\n\t\tupdate: function( deltaTime ) {\n\t\n\t\t\tdeltaTime *= this.timeScale;\n\t\n\t\t\tvar actions = this._actions,\n\t\t\t\tnActions = this._nActiveActions,\n\t\n\t\t\t\ttime = this.time += deltaTime,\n\t\t\t\ttimeDirection = Math.sign( deltaTime ),\n\t\n\t\t\t\taccuIndex = this._accuIndex ^= 1;\n\t\n\t\t\t// run active actions\n\t\n\t\t\tfor ( var i = 0; i !== nActions; ++ i ) {\n\t\n\t\t\t\tvar action = actions[ i ];\n\t\n\t\t\t\tif ( action.enabled ) {\n\t\n\t\t\t\t\taction._update( time, deltaTime, timeDirection, accuIndex );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// update scene graph\n\t\n\t\t\tvar bindings = this._bindings,\n\t\t\t\tnBindings = this._nActiveBindings;\n\t\n\t\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\n\t\n\t\t\t\tbindings[ i ].apply( accuIndex );\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\t// return this mixer's root target object\n\t\tgetRoot: function() {\n\t\n\t\t\treturn this._root;\n\t\n\t\t},\n\t\n\t\t// free all resources specific to a particular clip\n\t\tuncacheClip: function( clip ) {\n\t\n\t\t\tvar actions = this._actions,\n\t\t\t\tclipUuid = clip.uuid,\n\t\t\t\tactionsByClip = this._actionsByClip,\n\t\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\t\n\t\t\tif ( actionsForClip !== undefined ) {\n\t\n\t\t\t\t// note: just calling _removeInactiveAction would mess up the\n\t\t\t\t// iteration state and also require updating the state we can\n\t\t\t\t// just throw away\n\t\n\t\t\t\tvar actionsToRemove = actionsForClip.knownActions;\n\t\n\t\t\t\tfor ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tvar action = actionsToRemove[ i ];\n\t\n\t\t\t\t\tthis._deactivateAction( action );\n\t\n\t\t\t\t\tvar cacheIndex = action._cacheIndex,\n\t\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ];\n\t\n\t\t\t\t\taction._cacheIndex = null;\n\t\t\t\t\taction._byClipCacheIndex = null;\n\t\n\t\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\t\t\tactions.pop();\n\t\n\t\t\t\t\tthis._removeInactiveBindingsForAction( action );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tdelete actionsByClip[ clipUuid ];\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\t// free all resources specific to a particular root target object\n\t\tuncacheRoot: function( root ) {\n\t\n\t\t\tvar rootUuid = root.uuid,\n\t\t\t\tactionsByClip = this._actionsByClip;\n\t\n\t\t\tfor ( var clipUuid in actionsByClip ) {\n\t\n\t\t\t\tvar actionByRoot = actionsByClip[ clipUuid ].actionByRoot,\n\t\t\t\t\taction = actionByRoot[ rootUuid ];\n\t\n\t\t\t\tif ( action !== undefined ) {\n\t\n\t\t\t\t\tthis._deactivateAction( action );\n\t\t\t\t\tthis._removeInactiveAction( action );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tvar bindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\tbindingByName = bindingsByRoot[ rootUuid ];\n\t\n\t\t\tif ( bindingByName !== undefined ) {\n\t\n\t\t\t\tfor ( var trackName in bindingByName ) {\n\t\n\t\t\t\t\tvar binding = bindingByName[ trackName ];\n\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\tthis._removeInactiveBinding( binding );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\t// remove a targeted clip from the cache\n\t\tuncacheAction: function( clip, optionalRoot ) {\n\t\n\t\t\tvar action = this.existingAction( clip, optionalRoot );\n\t\n\t\t\tif ( action !== null ) {\n\t\n\t\t\t\tthis._deactivateAction( action );\n\t\t\t\tthis._removeInactiveAction( action );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t} );\n\t\n\tTHREE.AnimationMixer._Action = THREE.AnimationAction._new;\n\t\n\t// Implementation details:\n\t\n\tObject.assign( THREE.AnimationMixer.prototype, {\n\t\n\t\t_bindAction: function( action, prototypeAction ) {\n\t\n\t\t\tvar root = action._localRoot || this._root,\n\t\t\t\ttracks = action._clip.tracks,\n\t\t\t\tnTracks = tracks.length,\n\t\t\t\tbindings = action._propertyBindings,\n\t\t\t\tinterpolants = action._interpolants,\n\t\t\t\trootUuid = root.uuid,\n\t\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\tbindingsByName = bindingsByRoot[ rootUuid ];\n\t\n\t\t\tif ( bindingsByName === undefined ) {\n\t\n\t\t\t\tbindingsByName = {};\n\t\t\t\tbindingsByRoot[ rootUuid ] = bindingsByName;\n\t\n\t\t\t}\n\t\n\t\t\tfor ( var i = 0; i !== nTracks; ++ i ) {\n\t\n\t\t\t\tvar track = tracks[ i ],\n\t\t\t\t\ttrackName = track.name,\n\t\t\t\t\tbinding = bindingsByName[ trackName ];\n\t\n\t\t\t\tif ( binding !== undefined ) {\n\t\n\t\t\t\t\tbindings[ i ] = binding;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tbinding = bindings[ i ];\n\t\n\t\t\t\t\tif ( binding !== undefined ) {\n\t\n\t\t\t\t\t\t// existing binding, make sure the cache knows\n\t\n\t\t\t\t\t\tif ( binding._cacheIndex === null ) {\n\t\n\t\t\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tcontinue;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar path = prototypeAction && prototypeAction.\n\t\t\t\t\t\t\t_propertyBindings[ i ].binding.parsedPath;\n\t\n\t\t\t\t\tbinding = new THREE.PropertyMixer(\n\t\t\t\t\t\t\tTHREE.PropertyBinding.create( root, trackName, path ),\n\t\t\t\t\t\t\ttrack.ValueTypeName, track.getValueSize() );\n\t\n\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\t\n\t\t\t\t\tbindings[ i ] = binding;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tinterpolants[ i ].resultBuffer = binding.buffer;\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\t_activateAction: function( action ) {\n\t\n\t\t\tif ( ! this._isActiveAction( action ) ) {\n\t\n\t\t\t\tif ( action._cacheIndex === null ) {\n\t\n\t\t\t\t\t// this action has been forgotten by the cache, but the user\n\t\t\t\t\t// appears to be still using it -> rebind\n\t\n\t\t\t\t\tvar rootUuid = ( action._localRoot || this._root ).uuid,\n\t\t\t\t\t\tclipUuid = action._clip.uuid,\n\t\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\t\n\t\t\t\t\tthis._bindAction( action,\n\t\t\t\t\t\t\tactionsForClip && actionsForClip.knownActions[ 0 ] );\n\t\n\t\t\t\t\tthis._addInactiveAction( action, clipUuid, rootUuid );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar bindings = action._propertyBindings;\n\t\n\t\t\t\t// increment reference counts / sort out state\n\t\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tvar binding = bindings[ i ];\n\t\n\t\t\t\t\tif ( binding.useCount ++ === 0 ) {\n\t\n\t\t\t\t\t\tthis._lendBinding( binding );\n\t\t\t\t\t\tbinding.saveOriginalState();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis._lendAction( action );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\t_deactivateAction: function( action ) {\n\t\n\t\t\tif ( this._isActiveAction( action ) ) {\n\t\n\t\t\t\tvar bindings = action._propertyBindings;\n\t\n\t\t\t\t// decrement reference counts / sort out state\n\t\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tvar binding = bindings[ i ];\n\t\n\t\t\t\t\tif ( -- binding.useCount === 0 ) {\n\t\n\t\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\t\tthis._takeBackBinding( binding );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis._takeBackAction( action );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\t// Memory manager\n\t\n\t\t_initMemoryManager: function() {\n\t\n\t\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\n\t\t\tthis._nActiveActions = 0;\n\t\n\t\t\tthis._actionsByClip = {};\n\t\t\t// inside:\n\t\t\t// {\n\t\t\t// \t\tknownActions: Array< _Action >\t- used as prototypes\n\t\t\t// \t\tactionByRoot: _Action\t\t\t- lookup\n\t\t\t// }\n\t\n\t\n\t\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\n\t\t\tthis._nActiveBindings = 0;\n\t\n\t\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\t\n\t\n\t\t\tthis._controlInterpolants = []; // same game as above\n\t\t\tthis._nActiveControlInterpolants = 0;\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\tthis.stats = {\n\t\n\t\t\t\tactions: {\n\t\t\t\t\tget total() { return scope._actions.length; },\n\t\t\t\t\tget inUse() { return scope._nActiveActions; }\n\t\t\t\t},\n\t\t\t\tbindings: {\n\t\t\t\t\tget total() { return scope._bindings.length; },\n\t\t\t\t\tget inUse() { return scope._nActiveBindings; }\n\t\t\t\t},\n\t\t\t\tcontrolInterpolants: {\n\t\t\t\t\tget total() { return scope._controlInterpolants.length; },\n\t\t\t\t\tget inUse() { return scope._nActiveControlInterpolants; }\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t},\n\t\n\t\t// Memory management for _Action objects\n\t\n\t\t_isActiveAction: function( action ) {\n\t\n\t\t\tvar index = action._cacheIndex;\n\t\t\treturn index !== null && index < this._nActiveActions;\n\t\n\t\t},\n\t\n\t\t_addInactiveAction: function( action, clipUuid, rootUuid ) {\n\t\n\t\t\tvar actions = this._actions,\n\t\t\t\tactionsByClip = this._actionsByClip,\n\t\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\t\n\t\t\tif ( actionsForClip === undefined ) {\n\t\n\t\t\t\tactionsForClip = {\n\t\n\t\t\t\t\tknownActions: [ action ],\n\t\t\t\t\tactionByRoot: {}\n\t\n\t\t\t\t};\n\t\n\t\t\t\taction._byClipCacheIndex = 0;\n\t\n\t\t\t\tactionsByClip[ clipUuid ] = actionsForClip;\n\t\n\t\t\t} else {\n\t\n\t\t\t\tvar knownActions = actionsForClip.knownActions;\n\t\n\t\t\t\taction._byClipCacheIndex = knownActions.length;\n\t\t\t\tknownActions.push( action );\n\t\n\t\t\t}\n\t\n\t\t\taction._cacheIndex = actions.length;\n\t\t\tactions.push( action );\n\t\n\t\t\tactionsForClip.actionByRoot[ rootUuid ] = action;\n\t\n\t\t},\n\t\n\t\t_removeInactiveAction: function( action ) {\n\t\n\t\t\tvar actions = this._actions,\n\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ],\n\t\t\t\tcacheIndex = action._cacheIndex;\n\t\n\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\tactions.pop();\n\t\n\t\t\taction._cacheIndex = null;\n\t\n\t\n\t\t\tvar clipUuid = action._clip.uuid,\n\t\t\t\tactionsByClip = this._actionsByClip,\n\t\t\t\tactionsForClip = actionsByClip[ clipUuid ],\n\t\t\t\tknownActionsForClip = actionsForClip.knownActions,\n\t\n\t\t\t\tlastKnownAction =\n\t\t\t\t\tknownActionsForClip[ knownActionsForClip.length - 1 ],\n\t\n\t\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\n\t\n\t\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\n\t\t\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\n\t\t\tknownActionsForClip.pop();\n\t\n\t\t\taction._byClipCacheIndex = null;\n\t\n\t\n\t\t\tvar actionByRoot = actionsForClip.actionByRoot,\n\t\t\t\trootUuid = ( actions._localRoot || this._root ).uuid;\n\t\n\t\t\tdelete actionByRoot[ rootUuid ];\n\t\n\t\t\tif ( knownActionsForClip.length === 0 ) {\n\t\n\t\t\t\tdelete actionsByClip[ clipUuid ];\n\t\n\t\t\t}\n\t\n\t\t\tthis._removeInactiveBindingsForAction( action );\n\t\n\t\t},\n\t\n\t\t_removeInactiveBindingsForAction: function( action ) {\n\t\n\t\t\tvar bindings = action._propertyBindings;\n\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\t\n\t\t\t\tvar binding = bindings[ i ];\n\t\n\t\t\t\tif ( -- binding.referenceCount === 0 ) {\n\t\n\t\t\t\t\tthis._removeInactiveBinding( binding );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\t_lendAction: function( action ) {\n\t\n\t\t\t// [ active actions |  inactive actions  ]\n\t\t\t// [  active actions >| inactive actions ]\n\t\t\t//                 s        a\n\t\t\t//                  <-swap->\n\t\t\t//                 a        s\n\t\n\t\t\tvar actions = this._actions,\n\t\t\t\tprevIndex = action._cacheIndex,\n\t\n\t\t\t\tlastActiveIndex = this._nActiveActions ++,\n\t\n\t\t\t\tfirstInactiveAction = actions[ lastActiveIndex ];\n\t\n\t\t\taction._cacheIndex = lastActiveIndex;\n\t\t\tactions[ lastActiveIndex ] = action;\n\t\n\t\t\tfirstInactiveAction._cacheIndex = prevIndex;\n\t\t\tactions[ prevIndex ] = firstInactiveAction;\n\t\n\t\t},\n\t\n\t\t_takeBackAction: function( action ) {\n\t\n\t\t\t// [  active actions  | inactive actions ]\n\t\t\t// [ active actions |< inactive actions  ]\n\t\t\t//        a        s\n\t\t\t//         <-swap->\n\t\t\t//        s        a\n\t\n\t\t\tvar actions = this._actions,\n\t\t\t\tprevIndex = action._cacheIndex,\n\t\n\t\t\t\tfirstInactiveIndex = -- this._nActiveActions,\n\t\n\t\t\t\tlastActiveAction = actions[ firstInactiveIndex ];\n\t\n\t\t\taction._cacheIndex = firstInactiveIndex;\n\t\t\tactions[ firstInactiveIndex ] = action;\n\t\n\t\t\tlastActiveAction._cacheIndex = prevIndex;\n\t\t\tactions[ prevIndex ] = lastActiveAction;\n\t\n\t\t},\n\t\n\t\t// Memory management for PropertyMixer objects\n\t\n\t\t_addInactiveBinding: function( binding, rootUuid, trackName ) {\n\t\n\t\t\tvar bindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\t\n\t\t\t\tbindings = this._bindings;\n\t\n\t\t\tif ( bindingByName === undefined ) {\n\t\n\t\t\t\tbindingByName = {};\n\t\t\t\tbindingsByRoot[ rootUuid ] = bindingByName;\n\t\n\t\t\t}\n\t\n\t\t\tbindingByName[ trackName ] = binding;\n\t\n\t\t\tbinding._cacheIndex = bindings.length;\n\t\t\tbindings.push( binding );\n\t\n\t\t},\n\t\n\t\t_removeInactiveBinding: function( binding ) {\n\t\n\t\t\tvar bindings = this._bindings,\n\t\t\t\tpropBinding = binding.binding,\n\t\t\t\trootUuid = propBinding.rootNode.uuid,\n\t\t\t\ttrackName = propBinding.path,\n\t\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\t\n\t\t\t\tlastInactiveBinding = bindings[ bindings.length - 1 ],\n\t\t\t\tcacheIndex = binding._cacheIndex;\n\t\n\t\t\tlastInactiveBinding._cacheIndex = cacheIndex;\n\t\t\tbindings[ cacheIndex ] = lastInactiveBinding;\n\t\t\tbindings.pop();\n\t\n\t\t\tdelete bindingByName[ trackName ];\n\t\n\t\t\tremove_empty_map: {\n\t\n\t\t\t\tfor ( var _ in bindingByName ) break remove_empty_map;\n\t\n\t\t\t\tdelete bindingsByRoot[ rootUuid ];\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\t_lendBinding: function( binding ) {\n\t\n\t\t\tvar bindings = this._bindings,\n\t\t\t\tprevIndex = binding._cacheIndex,\n\t\n\t\t\t\tlastActiveIndex = this._nActiveBindings ++,\n\t\n\t\t\t\tfirstInactiveBinding = bindings[ lastActiveIndex ];\n\t\n\t\t\tbinding._cacheIndex = lastActiveIndex;\n\t\t\tbindings[ lastActiveIndex ] = binding;\n\t\n\t\t\tfirstInactiveBinding._cacheIndex = prevIndex;\n\t\t\tbindings[ prevIndex ] = firstInactiveBinding;\n\t\n\t\t},\n\t\n\t\t_takeBackBinding: function( binding ) {\n\t\n\t\t\tvar bindings = this._bindings,\n\t\t\t\tprevIndex = binding._cacheIndex,\n\t\n\t\t\t\tfirstInactiveIndex = -- this._nActiveBindings,\n\t\n\t\t\t\tlastActiveBinding = bindings[ firstInactiveIndex ];\n\t\n\t\t\tbinding._cacheIndex = firstInactiveIndex;\n\t\t\tbindings[ firstInactiveIndex ] = binding;\n\t\n\t\t\tlastActiveBinding._cacheIndex = prevIndex;\n\t\t\tbindings[ prevIndex ] = lastActiveBinding;\n\t\n\t\t},\n\t\n\t\n\t\t// Memory management of Interpolants for weight and time scale\n\t\n\t\t_lendControlInterpolant: function() {\n\t\n\t\t\tvar interpolants = this._controlInterpolants,\n\t\t\t\tlastActiveIndex = this._nActiveControlInterpolants ++,\n\t\t\t\tinterpolant = interpolants[ lastActiveIndex ];\n\t\n\t\t\tif ( interpolant === undefined ) {\n\t\n\t\t\t\tinterpolant = new THREE.LinearInterpolant(\n\t\t\t\t\t\tnew Float32Array( 2 ), new Float32Array( 2 ),\n\t\t\t\t\t\t\t1, this._controlInterpolantsResultBuffer );\n\t\n\t\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\n\t\t\t\tinterpolants[ lastActiveIndex ] = interpolant;\n\t\n\t\t\t}\n\t\n\t\t\treturn interpolant;\n\t\n\t\t},\n\t\n\t\t_takeBackControlInterpolant: function( interpolant ) {\n\t\n\t\t\tvar interpolants = this._controlInterpolants,\n\t\t\t\tprevIndex = interpolant.__cacheIndex,\n\t\n\t\t\t\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\n\t\n\t\t\t\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\n\t\n\t\t\tinterpolant.__cacheIndex = firstInactiveIndex;\n\t\t\tinterpolants[ firstInactiveIndex ] = interpolant;\n\t\n\t\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\n\t\t\tinterpolants[ prevIndex ] = lastActiveInterpolant;\n\t\n\t\t},\n\t\n\t\t_controlInterpolantsResultBuffer: new Float32Array( 1 )\n\t\n\t} );\n\t\n\t// File:src/animation/AnimationObjectGroup.js\n\t\n\t/**\n\t *\n\t * A group of objects that receives a shared animation state.\n\t *\n\t * Usage:\n\t *\n\t * \t-\tAdd objects you would otherwise pass as 'root' to the\n\t * \t\tconstructor or the .clipAction method of AnimationMixer.\n\t *\n\t * \t-\tInstead pass this object as 'root'.\n\t *\n\t * \t-\tYou can also add and remove objects later when the mixer\n\t * \t\tis running.\n\t *\n\t * Note:\n\t *\n\t *  \tObjects of this class appear as one object to the mixer,\n\t *  \tso cache control of the individual objects must be done\n\t *  \ton the group.\n\t *\n\t * Limitation:\n\t *\n\t * \t- \tThe animated properties must be compatible among the\n\t * \t\tall objects in the group.\n\t *\n\t *  -\tA single property can either be controlled through a\n\t *  \ttarget group or directly, but not both.\n\t *\n\t * @author tschw\n\t */\n\t\n\tTHREE.AnimationObjectGroup = function( var_args ) {\n\t\n\t\tthis.uuid = THREE.Math.generateUUID();\n\t\n\t\t// cached objects followed by the active ones\n\t\tthis._objects = Array.prototype.slice.call( arguments );\n\t\n\t\tthis.nCachedObjects_ = 0;\t\t\t// threshold\n\t\t// note: read by PropertyBinding.Composite\n\t\n\t\tvar indices = {};\n\t\tthis._indicesByUUID = indices;\t\t// for bookkeeping\n\t\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\t\n\t\t\tindices[ arguments[ i ].uuid ] = i;\n\t\n\t\t}\n\t\n\t\tthis._paths = [];\t\t\t\t\t// inside: string\n\t\tthis._parsedPaths = [];\t\t\t\t// inside: { we don't care, here }\n\t\tthis._bindings = []; \t\t\t\t// inside: Array< PropertyBinding >\n\t\tthis._bindingsIndicesByPath = {}; \t// inside: indices in these arrays\n\t\n\t\tvar scope = this;\n\t\n\t\tthis.stats = {\n\t\n\t\t\tobjects: {\n\t\t\t\tget total() { return scope._objects.length; },\n\t\t\t\tget inUse() { return this.total - scope.nCachedObjects_;  }\n\t\t\t},\n\t\n\t\t\tget bindingsPerObject() { return scope._bindings.length; }\n\t\n\t\t};\n\t\n\t};\n\t\n\tTHREE.AnimationObjectGroup.prototype = {\n\t\n\t\tconstructor: THREE.AnimationObjectGroup,\n\t\n\t\tadd: function( var_args ) {\n\t\n\t\t\tvar objects = this._objects,\n\t\t\t\tnObjects = objects.length,\n\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\t\tpaths = this._paths,\n\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tnBindings = bindings.length;\n\t\n\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\t\n\t\t\t\tvar object = arguments[ i ],\n\t\t\t\t\tuuid = object.uuid,\n\t\t\t\t\tindex = indicesByUUID[ uuid ];\n\t\n\t\t\t\tif ( index === undefined ) {\n\t\n\t\t\t\t\t// unknown object -> add it to the ACTIVE region\n\t\n\t\t\t\t\tindex = nObjects ++;\n\t\t\t\t\tindicesByUUID[ uuid ] = index;\n\t\t\t\t\tobjects.push( object );\n\t\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\t\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\t\n\t\t\t\t\t\tbindings[ j ].push(\n\t\t\t\t\t\t\t\tnew THREE.PropertyBinding(\n\t\t\t\t\t\t\t\t\tobject, paths[ j ], parsedPaths[ j ] ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( index < nCachedObjects ) {\n\t\n\t\t\t\t\tvar knownObject = objects[ index ];\n\t\n\t\t\t\t\t// move existing object to the ACTIVE region\n\t\n\t\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ];\n\t\n\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = lastCachedObject;\n\t\n\t\t\t\t\tindicesByUUID[ uuid ] = firstActiveIndex;\n\t\t\t\t\tobjects[ firstActiveIndex ] = object;\n\t\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\t\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\t\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\t\n\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\t\n\t\t\t\t\t\tif ( binding === undefined ) {\n\t\n\t\t\t\t\t\t\t// since we do not bother to create new bindings\n\t\t\t\t\t\t\t// for objects that are cached, the binding may\n\t\t\t\t\t\t\t// or may not exist\n\t\n\t\t\t\t\t\t\tbinding = new THREE.PropertyBinding(\n\t\t\t\t\t\t\t\t\tobject, paths[ j ], parsedPaths[ j ] );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = binding;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( objects[ index ] !== knownObject) {\n\t\n\t\t\t\t\tconsole.error( \"Different objects with the same UUID \" +\n\t\t\t\t\t\t\t\"detected. Clean the caches or recreate your \" +\n\t\t\t\t\t\t\t\"infrastructure when reloading scenes...\" );\n\t\n\t\t\t\t} // else the object is already where we want it to be\n\t\n\t\t\t} // for arguments\n\t\n\t\t\tthis.nCachedObjects_ = nCachedObjects;\n\t\n\t\t},\n\t\n\t\tremove: function( var_args ) {\n\t\n\t\t\tvar objects = this._objects,\n\t\t\t\tnObjects = objects.length,\n\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tnBindings = bindings.length;\n\t\n\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\t\n\t\t\t\tvar object = arguments[ i ],\n\t\t\t\t\tuuid = object.uuid,\n\t\t\t\t\tindex = indicesByUUID[ uuid ];\n\t\n\t\t\t\tif ( index !== undefined && index >= nCachedObjects ) {\n\t\n\t\t\t\t\t// move existing object into the CACHED region\n\t\n\t\t\t\t\tvar lastCachedIndex = nCachedObjects ++,\n\t\t\t\t\t\tfirstActiveObject = objects[ lastCachedIndex ];\n\t\n\t\t\t\t\tindicesByUUID[ firstActiveObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = firstActiveObject;\n\t\n\t\t\t\t\tindicesByUUID[ uuid ] = lastCachedIndex;\n\t\t\t\t\tobjects[ lastCachedIndex ] = object;\n\t\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\t\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\t\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\tfirstActive = bindingsForPath[ lastCachedIndex ],\n\t\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\t\n\t\t\t\t\t\tbindingsForPath[ index ] = firstActive;\n\t\t\t\t\t\tbindingsForPath[ lastCachedIndex ] = binding;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t} // for arguments\n\t\n\t\t\tthis.nCachedObjects_ = nCachedObjects;\n\t\n\t\t},\n\t\n\t\t// remove & forget\n\t\tuncache: function( var_args ) {\n\t\n\t\t\tvar objects = this._objects,\n\t\t\t\tnObjects = objects.length,\n\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tnBindings = bindings.length;\n\t\n\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\t\n\t\t\t\tvar object = arguments[ i ],\n\t\t\t\t\tuuid = object.uuid,\n\t\t\t\t\tindex = indicesByUUID[ uuid ];\n\t\n\t\t\t\tif ( index !== undefined ) {\n\t\n\t\t\t\t\tdelete indicesByUUID[ uuid ];\n\t\n\t\t\t\t\tif ( index < nCachedObjects ) {\n\t\n\t\t\t\t\t\t// object is cached, shrink the CACHED region\n\t\n\t\t\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ],\n\t\t\t\t\t\t\tlastIndex = -- nObjects,\n\t\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\t\n\t\t\t\t\t\t// last cached object takes this object's place\n\t\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\t\t\tobjects[ index ] = lastCachedObject;\n\t\n\t\t\t\t\t\t// last object goes to the activated slot and pop\n\t\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = firstActiveIndex;\n\t\t\t\t\t\tobjects[ firstActiveIndex ] = lastObject;\n\t\t\t\t\t\tobjects.pop();\n\t\n\t\t\t\t\t\t// accounting is done, now do the same for all bindings\n\t\n\t\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\t\n\t\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\t\t\tlast = bindingsForPath[ lastIndex ];\n\t\n\t\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\t\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = last;\n\t\t\t\t\t\t\tbindingsForPath.pop();\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// object is active, just swap with the last and pop\n\t\n\t\t\t\t\t\tvar lastIndex = -- nObjects,\n\t\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\t\n\t\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = index;\n\t\t\t\t\t\tobjects[ index ] = lastObject;\n\t\t\t\t\t\tobjects.pop();\n\t\n\t\t\t\t\t\t// accounting is done, now do the same for all bindings\n\t\n\t\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\t\n\t\t\t\t\t\t\tvar bindingsForPath = bindings[ j ];\n\t\n\t\t\t\t\t\t\tbindingsForPath[ index ] = bindingsForPath[ lastIndex ];\n\t\t\t\t\t\t\tbindingsForPath.pop();\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} // cached or active\n\t\n\t\t\t\t} // if object is known\n\t\n\t\t\t} // for arguments\n\t\n\t\t\tthis.nCachedObjects_ = nCachedObjects;\n\t\n\t\t},\n\t\n\t\t// Internal interface used by befriended PropertyBinding.Composite:\n\t\n\t\tsubscribe_: function( path, parsedPath ) {\n\t\t\t// returns an array of bindings for the given path that is changed\n\t\t\t// according to the contained objects in the group\n\t\n\t\t\tvar indicesByPath = this._bindingsIndicesByPath,\n\t\t\t\tindex = indicesByPath[ path ],\n\t\t\t\tbindings = this._bindings;\n\t\n\t\t\tif ( index !== undefined ) return bindings[ index ];\n\t\n\t\t\tvar paths = this._paths,\n\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\tobjects = this._objects,\n\t\t\t\tnObjects = objects.length,\n\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\tbindingsForPath = new Array( nObjects );\n\t\n\t\t\tindex = bindings.length;\n\t\n\t\t\tindicesByPath[ path ] = index;\n\t\n\t\t\tpaths.push( path );\n\t\t\tparsedPaths.push( parsedPath );\n\t\t\tbindings.push( bindingsForPath );\n\t\n\t\t\tfor ( var i = nCachedObjects,\n\t\t\t\t\tn = objects.length; i !== n; ++ i ) {\n\t\n\t\t\t\tvar object = objects[ i ];\n\t\n\t\t\t\tbindingsForPath[ i ] =\n\t\t\t\t\t\tnew THREE.PropertyBinding( object, path, parsedPath );\n\t\n\t\t\t}\n\t\n\t\t\treturn bindingsForPath;\n\t\n\t\t},\n\t\n\t\tunsubscribe_: function( path ) {\n\t\t\t// tells the group to forget about a property path and no longer\n\t\t\t// update the array previously obtained with 'subscribe_'\n\t\n\t\t\tvar indicesByPath = this._bindingsIndicesByPath,\n\t\t\t\tindex = indicesByPath[ path ];\n\t\n\t\t\tif ( index !== undefined ) {\n\t\n\t\t\t\tvar paths = this._paths,\n\t\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\tlastBindingsIndex = bindings.length - 1,\n\t\t\t\t\tlastBindings = bindings[ lastBindingsIndex ],\n\t\t\t\t\tlastBindingsPath = path[ lastBindingsIndex ];\n\t\n\t\t\t\tindicesByPath[ lastBindingsPath ] = index;\n\t\n\t\t\t\tbindings[ index ] = lastBindings;\n\t\t\t\tbindings.pop();\n\t\n\t\t\t\tparsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\n\t\t\t\tparsedPaths.pop();\n\t\n\t\t\t\tpaths[ index ] = paths[ lastBindingsIndex ];\n\t\t\t\tpaths.pop();\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t};\n\t\n\t\n\t// File:src/animation/AnimationUtils.js\n\t\n\t/**\n\t * @author tschw\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t */\n\t\n\tTHREE.AnimationUtils = {\n\t\n\t\t// same as Array.prototype.slice, but also works on typed arrays\n\t\tarraySlice: function( array, from, to ) {\n\t\n\t\t\tif ( THREE.AnimationUtils.isTypedArray( array ) ) {\n\t\n\t\t\t\treturn new array.constructor( array.subarray( from, to ) );\n\t\n\t\t\t}\n\t\n\t\t\treturn array.slice( from, to );\n\t\n\t\t},\n\t\n\t\t// converts an array to a specific type\n\t\tconvertArray: function( array, type, forceClone ) {\n\t\n\t\t\tif ( ! array || // let 'undefined' and 'null' pass\n\t\t\t\t\t! forceClone && array.constructor === type ) return array;\n\t\n\t\t\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\n\t\n\t\t\t\treturn new type( array ); // create typed array\n\t\n\t\t\t}\n\t\n\t\t\treturn Array.prototype.slice.call( array ); // create Array\n\t\n\t\t},\n\t\n\t\tisTypedArray: function( object ) {\n\t\n\t\t\treturn ArrayBuffer.isView( object ) &&\n\t\t\t\t\t! ( object instanceof DataView );\n\t\n\t\t},\n\t\n\t\t// returns an array by which times and values can be sorted\n\t\tgetKeyframeOrder: function( times ) {\n\t\n\t\t\tfunction compareTime( i, j ) {\n\t\n\t\t\t\treturn times[ i ] - times[ j ];\n\t\n\t\t\t}\n\t\n\t\t\tvar n = times.length;\n\t\t\tvar result = new Array( n );\n\t\t\tfor ( var i = 0; i !== n; ++ i ) result[ i ] = i;\n\t\n\t\t\tresult.sort( compareTime );\n\t\n\t\t\treturn result;\n\t\n\t\t},\n\t\n\t\t// uses the array previously returned by 'getKeyframeOrder' to sort data\n\t\tsortedArray: function( values, stride, order ) {\n\t\n\t\t\tvar nValues = values.length;\n\t\t\tvar result = new values.constructor( nValues );\n\t\n\t\t\tfor ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\n\t\n\t\t\t\tvar srcOffset = order[ i ] * stride;\n\t\n\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\t\n\t\t\t\t\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn result;\n\t\n\t\t},\n\t\n\t\t// function for parsing AOS keyframe formats\n\t\tflattenJSON: function( jsonKeys, times, values, valuePropertyName ) {\n\t\n\t\t\tvar i = 1, key = jsonKeys[ 0 ];\n\t\n\t\t\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\n\t\n\t\t\t\tkey = jsonKeys[ i ++ ];\n\t\n\t\t\t}\n\t\n\t\t\tif ( key === undefined ) return; // no data\n\t\n\t\t\tvar value = key[ valuePropertyName ];\n\t\t\tif ( value === undefined ) return; // no data\n\t\n\t\t\tif ( Array.isArray( value ) ) {\n\t\n\t\t\t\tdo {\n\t\n\t\t\t\t\tvalue = key[ valuePropertyName ];\n\t\n\t\t\t\t\tif ( value !== undefined ) {\n\t\n\t\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\t\tvalues.push.apply( values, value ); // push all elements\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tkey = jsonKeys[ i ++ ];\n\t\n\t\t\t\t} while ( key !== undefined );\n\t\n\t\t\t} else if ( value.toArray !== undefined ) {\n\t\t\t\t// ...assume THREE.Math-ish\n\t\n\t\t\t\tdo {\n\t\n\t\t\t\t\tvalue = key[ valuePropertyName ];\n\t\n\t\t\t\t\tif ( value !== undefined ) {\n\t\n\t\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\t\tvalue.toArray( values, values.length );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tkey = jsonKeys[ i ++ ];\n\t\n\t\t\t\t} while ( key !== undefined );\n\t\n\t\t\t} else {\n\t\t\t\t// otherwise push as-is\n\t\n\t\t\t\tdo {\n\t\n\t\t\t\t\tvalue = key[ valuePropertyName ];\n\t\n\t\t\t\t\tif ( value !== undefined ) {\n\t\n\t\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\t\tvalues.push( value );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tkey = jsonKeys[ i ++ ];\n\t\n\t\t\t\t} while ( key !== undefined );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/animation/KeyframeTrack.js\n\t\n\t/**\n\t *\n\t * A timed sequence of keyframes for a specific property.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\t\n\tTHREE.KeyframeTrack = function ( name, times, values, interpolation ) {\n\t\n\t\tif( name === undefined ) throw new Error( \"track name is undefined\" );\n\t\n\t\tif( times === undefined || times.length === 0 ) {\n\t\n\t\t\tthrow new Error( \"no keyframes in track named \" + name );\n\t\n\t\t}\n\t\n\t\tthis.name = name;\n\t\n\t\tthis.times = THREE.AnimationUtils.convertArray( times, this.TimeBufferType );\n\t\tthis.values = THREE.AnimationUtils.convertArray( values, this.ValueBufferType );\n\t\n\t\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\n\t\n\t\tthis.validate();\n\t\tthis.optimize();\n\t\n\t};\n\t\n\tTHREE.KeyframeTrack.prototype = {\n\t\n\t\tconstructor: THREE.KeyframeTrack,\n\t\n\t\tTimeBufferType: Float32Array,\n\t\tValueBufferType: Float32Array,\n\t\n\t\tDefaultInterpolation: THREE.InterpolateLinear,\n\t\n\t\tInterpolantFactoryMethodDiscrete: function( result ) {\n\t\n\t\t\treturn new THREE.DiscreteInterpolant(\n\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\t\n\t\t},\n\t\n\t\tInterpolantFactoryMethodLinear: function( result ) {\n\t\n\t\t\treturn new THREE.LinearInterpolant(\n\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\t\n\t\t},\n\t\n\t\tInterpolantFactoryMethodSmooth: function( result ) {\n\t\n\t\t\treturn new THREE.CubicInterpolant(\n\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\t\n\t\t},\n\t\n\t\tsetInterpolation: function( interpolation ) {\n\t\n\t\t\tvar factoryMethod;\n\t\n\t\t\tswitch ( interpolation ) {\n\t\n\t\t\t\tcase THREE.InterpolateDiscrete:\n\t\n\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\n\t\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase THREE.InterpolateLinear:\n\t\n\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodLinear;\n\t\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase THREE.InterpolateSmooth:\n\t\n\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\n\t\n\t\t\t\t\tbreak;\n\t\n\t\t\t}\n\t\n\t\t\tif ( factoryMethod === undefined ) {\n\t\n\t\t\t\tvar message = \"unsupported interpolation for \" +\n\t\t\t\t\t\tthis.ValueTypeName + \" keyframe track named \" + this.name;\n\t\n\t\t\t\tif ( this.createInterpolant === undefined ) {\n\t\n\t\t\t\t\t// fall back to default, unless the default itself is messed up\n\t\t\t\t\tif ( interpolation !== this.DefaultInterpolation ) {\n\t\n\t\t\t\t\t\tthis.setInterpolation( this.DefaultInterpolation );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tthrow new Error( message ); // fatal, in this case\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tconsole.warn( message );\n\t\t\t\treturn;\n\t\n\t\t\t}\n\t\n\t\t\tthis.createInterpolant = factoryMethod;\n\t\n\t\t},\n\t\n\t\tgetInterpolation: function() {\n\t\n\t\t\tswitch ( this.createInterpolant ) {\n\t\n\t\t\t\tcase this.InterpolantFactoryMethodDiscrete:\n\t\n\t\t\t\t\treturn THREE.InterpolateDiscrete;\n\t\n\t\t\t\tcase this.InterpolantFactoryMethodLinear:\n\t\n\t\t\t\t\treturn THREE.InterpolateLinear;\n\t\n\t\t\t\tcase this.InterpolantFactoryMethodSmooth:\n\t\n\t\t\t\t\treturn THREE.InterpolateSmooth;\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tgetValueSize: function() {\n\t\n\t\t\treturn this.values.length / this.times.length;\n\t\n\t\t},\n\t\n\t\t// move all keyframes either forwards or backwards in time\n\t\tshift: function( timeOffset ) {\n\t\n\t\t\tif( timeOffset !== 0.0 ) {\n\t\n\t\t\t\tvar times = this.times;\n\t\n\t\t\t\tfor( var i = 0, n = times.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\ttimes[ i ] += timeOffset;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\t// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\n\t\tscale: function( timeScale ) {\n\t\n\t\t\tif( timeScale !== 1.0 ) {\n\t\n\t\t\t\tvar times = this.times;\n\t\n\t\t\t\tfor( var i = 0, n = times.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\ttimes[ i ] *= timeScale;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\t// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\n\t\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\n\t\ttrim: function( startTime, endTime ) {\n\t\n\t\t\tvar times = this.times,\n\t\t\t\tnKeys = times.length,\n\t\t\t\tfrom = 0,\n\t\t\t\tto = nKeys - 1;\n\t\n\t\t\twhile ( from !== nKeys && times[ from ] < startTime ) ++ from;\n\t\t\twhile ( to !== -1 && times[ to ] > endTime ) -- to;\n\t\n\t\t\t++ to; // inclusive -> exclusive bound\n\t\n\t\t\tif( from !== 0 || to !== nKeys ) {\n\t\n\t\t\t\t// empty tracks are forbidden, so keep at least one keyframe\n\t\t\t\tif ( from >= to ) to = Math.max( to , 1 ), from = to - 1;\n\t\n\t\t\t\tvar stride = this.getValueSize();\n\t\t\t\tthis.times = THREE.AnimationUtils.arraySlice( times, from, to );\n\t\t\t\tthis.values = THREE.AnimationUtils.\n\t\t\t\t\t\tarraySlice( this.values, from * stride, to * stride );\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\t// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\n\t\tvalidate: function() {\n\t\n\t\t\tvar valid = true;\n\t\n\t\t\tvar valueSize = this.getValueSize();\n\t\t\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\n\t\n\t\t\t\tconsole.error( \"invalid value size in track\", this );\n\t\t\t\tvalid = false;\n\t\n\t\t\t}\n\t\n\t\t\tvar times = this.times,\n\t\t\t\tvalues = this.values,\n\t\n\t\t\t\tnKeys = times.length;\n\t\n\t\t\tif( nKeys === 0 ) {\n\t\n\t\t\t\tconsole.error( \"track is empty\", this );\n\t\t\t\tvalid = false;\n\t\n\t\t\t}\n\t\n\t\t\tvar prevTime = null;\n\t\n\t\t\tfor( var i = 0; i !== nKeys; i ++ ) {\n\t\n\t\t\t\tvar currTime = times[ i ];\n\t\n\t\t\t\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\n\t\n\t\t\t\t\tconsole.error( \"time is not a valid number\", this, i, currTime );\n\t\t\t\t\tvalid = false;\n\t\t\t\t\tbreak;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif( prevTime !== null && prevTime > currTime ) {\n\t\n\t\t\t\t\tconsole.error( \"out of order keys\", this, i, currTime, prevTime );\n\t\t\t\t\tvalid = false;\n\t\t\t\t\tbreak;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tprevTime = currTime;\n\t\n\t\t\t}\n\t\n\t\t\tif ( values !== undefined ) {\n\t\n\t\t\t\tif ( THREE.AnimationUtils.isTypedArray( values ) ) {\n\t\n\t\t\t\t\tfor ( var i = 0, n = values.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\tvar value = values[ i ];\n\t\n\t\t\t\t\t\tif ( isNaN( value ) ) {\n\t\n\t\t\t\t\t\t\tconsole.error( \"value is not a valid number\", this, i, value );\n\t\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn valid;\n\t\n\t\t},\n\t\n\t\t// removes equivalent sequential keys as common in morph target sequences\n\t\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n\t\toptimize: function() {\n\t\n\t\t\tvar times = this.times,\n\t\t\t\tvalues = this.values,\n\t\t\t\tstride = this.getValueSize(),\n\t\n\t\t\t\twriteIndex = 1;\n\t\n\t\t\tfor( var i = 1, n = times.length - 1; i <= n; ++ i ) {\n\t\n\t\t\t\tvar keep = false;\n\t\n\t\t\t\tvar time = times[ i ];\n\t\t\t\tvar timeNext = times[ i + 1 ];\n\t\n\t\t\t\t// remove adjacent keyframes scheduled at the same time\n\t\n\t\t\t\tif ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {\n\t\n\t\t\t\t\t// remove unnecessary keyframes same as their neighbors\n\t\t\t\t\tvar offset = i * stride,\n\t\t\t\t\t\toffsetP = offset - stride,\n\t\t\t\t\t\toffsetN = offset + stride;\n\t\n\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\t\n\t\t\t\t\t\tvar value = values[ offset + j ];\n\t\n\t\t\t\t\t\tif ( value !== values[ offsetP + j ] ||\n\t\t\t\t\t\t\t\tvalue !== values[ offsetN + j ] ) {\n\t\n\t\t\t\t\t\t\tkeep = true;\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// in-place compaction\n\t\n\t\t\t\tif ( keep ) {\n\t\n\t\t\t\t\tif ( i !== writeIndex ) {\n\t\n\t\t\t\t\t\ttimes[ writeIndex ] = times[ i ];\n\t\n\t\t\t\t\t\tvar readOffset = i * stride,\n\t\t\t\t\t\t\twriteOffset = writeIndex * stride;\n\t\n\t\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\t\n\t\t\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\t\n\t\t\t\t\t\t}\n\t\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t++ writeIndex;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif ( writeIndex !== times.length ) {\n\t\n\t\t\t\tthis.times = THREE.AnimationUtils.arraySlice( times, 0, writeIndex );\n\t\t\t\tthis.values = THREE.AnimationUtils.arraySlice( values, 0, writeIndex * stride );\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t};\n\t\n\t// Static methods:\n\t\n\tObject.assign( THREE.KeyframeTrack, {\n\t\n\t\t// Serialization (in static context, because of constructor invocation\n\t\t// and automatic invocation of .toJSON):\n\t\n\t\tparse: function( json ) {\n\t\n\t\t\tif( json.type === undefined ) {\n\t\n\t\t\t\tthrow new Error( \"track type undefined, can not parse\" );\n\t\n\t\t\t}\n\t\n\t\t\tvar trackType = THREE.KeyframeTrack._getTrackTypeForValueTypeName( json.type );\n\t\n\t\t\tif ( json.times === undefined ) {\n\t\n\t\t\t\tvar times = [], values = [];\n\t\n\t\t\t\tTHREE.AnimationUtils.flattenJSON( json.keys, times, values, 'value' );\n\t\n\t\t\t\tjson.times = times;\n\t\t\t\tjson.values = values;\n\t\n\t\t\t}\n\t\n\t\t\t// derived classes can define a static parse method\n\t\t\tif ( trackType.parse !== undefined ) {\n\t\n\t\t\t\treturn trackType.parse( json );\n\t\n\t\t\t} else {\n\t\n\t\t\t\t// by default, we asssume a constructor compatible with the base\n\t\t\t\treturn new trackType(\n\t\t\t\t\t\tjson.name, json.times, json.values, json.interpolation );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\ttoJSON: function( track ) {\n\t\n\t\t\tvar trackType = track.constructor;\n\t\n\t\t\tvar json;\n\t\n\t\t\t// derived classes can define a static toJSON method\n\t\t\tif ( trackType.toJSON !== undefined ) {\n\t\n\t\t\t\tjson = trackType.toJSON( track );\n\t\n\t\t\t} else {\n\t\n\t\t\t\t// by default, we assume the data can be serialized as-is\n\t\t\t\tjson = {\n\t\n\t\t\t\t\t'name': track.name,\n\t\t\t\t\t'times': THREE.AnimationUtils.convertArray( track.times, Array ),\n\t\t\t\t\t'values': THREE.AnimationUtils.convertArray( track.values, Array )\n\t\n\t\t\t\t};\n\t\n\t\t\t\tvar interpolation = track.getInterpolation();\n\t\n\t\t\t\tif ( interpolation !== track.DefaultInterpolation ) {\n\t\n\t\t\t\t\tjson.interpolation = interpolation;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tjson.type = track.ValueTypeName; // mandatory\n\t\n\t\t\treturn json;\n\t\n\t\t},\n\t\n\t\t_getTrackTypeForValueTypeName: function( typeName ) {\n\t\n\t\t\tswitch( typeName.toLowerCase() ) {\n\t\n\t\t\t\tcase \"scalar\":\n\t\t\t\tcase \"double\":\n\t\t\t\tcase \"float\":\n\t\t\t\tcase \"number\":\n\t\t\t\tcase \"integer\":\n\t\n\t\t\t\t\treturn THREE.NumberKeyframeTrack;\n\t\n\t\t\t\tcase \"vector\":\n\t\t\t\tcase \"vector2\":\n\t\t\t\tcase \"vector3\":\n\t\t\t\tcase \"vector4\":\n\t\n\t\t\t\t\treturn THREE.VectorKeyframeTrack;\n\t\n\t\t\t\tcase \"color\":\n\t\n\t\t\t\t\treturn THREE.ColorKeyframeTrack;\n\t\n\t\t\t\tcase \"quaternion\":\n\t\n\t\t\t\t\treturn THREE.QuaternionKeyframeTrack;\n\t\n\t\t\t\tcase \"bool\":\n\t\t\t\tcase \"boolean\":\n\t\n\t\t\t\t\treturn THREE.BooleanKeyframeTrack;\n\t\n\t\t\t\tcase \"string\":\n\t\n\t\t\t\t\treturn THREE.StringKeyframeTrack;\n\t\n\t\t\t}\n\t\n\t\t\tthrow new Error( \"Unsupported typeName: \" + typeName );\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/animation/PropertyBinding.js\n\t\n\t/**\n\t *\n\t * A reference to a real property in the scene graph.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\t\n\tTHREE.PropertyBinding = function ( rootNode, path, parsedPath ) {\n\t\n\t\tthis.path = path;\n\t\tthis.parsedPath = parsedPath ||\n\t\t\t\tTHREE.PropertyBinding.parseTrackName( path );\n\t\n\t\tthis.node = THREE.PropertyBinding.findNode(\n\t\t\t\trootNode, this.parsedPath.nodeName ) || rootNode;\n\t\n\t\tthis.rootNode = rootNode;\n\t\n\t};\n\t\n\tTHREE.PropertyBinding.prototype = {\n\t\n\t\tconstructor: THREE.PropertyBinding,\n\t\n\t\tgetValue: function getValue_unbound( targetArray, offset ) {\n\t\n\t\t\tthis.bind();\n\t\t\tthis.getValue( targetArray, offset );\n\t\n\t\t\t// Note: This class uses a State pattern on a per-method basis:\n\t\t\t// 'bind' sets 'this.getValue' / 'setValue' and shadows the\n\t\t\t// prototype version of these methods with one that represents\n\t\t\t// the bound state. When the property is not found, the methods\n\t\t\t// become no-ops.\n\t\n\t\t},\n\t\n\t\tsetValue: function getValue_unbound( sourceArray, offset ) {\n\t\n\t\t\tthis.bind();\n\t\t\tthis.setValue( sourceArray, offset );\n\t\n\t\t},\n\t\n\t\t// create getter / setter pair for a property in the scene graph\n\t\tbind: function() {\n\t\n\t\t\tvar targetObject = this.node,\n\t\t\t\tparsedPath = this.parsedPath,\n\t\n\t\t\t\tobjectName = parsedPath.objectName,\n\t\t\t\tpropertyName = parsedPath.propertyName,\n\t\t\t\tpropertyIndex = parsedPath.propertyIndex;\n\t\n\t\t\tif ( ! targetObject ) {\n\t\n\t\t\t\ttargetObject = THREE.PropertyBinding.findNode(\n\t\t\t\t\t\tthis.rootNode, parsedPath.nodeName ) || this.rootNode;\n\t\n\t\t\t\tthis.node = targetObject;\n\t\n\t\t\t}\n\t\n\t\t\t// set fail state so we can just 'return' on error\n\t\t\tthis.getValue = this._getValue_unavailable;\n\t\t\tthis.setValue = this._setValue_unavailable;\n\t\n\t \t\t// ensure there is a value node\n\t\t\tif ( ! targetObject ) {\n\t\n\t\t\t\tconsole.error( \"  trying to update node for track: \" + this.path + \" but it wasn't found.\" );\n\t\t\t\treturn;\n\t\n\t\t\t}\n\t\n\t\t\tif ( objectName ) {\n\t\n\t\t\t\tvar objectIndex = parsedPath.objectIndex;\n\t\n\t\t\t\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\n\t\t\t\tswitch ( objectName ) {\n\t\n\t\t\t\t\tcase 'materials':\n\t\n\t\t\t\t\t\tif ( ! targetObject.material ) {\n\t\n\t\t\t\t\t\t\tconsole.error( '  can not bind to material as node does not have a material', this );\n\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( ! targetObject.material.materials ) {\n\t\n\t\t\t\t\t\t\tconsole.error( '  can not bind to material.materials as node.material does not have a materials array', this );\n\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\ttargetObject = targetObject.material.materials;\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'bones':\n\t\n\t\t\t\t\t\tif ( ! targetObject.skeleton ) {\n\t\n\t\t\t\t\t\t\tconsole.error( '  can not bind to bones as node does not have a skeleton', this );\n\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// potential future optimization: skip this if propertyIndex is already an integer\n\t\t\t\t\t\t// and convert the integer string to a true integer.\n\t\n\t\t\t\t\t\ttargetObject = targetObject.skeleton.bones;\n\t\n\t\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\t\tfor ( var i = 0; i < targetObject.length; i ++ ) {\n\t\n\t\t\t\t\t\t\tif ( targetObject[ i ].name === objectIndex ) {\n\t\n\t\t\t\t\t\t\t\tobjectIndex = i;\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tdefault:\n\t\n\t\t\t\t\t\tif ( targetObject[ objectName ] === undefined ) {\n\t\n\t\t\t\t\t\t\tconsole.error( '  can not bind to objectName of node, undefined', this );\n\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\ttargetObject = targetObject[ objectName ];\n\t\n\t\t\t\t}\n\t\n\t\n\t\t\t\tif ( objectIndex !== undefined ) {\n\t\n\t\t\t\t\tif ( targetObject[ objectIndex ] === undefined ) {\n\t\n\t\t\t\t\t\tconsole.error( \"  trying to bind to objectIndex of objectName, but is undefined:\", this, targetObject );\n\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttargetObject = targetObject[ objectIndex ];\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// resolve property\n\t\t\tvar nodeProperty = targetObject[ propertyName ];\n\t\n\t\t\tif ( nodeProperty === undefined ) {\n\t\n\t\t\t\tvar nodeName = parsedPath.nodeName;\n\t\n\t\t\t\tconsole.error( \"  trying to update property for track: \" + nodeName +\n\t\t\t\t\t\t'.' + propertyName + \" but it wasn't found.\", targetObject );\n\t\t\t\treturn;\n\t\n\t\t\t}\n\t\n\t\t\t// determine versioning scheme\n\t\t\tvar versioning = this.Versioning.None;\n\t\n\t\t\tif ( targetObject.needsUpdate !== undefined ) { // material\n\t\n\t\t\t\tversioning = this.Versioning.NeedsUpdate;\n\t\t\t\tthis.targetObject = targetObject;\n\t\n\t\t\t} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\n\t\n\t\t\t\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\n\t\t\t\tthis.targetObject = targetObject;\n\t\n\t\t\t}\n\t\n\t\t\t// determine how the property gets bound\n\t\t\tvar bindingType = this.BindingType.Direct;\n\t\n\t\t\tif ( propertyIndex !== undefined ) {\n\t\t\t\t// access a sub element of the property array (only primitives are supported right now)\n\t\n\t\t\t\tif ( propertyName === \"morphTargetInfluences\" ) {\n\t\t\t\t\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\n\t\n\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\tif ( ! targetObject.geometry ) {\n\t\n\t\t\t\t\t\tconsole.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );\n\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( ! targetObject.geometry.morphTargets ) {\n\t\n\t\t\t\t\t\tconsole.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );\n\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {\n\t\n\t\t\t\t\t\tif ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {\n\t\n\t\t\t\t\t\t\tpropertyIndex = i;\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tbindingType = this.BindingType.ArrayElement;\n\t\n\t\t\t\tthis.resolvedProperty = nodeProperty;\n\t\t\t\tthis.propertyIndex = propertyIndex;\n\t\n\t\t\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\n\t\t\t\t// must use copy for Object3D.Euler/Quaternion\n\t\n\t\t\t\tbindingType = this.BindingType.HasFromToArray;\n\t\n\t\t\t\tthis.resolvedProperty = nodeProperty;\n\t\n\t\t\t} else if ( nodeProperty.length !== undefined ) {\n\t\n\t\t\t\tbindingType = this.BindingType.EntireArray;\n\t\n\t\t\t\tthis.resolvedProperty = nodeProperty;\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.propertyName = propertyName;\n\t\n\t\t\t}\n\t\n\t\t\t// select getter / setter\n\t\t\tthis.getValue = this.GetterByBindingType[ bindingType ];\n\t\t\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\n\t\n\t\t},\n\t\n\t\tunbind: function() {\n\t\n\t\t\tthis.node = null;\n\t\n\t\t\t// back to the prototype version of getValue / setValue\n\t\t\t// note: avoiding to mutate the shape of 'this' via 'delete'\n\t\t\tthis.getValue = this._getValue_unbound;\n\t\t\tthis.setValue = this._setValue_unbound;\n\t\n\t\t}\n\t\n\t};\n\t\n\tObject.assign( THREE.PropertyBinding.prototype, { // prototype, continued\n\t\n\t\t// these are used to \"bind\" a nonexistent property\n\t\t_getValue_unavailable: function() {},\n\t\t_setValue_unavailable: function() {},\n\t\n\t\t// initial state of these methods that calls 'bind'\n\t\t_getValue_unbound: THREE.PropertyBinding.prototype.getValue,\n\t\t_setValue_unbound: THREE.PropertyBinding.prototype.setValue,\n\t\n\t\tBindingType: {\n\t\t\tDirect: 0,\n\t\t\tEntireArray: 1,\n\t\t\tArrayElement: 2,\n\t\t\tHasFromToArray: 3\n\t\t},\n\t\n\t\tVersioning: {\n\t\t\tNone: 0,\n\t\t\tNeedsUpdate: 1,\n\t\t\tMatrixWorldNeedsUpdate: 2\n\t\t},\n\t\n\t\tGetterByBindingType: [\n\t\n\t\t\tfunction getValue_direct( buffer, offset ) {\n\t\n\t\t\t\tbuffer[ offset ] = this.node[ this.propertyName ];\n\t\n\t\t\t},\n\t\n\t\t\tfunction getValue_array( buffer, offset ) {\n\t\n\t\t\t\tvar source = this.resolvedProperty;\n\t\n\t\t\t\tfor ( var i = 0, n = source.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tbuffer[ offset ++ ] = source[ i ];\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tfunction getValue_arrayElement( buffer, offset ) {\n\t\n\t\t\t\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\n\t\n\t\t\t},\n\t\n\t\t\tfunction getValue_toArray( buffer, offset ) {\n\t\n\t\t\t\tthis.resolvedProperty.toArray( buffer, offset );\n\t\n\t\t\t}\n\t\n\t\t],\n\t\n\t\tSetterByBindingTypeAndVersioning: [\n\t\n\t\t\t[\n\t\t\t\t// Direct\n\t\n\t\t\t\tfunction setValue_direct( buffer, offset ) {\n\t\n\t\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\t\n\t\t\t\t},\n\t\n\t\t\t\tfunction setValue_direct_setNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tfunction setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t], [\n\t\n\t\t\t\t// EntireArray\n\t\n\t\t\t\tfunction setValue_array( buffer, offset ) {\n\t\n\t\t\t\t\tvar dest = this.resolvedProperty;\n\t\n\t\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t},\n\t\n\t\t\t\tfunction setValue_array_setNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\tvar dest = this.resolvedProperty;\n\t\n\t\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tfunction setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\tvar dest = this.resolvedProperty;\n\t\n\t\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t], [\n\t\n\t\t\t\t// ArrayElement\n\t\n\t\t\t\tfunction setValue_arrayElement( buffer, offset ) {\n\t\n\t\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\n\t\t\t\t},\n\t\n\t\t\t\tfunction setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tfunction setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t], [\n\t\n\t\t\t\t// HasToFromArray\n\t\n\t\t\t\tfunction setValue_fromArray( buffer, offset ) {\n\t\n\t\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\n\t\t\t\t},\n\t\n\t\t\t\tfunction setValue_fromArray_setNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tfunction setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t]\n\t\n\t\t]\n\t\n\t} );\n\t\n\tTHREE.PropertyBinding.Composite =\n\t\t\tfunction( targetGroup, path, optionalParsedPath ) {\n\t\n\t\tvar parsedPath = optionalParsedPath ||\n\t\t\t\tTHREE.PropertyBinding.parseTrackName( path );\n\t\n\t\tthis._targetGroup = targetGroup;\n\t\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\n\t\n\t};\n\t\n\tTHREE.PropertyBinding.Composite.prototype = {\n\t\n\t\tconstructor: THREE.PropertyBinding.Composite,\n\t\n\t\tgetValue: function( array, offset ) {\n\t\n\t\t\tthis.bind(); // bind all binding\n\t\n\t\t\tvar firstValidIndex = this._targetGroup.nCachedObjects_,\n\t\t\t\tbinding = this._bindings[ firstValidIndex ];\n\t\n\t\t\t// and only call .getValue on the first\n\t\t\tif ( binding !== undefined ) binding.getValue( array, offset );\n\t\n\t\t},\n\t\n\t\tsetValue: function( array, offset ) {\n\t\n\t\t\tvar bindings = this._bindings;\n\t\n\t\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\t\n\t\t\t\tbindings[ i ].setValue( array, offset );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tbind: function() {\n\t\n\t\t\tvar bindings = this._bindings;\n\t\n\t\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\t\n\t\t\t\tbindings[ i ].bind();\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tunbind: function() {\n\t\n\t\t\tvar bindings = this._bindings;\n\t\n\t\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\t\n\t\t\t\tbindings[ i ].unbind();\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.PropertyBinding.create = function( root, path, parsedPath ) {\n\t\n\t\tif ( ! ( root instanceof THREE.AnimationObjectGroup ) ) {\n\t\n\t\t\treturn new THREE.PropertyBinding( root, path, parsedPath );\n\t\n\t\t} else {\n\t\n\t\t\treturn new THREE.PropertyBinding.Composite( root, path, parsedPath );\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.PropertyBinding.parseTrackName = function( trackName ) {\n\t\n\t\t// matches strings in the form of:\n\t\t//    nodeName.property\n\t\t//    nodeName.property[accessor]\n\t\t//    nodeName.material.property[accessor]\n\t\t//    uuid.property[accessor]\n\t\t//    uuid.objectName[objectIndex].propertyName[propertyIndex]\n\t\t//    parentName/nodeName.property\n\t\t//    parentName/parentName/nodeName.property[index]\n\t\t//\t  .bone[Armature.DEF_cog].position\n\t\t// created and tested via https://regex101.com/#javascript\n\t\n\t\tvar re = /^(([\\w]+\\/)*)([\\w-\\d]+)?(\\.([\\w]+)(\\[([\\w\\d\\[\\]\\_.:\\- ]+)\\])?)?(\\.([\\w.]+)(\\[([\\w\\d\\[\\]\\_. ]+)\\])?)$/;\n\t\tvar matches = re.exec( trackName );\n\t\n\t\tif ( ! matches ) {\n\t\n\t\t\tthrow new Error( \"cannot parse trackName at all: \" + trackName );\n\t\n\t\t}\n\t\n\t\tif ( matches.index === re.lastIndex ) {\n\t\n\t\t\tre.lastIndex++;\n\t\n\t\t}\n\t\n\t\tvar results = {\n\t\t\t// directoryName: matches[ 1 ], // (tschw) currently unused\n\t\t\tnodeName: matches[ 3 ], \t// allowed to be null, specified root node.\n\t\t\tobjectName: matches[ 5 ],\n\t\t\tobjectIndex: matches[ 7 ],\n\t\t\tpropertyName: matches[ 9 ],\n\t\t\tpropertyIndex: matches[ 11 ]\t// allowed to be null, specifies that the whole property is set.\n\t\t};\n\t\n\t\tif ( results.propertyName === null || results.propertyName.length === 0 ) {\n\t\n\t\t\tthrow new Error( \"can not parse propertyName from trackName: \" + trackName );\n\t\n\t\t}\n\t\n\t\treturn results;\n\t\n\t};\n\t\n\tTHREE.PropertyBinding.findNode = function( root, nodeName ) {\n\t\n\t\tif ( ! nodeName || nodeName === \"\" || nodeName === \"root\" || nodeName === \".\" || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {\n\t\n\t\t\treturn root;\n\t\n\t\t}\n\t\n\t\t// search into skeleton bones.\n\t\tif ( root.skeleton ) {\n\t\n\t\t\tvar searchSkeleton = function( skeleton ) {\n\t\n\t\t\t\tfor( var i = 0; i < skeleton.bones.length; i ++ ) {\n\t\n\t\t\t\t\tvar bone = skeleton.bones[ i ];\n\t\n\t\t\t\t\tif ( bone.name === nodeName ) {\n\t\n\t\t\t\t\t\treturn bone;\n\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\treturn null;\n\t\n\t\t\t};\n\t\n\t\t\tvar bone = searchSkeleton( root.skeleton );\n\t\n\t\t\tif ( bone ) {\n\t\n\t\t\t\treturn bone;\n\t\n\t\t\t}\n\t\t}\n\t\n\t\t// search into node subtree.\n\t\tif ( root.children ) {\n\t\n\t\t\tvar searchNodeSubtree = function( children ) {\n\t\n\t\t\t\tfor( var i = 0; i < children.length; i ++ ) {\n\t\n\t\t\t\t\tvar childNode = children[ i ];\n\t\n\t\t\t\t\tif ( childNode.name === nodeName || childNode.uuid === nodeName ) {\n\t\n\t\t\t\t\t\treturn childNode;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar result = searchNodeSubtree( childNode.children );\n\t\n\t\t\t\t\tif ( result ) return result;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn null;\n\t\n\t\t\t};\n\t\n\t\t\tvar subTreeNode = searchNodeSubtree( root.children );\n\t\n\t\t\tif ( subTreeNode ) {\n\t\n\t\t\t\treturn subTreeNode;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\treturn null;\n\t\n\t};\n\t\n\t// File:src/animation/PropertyMixer.js\n\t\n\t/**\n\t *\n\t * Buffered scene graph property that allows weighted accumulation.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\t\n\tTHREE.PropertyMixer = function ( binding, typeName, valueSize ) {\n\t\n\t\tthis.binding = binding;\n\t\tthis.valueSize = valueSize;\n\t\n\t\tvar bufferType = Float64Array,\n\t\t\tmixFunction;\n\t\n\t\tswitch ( typeName ) {\n\t\n\t\t\tcase 'quaternion':\t\t\tmixFunction = this._slerp;\t\tbreak;\n\t\n\t\t\tcase 'string':\n\t\t\tcase 'bool':\n\t\n\t\t\t\tbufferType = Array,\t\tmixFunction = this._select;\t\tbreak;\n\t\n\t\t\tdefault:\t\t\t\t\tmixFunction = this._lerp;\n\t\n\t\t}\n\t\n\t\tthis.buffer = new bufferType( valueSize * 4 );\n\t\t// layout: [ incoming | accu0 | accu1 | orig ]\n\t\t//\n\t\t// interpolators can use .buffer as their .result\n\t\t// the data then goes to 'incoming'\n\t\t//\n\t\t// 'accu0' and 'accu1' are used frame-interleaved for\n\t\t// the cumulative result and are compared to detect\n\t\t// changes\n\t\t//\n\t\t// 'orig' stores the original state of the property\n\t\n\t\tthis._mixBufferRegion = mixFunction;\n\t\n\t\tthis.cumulativeWeight = 0;\n\t\n\t\tthis.useCount = 0;\n\t\tthis.referenceCount = 0;\n\t\n\t};\n\t\n\tTHREE.PropertyMixer.prototype = {\n\t\n\t\tconstructor: THREE.PropertyMixer,\n\t\n\t\t// accumulate data in the 'incoming' region into 'accu<i>'\n\t\taccumulate: function( accuIndex, weight ) {\n\t\n\t\t\t// note: happily accumulating nothing when weight = 0, the caller knows\n\t\t\t// the weight and shouldn't have made the call in the first place\n\t\n\t\t\tvar buffer = this.buffer,\n\t\t\t\tstride = this.valueSize,\n\t\t\t\toffset = accuIndex * stride + stride,\n\t\n\t\t\t\tcurrentWeight = this.cumulativeWeight;\n\t\n\t\t\tif ( currentWeight === 0 ) {\n\t\n\t\t\t\t// accuN := incoming * weight\n\t\n\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\t\n\t\t\t\t\tbuffer[ offset + i ] = buffer[ i ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tcurrentWeight = weight;\n\t\n\t\t\t} else {\n\t\n\t\t\t\t// accuN := accuN + incoming * weight\n\t\n\t\t\t\tcurrentWeight += weight;\n\t\t\t\tvar mix = weight / currentWeight;\n\t\t\t\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\n\t\n\t\t\t}\n\t\n\t\t\tthis.cumulativeWeight = currentWeight;\n\t\n\t\t},\n\t\n\t\t// apply the state of 'accu<i>' to the binding when accus differ\n\t\tapply: function( accuIndex ) {\n\t\n\t\t\tvar stride = this.valueSize,\n\t\t\t\tbuffer = this.buffer,\n\t\t\t\toffset = accuIndex * stride + stride,\n\t\n\t\t\t\tweight = this.cumulativeWeight,\n\t\n\t\t\t\tbinding = this.binding;\n\t\n\t\t\tthis.cumulativeWeight = 0;\n\t\n\t\t\tif ( weight < 1 ) {\n\t\n\t\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\n\t\n\t\t\t\tvar originalValueOffset = stride * 3;\n\t\n\t\t\t\tthis._mixBufferRegion(\n\t\t\t\t\t\tbuffer, offset, originalValueOffset, 1 - weight, stride );\n\t\n\t\t\t}\n\t\n\t\t\tfor ( var i = stride, e = stride + stride; i !== e; ++ i ) {\n\t\n\t\t\t\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\n\t\n\t\t\t\t\t// value has changed -> update scene graph\n\t\n\t\t\t\t\tbinding.setValue( buffer, offset );\n\t\t\t\t\tbreak;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\t// remember the state of the bound property and copy it to both accus\n\t\tsaveOriginalState: function() {\n\t\n\t\t\tvar binding = this.binding;\n\t\n\t\t\tvar buffer = this.buffer,\n\t\t\t\tstride = this.valueSize,\n\t\n\t\t\t\toriginalValueOffset = stride * 3;\n\t\n\t\t\tbinding.getValue( buffer, originalValueOffset );\n\t\n\t\t\t// accu[0..1] := orig -- initially detect changes against the original\n\t\t\tfor ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {\n\t\n\t\t\t\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\n\t\n\t\t\t}\n\t\n\t\t\tthis.cumulativeWeight = 0;\n\t\n\t\t},\n\t\n\t\t// apply the state previously taken via 'saveOriginalState' to the binding\n\t\trestoreOriginalState: function() {\n\t\n\t\t\tvar originalValueOffset = this.valueSize * 3;\n\t\t\tthis.binding.setValue( this.buffer, originalValueOffset );\n\t\n\t\t},\n\t\n\t\n\t\t// mix functions\n\t\n\t\t_select: function( buffer, dstOffset, srcOffset, t, stride ) {\n\t\n\t\t\tif ( t >= 0.5 ) {\n\t\n\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\t\n\t\t\t\t\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\t_slerp: function( buffer, dstOffset, srcOffset, t, stride ) {\n\t\n\t\t\tTHREE.Quaternion.slerpFlat( buffer, dstOffset,\n\t\t\t\t\tbuffer, dstOffset, buffer, srcOffset, t );\n\t\n\t\t},\n\t\n\t\t_lerp: function( buffer, dstOffset, srcOffset, t, stride ) {\n\t\n\t\t\tvar s = 1 - t;\n\t\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\t\n\t\t\t\tvar j = dstOffset + i;\n\t\n\t\t\t\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/animation/tracks/BooleanKeyframeTrack.js\n\t\n\t/**\n\t *\n\t * A Track of Boolean keyframe values.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\t\n\tTHREE.BooleanKeyframeTrack = function ( name, times, values ) {\n\t\n\t\tTHREE.KeyframeTrack.call( this, name, times, values );\n\t\n\t};\n\t\n\tTHREE.BooleanKeyframeTrack.prototype =\n\t\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\t\n\t\tconstructor: THREE.BooleanKeyframeTrack,\n\t\n\t\tValueTypeName: 'bool',\n\t\tValueBufferType: Array,\n\t\n\t\tDefaultInterpolation: THREE.InterpolateDiscrete,\n\t\n\t\tInterpolantFactoryMethodLinear: undefined,\n\t\tInterpolantFactoryMethodSmooth: undefined\n\t\n\t\t// Note: Actually this track could have a optimized / compressed\n\t\t// representation of a single value and a custom interpolant that\n\t\t// computes \"firstValue ^ isOdd( index )\".\n\t\n\t} );\n\t\n\t// File:src/animation/tracks/ColorKeyframeTrack.js\n\t\n\t/**\n\t *\n\t * A Track of keyframe values that represent color.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\t\n\tTHREE.ColorKeyframeTrack = function ( name, times, values, interpolation ) {\n\t\n\t\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\n\t\n\t};\n\t\n\tTHREE.ColorKeyframeTrack.prototype =\n\t\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\t\n\t\tconstructor: THREE.ColorKeyframeTrack,\n\t\n\t\tValueTypeName: 'color'\n\t\n\t\t// ValueBufferType is inherited\n\t\n\t\t// DefaultInterpolation is inherited\n\t\n\t\n\t\t// Note: Very basic implementation and nothing special yet.\n\t\t// However, this is the place for color space parameterization.\n\t\n\t} );\n\t\n\t// File:src/animation/tracks/NumberKeyframeTrack.js\n\t\n\t/**\n\t *\n\t * A Track of numeric keyframe values.\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\t\n\tTHREE.NumberKeyframeTrack = function ( name, times, values, interpolation ) {\n\t\n\t\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\n\t\n\t};\n\t\n\tTHREE.NumberKeyframeTrack.prototype =\n\t\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\t\n\t\tconstructor: THREE.NumberKeyframeTrack,\n\t\n\t\tValueTypeName: 'number',\n\t\n\t\t// ValueBufferType is inherited\n\t\n\t\t// DefaultInterpolation is inherited\n\t\n\t} );\n\t\n\t// File:src/animation/tracks/QuaternionKeyframeTrack.js\n\t\n\t/**\n\t *\n\t * A Track of quaternion keyframe values.\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\t\n\tTHREE.QuaternionKeyframeTrack = function ( name, times, values, interpolation ) {\n\t\n\t\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\n\t\n\t};\n\t\n\tTHREE.QuaternionKeyframeTrack.prototype =\n\t\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\t\n\t\tconstructor: THREE.QuaternionKeyframeTrack,\n\t\n\t\tValueTypeName: 'quaternion',\n\t\n\t\t// ValueBufferType is inherited\n\t\n\t\tDefaultInterpolation: THREE.InterpolateLinear,\n\t\n\t\tInterpolantFactoryMethodLinear: function( result ) {\n\t\n\t\t\treturn new THREE.QuaternionLinearInterpolant(\n\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\t\n\t\t},\n\t\n\t\tInterpolantFactoryMethodSmooth: undefined // not yet implemented\n\t\n\t} );\n\t\n\t// File:src/animation/tracks/StringKeyframeTrack.js\n\t\n\t/**\n\t *\n\t * A Track that interpolates Strings\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\t\n\tTHREE.StringKeyframeTrack = function ( name, times, values, interpolation ) {\n\t\n\t\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\n\t\n\t};\n\t\n\tTHREE.StringKeyframeTrack.prototype =\n\t\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\t\n\t\tconstructor: THREE.StringKeyframeTrack,\n\t\n\t\tValueTypeName: 'string',\n\t\tValueBufferType: Array,\n\t\n\t\tDefaultInterpolation: THREE.InterpolateDiscrete,\n\t\n\t\tInterpolantFactoryMethodLinear: undefined,\n\t\n\t\tInterpolantFactoryMethodSmooth: undefined\n\t\n\t} );\n\t\n\t// File:src/animation/tracks/VectorKeyframeTrack.js\n\t\n\t/**\n\t *\n\t * A Track of vectored keyframe values.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\t\n\tTHREE.VectorKeyframeTrack = function ( name, times, values, interpolation ) {\n\t\n\t\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\n\t\n\t};\n\t\n\tTHREE.VectorKeyframeTrack.prototype =\n\t\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\t\n\t\tconstructor: THREE.VectorKeyframeTrack,\n\t\n\t\tValueTypeName: 'vector'\n\t\n\t\t// ValueBufferType is inherited\n\t\n\t\t// DefaultInterpolation is inherited\n\t\n\t} );\n\t\n\t// File:src/audio/Audio.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author Reece Aaron Lecrivain / http://reecenotes.com/\n\t */\n\t\n\tTHREE.Audio = function ( listener ) {\n\t\n\t\tTHREE.Object3D.call( this );\n\t\n\t\tthis.type = 'Audio';\n\t\n\t\tthis.context = listener.context;\n\t\tthis.source = this.context.createBufferSource();\n\t\tthis.source.onended = this.onEnded.bind( this );\n\t\n\t\tthis.gain = this.context.createGain();\n\t\tthis.gain.connect( listener.getInput() );\n\t\n\t\tthis.autoplay = false;\n\t\n\t\tthis.startTime = 0;\n\t\tthis.playbackRate = 1;\n\t\tthis.isPlaying = false;\n\t\tthis.hasPlaybackControl = true;\n\t\tthis.sourceType = 'empty';\n\t\n\t\tthis.filters = [];\n\t\n\t};\n\t\n\tTHREE.Audio.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\t\n\t\tconstructor: THREE.Audio,\n\t\n\t\tgetOutput: function () {\n\t\n\t\t\treturn this.gain;\n\t\n\t\t},\n\t\n\t\tsetNodeSource: function ( audioNode ) {\n\t\n\t\t\tthis.hasPlaybackControl = false;\n\t\t\tthis.sourceType = 'audioNode';\n\t\t\tthis.source = audioNode;\n\t\t\tthis.connect();\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetBuffer: function ( audioBuffer ) {\n\t\n\t\t\tthis.source.buffer = audioBuffer;\n\t\t\tthis.sourceType = 'buffer';\n\t\n\t\t\tif ( this.autoplay ) this.play();\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tplay: function () {\n\t\n\t\t\tif ( this.isPlaying === true ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Audio: Audio is already playing.' );\n\t\t\t\treturn;\n\t\n\t\t\t}\n\t\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn;\n\t\n\t\t\t}\n\t\n\t\t\tvar source = this.context.createBufferSource();\n\t\n\t\t\tsource.buffer = this.source.buffer;\n\t\t\tsource.loop = this.source.loop;\n\t\t\tsource.onended = this.source.onended;\n\t\t\tsource.start( 0, this.startTime );\n\t\t\tsource.playbackRate.value = this.playbackRate;\n\t\n\t\t\tthis.isPlaying = true;\n\t\n\t\t\tthis.source = source;\n\t\n\t\t\treturn this.connect();\n\t\n\t\t},\n\t\n\t\tpause: function () {\n\t\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn;\n\t\n\t\t\t}\n\t\n\t\t\tthis.source.stop();\n\t\t\tthis.startTime = this.context.currentTime;\n\t\t\tthis.isPlaying = false;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tstop: function () {\n\t\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn;\n\t\n\t\t\t}\n\t\n\t\t\tthis.source.stop();\n\t\t\tthis.startTime = 0;\n\t\t\tthis.isPlaying = false;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tconnect: function () {\n\t\n\t\t\tif ( this.filters.length > 0 ) {\n\t\n\t\t\t\tthis.source.connect( this.filters[ 0 ] );\n\t\n\t\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tthis.filters[ i - 1 ].connect( this.filters[ i ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.filters[ this.filters.length - 1 ].connect( this.getOutput() );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.source.connect( this.getOutput() );\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tdisconnect: function () {\n\t\n\t\t\tif ( this.filters.length > 0 ) {\n\t\n\t\t\t\tthis.source.disconnect( this.filters[ 0 ] );\n\t\n\t\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tthis.filters[ i - 1 ].disconnect( this.filters[ i ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.source.disconnect( this.getOutput() );\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tgetFilters: function () {\n\t\n\t\t\treturn this.filters;\n\t\n\t\t},\n\t\n\t\tsetFilters: function ( value ) {\n\t\n\t\t\tif ( ! value ) value = [];\n\t\n\t\t\tif ( this.isPlaying === true ) {\n\t\n\t\t\t\tthis.disconnect();\n\t\t\t\tthis.filters = value;\n\t\t\t\tthis.connect();\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.filters = value;\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tgetFilter: function () {\n\t\n\t\t\treturn this.getFilters()[ 0 ];\n\t\n\t\t},\n\t\n\t\tsetFilter: function ( filter ) {\n\t\n\t\t\treturn this.setFilters( filter ? [ filter ] : [] );\n\t\n\t\t},\n\t\n\t\tsetPlaybackRate: function ( value ) {\n\t\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn;\n\t\n\t\t\t}\n\t\n\t\t\tthis.playbackRate = value;\n\t\n\t\t\tif ( this.isPlaying === true ) {\n\t\n\t\t\t\tthis.source.playbackRate.value = this.playbackRate;\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tgetPlaybackRate: function () {\n\t\n\t\t\treturn this.playbackRate;\n\t\n\t\t},\n\t\n\t\tonEnded: function () {\n\t\n\t\t\tthis.isPlaying = false;\n\t\n\t\t},\n\t\n\t\tgetLoop: function () {\n\t\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn false;\n\t\n\t\t\t}\n\t\n\t\t\treturn this.source.loop;\n\t\n\t\t},\n\t\n\t\tsetLoop: function ( value ) {\n\t\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn;\n\t\n\t\t\t}\n\t\n\t\t\tthis.source.loop = value;\n\t\n\t\t},\n\t\n\t\tgetVolume: function () {\n\t\n\t\t\treturn this.gain.gain.value;\n\t\n\t\t},\n\t\n\t\n\t\tsetVolume: function ( value ) {\n\t\n\t\t\tthis.gain.gain.value = value;\n\t\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/audio/AudioAnalyser.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.AudioAnalyser = function ( audio, fftSize ) {\n\t\n\t\tthis.analyser = audio.context.createAnalyser();\n\t\tthis.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;\n\t\n\t\tthis.data = new Uint8Array( this.analyser.frequencyBinCount );\n\t\n\t\taudio.getOutput().connect( this.analyser );\n\t\n\t};\n\t\n\tObject.assign( THREE.AudioAnalyser.prototype, {\n\t\n\t\tgetFrequencyData: function () {\n\t\n\t\t\tthis.analyser.getByteFrequencyData( this.data );\n\t\n\t\t\treturn this.data;\n\t\n\t\t},\n\t\n\t\tgetAverageFrequency: function () {\n\t\n\t\t\tvar value = 0, data = this.getFrequencyData();\n\t\n\t\t\tfor ( var i = 0; i < data.length; i ++ ) {\n\t\n\t\t\t\tvalue += data[ i ];\n\t\n\t\t\t}\n\t\n\t\t\treturn value / data.length;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/audio/AudioContext.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tObject.defineProperty( THREE, 'AudioContext', {\n\t\n\t\tget: ( function () {\n\t\n\t\t\tvar context;\n\t\n\t\t\treturn function get() {\n\t\n\t\t\t\tif ( context === undefined ) {\n\t\n\t\t\t\t\tcontext = new ( window.AudioContext || window.webkitAudioContext )();\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn context;\n\t\n\t\t\t};\n\t\n\t\t} )()\n\t\n\t} );\n\t\n\t// File:src/audio/PositionalAudio.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.PositionalAudio = function ( listener ) {\n\t\n\t\tTHREE.Audio.call( this, listener );\n\t\n\t\tthis.panner = this.context.createPanner();\n\t\tthis.panner.connect( this.gain );\n\t\n\t};\n\t\n\tTHREE.PositionalAudio.prototype = Object.assign( Object.create( THREE.Audio.prototype ), {\n\t\n\t\tconstructor: THREE.PositionalAudio,\n\t\n\t\tgetOutput: function () {\n\t\n\t\t\treturn this.panner;\n\t\n\t\t},\n\t\n\t\tgetRefDistance: function () {\n\t\n\t\t\treturn this.panner.refDistance;\n\t\n\t\t},\n\t\n\t\tsetRefDistance: function ( value ) {\n\t\n\t\t\tthis.panner.refDistance = value;\n\t\n\t\t},\n\t\n\t\tgetRolloffFactor: function () {\n\t\n\t\t\treturn this.panner.rolloffFactor;\n\t\n\t\t},\n\t\n\t\tsetRolloffFactor: function ( value ) {\n\t\n\t\t\tthis.panner.rolloffFactor = value;\n\t\n\t\t},\n\t\n\t\tgetDistanceModel: function () {\n\t\n\t\t\treturn this.panner.distanceModel;\n\t\n\t\t},\n\t\n\t\tsetDistanceModel: function ( value ) {\n\t\n\t\t\tthis.panner.distanceModel = value;\n\t\n\t\t},\n\t\n\t\tgetMaxDistance: function () {\n\t\n\t\t\treturn this.panner.maxDistance;\n\t\n\t\t},\n\t\n\t\tsetMaxDistance: function ( value ) {\n\t\n\t\t\tthis.panner.maxDistance = value;\n\t\n\t\t},\n\t\n\t\tupdateMatrixWorld: ( function () {\n\t\n\t\t\tvar position = new THREE.Vector3();\n\t\n\t\t\treturn function updateMatrixWorld( force ) {\n\t\n\t\t\t\tTHREE.Object3D.prototype.updateMatrixWorld.call( this, force );\n\t\n\t\t\t\tposition.setFromMatrixPosition( this.matrixWorld );\n\t\n\t\t\t\tthis.panner.setPosition( position.x, position.y, position.z );\n\t\n\t\t\t};\n\t\n\t\t} )()\n\t\n\t\n\t} );\n\t\n\t// File:src/audio/AudioListener.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.AudioListener = function () {\n\t\n\t\tTHREE.Object3D.call( this );\n\t\n\t\tthis.type = 'AudioListener';\n\t\n\t\tthis.context = THREE.AudioContext;\n\t\n\t\tthis.gain = this.context.createGain();\n\t\tthis.gain.connect( this.context.destination );\n\t\n\t\tthis.filter = null;\n\t\n\t};\n\t\n\tTHREE.AudioListener.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\t\n\t\tconstructor: THREE.AudioListener,\n\t\n\t\tgetInput: function () {\n\t\n\t\t\treturn this.gain;\n\t\n\t\t},\n\t\n\t\tremoveFilter: function ( ) {\n\t\n\t\t\tif ( this.filter !== null ) {\n\t\n\t\t\t\tthis.gain.disconnect( this.filter );\n\t\t\t\tthis.filter.disconnect( this.context.destination );\n\t\t\t\tthis.gain.connect( this.context.destination );\n\t\t\t\tthis.filter = null;\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tgetFilter: function () {\n\t\n\t\t\treturn this.filter;\n\t\n\t\t},\n\t\n\t\tsetFilter: function ( value ) {\n\t\n\t\t\tif ( this.filter !== null ) {\n\t\n\t\t\t\tthis.gain.disconnect( this.filter );\n\t\t\t\tthis.filter.disconnect( this.context.destination );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.gain.disconnect( this.context.destination );\n\t\n\t\t\t}\n\t\n\t\t\tthis.filter = value;\n\t\t\tthis.gain.connect( this.filter );\n\t\t\tthis.filter.connect( this.context.destination );\n\t\n\t\t},\n\t\n\t\tgetMasterVolume: function () {\n\t\n\t\t\treturn this.gain.gain.value;\n\t\n\t\t},\n\t\n\t\tsetMasterVolume: function ( value ) {\n\t\n\t\t\tthis.gain.gain.value = value;\n\t\n\t\t},\n\t\n\t\tupdateMatrixWorld: ( function () {\n\t\n\t\t\tvar position = new THREE.Vector3();\n\t\t\tvar quaternion = new THREE.Quaternion();\n\t\t\tvar scale = new THREE.Vector3();\n\t\n\t\t\tvar orientation = new THREE.Vector3();\n\t\n\t\t\treturn function updateMatrixWorld( force ) {\n\t\n\t\t\t\tTHREE.Object3D.prototype.updateMatrixWorld.call( this, force );\n\t\n\t\t\t\tvar listener = this.context.listener;\n\t\t\t\tvar up = this.up;\n\t\n\t\t\t\tthis.matrixWorld.decompose( position, quaternion, scale );\n\t\n\t\t\t\torientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );\n\t\n\t\t\t\tlistener.setPosition( position.x, position.y, position.z );\n\t\t\t\tlistener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );\n\t\n\t\t\t};\n\t\n\t\t} )()\n\t\n\t} );\n\t\n\t// File:src/cameras/Camera.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author WestLangley / http://github.com/WestLangley\n\t*/\n\t\n\tTHREE.Camera = function () {\n\t\n\t\tTHREE.Object3D.call( this );\n\t\n\t\tthis.type = 'Camera';\n\t\n\t\tthis.matrixWorldInverse = new THREE.Matrix4();\n\t\tthis.projectionMatrix = new THREE.Matrix4();\n\t\n\t};\n\t\n\tTHREE.Camera.prototype = Object.create( THREE.Object3D.prototype );\n\tTHREE.Camera.prototype.constructor = THREE.Camera;\n\t\n\tTHREE.Camera.prototype.getWorldDirection = function () {\n\t\n\t\tvar quaternion = new THREE.Quaternion();\n\t\n\t\treturn function getWorldDirection( optionalTarget ) {\n\t\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\n\t\t\tthis.getWorldQuaternion( quaternion );\n\t\n\t\t\treturn result.set( 0, 0, - 1 ).applyQuaternion( quaternion );\n\t\n\t\t};\n\t\n\t}();\n\t\n\tTHREE.Camera.prototype.lookAt = function () {\n\t\n\t\t// This routine does not support cameras with rotated and/or translated parent(s)\n\t\n\t\tvar m1 = new THREE.Matrix4();\n\t\n\t\treturn function lookAt( vector ) {\n\t\n\t\t\tm1.lookAt( this.position, vector, this.up );\n\t\n\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\n\t\n\t\t};\n\t\n\t}();\n\t\n\tTHREE.Camera.prototype.clone = function () {\n\t\n\t\treturn new this.constructor().copy( this );\n\t\n\t};\n\t\n\tTHREE.Camera.prototype.copy = function ( source ) {\n\t\n\t\tTHREE.Object3D.prototype.copy.call( this, source );\n\t\n\t\tthis.matrixWorldInverse.copy( source.matrixWorldInverse );\n\t\tthis.projectionMatrix.copy( source.projectionMatrix );\n\t\n\t\treturn this;\n\t\n\t};\n\t\n\t// File:src/cameras/CubeCamera.js\n\t\n\t/**\n\t * Camera for rendering cube maps\n\t *\t- renders scene into axis-aligned cube\n\t *\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.CubeCamera = function ( near, far, cubeResolution ) {\n\t\n\t\tTHREE.Object3D.call( this );\n\t\n\t\tthis.type = 'CubeCamera';\n\t\n\t\tvar fov = 90, aspect = 1;\n\t\n\t\tvar cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPX.up.set( 0, - 1, 0 );\n\t\tcameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );\n\t\tthis.add( cameraPX );\n\t\n\t\tvar cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNX.up.set( 0, - 1, 0 );\n\t\tcameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );\n\t\tthis.add( cameraNX );\n\t\n\t\tvar cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPY.up.set( 0, 0, 1 );\n\t\tcameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );\n\t\tthis.add( cameraPY );\n\t\n\t\tvar cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNY.up.set( 0, 0, - 1 );\n\t\tcameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );\n\t\tthis.add( cameraNY );\n\t\n\t\tvar cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPZ.up.set( 0, - 1, 0 );\n\t\tcameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );\n\t\tthis.add( cameraPZ );\n\t\n\t\tvar cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNZ.up.set( 0, - 1, 0 );\n\t\tcameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );\n\t\tthis.add( cameraNZ );\n\t\n\t\tvar options = { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter };\n\t\n\t\tthis.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, options );\n\t\n\t\tthis.updateCubeMap = function ( renderer, scene ) {\n\t\n\t\t\tif ( this.parent === null ) this.updateMatrixWorld();\n\t\n\t\t\tvar renderTarget = this.renderTarget;\n\t\t\tvar generateMipmaps = renderTarget.texture.generateMipmaps;\n\t\n\t\t\trenderTarget.texture.generateMipmaps = false;\n\t\n\t\t\trenderTarget.activeCubeFace = 0;\n\t\t\trenderer.render( scene, cameraPX, renderTarget );\n\t\n\t\t\trenderTarget.activeCubeFace = 1;\n\t\t\trenderer.render( scene, cameraNX, renderTarget );\n\t\n\t\t\trenderTarget.activeCubeFace = 2;\n\t\t\trenderer.render( scene, cameraPY, renderTarget );\n\t\n\t\t\trenderTarget.activeCubeFace = 3;\n\t\t\trenderer.render( scene, cameraNY, renderTarget );\n\t\n\t\t\trenderTarget.activeCubeFace = 4;\n\t\t\trenderer.render( scene, cameraPZ, renderTarget );\n\t\n\t\t\trenderTarget.texture.generateMipmaps = generateMipmaps;\n\t\n\t\t\trenderTarget.activeCubeFace = 5;\n\t\t\trenderer.render( scene, cameraNZ, renderTarget );\n\t\n\t\t\trenderer.setRenderTarget( null );\n\t\n\t\t};\n\t\n\t};\n\t\n\tTHREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );\n\tTHREE.CubeCamera.prototype.constructor = THREE.CubeCamera;\n\t\n\t// File:src/cameras/OrthographicCamera.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author arose / http://github.com/arose\n\t */\n\t\n\tTHREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {\n\t\n\t\tTHREE.Camera.call( this );\n\t\n\t\tthis.type = 'OrthographicCamera';\n\t\n\t\tthis.zoom = 1;\n\t\tthis.view = null;\n\t\n\t\tthis.left = left;\n\t\tthis.right = right;\n\t\tthis.top = top;\n\t\tthis.bottom = bottom;\n\t\n\t\tthis.near = ( near !== undefined ) ? near : 0.1;\n\t\tthis.far = ( far !== undefined ) ? far : 2000;\n\t\n\t\tthis.updateProjectionMatrix();\n\t\n\t};\n\t\n\tTHREE.OrthographicCamera.prototype = Object.assign( Object.create( THREE.Camera.prototype ), {\n\t\n\t\tconstructor: THREE.OrthographicCamera,\n\t\n\t\tcopy: function ( source ) {\n\t\n\t\t\tTHREE.Camera.prototype.copy.call( this, source );\n\t\n\t\t\tthis.left = source.left;\n\t\t\tthis.right = source.right;\n\t\t\tthis.top = source.top;\n\t\t\tthis.bottom = source.bottom;\n\t\t\tthis.near = source.near;\n\t\t\tthis.far = source.far;\n\t\n\t\t\tthis.zoom = source.zoom;\n\t\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetViewOffset: function( fullWidth, fullHeight, x, y, width, height ) {\n\t\n\t\t\tthis.view = {\n\t\t\t\tfullWidth: fullWidth,\n\t\t\t\tfullHeight: fullHeight,\n\t\t\t\toffsetX: x,\n\t\t\t\toffsetY: y,\n\t\t\t\twidth: width,\n\t\t\t\theight: height\n\t\t\t};\n\t\n\t\t\tthis.updateProjectionMatrix();\n\t\n\t\t},\n\t\n\t\tclearViewOffset: function() {\n\t\n\t\t\tthis.view = null;\n\t\t\tthis.updateProjectionMatrix();\n\t\n\t\t},\n\t\n\t\tupdateProjectionMatrix: function () {\n\t\n\t\t\tvar dx = ( this.right - this.left ) / ( 2 * this.zoom );\n\t\t\tvar dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\n\t\t\tvar cx = ( this.right + this.left ) / 2;\n\t\t\tvar cy = ( this.top + this.bottom ) / 2;\n\t\n\t\t\tvar left = cx - dx;\n\t\t\tvar right = cx + dx;\n\t\t\tvar top = cy + dy;\n\t\t\tvar bottom = cy - dy;\n\t\n\t\t\tif ( this.view !== null ) {\n\t\n\t\t\t\tvar zoomW = this.zoom / ( this.view.width / this.view.fullWidth );\n\t\t\t\tvar zoomH = this.zoom / ( this.view.height / this.view.fullHeight );\n\t\t\t\tvar scaleW = ( this.right - this.left ) / this.view.width;\n\t\t\t\tvar scaleH = ( this.top - this.bottom ) / this.view.height;\n\t\n\t\t\t\tleft += scaleW * ( this.view.offsetX / zoomW );\n\t\t\t\tright = left + scaleW * ( this.view.width / zoomW );\n\t\t\t\ttop -= scaleH * ( this.view.offsetY / zoomH );\n\t\t\t\tbottom = top - scaleH * ( this.view.height / zoomH );\n\t\n\t\t\t}\n\t\n\t\t\tthis.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );\n\t\n\t\t},\n\t\n\t\ttoJSON: function ( meta ) {\n\t\n\t\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\n\t\n\t\t\tdata.object.zoom = this.zoom;\n\t\t\tdata.object.left = this.left;\n\t\t\tdata.object.right = this.right;\n\t\t\tdata.object.top = this.top;\n\t\t\tdata.object.bottom = this.bottom;\n\t\t\tdata.object.near = this.near;\n\t\t\tdata.object.far = this.far;\n\t\n\t\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\t\n\t\t\treturn data;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/cameras/PerspectiveCamera.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author greggman / http://games.greggman.com/\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * @author tschw\n\t */\n\t\n\tTHREE.PerspectiveCamera = function( fov, aspect, near, far ) {\n\t\n\t\tTHREE.Camera.call( this );\n\t\n\t\tthis.type = 'PerspectiveCamera';\n\t\n\t\tthis.fov = fov !== undefined ? fov : 50;\n\t\tthis.zoom = 1;\n\t\n\t\tthis.near = near !== undefined ? near : 0.1;\n\t\tthis.far = far !== undefined ? far : 2000;\n\t\tthis.focus = 10;\n\t\n\t\tthis.aspect = aspect !== undefined ? aspect : 1;\n\t\tthis.view = null;\n\t\n\t\tthis.filmGauge = 35;\t// width of the film (default in millimeters)\n\t\tthis.filmOffset = 0;\t// horizontal film offset (same unit as gauge)\n\t\n\t\tthis.updateProjectionMatrix();\n\t\n\t};\n\t\n\tTHREE.PerspectiveCamera.prototype = Object.assign( Object.create( THREE.Camera.prototype ), {\n\t\n\t\tconstructor: THREE.PerspectiveCamera,\n\t\n\t\tcopy: function ( source ) {\n\t\n\t\t\tTHREE.Camera.prototype.copy.call( this, source );\n\t\n\t\t\tthis.fov = source.fov;\n\t\t\tthis.zoom = source.zoom;\n\t\n\t\t\tthis.near = source.near;\n\t\t\tthis.far = source.far;\n\t\t\tthis.focus = source.focus;\n\t\n\t\t\tthis.aspect = source.aspect;\n\t\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\t\n\t\t\tthis.filmGauge = source.filmGauge;\n\t\t\tthis.filmOffset = source.filmOffset;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\t/**\n\t\t * Sets the FOV by focal length in respect to the current .filmGauge.\n\t\t *\n\t\t * The default film gauge is 35, so that the focal length can be specified for\n\t\t * a 35mm (full frame) camera.\n\t\t *\n\t\t * Values for focal length and film gauge must have the same unit.\n\t\t */\n\t\tsetFocalLength: function ( focalLength ) {\n\t\n\t\t\t// see http://www.bobatkins.com/photography/technical/field_of_view.html\n\t\t\tvar vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n\t\n\t\t\tthis.fov = THREE.Math.RAD2DEG * 2 * Math.atan( vExtentSlope );\n\t\t\tthis.updateProjectionMatrix();\n\t\n\t\t},\n\t\n\t\t/**\n\t\t * Calculates the focal length from the current .fov and .filmGauge.\n\t\t */\n\t\tgetFocalLength: function () {\n\t\n\t\t\tvar vExtentSlope = Math.tan( THREE.Math.DEG2RAD * 0.5 * this.fov );\n\t\n\t\t\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\n\t\n\t\t},\n\t\n\t\tgetEffectiveFOV: function () {\n\t\n\t\t\treturn THREE.Math.RAD2DEG * 2 * Math.atan(\n\t\t\t\t\tMath.tan( THREE.Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );\n\t\n\t\t},\n\t\n\t\tgetFilmWidth: function () {\n\t\n\t\t\t// film not completely covered in portrait format (aspect < 1)\n\t\t\treturn this.filmGauge * Math.min( this.aspect, 1 );\n\t\n\t\t},\n\t\n\t\tgetFilmHeight: function () {\n\t\n\t\t\t// film not completely covered in landscape format (aspect > 1)\n\t\t\treturn this.filmGauge / Math.max( this.aspect, 1 );\n\t\n\t\t},\n\t\n\t\t/**\n\t\t * Sets an offset in a larger frustum. This is useful for multi-window or\n\t\t * multi-monitor/multi-machine setups.\n\t\t *\n\t\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n\t\t * the monitors are in grid like this\n\t\t *\n\t\t *   +---+---+---+\n\t\t *   | A | B | C |\n\t\t *   +---+---+---+\n\t\t *   | D | E | F |\n\t\t *   +---+---+---+\n\t\t *\n\t\t * then for each monitor you would call it like this\n\t\t *\n\t\t *   var w = 1920;\n\t\t *   var h = 1080;\n\t\t *   var fullWidth = w * 3;\n\t\t *   var fullHeight = h * 2;\n\t\t *\n\t\t *   --A--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n\t\t *   --B--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n\t\t *   --C--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n\t\t *   --D--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n\t\t *   --E--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n\t\t *   --F--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n\t\t *\n\t\t *   Note there is no reason monitors have to be the same size or in a grid.\n\t\t */\n\t\tsetViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {\n\t\n\t\t\tthis.aspect = fullWidth / fullHeight;\n\t\n\t\t\tthis.view = {\n\t\t\t\tfullWidth: fullWidth,\n\t\t\t\tfullHeight: fullHeight,\n\t\t\t\toffsetX: x,\n\t\t\t\toffsetY: y,\n\t\t\t\twidth: width,\n\t\t\t\theight: height\n\t\t\t};\n\t\n\t\t\tthis.updateProjectionMatrix();\n\t\n\t\t},\n\t\n\t\tclearViewOffset: function() {\n\t\n\t\t\tthis.view = null;\n\t\t\tthis.updateProjectionMatrix();\n\t\n\t\t},\n\t\n\t\tupdateProjectionMatrix: function () {\n\t\n\t\t\tvar near = this.near,\n\t\t\t\ttop = near * Math.tan(\n\t\t\t\t\t\tTHREE.Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,\n\t\t\t\theight = 2 * top,\n\t\t\t\twidth = this.aspect * height,\n\t\t\t\tleft = - 0.5 * width,\n\t\t\t\tview = this.view;\n\t\n\t\t\tif ( view !== null ) {\n\t\n\t\t\t\tvar fullWidth = view.fullWidth,\n\t\t\t\t\tfullHeight = view.fullHeight;\n\t\n\t\t\t\tleft += view.offsetX * width / fullWidth;\n\t\t\t\ttop -= view.offsetY * height / fullHeight;\n\t\t\t\twidth *= view.width / fullWidth;\n\t\t\t\theight *= view.height / fullHeight;\n\t\n\t\t\t}\n\t\n\t\t\tvar skew = this.filmOffset;\n\t\t\tif ( skew !== 0 ) left += near * skew / this.getFilmWidth();\n\t\n\t\t\tthis.projectionMatrix.makeFrustum(\n\t\t\t\t\tleft, left + width, top - height, top, near, this.far );\n\t\n\t\t},\n\t\n\t\ttoJSON: function ( meta ) {\n\t\n\t\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\n\t\n\t\t\tdata.object.fov = this.fov;\n\t\t\tdata.object.zoom = this.zoom;\n\t\n\t\t\tdata.object.near = this.near;\n\t\t\tdata.object.far = this.far;\n\t\t\tdata.object.focus = this.focus;\n\t\n\t\t\tdata.object.aspect = this.aspect;\n\t\n\t\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\t\n\t\t\tdata.object.filmGauge = this.filmGauge;\n\t\t\tdata.object.filmOffset = this.filmOffset;\n\t\n\t\t\treturn data;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/cameras/StereoCamera.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.StereoCamera = function () {\n\t\n\t\tthis.type = 'StereoCamera';\n\t\n\t\tthis.aspect = 1;\n\t\n\t\tthis.cameraL = new THREE.PerspectiveCamera();\n\t\tthis.cameraL.layers.enable( 1 );\n\t\tthis.cameraL.matrixAutoUpdate = false;\n\t\n\t\tthis.cameraR = new THREE.PerspectiveCamera();\n\t\tthis.cameraR.layers.enable( 2 );\n\t\tthis.cameraR.matrixAutoUpdate = false;\n\t\n\t};\n\t\n\tObject.assign( THREE.StereoCamera.prototype, {\n\t\n\t\tupdate: ( function () {\n\t\n\t\t\tvar focus, fov, aspect, near, far;\n\t\n\t\t\tvar eyeRight = new THREE.Matrix4();\n\t\t\tvar eyeLeft = new THREE.Matrix4();\n\t\n\t\t\treturn function update( camera ) {\n\t\n\t\t\t\tvar needsUpdate = focus !== camera.focus || fov !== camera.fov ||\n\t\t\t\t\t\t\t\t\t\t\t\t\taspect !== camera.aspect * this.aspect || near !== camera.near ||\n\t\t\t\t\t\t\t\t\t\t\t\t\tfar !== camera.far;\n\t\n\t\t\t\tif ( needsUpdate ) {\n\t\n\t\t\t\t\tfocus = camera.focus;\n\t\t\t\t\tfov = camera.fov;\n\t\t\t\t\taspect = camera.aspect * this.aspect;\n\t\t\t\t\tnear = camera.near;\n\t\t\t\t\tfar = camera.far;\n\t\n\t\t\t\t\t// Off-axis stereoscopic effect based on\n\t\t\t\t\t// http://paulbourke.net/stereographics/stereorender/\n\t\n\t\t\t\t\tvar projectionMatrix = camera.projectionMatrix.clone();\n\t\t\t\t\tvar eyeSep = 0.064 / 2;\n\t\t\t\t\tvar eyeSepOnProjection = eyeSep * near / focus;\n\t\t\t\t\tvar ymax = near * Math.tan( THREE.Math.DEG2RAD * fov * 0.5 );\n\t\t\t\t\tvar xmin, xmax;\n\t\n\t\t\t\t\t// translate xOffset\n\t\n\t\t\t\t\teyeLeft.elements[ 12 ] = - eyeSep;\n\t\t\t\t\teyeRight.elements[ 12 ] = eyeSep;\n\t\n\t\t\t\t\t// for left eye\n\t\n\t\t\t\t\txmin = - ymax * aspect + eyeSepOnProjection;\n\t\t\t\t\txmax = ymax * aspect + eyeSepOnProjection;\n\t\n\t\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\n\t\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\t\n\t\t\t\t\tthis.cameraL.projectionMatrix.copy( projectionMatrix );\n\t\n\t\t\t\t\t// for right eye\n\t\n\t\t\t\t\txmin = - ymax * aspect - eyeSepOnProjection;\n\t\t\t\t\txmax = ymax * aspect - eyeSepOnProjection;\n\t\n\t\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\n\t\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\t\n\t\t\t\t\tthis.cameraR.projectionMatrix.copy( projectionMatrix );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );\n\t\t\t\tthis.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );\n\t\n\t\t\t};\n\t\n\t\t} )()\n\t\n\t} );\n\t\n\t// File:src/lights/Light.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.Light = function ( color, intensity ) {\n\t\n\t\tTHREE.Object3D.call( this );\n\t\n\t\tthis.type = 'Light';\n\t\n\t\tthis.color = new THREE.Color( color );\n\t\tthis.intensity = intensity !== undefined ? intensity : 1;\n\t\n\t\tthis.receiveShadow = undefined;\n\t\n\t};\n\t\n\tTHREE.Light.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\t\n\t\tconstructor: THREE.Light,\n\t\n\t\tcopy: function ( source ) {\n\t\n\t\t\tTHREE.Object3D.prototype.copy.call( this, source );\n\t\n\t\t\tthis.color.copy( source.color );\n\t\t\tthis.intensity = source.intensity;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\ttoJSON: function ( meta ) {\n\t\n\t\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\n\t\n\t\t\tdata.object.color = this.color.getHex();\n\t\t\tdata.object.intensity = this.intensity;\n\t\n\t\t\tif ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();\n\t\n\t\t\tif ( this.distance !== undefined ) data.object.distance = this.distance;\n\t\t\tif ( this.angle !== undefined ) data.object.angle = this.angle;\n\t\t\tif ( this.decay !== undefined ) data.object.decay = this.decay;\n\t\t\tif ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;\n\t\n\t\t\treturn data;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/lights/LightShadow.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.LightShadow = function ( camera ) {\n\t\n\t\tthis.camera = camera;\n\t\n\t\tthis.bias = 0;\n\t\tthis.radius = 1;\n\t\n\t\tthis.mapSize = new THREE.Vector2( 512, 512 );\n\t\n\t\tthis.map = null;\n\t\tthis.matrix = new THREE.Matrix4();\n\t\n\t};\n\t\n\tObject.assign( THREE.LightShadow.prototype, {\n\t\n\t\tcopy: function ( source ) {\n\t\n\t\t\tthis.camera = source.camera.clone();\n\t\n\t\t\tthis.bias = source.bias;\n\t\t\tthis.radius = source.radius;\n\t\n\t\t\tthis.mapSize.copy( source.mapSize );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/lights/AmbientLight.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.AmbientLight = function ( color, intensity ) {\n\t\n\t\tTHREE.Light.call( this, color, intensity );\n\t\n\t\tthis.type = 'AmbientLight';\n\t\n\t\tthis.castShadow = undefined;\n\t\n\t};\n\t\n\tTHREE.AmbientLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\n\t\n\t\tconstructor: THREE.AmbientLight\n\t\n\t} );\n\t\n\t// File:src/lights/DirectionalLight.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.DirectionalLight = function ( color, intensity ) {\n\t\n\t\tTHREE.Light.call( this, color, intensity );\n\t\n\t\tthis.type = 'DirectionalLight';\n\t\n\t\tthis.position.set( 0, 1, 0 );\n\t\tthis.updateMatrix();\n\t\n\t\tthis.target = new THREE.Object3D();\n\t\n\t\tthis.shadow = new THREE.DirectionalLightShadow();\n\t\n\t};\n\t\n\tTHREE.DirectionalLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\n\t\n\t\tconstructor: THREE.DirectionalLight,\n\t\n\t\tcopy: function ( source ) {\n\t\n\t\t\tTHREE.Light.prototype.copy.call( this, source );\n\t\n\t\t\tthis.target = source.target.clone();\n\t\n\t\t\tthis.shadow = source.shadow.clone();\n\t\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/lights/DirectionalLightShadow.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.DirectionalLightShadow = function ( light ) {\n\t\n\t\tTHREE.LightShadow.call( this, new THREE.OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );\n\t\n\t};\n\t\n\tTHREE.DirectionalLightShadow.prototype = Object.assign( Object.create( THREE.LightShadow.prototype ), {\n\t\n\t\tconstructor: THREE.DirectionalLightShadow\n\t\n\t} );\n\t\n\t// File:src/lights/HemisphereLight.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {\n\t\n\t\tTHREE.Light.call( this, skyColor, intensity );\n\t\n\t\tthis.type = 'HemisphereLight';\n\t\n\t\tthis.castShadow = undefined;\n\t\n\t\tthis.position.set( 0, 1, 0 );\n\t\tthis.updateMatrix();\n\t\n\t\tthis.groundColor = new THREE.Color( groundColor );\n\t\n\t};\n\t\n\tTHREE.HemisphereLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\n\t\n\t\tconstructor: THREE.HemisphereLight,\n\t\n\t\tcopy: function ( source ) {\n\t\n\t\t\tTHREE.Light.prototype.copy.call( this, source );\n\t\n\t\t\tthis.groundColor.copy( source.groundColor );\n\t\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/lights/PointLight.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\t\n\tTHREE.PointLight = function ( color, intensity, distance, decay ) {\n\t\n\t\tTHREE.Light.call( this, color, intensity );\n\t\n\t\tthis.type = 'PointLight';\n\t\n\t\tObject.defineProperty( this, 'power', {\n\t\t\tget: function () {\n\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\t\treturn this.intensity * 4 * Math.PI;\n\t\n\t\t\t},\n\t\t\tset: function ( power ) {\n\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\t\tthis.intensity = power / ( 4 * Math.PI );\n\t\t\t}\n\t\t} );\n\t\n\t\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\t\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\n\t\n\t\tthis.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 90, 1, 0.5, 500 ) );\n\t\n\t};\n\t\n\tTHREE.PointLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\n\t\n\t\tconstructor: THREE.PointLight,\n\t\n\t\tcopy: function ( source ) {\n\t\n\t\t\tTHREE.Light.prototype.copy.call( this, source );\n\t\n\t\t\tthis.distance = source.distance;\n\t\t\tthis.decay = source.decay;\n\t\n\t\t\tthis.shadow = source.shadow.clone();\n\t\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/lights/SpotLight.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.SpotLight = function ( color, intensity, distance, angle, penumbra, decay ) {\n\t\n\t\tTHREE.Light.call( this, color, intensity );\n\t\n\t\tthis.type = 'SpotLight';\n\t\n\t\tthis.position.set( 0, 1, 0 );\n\t\tthis.updateMatrix();\n\t\n\t\tthis.target = new THREE.Object3D();\n\t\n\t\tObject.defineProperty( this, 'power', {\n\t\t\tget: function () {\n\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\t\treturn this.intensity * Math.PI;\n\t\t\t},\n\t\t\tset: function ( power ) {\n\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\t\tthis.intensity = power / Math.PI;\n\t\t\t}\n\t\t} );\n\t\n\t\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\t\tthis.angle = ( angle !== undefined ) ? angle : Math.PI / 3;\n\t\tthis.penumbra = ( penumbra !== undefined ) ? penumbra : 0;\n\t\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\n\t\n\t\tthis.shadow = new THREE.SpotLightShadow();\n\t\n\t};\n\t\n\tTHREE.SpotLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\n\t\n\t\tconstructor: THREE.SpotLight,\n\t\n\t\tcopy: function ( source ) {\n\t\n\t\t\tTHREE.Light.prototype.copy.call( this, source );\n\t\n\t\t\tthis.distance = source.distance;\n\t\t\tthis.angle = source.angle;\n\t\t\tthis.penumbra = source.penumbra;\n\t\t\tthis.decay = source.decay;\n\t\n\t\t\tthis.target = source.target.clone();\n\t\n\t\t\tthis.shadow = source.shadow.clone();\n\t\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/lights/SpotLightShadow.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.SpotLightShadow = function () {\n\t\n\t\tTHREE.LightShadow.call( this, new THREE.PerspectiveCamera( 50, 1, 0.5, 500 ) );\n\t\n\t};\n\t\n\tTHREE.SpotLightShadow.prototype = Object.assign( Object.create( THREE.LightShadow.prototype ), {\n\t\n\t\tconstructor: THREE.SpotLightShadow,\n\t\n\t\tupdate: function ( light ) {\n\t\n\t\t\tvar fov = THREE.Math.RAD2DEG * 2 * light.angle;\n\t\t\tvar aspect = this.mapSize.width / this.mapSize.height;\n\t\t\tvar far = light.distance || 500;\n\t\n\t\t\tvar camera = this.camera;\n\t\n\t\t\tif ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {\n\t\n\t\t\t\tcamera.fov = fov;\n\t\t\t\tcamera.aspect = aspect;\n\t\t\t\tcamera.far = far;\n\t\t\t\tcamera.updateProjectionMatrix();\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/loaders/AudioLoader.js\n\t\n\t/**\n\t * @author Reece Aaron Lecrivain / http://reecenotes.com/\n\t */\n\t\n\tTHREE.AudioLoader = function ( manager ) {\n\t\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\t\n\t};\n\t\n\tObject.assign( THREE.AudioLoader.prototype, {\n\t\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\t\tloader.load( url, function ( buffer ) {\n\t\n\t\t\t\tvar context = THREE.AudioContext;\n\t\n\t\t\t\tcontext.decodeAudioData( buffer, function ( audioBuffer ) {\n\t\n\t\t\t\t\tonLoad( audioBuffer );\n\t\n\t\t\t\t} );\n\t\n\t\t\t}, onProgress, onError );\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/loaders/Cache.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.Cache = {\n\t\n\t\tenabled: false,\n\t\n\t\tfiles: {},\n\t\n\t\tadd: function ( key, file ) {\n\t\n\t\t\tif ( this.enabled === false ) return;\n\t\n\t\t\t// console.log( 'THREE.Cache', 'Adding key:', key );\n\t\n\t\t\tthis.files[ key ] = file;\n\t\n\t\t},\n\t\n\t\tget: function ( key ) {\n\t\n\t\t\tif ( this.enabled === false ) return;\n\t\n\t\t\t// console.log( 'THREE.Cache', 'Checking key:', key );\n\t\n\t\t\treturn this.files[ key ];\n\t\n\t\t},\n\t\n\t\tremove: function ( key ) {\n\t\n\t\t\tdelete this.files[ key ];\n\t\n\t\t},\n\t\n\t\tclear: function () {\n\t\n\t\t\tthis.files = {};\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/loaders/Loader.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.Loader = function () {\n\t\n\t\tthis.onLoadStart = function () {};\n\t\tthis.onLoadProgress = function () {};\n\t\tthis.onLoadComplete = function () {};\n\t\n\t};\n\t\n\tTHREE.Loader.prototype = {\n\t\n\t\tconstructor: THREE.Loader,\n\t\n\t\tcrossOrigin: undefined,\n\t\n\t\textractUrlBase: function ( url ) {\n\t\n\t\t\tvar parts = url.split( '/' );\n\t\n\t\t\tif ( parts.length === 1 ) return './';\n\t\n\t\t\tparts.pop();\n\t\n\t\t\treturn parts.join( '/' ) + '/';\n\t\n\t\t},\n\t\n\t\tinitMaterials: function ( materials, texturePath, crossOrigin ) {\n\t\n\t\t\tvar array = [];\n\t\n\t\t\tfor ( var i = 0; i < materials.length; ++ i ) {\n\t\n\t\t\t\tarray[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );\n\t\n\t\t\t}\n\t\n\t\t\treturn array;\n\t\n\t\t},\n\t\n\t\tcreateMaterial: ( function () {\n\t\n\t\t\tvar color, textureLoader, materialLoader;\n\t\n\t\t\treturn function createMaterial( m, texturePath, crossOrigin ) {\n\t\n\t\t\t\tif ( color === undefined ) color = new THREE.Color();\n\t\t\t\tif ( textureLoader === undefined ) textureLoader = new THREE.TextureLoader();\n\t\t\t\tif ( materialLoader === undefined ) materialLoader = new THREE.MaterialLoader();\n\t\n\t\t\t\t// convert from old material format\n\t\n\t\t\t\tvar textures = {};\n\t\n\t\t\t\tfunction loadTexture( path, repeat, offset, wrap, anisotropy ) {\n\t\n\t\t\t\t\tvar fullPath = texturePath + path;\n\t\t\t\t\tvar loader = THREE.Loader.Handlers.get( fullPath );\n\t\n\t\t\t\t\tvar texture;\n\t\n\t\t\t\t\tif ( loader !== null ) {\n\t\n\t\t\t\t\t\ttexture = loader.load( fullPath );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\ttextureLoader.setCrossOrigin( crossOrigin );\n\t\t\t\t\t\ttexture = textureLoader.load( fullPath );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( repeat !== undefined ) {\n\t\n\t\t\t\t\t\ttexture.repeat.fromArray( repeat );\n\t\n\t\t\t\t\t\tif ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\t\tif ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( offset !== undefined ) {\n\t\n\t\t\t\t\t\ttexture.offset.fromArray( offset );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( wrap !== undefined ) {\n\t\n\t\t\t\t\t\tif ( wrap[ 0 ] === 'repeat' ) texture.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\t\tif ( wrap[ 0 ] === 'mirror' ) texture.wrapS = THREE.MirroredRepeatWrapping;\n\t\n\t\t\t\t\t\tif ( wrap[ 1 ] === 'repeat' ) texture.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\t\tif ( wrap[ 1 ] === 'mirror' ) texture.wrapT = THREE.MirroredRepeatWrapping;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( anisotropy !== undefined ) {\n\t\n\t\t\t\t\t\ttexture.anisotropy = anisotropy;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar uuid = THREE.Math.generateUUID();\n\t\n\t\t\t\t\ttextures[ uuid ] = texture;\n\t\n\t\t\t\t\treturn uuid;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t//\n\t\n\t\t\t\tvar json = {\n\t\t\t\t\tuuid: THREE.Math.generateUUID(),\n\t\t\t\t\ttype: 'MeshLambertMaterial'\n\t\t\t\t};\n\t\n\t\t\t\tfor ( var name in m ) {\n\t\n\t\t\t\t\tvar value = m[ name ];\n\t\n\t\t\t\t\tswitch ( name ) {\n\t\t\t\t\t\tcase 'DbgColor':\n\t\t\t\t\t\tcase 'DbgIndex':\n\t\t\t\t\t\tcase 'opticalDensity':\n\t\t\t\t\t\tcase 'illumination':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'DbgName':\n\t\t\t\t\t\t\tjson.name = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'blending':\n\t\t\t\t\t\t\tjson.blending = THREE[ value ];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'colorAmbient':\n\t\t\t\t\t\tcase 'mapAmbient':\n\t\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'colorDiffuse':\n\t\t\t\t\t\t\tjson.color = color.fromArray( value ).getHex();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'colorSpecular':\n\t\t\t\t\t\t\tjson.specular = color.fromArray( value ).getHex();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'colorEmissive':\n\t\t\t\t\t\t\tjson.emissive = color.fromArray( value ).getHex();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'specularCoef':\n\t\t\t\t\t\t\tjson.shininess = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'shading':\n\t\t\t\t\t\t\tif ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';\n\t\t\t\t\t\t\tif ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';\n\t\t\t\t\t\t\tif ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapDiffuse':\n\t\t\t\t\t\t\tjson.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapDiffuseRepeat':\n\t\t\t\t\t\tcase 'mapDiffuseOffset':\n\t\t\t\t\t\tcase 'mapDiffuseWrap':\n\t\t\t\t\t\tcase 'mapDiffuseAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapEmissive':\n\t\t\t\t\t\t\tjson.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapEmissiveRepeat':\n\t\t\t\t\t\tcase 'mapEmissiveOffset':\n\t\t\t\t\t\tcase 'mapEmissiveWrap':\n\t\t\t\t\t\tcase 'mapEmissiveAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapLight':\n\t\t\t\t\t\t\tjson.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapLightRepeat':\n\t\t\t\t\t\tcase 'mapLightOffset':\n\t\t\t\t\t\tcase 'mapLightWrap':\n\t\t\t\t\t\tcase 'mapLightAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapAO':\n\t\t\t\t\t\t\tjson.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapAORepeat':\n\t\t\t\t\t\tcase 'mapAOOffset':\n\t\t\t\t\t\tcase 'mapAOWrap':\n\t\t\t\t\t\tcase 'mapAOAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapBump':\n\t\t\t\t\t\t\tjson.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapBumpScale':\n\t\t\t\t\t\t\tjson.bumpScale = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapBumpRepeat':\n\t\t\t\t\t\tcase 'mapBumpOffset':\n\t\t\t\t\t\tcase 'mapBumpWrap':\n\t\t\t\t\t\tcase 'mapBumpAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapNormal':\n\t\t\t\t\t\t\tjson.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapNormalFactor':\n\t\t\t\t\t\t\tjson.normalScale = [ value, value ];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapNormalRepeat':\n\t\t\t\t\t\tcase 'mapNormalOffset':\n\t\t\t\t\t\tcase 'mapNormalWrap':\n\t\t\t\t\t\tcase 'mapNormalAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapSpecular':\n\t\t\t\t\t\t\tjson.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapSpecularRepeat':\n\t\t\t\t\t\tcase 'mapSpecularOffset':\n\t\t\t\t\t\tcase 'mapSpecularWrap':\n\t\t\t\t\t\tcase 'mapSpecularAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapMetalness':\n\t\t\t\t\t\t\tjson.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapMetalnessRepeat':\n\t\t\t\t\t\tcase 'mapMetalnessOffset':\n\t\t\t\t\t\tcase 'mapMetalnessWrap':\n\t\t\t\t\t\tcase 'mapMetalnessAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapRoughness':\n\t\t\t\t\t\t\tjson.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapRoughnessRepeat':\n\t\t\t\t\t\tcase 'mapRoughnessOffset':\n\t\t\t\t\t\tcase 'mapRoughnessWrap':\n\t\t\t\t\t\tcase 'mapRoughnessAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapAlpha':\n\t\t\t\t\t\t\tjson.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapAlphaRepeat':\n\t\t\t\t\t\tcase 'mapAlphaOffset':\n\t\t\t\t\t\tcase 'mapAlphaWrap':\n\t\t\t\t\t\tcase 'mapAlphaAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'flipSided':\n\t\t\t\t\t\t\tjson.side = THREE.BackSide;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'doubleSided':\n\t\t\t\t\t\t\tjson.side = THREE.DoubleSide;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'transparency':\n\t\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );\n\t\t\t\t\t\t\tjson.opacity = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'depthTest':\n\t\t\t\t\t\tcase 'depthWrite':\n\t\t\t\t\t\tcase 'colorWrite':\n\t\t\t\t\t\tcase 'opacity':\n\t\t\t\t\t\tcase 'reflectivity':\n\t\t\t\t\t\tcase 'transparent':\n\t\t\t\t\t\tcase 'visible':\n\t\t\t\t\t\tcase 'wireframe':\n\t\t\t\t\t\t\tjson[ name ] = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'vertexColors':\n\t\t\t\t\t\t\tif ( value === true ) json.vertexColors = THREE.VertexColors;\n\t\t\t\t\t\t\tif ( value === 'face' ) json.vertexColors = THREE.FaceColors;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.Loader.createMaterial: Unsupported', name, value );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( json.type === 'MeshBasicMaterial' ) delete json.emissive;\n\t\t\t\tif ( json.type !== 'MeshPhongMaterial' ) delete json.specular;\n\t\n\t\t\t\tif ( json.opacity < 1 ) json.transparent = true;\n\t\n\t\t\t\tmaterialLoader.setTextures( textures );\n\t\n\t\t\t\treturn materialLoader.parse( json );\n\t\n\t\t\t};\n\t\n\t\t} )()\n\t\n\t};\n\t\n\tTHREE.Loader.Handlers = {\n\t\n\t\thandlers: [],\n\t\n\t\tadd: function ( regex, loader ) {\n\t\n\t\t\tthis.handlers.push( regex, loader );\n\t\n\t\t},\n\t\n\t\tget: function ( file ) {\n\t\n\t\t\tvar handlers = this.handlers;\n\t\n\t\t\tfor ( var i = 0, l = handlers.length; i < l; i += 2 ) {\n\t\n\t\t\t\tvar regex = handlers[ i ];\n\t\t\t\tvar loader  = handlers[ i + 1 ];\n\t\n\t\t\t\tif ( regex.test( file ) ) {\n\t\n\t\t\t\t\treturn loader;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn null;\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/loaders/XHRLoader.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.XHRLoader = function ( manager ) {\n\t\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\t\n\t};\n\t\n\tObject.assign( THREE.XHRLoader.prototype, {\n\t\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\tif ( this.path !== undefined ) url = this.path + url;\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\tvar cached = THREE.Cache.get( url );\n\t\n\t\t\tif ( cached !== undefined ) {\n\t\n\t\t\t\tif ( onLoad ) {\n\t\n\t\t\t\t\tsetTimeout( function () {\n\t\n\t\t\t\t\t\tonLoad( cached );\n\t\n\t\t\t\t\t}, 0 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn cached;\n\t\n\t\t\t}\n\t\n\t\t\tvar request = new XMLHttpRequest();\n\t\t\trequest.overrideMimeType( 'text/plain' );\n\t\t\trequest.open( 'GET', url, true );\n\t\n\t\t\trequest.addEventListener( 'load', function ( event ) {\n\t\n\t\t\t\tvar response = event.target.response;\n\t\n\t\t\t\tTHREE.Cache.add( url, response );\n\t\n\t\t\t\tif ( this.status === 200 ) {\n\t\n\t\t\t\t\tif ( onLoad ) onLoad( response );\n\t\n\t\t\t\t\tscope.manager.itemEnd( url );\n\t\n\t\t\t\t} else if ( this.status === 0 ) {\n\t\n\t\t\t\t\t// Some browsers return HTTP Status 0 when using non-http protocol\n\t\t\t\t\t// e.g. 'file://' or 'data://'. Handle as success.\n\t\n\t\t\t\t\tconsole.warn( 'THREE.XHRLoader: HTTP Status 0 received.' );\n\t\n\t\t\t\t\tif ( onLoad ) onLoad( response );\n\t\n\t\t\t\t\tscope.manager.itemEnd( url );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tif ( onError ) onError( event );\n\t\n\t\t\t\t\tscope.manager.itemError( url );\n\t\n\t\t\t\t}\n\t\n\t\t\t}, false );\n\t\n\t\t\tif ( onProgress !== undefined ) {\n\t\n\t\t\t\trequest.addEventListener( 'progress', function ( event ) {\n\t\n\t\t\t\t\tonProgress( event );\n\t\n\t\t\t\t}, false );\n\t\n\t\t\t}\n\t\n\t\t\trequest.addEventListener( 'error', function ( event ) {\n\t\n\t\t\t\tif ( onError ) onError( event );\n\t\n\t\t\t\tscope.manager.itemError( url );\n\t\n\t\t\t}, false );\n\t\n\t\t\tif ( this.responseType !== undefined ) request.responseType = this.responseType;\n\t\t\tif ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;\n\t\n\t\t\trequest.send( null );\n\t\n\t\t\tscope.manager.itemStart( url );\n\t\n\t\t\treturn request;\n\t\n\t\t},\n\t\n\t\tsetPath: function ( value ) {\n\t\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetResponseType: function ( value ) {\n\t\n\t\t\tthis.responseType = value;\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetWithCredentials: function ( value ) {\n\t\n\t\t\tthis.withCredentials = value;\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/loaders/FontLoader.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.FontLoader = function ( manager ) {\n\t\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\t\n\t};\n\t\n\tObject.assign( THREE.FontLoader.prototype, {\n\t\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\t\tloader.load( url, function ( text ) {\n\t\n\t\t\t\tvar json;\n\t\n\t\t\t\ttry {\n\t\n\t\t\t\t\tjson = JSON.parse( text );\n\t\n\t\t\t\t} catch ( e ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );\n\t\t\t\t\tjson = JSON.parse( text.substring( 65, text.length - 2 ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar font = scope.parse( json );\n\t\n\t\t\t\tif ( onLoad ) onLoad( font );\n\t\n\t\t\t}, onProgress, onError );\n\t\n\t\t},\n\t\n\t\tparse: function ( json ) {\n\t\n\t\t\treturn new THREE.Font( json );\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/loaders/ImageLoader.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.ImageLoader = function ( manager ) {\n\t\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\t\n\t};\n\t\n\tObject.assign( THREE.ImageLoader.prototype, {\n\t\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\tvar image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );\n\t\t\timage.onload = function () {\n\t\n\t\t\t\tURL.revokeObjectURL( image.src );\n\t\t\t\tif ( onLoad ) onLoad( image );\n\t\n\t\t\t};\n\t\n\t\t\tif ( url.indexOf( 'data:' ) === 0 ) {\n\t\n\t\t\t\timage.src = url;\n\t\n\t\t\t} else {\n\t\n\t\t\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\t\t\tloader.setPath( this.path );\n\t\t\t\tloader.setResponseType( 'blob' );\n\t\t\t\tloader.load( url, function ( blob ) {\n\t\n\t\t\t\t\timage.src = URL.createObjectURL( blob );\n\t\n\t\t\t\t}, onProgress, onError );\n\t\n\t\t\t}\n\t\n\t\t\treturn image;\n\t\n\t\t},\n\t\n\t\tsetCrossOrigin: function ( value ) {\n\t\n\t\t\tthis.crossOrigin = value;\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetPath: function ( value ) {\n\t\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/loaders/JSONLoader.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.JSONLoader = function ( manager ) {\n\t\n\t\tif ( typeof manager === 'boolean' ) {\n\t\n\t\t\tconsole.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );\n\t\t\tmanager = undefined;\n\t\n\t\t}\n\t\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\t\n\t\tthis.withCredentials = false;\n\t\n\t};\n\t\n\tObject.assign( THREE.JSONLoader.prototype, {\n\t\n\t\tload: function( url, onLoad, onProgress, onError ) {\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\tvar texturePath = this.texturePath && ( typeof this.texturePath === \"string\" ) ? this.texturePath : THREE.Loader.prototype.extractUrlBase( url );\n\t\n\t\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\t\tloader.setWithCredentials( this.withCredentials );\n\t\t\tloader.load( url, function ( text ) {\n\t\n\t\t\t\tvar json = JSON.parse( text );\n\t\t\t\tvar metadata = json.metadata;\n\t\n\t\t\t\tif ( metadata !== undefined ) {\n\t\n\t\t\t\t\tvar type = metadata.type;\n\t\n\t\t\t\t\tif ( type !== undefined ) {\n\t\n\t\t\t\t\t\tif ( type.toLowerCase() === 'object' ) {\n\t\n\t\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );\n\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( type.toLowerCase() === 'scene' ) {\n\t\n\t\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );\n\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar object = scope.parse( json, texturePath );\n\t\t\t\tonLoad( object.geometry, object.materials );\n\t\n\t\t\t}, onProgress, onError );\n\t\n\t\t},\n\t\n\t\tsetTexturePath: function ( value ) {\n\t\n\t\t\tthis.texturePath = value;\n\t\n\t\t},\n\t\n\t\tparse: function ( json, texturePath ) {\n\t\n\t\t\tvar geometry = new THREE.Geometry(),\n\t\t\tscale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;\n\t\n\t\t\tparseModel( scale );\n\t\n\t\t\tparseSkin();\n\t\t\tparseMorphing( scale );\n\t\t\tparseAnimations();\n\t\n\t\t\tgeometry.computeFaceNormals();\n\t\t\tgeometry.computeBoundingSphere();\n\t\n\t\t\tfunction parseModel( scale ) {\n\t\n\t\t\t\tfunction isBitSet( value, position ) {\n\t\n\t\t\t\t\treturn value & ( 1 << position );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar i, j, fi,\n\t\n\t\t\t\toffset, zLength,\n\t\n\t\t\tcolorIndex, normalIndex, uvIndex, materialIndex,\n\t\n\t\t\t\ttype,\n\t\t\t\tisQuad,\n\t\t\t\thasMaterial,\n\t\t\t\thasFaceVertexUv,\n\t\t\t\thasFaceNormal, hasFaceVertexNormal,\n\t\t\t\thasFaceColor, hasFaceVertexColor,\n\t\n\t\t\tvertex, face, faceA, faceB, hex, normal,\n\t\n\t\t\t\tuvLayer, uv, u, v,\n\t\n\t\t\t\tfaces = json.faces,\n\t\t\t\tvertices = json.vertices,\n\t\t\t\tnormals = json.normals,\n\t\t\t\tcolors = json.colors,\n\t\n\t\t\t\tnUvLayers = 0;\n\t\n\t\t\t\tif ( json.uvs !== undefined ) {\n\t\n\t\t\t\t\t// disregard empty arrays\n\t\n\t\t\t\t\tfor ( i = 0; i < json.uvs.length; i ++ ) {\n\t\n\t\t\t\t\t\tif ( json.uvs[ i ].length ) nUvLayers ++;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\t\n\t\t\t\t\t\tgeometry.faceVertexUvs[ i ] = [];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\toffset = 0;\n\t\t\t\tzLength = vertices.length;\n\t\n\t\t\t\twhile ( offset < zLength ) {\n\t\n\t\t\t\t\tvertex = new THREE.Vector3();\n\t\n\t\t\t\t\tvertex.x = vertices[ offset ++ ] * scale;\n\t\t\t\t\tvertex.y = vertices[ offset ++ ] * scale;\n\t\t\t\t\tvertex.z = vertices[ offset ++ ] * scale;\n\t\n\t\t\t\t\tgeometry.vertices.push( vertex );\n\t\n\t\t\t\t}\n\t\n\t\t\t\toffset = 0;\n\t\t\t\tzLength = faces.length;\n\t\n\t\t\t\twhile ( offset < zLength ) {\n\t\n\t\t\t\t\ttype = faces[ offset ++ ];\n\t\n\t\n\t\t\t\t\tisQuad              = isBitSet( type, 0 );\n\t\t\t\t\thasMaterial         = isBitSet( type, 1 );\n\t\t\t\t\thasFaceVertexUv     = isBitSet( type, 3 );\n\t\t\t\t\thasFaceNormal       = isBitSet( type, 4 );\n\t\t\t\t\thasFaceVertexNormal = isBitSet( type, 5 );\n\t\t\t\t\thasFaceColor\t     = isBitSet( type, 6 );\n\t\t\t\t\thasFaceVertexColor  = isBitSet( type, 7 );\n\t\n\t\t\t\t\t// console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\n\t\n\t\t\t\t\tif ( isQuad ) {\n\t\n\t\t\t\t\t\tfaceA = new THREE.Face3();\n\t\t\t\t\t\tfaceA.a = faces[ offset ];\n\t\t\t\t\t\tfaceA.b = faces[ offset + 1 ];\n\t\t\t\t\t\tfaceA.c = faces[ offset + 3 ];\n\t\n\t\t\t\t\t\tfaceB = new THREE.Face3();\n\t\t\t\t\t\tfaceB.a = faces[ offset + 1 ];\n\t\t\t\t\t\tfaceB.b = faces[ offset + 2 ];\n\t\t\t\t\t\tfaceB.c = faces[ offset + 3 ];\n\t\n\t\t\t\t\t\toffset += 4;\n\t\n\t\t\t\t\t\tif ( hasMaterial ) {\n\t\n\t\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\tfaceA.materialIndex = materialIndex;\n\t\t\t\t\t\t\tfaceB.materialIndex = materialIndex;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// to get face <=> uv index correspondence\n\t\n\t\t\t\t\t\tfi = geometry.faces.length;\n\t\n\t\t\t\t\t\tif ( hasFaceVertexUv ) {\n\t\n\t\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\t\n\t\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\n\t\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi + 1 ] = [];\n\t\n\t\t\t\t\t\t\t\tfor ( j = 0; j < 4; j ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\t\n\t\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\t\n\t\t\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\n\t\n\t\t\t\t\t\t\t\t\tif ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );\n\t\t\t\t\t\t\t\t\tif ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( hasFaceNormal ) {\n\t\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\t\n\t\t\t\t\t\t\tfaceA.normal.set(\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\tfaceB.normal.copy( faceA.normal );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( hasFaceVertexNormal ) {\n\t\n\t\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\t\n\t\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\t\n\t\t\t\t\t\t\t\tnormal = new THREE.Vector3(\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t\t);\n\t\n\t\n\t\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexNormals.push( normal );\n\t\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexNormals.push( normal );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\n\t\t\t\t\t\tif ( hasFaceColor ) {\n\t\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\thex = colors[ colorIndex ];\n\t\n\t\t\t\t\t\t\tfaceA.color.setHex( hex );\n\t\t\t\t\t\t\tfaceB.color.setHex( hex );\n\t\n\t\t\t\t\t\t}\n\t\n\t\n\t\t\t\t\t\tif ( hasFaceVertexColor ) {\n\t\n\t\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\t\n\t\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\t\thex = colors[ colorIndex ];\n\t\n\t\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );\n\t\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tgeometry.faces.push( faceA );\n\t\t\t\t\t\tgeometry.faces.push( faceB );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tface = new THREE.Face3();\n\t\t\t\t\t\tface.a = faces[ offset ++ ];\n\t\t\t\t\t\tface.b = faces[ offset ++ ];\n\t\t\t\t\t\tface.c = faces[ offset ++ ];\n\t\n\t\t\t\t\t\tif ( hasMaterial ) {\n\t\n\t\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\tface.materialIndex = materialIndex;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// to get face <=> uv index correspondence\n\t\n\t\t\t\t\t\tfi = geometry.faces.length;\n\t\n\t\t\t\t\t\tif ( hasFaceVertexUv ) {\n\t\n\t\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\t\n\t\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\n\t\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\n\t\n\t\t\t\t\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\t\n\t\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\t\n\t\t\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\n\t\n\t\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ].push( uv );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( hasFaceNormal ) {\n\t\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\t\n\t\t\t\t\t\t\tface.normal.set(\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( hasFaceVertexNormal ) {\n\t\n\t\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\t\n\t\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\t\n\t\t\t\t\t\t\t\tnormal = new THREE.Vector3(\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tface.vertexNormals.push( normal );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\n\t\t\t\t\t\tif ( hasFaceColor ) {\n\t\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\tface.color.setHex( colors[ colorIndex ] );\n\t\n\t\t\t\t\t\t}\n\t\n\t\n\t\t\t\t\t\tif ( hasFaceVertexColor ) {\n\t\n\t\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\t\n\t\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\t\tface.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tgeometry.faces.push( face );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction parseSkin() {\n\t\n\t\t\t\tvar influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;\n\t\n\t\t\t\tif ( json.skinWeights ) {\n\t\n\t\t\t\t\tfor ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {\n\t\n\t\t\t\t\t\tvar x =                               json.skinWeights[ i ];\n\t\t\t\t\t\tvar y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;\n\t\t\t\t\t\tvar z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;\n\t\t\t\t\t\tvar w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;\n\t\n\t\t\t\t\t\tgeometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( json.skinIndices ) {\n\t\n\t\t\t\t\tfor ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {\n\t\n\t\t\t\t\t\tvar a =                               json.skinIndices[ i ];\n\t\t\t\t\t\tvar b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;\n\t\t\t\t\t\tvar c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;\n\t\t\t\t\t\tvar d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;\n\t\n\t\t\t\t\t\tgeometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tgeometry.bones = json.bones;\n\t\n\t\t\t\tif ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {\n\t\n\t\t\t\t\tconsole.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +\n\t\t\t\t\t\tgeometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction parseMorphing( scale ) {\n\t\n\t\t\t\tif ( json.morphTargets !== undefined ) {\n\t\n\t\t\t\t\tfor ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tgeometry.morphTargets[ i ] = {};\n\t\t\t\t\t\tgeometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\n\t\t\t\t\t\tgeometry.morphTargets[ i ].vertices = [];\n\t\n\t\t\t\t\t\tvar dstVertices = geometry.morphTargets[ i ].vertices;\n\t\t\t\t\t\tvar srcVertices = json.morphTargets[ i ].vertices;\n\t\n\t\t\t\t\t\tfor ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\n\t\n\t\t\t\t\t\t\tvar vertex = new THREE.Vector3();\n\t\t\t\t\t\t\tvertex.x = srcVertices[ v ] * scale;\n\t\t\t\t\t\t\tvertex.y = srcVertices[ v + 1 ] * scale;\n\t\t\t\t\t\t\tvertex.z = srcVertices[ v + 2 ] * scale;\n\t\n\t\t\t\t\t\t\tdstVertices.push( vertex );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( json.morphColors !== undefined && json.morphColors.length > 0 ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.JSONLoader: \"morphColors\" no longer supported. Using them as face colors.' );\n\t\n\t\t\t\t\tvar faces = geometry.faces;\n\t\t\t\t\tvar morphColors = json.morphColors[ 0 ].colors;\n\t\n\t\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tfaces[ i ].color.fromArray( morphColors, i * 3 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction parseAnimations() {\n\t\n\t\t\t\tvar outputAnimations = [];\n\t\n\t\t\t\t// parse old style Bone/Hierarchy animations\n\t\t\t\tvar animations = [];\n\t\n\t\t\t\tif ( json.animation !== undefined ) {\n\t\n\t\t\t\t\tanimations.push( json.animation );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( json.animations !== undefined ) {\n\t\n\t\t\t\t\tif ( json.animations.length ) {\n\t\n\t\t\t\t\t\tanimations = animations.concat( json.animations );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tanimations.push( json.animations );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var i = 0; i < animations.length; i ++ ) {\n\t\n\t\t\t\t\tvar clip = THREE.AnimationClip.parseAnimation( animations[ i ], geometry.bones );\n\t\t\t\t\tif ( clip ) outputAnimations.push( clip );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// parse implicit morph animations\n\t\t\t\tif ( geometry.morphTargets ) {\n\t\n\t\t\t\t\t// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.\n\t\t\t\t\tvar morphAnimationClips = THREE.AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );\n\t\t\t\t\toutputAnimations = outputAnimations.concat( morphAnimationClips );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;\n\t\n\t\t\t}\n\t\n\t\t\tif ( json.materials === undefined || json.materials.length === 0 ) {\n\t\n\t\t\t\treturn { geometry: geometry };\n\t\n\t\t\t} else {\n\t\n\t\t\t\tvar materials = THREE.Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );\n\t\n\t\t\t\treturn { geometry: geometry, materials: materials };\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/loaders/LoadingManager.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.LoadingManager = function ( onLoad, onProgress, onError ) {\n\t\n\t\tvar scope = this;\n\t\n\t\tvar isLoading = false, itemsLoaded = 0, itemsTotal = 0;\n\t\n\t\tthis.onStart = undefined;\n\t\tthis.onLoad = onLoad;\n\t\tthis.onProgress = onProgress;\n\t\tthis.onError = onError;\n\t\n\t\tthis.itemStart = function ( url ) {\n\t\n\t\t\titemsTotal ++;\n\t\n\t\t\tif ( isLoading === false ) {\n\t\n\t\t\t\tif ( scope.onStart !== undefined ) {\n\t\n\t\t\t\t\tscope.onStart( url, itemsLoaded, itemsTotal );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tisLoading = true;\n\t\n\t\t};\n\t\n\t\tthis.itemEnd = function ( url ) {\n\t\n\t\t\titemsLoaded ++;\n\t\n\t\t\tif ( scope.onProgress !== undefined ) {\n\t\n\t\t\t\tscope.onProgress( url, itemsLoaded, itemsTotal );\n\t\n\t\t\t}\n\t\n\t\t\tif ( itemsLoaded === itemsTotal ) {\n\t\n\t\t\t\tisLoading = false;\n\t\n\t\t\t\tif ( scope.onLoad !== undefined ) {\n\t\n\t\t\t\t\tscope.onLoad();\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.itemError = function ( url ) {\n\t\n\t\t\tif ( scope.onError !== undefined ) {\n\t\n\t\t\t\tscope.onError( url );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t};\n\t\n\tTHREE.DefaultLoadingManager = new THREE.LoadingManager();\n\t\n\t// File:src/loaders/BufferGeometryLoader.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.BufferGeometryLoader = function ( manager ) {\n\t\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\t\n\t};\n\t\n\tObject.assign( THREE.BufferGeometryLoader.prototype, {\n\t\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\tvar loader = new THREE.XHRLoader( scope.manager );\n\t\t\tloader.load( url, function ( text ) {\n\t\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\t\n\t\t\t}, onProgress, onError );\n\t\n\t\t},\n\t\n\t\tparse: function ( json ) {\n\t\n\t\t\tvar geometry = new THREE.BufferGeometry();\n\t\n\t\t\tvar index = json.data.index;\n\t\n\t\t\tvar TYPED_ARRAYS = {\n\t\t\t\t'Int8Array': Int8Array,\n\t\t\t\t'Uint8Array': Uint8Array,\n\t\t\t\t'Uint8ClampedArray': Uint8ClampedArray,\n\t\t\t\t'Int16Array': Int16Array,\n\t\t\t\t'Uint16Array': Uint16Array,\n\t\t\t\t'Int32Array': Int32Array,\n\t\t\t\t'Uint32Array': Uint32Array,\n\t\t\t\t'Float32Array': Float32Array,\n\t\t\t\t'Float64Array': Float64Array\n\t\t\t};\n\t\n\t\t\tif ( index !== undefined ) {\n\t\n\t\t\t\tvar typedArray = new TYPED_ARRAYS[ index.type ]( index.array );\n\t\t\t\tgeometry.setIndex( new THREE.BufferAttribute( typedArray, 1 ) );\n\t\n\t\t\t}\n\t\n\t\t\tvar attributes = json.data.attributes;\n\t\n\t\t\tfor ( var key in attributes ) {\n\t\n\t\t\t\tvar attribute = attributes[ key ];\n\t\t\t\tvar typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );\n\t\n\t\t\t\tgeometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );\n\t\n\t\t\t}\n\t\n\t\t\tvar groups = json.data.groups || json.data.drawcalls || json.data.offsets;\n\t\n\t\t\tif ( groups !== undefined ) {\n\t\n\t\t\t\tfor ( var i = 0, n = groups.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tvar group = groups[ i ];\n\t\n\t\t\t\t\tgeometry.addGroup( group.start, group.count, group.materialIndex );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tvar boundingSphere = json.data.boundingSphere;\n\t\n\t\t\tif ( boundingSphere !== undefined ) {\n\t\n\t\t\t\tvar center = new THREE.Vector3();\n\t\n\t\t\t\tif ( boundingSphere.center !== undefined ) {\n\t\n\t\t\t\t\tcenter.fromArray( boundingSphere.center );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tgeometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );\n\t\n\t\t\t}\n\t\n\t\t\treturn geometry;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/loaders/MaterialLoader.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.MaterialLoader = function ( manager ) {\n\t\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\t\tthis.textures = {};\n\t\n\t};\n\t\n\tObject.assign( THREE.MaterialLoader.prototype, {\n\t\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\tvar loader = new THREE.XHRLoader( scope.manager );\n\t\t\tloader.load( url, function ( text ) {\n\t\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\t\n\t\t\t}, onProgress, onError );\n\t\n\t\t},\n\t\n\t\tsetTextures: function ( value ) {\n\t\n\t\t\tthis.textures = value;\n\t\n\t\t},\n\t\n\t\tgetTexture: function ( name ) {\n\t\n\t\t\tvar textures = this.textures;\n\t\n\t\t\tif ( textures[ name ] === undefined ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.MaterialLoader: Undefined texture', name );\n\t\n\t\t\t}\n\t\n\t\t\treturn textures[ name ];\n\t\n\t\t},\n\t\n\t\tparse: function ( json ) {\n\t\n\t\t\tvar material = new THREE[ json.type ];\n\t\n\t\t\tif ( json.uuid !== undefined ) material.uuid = json.uuid;\n\t\t\tif ( json.name !== undefined ) material.name = json.name;\n\t\t\tif ( json.color !== undefined ) material.color.setHex( json.color );\n\t\t\tif ( json.roughness !== undefined ) material.roughness = json.roughness;\n\t\t\tif ( json.metalness !== undefined ) material.metalness = json.metalness;\n\t\t\tif ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );\n\t\t\tif ( json.specular !== undefined ) material.specular.setHex( json.specular );\n\t\t\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\n\t\t\tif ( json.uniforms !== undefined ) material.uniforms = json.uniforms;\n\t\t\tif ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\n\t\t\tif ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\n\t\t\tif ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;\n\t\t\tif ( json.shading !== undefined ) material.shading = json.shading;\n\t\t\tif ( json.blending !== undefined ) material.blending = json.blending;\n\t\t\tif ( json.side !== undefined ) material.side = json.side;\n\t\t\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\n\t\t\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\n\t\t\tif ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;\n\t\t\tif ( json.depthTest !== undefined ) material.depthTest = json.depthTest;\n\t\t\tif ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;\n\t\t\tif ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;\n\t\t\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\n\t\t\tif ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;\n\t\n\t\t\t// for PointsMaterial\n\t\t\tif ( json.size !== undefined ) material.size = json.size;\n\t\t\tif ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\n\t\n\t\t\t// maps\n\t\n\t\t\tif ( json.map !== undefined ) material.map = this.getTexture( json.map );\n\t\n\t\t\tif ( json.alphaMap !== undefined ) {\n\t\n\t\t\t\tmaterial.alphaMap = this.getTexture( json.alphaMap );\n\t\t\t\tmaterial.transparent = true;\n\t\n\t\t\t}\n\t\n\t\t\tif ( json.bumpMap !== undefined ) material.bumpMap = this.getTexture( json.bumpMap );\n\t\t\tif ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;\n\t\n\t\t\tif ( json.normalMap !== undefined ) material.normalMap = this.getTexture( json.normalMap );\n\t\t\tif ( json.normalScale !== undefined ) {\n\t\n\t\t\t\tvar normalScale = json.normalScale;\n\t\n\t\t\t\tif ( Array.isArray( normalScale ) === false ) {\n\t\n\t\t\t\t\t// Blender exporter used to export a scalar. See #7459\n\t\n\t\t\t\t\tnormalScale = [ normalScale, normalScale ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tmaterial.normalScale = new THREE.Vector2().fromArray( normalScale );\n\t\n\t\t\t}\n\t\n\t\t\tif ( json.displacementMap !== undefined ) material.displacementMap = this.getTexture( json.displacementMap );\n\t\t\tif ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;\n\t\t\tif ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;\n\t\n\t\t\tif ( json.roughnessMap !== undefined ) material.roughnessMap = this.getTexture( json.roughnessMap );\n\t\t\tif ( json.metalnessMap !== undefined ) material.metalnessMap = this.getTexture( json.metalnessMap );\n\t\n\t\t\tif ( json.emissiveMap !== undefined ) material.emissiveMap = this.getTexture( json.emissiveMap );\n\t\t\tif ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;\n\t\n\t\t\tif ( json.specularMap !== undefined ) material.specularMap = this.getTexture( json.specularMap );\n\t\n\t\t\tif ( json.envMap !== undefined ) {\n\t\n\t\t\t\tmaterial.envMap = this.getTexture( json.envMap );\n\t\t\t\tmaterial.combine = THREE.MultiplyOperation;\n\t\n\t\t\t}\n\t\n\t\t\tif ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;\n\t\n\t\t\tif ( json.lightMap !== undefined ) material.lightMap = this.getTexture( json.lightMap );\n\t\t\tif ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;\n\t\n\t\t\tif ( json.aoMap !== undefined ) material.aoMap = this.getTexture( json.aoMap );\n\t\t\tif ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;\n\t\n\t\t\t// MultiMaterial\n\t\n\t\t\tif ( json.materials !== undefined ) {\n\t\n\t\t\t\tfor ( var i = 0, l = json.materials.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tmaterial.materials.push( this.parse( json.materials[ i ] ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn material;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/loaders/ObjectLoader.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.ObjectLoader = function ( manager ) {\n\t\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\t\tthis.texturePath = '';\n\t\n\t};\n\t\n\tObject.assign( THREE.ObjectLoader.prototype, {\n\t\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\tif ( this.texturePath === '' ) {\n\t\n\t\t\t\tthis.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );\n\t\n\t\t\t}\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\tvar loader = new THREE.XHRLoader( scope.manager );\n\t\t\tloader.load( url, function ( text ) {\n\t\n\t\t\t\tscope.parse( JSON.parse( text ), onLoad );\n\t\n\t\t\t}, onProgress, onError );\n\t\n\t\t},\n\t\n\t\tsetTexturePath: function ( value ) {\n\t\n\t\t\tthis.texturePath = value;\n\t\n\t\t},\n\t\n\t\tsetCrossOrigin: function ( value ) {\n\t\n\t\t\tthis.crossOrigin = value;\n\t\n\t\t},\n\t\n\t\tparse: function ( json, onLoad ) {\n\t\n\t\t\tvar geometries = this.parseGeometries( json.geometries );\n\t\n\t\t\tvar images = this.parseImages( json.images, function () {\n\t\n\t\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\t\n\t\t\t} );\n\t\n\t\t\tvar textures  = this.parseTextures( json.textures, images );\n\t\t\tvar materials = this.parseMaterials( json.materials, textures );\n\t\n\t\t\tvar object = this.parseObject( json.object, geometries, materials );\n\t\n\t\t\tif ( json.animations ) {\n\t\n\t\t\t\tobject.animations = this.parseAnimations( json.animations );\n\t\n\t\t\t}\n\t\n\t\t\tif ( json.images === undefined || json.images.length === 0 ) {\n\t\n\t\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\t\n\t\t\t}\n\t\n\t\t\treturn object;\n\t\n\t\t},\n\t\n\t\tparseGeometries: function ( json ) {\n\t\n\t\t\tvar geometries = {};\n\t\n\t\t\tif ( json !== undefined ) {\n\t\n\t\t\t\tvar geometryLoader = new THREE.JSONLoader();\n\t\t\t\tvar bufferGeometryLoader = new THREE.BufferGeometryLoader();\n\t\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar geometry;\n\t\t\t\t\tvar data = json[ i ];\n\t\n\t\t\t\t\tswitch ( data.type ) {\n\t\n\t\t\t\t\t\tcase 'PlaneGeometry':\n\t\t\t\t\t\tcase 'PlaneBufferGeometry':\n\t\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\t\tdata.heightSegments\n\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'BoxGeometry':\n\t\t\t\t\t\tcase 'BoxBufferGeometry':\n\t\t\t\t\t\tcase 'CubeGeometry': // backwards compatible\n\t\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\tdata.depth,\n\t\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\tdata.depthSegments\n\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'CircleGeometry':\n\t\t\t\t\t\tcase 'CircleBufferGeometry':\n\t\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.segments,\n\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'CylinderGeometry':\n\t\t\t\t\t\tcase 'CylinderBufferGeometry':\n\t\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\t\tdata.radiusTop,\n\t\t\t\t\t\t\t\tdata.radiusBottom,\n\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\tdata.openEnded,\n\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'ConeGeometry':\n\t\t\t\t\t\tcase 'ConeBufferGeometry':\n\t\n\t\t\t\t\t\t\tgeometry = new THREE [ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\tdata.openEnded,\n\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'SphereGeometry':\n\t\t\t\t\t\tcase 'SphereBufferGeometry':\n\t\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\tdata.phiStart,\n\t\t\t\t\t\t\t\tdata.phiLength,\n\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'DodecahedronGeometry':\n\t\t\t\t\t\tcase 'IcosahedronGeometry':\n\t\t\t\t\t\tcase 'OctahedronGeometry':\n\t\t\t\t\t\tcase 'TetrahedronGeometry':\n\t\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.detail\n\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'RingGeometry':\n\t\t\t\t\t\tcase 'RingBufferGeometry':\n\t\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\t\tdata.innerRadius,\n\t\t\t\t\t\t\t\tdata.outerRadius,\n\t\t\t\t\t\t\t\tdata.thetaSegments,\n\t\t\t\t\t\t\t\tdata.phiSegments,\n\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'TorusGeometry':\n\t\t\t\t\t\tcase 'TorusBufferGeometry':\n\t\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\t\tdata.arc\n\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'TorusKnotGeometry':\n\t\t\t\t\t\tcase 'TorusKnotBufferGeometry':\n\t\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\tdata.p,\n\t\t\t\t\t\t\t\tdata.q\n\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'LatheGeometry':\n\t\t\t\t\t\tcase 'LatheBufferGeometry':\n\t\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\t\tdata.points,\n\t\t\t\t\t\t\t\tdata.segments,\n\t\t\t\t\t\t\t\tdata.phiStart,\n\t\t\t\t\t\t\t\tdata.phiLength\n\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'BufferGeometry':\n\t\n\t\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse( data );\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'Geometry':\n\t\n\t\t\t\t\t\t\tgeometry = geometryLoader.parse( data.data, this.texturePath ).geometry;\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tdefault:\n\t\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Unsupported geometry type \"' + data.type + '\"' );\n\t\n\t\t\t\t\t\t\tcontinue;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgeometry.uuid = data.uuid;\n\t\n\t\t\t\t\tif ( data.name !== undefined ) geometry.name = data.name;\n\t\n\t\t\t\t\tgeometries[ data.uuid ] = geometry;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn geometries;\n\t\n\t\t},\n\t\n\t\tparseMaterials: function ( json, textures ) {\n\t\n\t\t\tvar materials = {};\n\t\n\t\t\tif ( json !== undefined ) {\n\t\n\t\t\t\tvar loader = new THREE.MaterialLoader();\n\t\t\t\tloader.setTextures( textures );\n\t\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar material = loader.parse( json[ i ] );\n\t\t\t\t\tmaterials[ material.uuid ] = material;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn materials;\n\t\n\t\t},\n\t\n\t\tparseAnimations: function ( json ) {\n\t\n\t\t\tvar animations = [];\n\t\n\t\t\tfor ( var i = 0; i < json.length; i ++ ) {\n\t\n\t\t\t\tvar clip = THREE.AnimationClip.parse( json[ i ] );\n\t\n\t\t\t\tanimations.push( clip );\n\t\n\t\t\t}\n\t\n\t\t\treturn animations;\n\t\n\t\t},\n\t\n\t\tparseImages: function ( json, onLoad ) {\n\t\n\t\t\tvar scope = this;\n\t\t\tvar images = {};\n\t\n\t\t\tfunction loadImage( url ) {\n\t\n\t\t\t\tscope.manager.itemStart( url );\n\t\n\t\t\t\treturn loader.load( url, function () {\n\t\n\t\t\t\t\tscope.manager.itemEnd( url );\n\t\n\t\t\t\t} );\n\t\n\t\t\t}\n\t\n\t\t\tif ( json !== undefined && json.length > 0 ) {\n\t\n\t\t\t\tvar manager = new THREE.LoadingManager( onLoad );\n\t\n\t\t\t\tvar loader = new THREE.ImageLoader( manager );\n\t\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar image = json[ i ];\n\t\t\t\t\tvar path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;\n\t\n\t\t\t\t\timages[ image.uuid ] = loadImage( path );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn images;\n\t\n\t\t},\n\t\n\t\tparseTextures: function ( json, images ) {\n\t\n\t\t\tfunction parseConstant( value ) {\n\t\n\t\t\t\tif ( typeof( value ) === 'number' ) return value;\n\t\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );\n\t\n\t\t\t\treturn THREE[ value ];\n\t\n\t\t\t}\n\t\n\t\t\tvar textures = {};\n\t\n\t\t\tif ( json !== undefined ) {\n\t\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar data = json[ i ];\n\t\n\t\t\t\t\tif ( data.image === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No \"image\" specified for', data.uuid );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( images[ data.image ] === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined image', data.image );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar texture = new THREE.Texture( images[ data.image ] );\n\t\t\t\t\ttexture.needsUpdate = true;\n\t\n\t\t\t\t\ttexture.uuid = data.uuid;\n\t\n\t\t\t\t\tif ( data.name !== undefined ) texture.name = data.name;\n\t\t\t\t\tif ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping );\n\t\t\t\t\tif ( data.offset !== undefined ) texture.offset = new THREE.Vector2( data.offset[ 0 ], data.offset[ 1 ] );\n\t\t\t\t\tif ( data.repeat !== undefined ) texture.repeat = new THREE.Vector2( data.repeat[ 0 ], data.repeat[ 1 ] );\n\t\t\t\t\tif ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter );\n\t\t\t\t\tif ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter );\n\t\t\t\t\tif ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\n\t\t\t\t\tif ( Array.isArray( data.wrap ) ) {\n\t\n\t\t\t\t\t\ttexture.wrapS = parseConstant( data.wrap[ 0 ] );\n\t\t\t\t\t\ttexture.wrapT = parseConstant( data.wrap[ 1 ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttextures[ data.uuid ] = texture;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn textures;\n\t\n\t\t},\n\t\n\t\tparseObject: function () {\n\t\n\t\t\tvar matrix = new THREE.Matrix4();\n\t\n\t\t\treturn function parseObject( data, geometries, materials ) {\n\t\n\t\t\t\tvar object;\n\t\n\t\t\t\tfunction getGeometry( name ) {\n\t\n\t\t\t\t\tif ( geometries[ name ] === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined geometry', name );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn geometries[ name ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction getMaterial( name ) {\n\t\n\t\t\t\t\tif ( name === undefined ) return undefined;\n\t\n\t\t\t\t\tif ( materials[ name ] === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', name );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn materials[ name ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tswitch ( data.type ) {\n\t\n\t\t\t\t\tcase 'Scene':\n\t\n\t\t\t\t\t\tobject = new THREE.Scene();\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'PerspectiveCamera':\n\t\n\t\t\t\t\t\tobject = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\n\t\n\t\t\t\t\t\tif ( data.focus !== undefined ) object.focus = data.focus;\n\t\t\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\n\t\t\t\t\t\tif ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;\n\t\t\t\t\t\tif ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;\n\t\t\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'OrthographicCamera':\n\t\n\t\t\t\t\t\tobject = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'AmbientLight':\n\t\n\t\t\t\t\t\tobject = new THREE.AmbientLight( data.color, data.intensity );\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'DirectionalLight':\n\t\n\t\t\t\t\t\tobject = new THREE.DirectionalLight( data.color, data.intensity );\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'PointLight':\n\t\n\t\t\t\t\t\tobject = new THREE.PointLight( data.color, data.intensity, data.distance, data.decay );\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'SpotLight':\n\t\n\t\t\t\t\t\tobject = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'HemisphereLight':\n\t\n\t\t\t\t\t\tobject = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'Mesh':\n\t\n\t\t\t\t\t\tvar geometry = getGeometry( data.geometry );\n\t\t\t\t\t\tvar material = getMaterial( data.material );\n\t\n\t\t\t\t\t\tif ( geometry.bones && geometry.bones.length > 0 ) {\n\t\n\t\t\t\t\t\t\tobject = new THREE.SkinnedMesh( geometry, material );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tobject = new THREE.Mesh( geometry, material );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'LOD':\n\t\n\t\t\t\t\t\tobject = new THREE.LOD();\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'Line':\n\t\n\t\t\t\t\t\tobject = new THREE.Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'PointCloud':\n\t\t\t\t\tcase 'Points':\n\t\n\t\t\t\t\t\tobject = new THREE.Points( getGeometry( data.geometry ), getMaterial( data.material ) );\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'Sprite':\n\t\n\t\t\t\t\t\tobject = new THREE.Sprite( getMaterial( data.material ) );\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'Group':\n\t\n\t\t\t\t\t\tobject = new THREE.Group();\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tdefault:\n\t\n\t\t\t\t\t\tobject = new THREE.Object3D();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tobject.uuid = data.uuid;\n\t\n\t\t\t\tif ( data.name !== undefined ) object.name = data.name;\n\t\t\t\tif ( data.matrix !== undefined ) {\n\t\n\t\t\t\t\tmatrix.fromArray( data.matrix );\n\t\t\t\t\tmatrix.decompose( object.position, object.quaternion, object.scale );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tif ( data.position !== undefined ) object.position.fromArray( data.position );\n\t\t\t\t\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\n\t\t\t\t\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( data.castShadow !== undefined ) object.castShadow = data.castShadow;\n\t\t\t\tif ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;\n\t\n\t\t\t\tif ( data.visible !== undefined ) object.visible = data.visible;\n\t\t\t\tif ( data.userData !== undefined ) object.userData = data.userData;\n\t\n\t\t\t\tif ( data.children !== undefined ) {\n\t\n\t\t\t\t\tfor ( var child in data.children ) {\n\t\n\t\t\t\t\t\tobject.add( this.parseObject( data.children[ child ], geometries, materials ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( data.type === 'LOD' ) {\n\t\n\t\t\t\t\tvar levels = data.levels;\n\t\n\t\t\t\t\tfor ( var l = 0; l < levels.length; l ++ ) {\n\t\n\t\t\t\t\t\tvar level = levels[ l ];\n\t\t\t\t\t\tvar child = object.getObjectByProperty( 'uuid', level.object );\n\t\n\t\t\t\t\t\tif ( child !== undefined ) {\n\t\n\t\t\t\t\t\t\tobject.addLevel( child, level.distance );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn object;\n\t\n\t\t\t};\n\t\n\t\t}()\n\t\n\t} );\n\t\n\t// File:src/loaders/TextureLoader.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.TextureLoader = function ( manager ) {\n\t\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\t\n\t};\n\t\n\tObject.assign( THREE.TextureLoader.prototype, {\n\t\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\tvar texture = new THREE.Texture();\n\t\n\t\t\tvar loader = new THREE.ImageLoader( this.manager );\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\t\tloader.setPath( this.path );\n\t\t\tloader.load( url, function ( image ) {\n\t\n\t\t\t\ttexture.image = image;\n\t\t\t\ttexture.needsUpdate = true;\n\t\n\t\t\t\tif ( onLoad !== undefined ) {\n\t\n\t\t\t\t\tonLoad( texture );\n\t\n\t\t\t\t}\n\t\n\t\t\t}, onProgress, onError );\n\t\n\t\t\treturn texture;\n\t\n\t\t},\n\t\n\t\tsetCrossOrigin: function ( value ) {\n\t\n\t\t\tthis.crossOrigin = value;\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetPath: function ( value ) {\n\t\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/loaders/CubeTextureLoader.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.CubeTextureLoader = function ( manager ) {\n\t\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\t\n\t};\n\t\n\tObject.assign( THREE.CubeTextureLoader.prototype, {\n\t\n\t\tload: function ( urls, onLoad, onProgress, onError ) {\n\t\n\t\t\tvar texture = new THREE.CubeTexture();\n\t\n\t\t\tvar loader = new THREE.ImageLoader( this.manager );\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\t\tloader.setPath( this.path );\n\t\n\t\t\tvar loaded = 0;\n\t\n\t\t\tfunction loadTexture( i ) {\n\t\n\t\t\t\tloader.load( urls[ i ], function ( image ) {\n\t\n\t\t\t\t\ttexture.images[ i ] = image;\n\t\n\t\t\t\t\tloaded ++;\n\t\n\t\t\t\t\tif ( loaded === 6 ) {\n\t\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\t\n\t\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}, undefined, onError );\n\t\n\t\t\t}\n\t\n\t\t\tfor ( var i = 0; i < urls.length; ++ i ) {\n\t\n\t\t\t\tloadTexture( i );\n\t\n\t\t\t}\n\t\n\t\t\treturn texture;\n\t\n\t\t},\n\t\n\t\tsetCrossOrigin: function ( value ) {\n\t\n\t\t\tthis.crossOrigin = value;\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetPath: function ( value ) {\n\t\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/loaders/BinaryTextureLoader.js\n\t\n\t/**\n\t * @author Nikos M. / https://github.com/foo123/\n\t *\n\t * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\n\t */\n\t\n\tTHREE.DataTextureLoader = THREE.BinaryTextureLoader = function ( manager ) {\n\t\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\t\n\t\t// override in sub classes\n\t\tthis._parser = null;\n\t\n\t};\n\t\n\tObject.assign( THREE.BinaryTextureLoader.prototype, {\n\t\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\tvar texture = new THREE.DataTexture();\n\t\n\t\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\n\t\t\tloader.load( url, function ( buffer ) {\n\t\n\t\t\t\tvar texData = scope._parser( buffer );\n\t\n\t\t\t\tif ( ! texData ) return;\n\t\n\t\t\t\tif ( undefined !== texData.image ) {\n\t\n\t\t\t\t\ttexture.image = texData.image;\n\t\n\t\t\t\t} else if ( undefined !== texData.data ) {\n\t\n\t\t\t\t\ttexture.image.width = texData.width;\n\t\t\t\t\ttexture.image.height = texData.height;\n\t\t\t\t\ttexture.image.data = texData.data;\n\t\n\t\t\t\t}\n\t\n\t\t\t\ttexture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;\n\t\t\t\ttexture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;\n\t\n\t\t\t\ttexture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;\n\t\t\t\ttexture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;\n\t\n\t\t\t\ttexture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;\n\t\n\t\t\t\tif ( undefined !== texData.format ) {\n\t\n\t\t\t\t\ttexture.format = texData.format;\n\t\n\t\t\t\t}\n\t\t\t\tif ( undefined !== texData.type ) {\n\t\n\t\t\t\t\ttexture.type = texData.type;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( undefined !== texData.mipmaps ) {\n\t\n\t\t\t\t\ttexture.mipmaps = texData.mipmaps;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( 1 === texData.mipmapCount ) {\n\t\n\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\n\t\n\t\t\t\t}\n\t\n\t\t\t\ttexture.needsUpdate = true;\n\t\n\t\t\t\tif ( onLoad ) onLoad( texture, texData );\n\t\n\t\t\t}, onProgress, onError );\n\t\n\t\n\t\t\treturn texture;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/loaders/CompressedTextureLoader.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t *\n\t * Abstract Base class to block based textures loader (dds, pvr, ...)\n\t */\n\t\n\tTHREE.CompressedTextureLoader = function ( manager ) {\n\t\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\t\n\t\t// override in sub classes\n\t\tthis._parser = null;\n\t\n\t};\n\t\n\tObject.assign( THREE.CompressedTextureLoader.prototype, {\n\t\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\tvar images = [];\n\t\n\t\t\tvar texture = new THREE.CompressedTexture();\n\t\t\ttexture.image = images;\n\t\n\t\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\t\tloader.setPath( this.path );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\n\t\t\tfunction loadTexture( i ) {\n\t\n\t\t\t\tloader.load( url[ i ], function ( buffer ) {\n\t\n\t\t\t\t\tvar texDatas = scope._parser( buffer, true );\n\t\n\t\t\t\t\timages[ i ] = {\n\t\t\t\t\t\twidth: texDatas.width,\n\t\t\t\t\t\theight: texDatas.height,\n\t\t\t\t\t\tformat: texDatas.format,\n\t\t\t\t\t\tmipmaps: texDatas.mipmaps\n\t\t\t\t\t};\n\t\n\t\t\t\t\tloaded += 1;\n\t\n\t\t\t\t\tif ( loaded === 6 ) {\n\t\n\t\t\t\t\t\tif ( texDatas.mipmapCount === 1 )\n\t\t\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\n\t\n\t\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\t\n\t\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}, onProgress, onError );\n\t\n\t\t\t}\n\t\n\t\t\tif ( Array.isArray( url ) ) {\n\t\n\t\t\t\tvar loaded = 0;\n\t\n\t\t\t\tfor ( var i = 0, il = url.length; i < il; ++ i ) {\n\t\n\t\t\t\t\tloadTexture( i );\n\t\n\t\t\t\t}\n\t\n\t\t\t} else {\n\t\n\t\t\t\t// compressed cubemap texture stored in a single DDS file\n\t\n\t\t\t\tloader.load( url, function ( buffer ) {\n\t\n\t\t\t\t\tvar texDatas = scope._parser( buffer, true );\n\t\n\t\t\t\t\tif ( texDatas.isCubemap ) {\n\t\n\t\t\t\t\t\tvar faces = texDatas.mipmaps.length / texDatas.mipmapCount;\n\t\n\t\t\t\t\t\tfor ( var f = 0; f < faces; f ++ ) {\n\t\n\t\t\t\t\t\t\timages[ f ] = { mipmaps : [] };\n\t\n\t\t\t\t\t\t\tfor ( var i = 0; i < texDatas.mipmapCount; i ++ ) {\n\t\n\t\t\t\t\t\t\t\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\n\t\t\t\t\t\t\t\timages[ f ].format = texDatas.format;\n\t\t\t\t\t\t\t\timages[ f ].width = texDatas.width;\n\t\t\t\t\t\t\t\timages[ f ].height = texDatas.height;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\ttexture.image.width = texDatas.width;\n\t\t\t\t\t\ttexture.image.height = texDatas.height;\n\t\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( texDatas.mipmapCount === 1 ) {\n\t\n\t\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\ttexture.needsUpdate = true;\n\t\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\t\n\t\t\t\t}, onProgress, onError );\n\t\n\t\t\t}\n\t\n\t\t\treturn texture;\n\t\n\t\t},\n\t\n\t\tsetPath: function ( value ) {\n\t\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/materials/Material.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.Material = function () {\n\t\n\t\tObject.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );\n\t\n\t\tthis.uuid = THREE.Math.generateUUID();\n\t\n\t\tthis.name = '';\n\t\tthis.type = 'Material';\n\t\n\t\tthis.fog = true;\n\t\tthis.lights = true;\n\t\n\t\tthis.blending = THREE.NormalBlending;\n\t\tthis.side = THREE.FrontSide;\n\t\tthis.shading = THREE.SmoothShading; // THREE.FlatShading, THREE.SmoothShading\n\t\tthis.vertexColors = THREE.NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors\n\t\n\t\tthis.opacity = 1;\n\t\tthis.transparent = false;\n\t\n\t\tthis.blendSrc = THREE.SrcAlphaFactor;\n\t\tthis.blendDst = THREE.OneMinusSrcAlphaFactor;\n\t\tthis.blendEquation = THREE.AddEquation;\n\t\tthis.blendSrcAlpha = null;\n\t\tthis.blendDstAlpha = null;\n\t\tthis.blendEquationAlpha = null;\n\t\n\t\tthis.depthFunc = THREE.LessEqualDepth;\n\t\tthis.depthTest = true;\n\t\tthis.depthWrite = true;\n\t\n\t\tthis.clippingPlanes = null;\n\t\tthis.clipShadows = false;\n\t\n\t\tthis.colorWrite = true;\n\t\n\t\tthis.precision = null; // override the renderer's default precision for this material\n\t\n\t\tthis.polygonOffset = false;\n\t\tthis.polygonOffsetFactor = 0;\n\t\tthis.polygonOffsetUnits = 0;\n\t\n\t\tthis.alphaTest = 0;\n\t\tthis.premultipliedAlpha = false;\n\t\n\t\tthis.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer\n\t\n\t\tthis.visible = true;\n\t\n\t\tthis._needsUpdate = true;\n\t\n\t};\n\t\n\tTHREE.Material.prototype = {\n\t\n\t\tconstructor: THREE.Material,\n\t\n\t\tget needsUpdate() {\n\t\n\t\t\treturn this._needsUpdate;\n\t\n\t\t},\n\t\n\t\tset needsUpdate( value ) {\n\t\n\t\t\tif ( value === true ) this.update();\n\t\t\tthis._needsUpdate = value;\n\t\n\t\t},\n\t\n\t\tsetValues: function ( values ) {\n\t\n\t\t\tif ( values === undefined ) return;\n\t\n\t\t\tfor ( var key in values ) {\n\t\n\t\t\t\tvar newValue = values[ key ];\n\t\n\t\t\t\tif ( newValue === undefined ) {\n\t\n\t\t\t\t\tconsole.warn( \"THREE.Material: '\" + key + \"' parameter is undefined.\" );\n\t\t\t\t\tcontinue;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar currentValue = this[ key ];\n\t\n\t\t\t\tif ( currentValue === undefined ) {\n\t\n\t\t\t\t\tconsole.warn( \"THREE.\" + this.type + \": '\" + key + \"' is not a property of this material.\" );\n\t\t\t\t\tcontinue;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( currentValue instanceof THREE.Color ) {\n\t\n\t\t\t\t\tcurrentValue.set( newValue );\n\t\n\t\t\t\t} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {\n\t\n\t\t\t\t\tcurrentValue.copy( newValue );\n\t\n\t\t\t\t} else if ( key === 'overdraw' ) {\n\t\n\t\t\t\t\t// ensure overdraw is backwards-compatible with legacy boolean type\n\t\t\t\t\tthis[ key ] = Number( newValue );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis[ key ] = newValue;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\ttoJSON: function ( meta ) {\n\t\n\t\t\tvar isRoot = meta === undefined;\n\t\n\t\t\tif ( isRoot ) {\n\t\n\t\t\t\tmeta = {\n\t\t\t\t\ttextures: {},\n\t\t\t\t\timages: {}\n\t\t\t\t};\n\t\n\t\t\t}\n\t\n\t\t\tvar data = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.4,\n\t\t\t\t\ttype: 'Material',\n\t\t\t\t\tgenerator: 'Material.toJSON'\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\t// standard Material serialization\n\t\t\tdata.uuid = this.uuid;\n\t\t\tdata.type = this.type;\n\t\n\t\t\tif ( this.name !== '' ) data.name = this.name;\n\t\n\t\t\tif ( this.color instanceof THREE.Color ) data.color = this.color.getHex();\n\t\n\t\t\tif ( this.roughness !== undefined ) data.roughness = this.roughness;\n\t\t\tif ( this.metalness !== undefined ) data.metalness = this.metalness;\n\t\n\t\t\tif ( this.emissive instanceof THREE.Color ) data.emissive = this.emissive.getHex();\n\t\t\tif ( this.specular instanceof THREE.Color ) data.specular = this.specular.getHex();\n\t\t\tif ( this.shininess !== undefined ) data.shininess = this.shininess;\n\t\n\t\t\tif ( this.map instanceof THREE.Texture ) data.map = this.map.toJSON( meta ).uuid;\n\t\t\tif ( this.alphaMap instanceof THREE.Texture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;\n\t\t\tif ( this.lightMap instanceof THREE.Texture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;\n\t\t\tif ( this.bumpMap instanceof THREE.Texture ) {\n\t\n\t\t\t\tdata.bumpMap = this.bumpMap.toJSON( meta ).uuid;\n\t\t\t\tdata.bumpScale = this.bumpScale;\n\t\n\t\t\t}\n\t\t\tif ( this.normalMap instanceof THREE.Texture ) {\n\t\n\t\t\t\tdata.normalMap = this.normalMap.toJSON( meta ).uuid;\n\t\t\t\tdata.normalScale = this.normalScale.toArray();\n\t\n\t\t\t}\n\t\t\tif ( this.displacementMap instanceof THREE.Texture ) {\n\t\n\t\t\t\tdata.displacementMap = this.displacementMap.toJSON( meta ).uuid;\n\t\t\t\tdata.displacementScale = this.displacementScale;\n\t\t\t\tdata.displacementBias = this.displacementBias;\n\t\n\t\t\t}\n\t\t\tif ( this.roughnessMap instanceof THREE.Texture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;\n\t\t\tif ( this.metalnessMap instanceof THREE.Texture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;\n\t\n\t\t\tif ( this.emissiveMap instanceof THREE.Texture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;\n\t\t\tif ( this.specularMap instanceof THREE.Texture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;\n\t\n\t\t\tif ( this.envMap instanceof THREE.Texture ) {\n\t\n\t\t\t\tdata.envMap = this.envMap.toJSON( meta ).uuid;\n\t\t\t\tdata.reflectivity = this.reflectivity; // Scale behind envMap\n\t\n\t\t\t}\n\t\n\t\t\tif ( this.size !== undefined ) data.size = this.size;\n\t\t\tif ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;\n\t\n\t\t\tif ( this.blending !== THREE.NormalBlending ) data.blending = this.blending;\n\t\t\tif ( this.shading !== THREE.SmoothShading ) data.shading = this.shading;\n\t\t\tif ( this.side !== THREE.FrontSide ) data.side = this.side;\n\t\t\tif ( this.vertexColors !== THREE.NoColors ) data.vertexColors = this.vertexColors;\n\t\n\t\t\tif ( this.opacity < 1 ) data.opacity = this.opacity;\n\t\t\tif ( this.transparent === true ) data.transparent = this.transparent;\n\t\t\tif ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;\n\t\t\tif ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;\n\t\t\tif ( this.wireframe === true ) data.wireframe = this.wireframe;\n\t\t\tif ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;\n\t\n\t\t\t// TODO: Copied from Object3D.toJSON\n\t\n\t\t\tfunction extractFromCache ( cache ) {\n\t\n\t\t\t\tvar values = [];\n\t\n\t\t\t\tfor ( var key in cache ) {\n\t\n\t\t\t\t\tvar data = cache[ key ];\n\t\t\t\t\tdelete data.metadata;\n\t\t\t\t\tvalues.push( data );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn values;\n\t\n\t\t\t}\n\t\n\t\t\tif ( isRoot ) {\n\t\n\t\t\t\tvar textures = extractFromCache( meta.textures );\n\t\t\t\tvar images = extractFromCache( meta.images );\n\t\n\t\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\t\tif ( images.length > 0 ) data.images = images;\n\t\n\t\t\t}\n\t\n\t\t\treturn data;\n\t\n\t\t},\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t},\n\t\n\t\tcopy: function ( source ) {\n\t\n\t\t\tthis.name = source.name;\n\t\n\t\t\tthis.fog = source.fog;\n\t\t\tthis.lights = source.lights;\n\t\n\t\t\tthis.blending = source.blending;\n\t\t\tthis.side = source.side;\n\t\t\tthis.shading = source.shading;\n\t\t\tthis.vertexColors = source.vertexColors;\n\t\n\t\t\tthis.opacity = source.opacity;\n\t\t\tthis.transparent = source.transparent;\n\t\n\t\t\tthis.blendSrc = source.blendSrc;\n\t\t\tthis.blendDst = source.blendDst;\n\t\t\tthis.blendEquation = source.blendEquation;\n\t\t\tthis.blendSrcAlpha = source.blendSrcAlpha;\n\t\t\tthis.blendDstAlpha = source.blendDstAlpha;\n\t\t\tthis.blendEquationAlpha = source.blendEquationAlpha;\n\t\n\t\t\tthis.depthFunc = source.depthFunc;\n\t\t\tthis.depthTest = source.depthTest;\n\t\t\tthis.depthWrite = source.depthWrite;\n\t\n\t\t\tthis.colorWrite = source.colorWrite;\n\t\n\t\t\tthis.precision = source.precision;\n\t\n\t\t\tthis.polygonOffset = source.polygonOffset;\n\t\t\tthis.polygonOffsetFactor = source.polygonOffsetFactor;\n\t\t\tthis.polygonOffsetUnits = source.polygonOffsetUnits;\n\t\n\t\t\tthis.alphaTest = source.alphaTest;\n\t\n\t\t\tthis.premultipliedAlpha = source.premultipliedAlpha;\n\t\n\t\t\tthis.overdraw = source.overdraw;\n\t\n\t\t\tthis.visible = source.visible;\n\t\t\tthis.clipShadows = source.clipShadows;\n\t\n\t\t\tvar srcPlanes = source.clippingPlanes,\n\t\t\t\tdstPlanes = null;\n\t\n\t\t\tif ( srcPlanes !== null ) {\n\t\n\t\t\t\tvar n = srcPlanes.length;\n\t\t\t\tdstPlanes = new Array( n );\n\t\n\t\t\t\tfor ( var i = 0; i !== n; ++ i )\n\t\t\t\t\tdstPlanes[ i ] = srcPlanes[ i ].clone();\n\t\n\t\t\t}\n\t\n\t\t\tthis.clippingPlanes = dstPlanes;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tupdate: function () {\n\t\n\t\t\tthis.dispatchEvent( { type: 'update' } );\n\t\n\t\t},\n\t\n\t\tdispose: function () {\n\t\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\t\n\t\t}\n\t\n\t};\n\t\n\tObject.assign( THREE.Material.prototype, THREE.EventDispatcher.prototype );\n\t\n\tTHREE.MaterialIdCount = 0;\n\t\n\t// File:src/materials/LineBasicMaterial.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *\n\t *  linewidth: <float>,\n\t *  linecap: \"round\",\n\t *  linejoin: \"round\"\n\t * }\n\t */\n\t\n\tTHREE.LineBasicMaterial = function ( parameters ) {\n\t\n\t\tTHREE.Material.call( this );\n\t\n\t\tthis.type = 'LineBasicMaterial';\n\t\n\t\tthis.color = new THREE.Color( 0xffffff );\n\t\n\t\tthis.linewidth = 1;\n\t\tthis.linecap = 'round';\n\t\tthis.linejoin = 'round';\n\t\n\t\tthis.lights = false;\n\t\n\t\tthis.setValues( parameters );\n\t\n\t};\n\t\n\tTHREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );\n\tTHREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;\n\t\n\tTHREE.LineBasicMaterial.prototype.copy = function ( source ) {\n\t\n\t\tTHREE.Material.prototype.copy.call( this, source );\n\t\n\t\tthis.color.copy( source.color );\n\t\n\t\tthis.linewidth = source.linewidth;\n\t\tthis.linecap = source.linecap;\n\t\tthis.linejoin = source.linejoin;\n\t\n\t\treturn this;\n\t\n\t};\n\t\n\t// File:src/materials/LineDashedMaterial.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *\n\t *  linewidth: <float>,\n\t *\n\t *  scale: <float>,\n\t *  dashSize: <float>,\n\t *  gapSize: <float>\n\t * }\n\t */\n\t\n\tTHREE.LineDashedMaterial = function ( parameters ) {\n\t\n\t\tTHREE.Material.call( this );\n\t\n\t\tthis.type = 'LineDashedMaterial';\n\t\n\t\tthis.color = new THREE.Color( 0xffffff );\n\t\n\t\tthis.linewidth = 1;\n\t\n\t\tthis.scale = 1;\n\t\tthis.dashSize = 3;\n\t\tthis.gapSize = 1;\n\t\n\t\tthis.lights = false;\n\t\n\t\tthis.setValues( parameters );\n\t\n\t};\n\t\n\tTHREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );\n\tTHREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;\n\t\n\tTHREE.LineDashedMaterial.prototype.copy = function ( source ) {\n\t\n\t\tTHREE.Material.prototype.copy.call( this, source );\n\t\n\t\tthis.color.copy( source.color );\n\t\n\t\tthis.linewidth = source.linewidth;\n\t\n\t\tthis.scale = source.scale;\n\t\tthis.dashSize = source.dashSize;\n\t\tthis.gapSize = source.gapSize;\n\t\n\t\treturn this;\n\t\n\t};\n\t\n\t// File:src/materials/MeshBasicMaterial.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  aoMap: new THREE.Texture( <Image> ),\n\t *  aoMapIntensity: <float>\n\t *\n\t *  specularMap: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n\t *  combine: THREE.Multiply,\n\t *  reflectivity: <float>,\n\t *  refractionRatio: <float>,\n\t *\n\t *  shading: THREE.SmoothShading,\n\t *  depthTest: <bool>,\n\t *  depthWrite: <bool>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>\n\t * }\n\t */\n\t\n\tTHREE.MeshBasicMaterial = function ( parameters ) {\n\t\n\t\tTHREE.Material.call( this );\n\t\n\t\tthis.type = 'MeshBasicMaterial';\n\t\n\t\tthis.color = new THREE.Color( 0xffffff ); // emissive\n\t\n\t\tthis.map = null;\n\t\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\t\n\t\tthis.specularMap = null;\n\t\n\t\tthis.alphaMap = null;\n\t\n\t\tthis.envMap = null;\n\t\tthis.combine = THREE.MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\t\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\t\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\t\n\t\tthis.lights = false;\n\t\n\t\tthis.setValues( parameters );\n\t\n\t};\n\t\n\tTHREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );\n\tTHREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;\n\t\n\tTHREE.MeshBasicMaterial.prototype.copy = function ( source ) {\n\t\n\t\tTHREE.Material.prototype.copy.call( this, source );\n\t\n\t\tthis.color.copy( source.color );\n\t\n\t\tthis.map = source.map;\n\t\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\t\n\t\tthis.specularMap = source.specularMap;\n\t\n\t\tthis.alphaMap = source.alphaMap;\n\t\n\t\tthis.envMap = source.envMap;\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\t\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\t\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\t\n\t\treturn this;\n\t\n\t};\n\t\n\t// File:src/materials/MeshDepthMaterial.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author bhouston / https://clara.io\n\t * @author WestLangley / http://github.com/WestLangley\n\t *\n\t * parameters = {\n\t *\n\t *  opacity: <float>,\n\t *\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  displacementMap: new THREE.Texture( <Image> ),\n\t *  displacementScale: <float>,\n\t *  displacementBias: <float>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>\n\t * }\n\t */\n\t\n\tTHREE.MeshDepthMaterial = function ( parameters ) {\n\t\n\t\tTHREE.Material.call( this );\n\t\n\t\tthis.type = 'MeshDepthMaterial';\n\t\n\t\tthis.depthPacking = THREE.BasicDepthPacking;\n\t\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\t\n\t\tthis.map = null;\n\t\n\t\tthis.alphaMap = null;\n\t\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\t\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\n\t\tthis.fog = false;\n\t\tthis.lights = false;\n\t\n\t\tthis.setValues( parameters );\n\t\n\t};\n\t\n\tTHREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );\n\tTHREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;\n\t\n\tTHREE.MeshDepthMaterial.prototype.copy = function ( source ) {\n\t\n\t\tTHREE.Material.prototype.copy.call( this, source );\n\t\n\t\tthis.depthPacking = source.depthPacking;\n\t\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\t\n\t\tthis.map = source.map;\n\t\n\t\tthis.alphaMap = source.alphaMap;\n\t\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\t\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\n\t\treturn this;\n\t\n\t};\n\t\n\t// File:src/materials/MeshLambertMaterial.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  lightMap: new THREE.Texture( <Image> ),\n\t *  lightMapIntensity: <float>\n\t *\n\t *  aoMap: new THREE.Texture( <Image> ),\n\t *  aoMapIntensity: <float>\n\t *\n\t *  emissive: <hex>,\n\t *  emissiveIntensity: <float>\n\t *  emissiveMap: new THREE.Texture( <Image> ),\n\t *\n\t *  specularMap: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n\t *  combine: THREE.Multiply,\n\t *  reflectivity: <float>,\n\t *  refractionRatio: <float>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>,\n\t *  morphNormals: <bool>\n\t * }\n\t */\n\t\n\tTHREE.MeshLambertMaterial = function ( parameters ) {\n\t\n\t\tTHREE.Material.call( this );\n\t\n\t\tthis.type = 'MeshLambertMaterial';\n\t\n\t\tthis.color = new THREE.Color( 0xffffff ); // diffuse\n\t\n\t\tthis.map = null;\n\t\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\t\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\t\n\t\tthis.emissive = new THREE.Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\t\n\t\tthis.specularMap = null;\n\t\n\t\tthis.alphaMap = null;\n\t\n\t\tthis.envMap = null;\n\t\tthis.combine = THREE.MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\t\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\t\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\t\tthis.morphNormals = false;\n\t\n\t\tthis.setValues( parameters );\n\t\n\t};\n\t\n\tTHREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );\n\tTHREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;\n\t\n\tTHREE.MeshLambertMaterial.prototype.copy = function ( source ) {\n\t\n\t\tTHREE.Material.prototype.copy.call( this, source );\n\t\n\t\tthis.color.copy( source.color );\n\t\n\t\tthis.map = source.map;\n\t\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\t\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\t\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\t\n\t\tthis.specularMap = source.specularMap;\n\t\n\t\tthis.alphaMap = source.alphaMap;\n\t\n\t\tthis.envMap = source.envMap;\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\t\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\t\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\t\tthis.morphNormals = source.morphNormals;\n\t\n\t\treturn this;\n\t\n\t};\n\t\n\t// File:src/materials/MeshNormalMaterial.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t *\n\t * parameters = {\n\t *  opacity: <float>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>\n\t * }\n\t */\n\t\n\tTHREE.MeshNormalMaterial = function ( parameters ) {\n\t\n\t\tTHREE.Material.call( this, parameters );\n\t\n\t\tthis.type = 'MeshNormalMaterial';\n\t\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\n\t\tthis.fog = false;\n\t\tthis.lights = false;\n\t\tthis.morphTargets = false;\n\t\n\t\tthis.setValues( parameters );\n\t\n\t};\n\t\n\tTHREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );\n\tTHREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;\n\t\n\tTHREE.MeshNormalMaterial.prototype.copy = function ( source ) {\n\t\n\t\tTHREE.Material.prototype.copy.call( this, source );\n\t\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\n\t\treturn this;\n\t\n\t};\n\t\n\t// File:src/materials/MeshPhongMaterial.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  specular: <hex>,\n\t *  shininess: <float>,\n\t *  opacity: <float>,\n\t *\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  lightMap: new THREE.Texture( <Image> ),\n\t *  lightMapIntensity: <float>\n\t *\n\t *  aoMap: new THREE.Texture( <Image> ),\n\t *  aoMapIntensity: <float>\n\t *\n\t *  emissive: <hex>,\n\t *  emissiveIntensity: <float>\n\t *  emissiveMap: new THREE.Texture( <Image> ),\n\t *\n\t *  bumpMap: new THREE.Texture( <Image> ),\n\t *  bumpScale: <float>,\n\t *\n\t *  normalMap: new THREE.Texture( <Image> ),\n\t *  normalScale: <Vector2>,\n\t *\n\t *  displacementMap: new THREE.Texture( <Image> ),\n\t *  displacementScale: <float>,\n\t *  displacementBias: <float>,\n\t *\n\t *  specularMap: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n\t *  combine: THREE.Multiply,\n\t *  reflectivity: <float>,\n\t *  refractionRatio: <float>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>,\n\t *  morphNormals: <bool>\n\t * }\n\t */\n\t\n\tTHREE.MeshPhongMaterial = function ( parameters ) {\n\t\n\t\tTHREE.Material.call( this );\n\t\n\t\tthis.type = 'MeshPhongMaterial';\n\t\n\t\tthis.color = new THREE.Color( 0xffffff ); // diffuse\n\t\tthis.specular = new THREE.Color( 0x111111 );\n\t\tthis.shininess = 30;\n\t\n\t\tthis.map = null;\n\t\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\t\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\t\n\t\tthis.emissive = new THREE.Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\t\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\t\n\t\tthis.normalMap = null;\n\t\tthis.normalScale = new THREE.Vector2( 1, 1 );\n\t\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\t\n\t\tthis.specularMap = null;\n\t\n\t\tthis.alphaMap = null;\n\t\n\t\tthis.envMap = null;\n\t\tthis.combine = THREE.MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\t\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\t\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\t\tthis.morphNormals = false;\n\t\n\t\tthis.setValues( parameters );\n\t\n\t};\n\t\n\tTHREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );\n\tTHREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;\n\t\n\tTHREE.MeshPhongMaterial.prototype.copy = function ( source ) {\n\t\n\t\tTHREE.Material.prototype.copy.call( this, source );\n\t\n\t\tthis.color.copy( source.color );\n\t\tthis.specular.copy( source.specular );\n\t\tthis.shininess = source.shininess;\n\t\n\t\tthis.map = source.map;\n\t\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\t\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\t\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\t\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\t\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalScale.copy( source.normalScale );\n\t\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\t\n\t\tthis.specularMap = source.specularMap;\n\t\n\t\tthis.alphaMap = source.alphaMap;\n\t\n\t\tthis.envMap = source.envMap;\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\t\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\t\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\t\tthis.morphNormals = source.morphNormals;\n\t\n\t\treturn this;\n\t\n\t};\n\t\n\t// File:src/materials/MeshStandardMaterial.js\n\t\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  roughness: <float>,\n\t *  metalness: <float>,\n\t *  opacity: <float>,\n\t *\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  lightMap: new THREE.Texture( <Image> ),\n\t *  lightMapIntensity: <float>\n\t *\n\t *  aoMap: new THREE.Texture( <Image> ),\n\t *  aoMapIntensity: <float>\n\t *\n\t *  emissive: <hex>,\n\t *  emissiveIntensity: <float>\n\t *  emissiveMap: new THREE.Texture( <Image> ),\n\t *\n\t *  bumpMap: new THREE.Texture( <Image> ),\n\t *  bumpScale: <float>,\n\t *\n\t *  normalMap: new THREE.Texture( <Image> ),\n\t *  normalScale: <Vector2>,\n\t *\n\t *  displacementMap: new THREE.Texture( <Image> ),\n\t *  displacementScale: <float>,\n\t *  displacementBias: <float>,\n\t *\n\t *  roughnessMap: new THREE.Texture( <Image> ),\n\t *\n\t *  metalnessMap: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n\t *  envMapIntensity: <float>\n\t *\n\t *  refractionRatio: <float>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>,\n\t *  morphNormals: <bool>\n\t * }\n\t */\n\t\n\tTHREE.MeshStandardMaterial = function ( parameters ) {\n\t\n\t\tTHREE.Material.call( this );\n\t\n\t\tthis.defines = { 'STANDARD': '' };\n\t\n\t\tthis.type = 'MeshStandardMaterial';\n\t\n\t\tthis.color = new THREE.Color( 0xffffff ); // diffuse\n\t\tthis.roughness = 0.5;\n\t\tthis.metalness = 0.5;\n\t\n\t\tthis.map = null;\n\t\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\t\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\t\n\t\tthis.emissive = new THREE.Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\t\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\t\n\t\tthis.normalMap = null;\n\t\tthis.normalScale = new THREE.Vector2( 1, 1 );\n\t\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\t\n\t\tthis.roughnessMap = null;\n\t\n\t\tthis.metalnessMap = null;\n\t\n\t\tthis.alphaMap = null;\n\t\n\t\tthis.envMap = null;\n\t\tthis.envMapIntensity = 1.0;\n\t\n\t\tthis.refractionRatio = 0.98;\n\t\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\t\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\t\tthis.morphNormals = false;\n\t\n\t\tthis.setValues( parameters );\n\t\n\t};\n\t\n\tTHREE.MeshStandardMaterial.prototype = Object.create( THREE.Material.prototype );\n\tTHREE.MeshStandardMaterial.prototype.constructor = THREE.MeshStandardMaterial;\n\t\n\tTHREE.MeshStandardMaterial.prototype.copy = function ( source ) {\n\t\n\t\tTHREE.Material.prototype.copy.call( this, source );\n\t\n\t\tthis.defines = { 'STANDARD': '' };\n\t\n\t\tthis.color.copy( source.color );\n\t\tthis.roughness = source.roughness;\n\t\tthis.metalness = source.metalness;\n\t\n\t\tthis.map = source.map;\n\t\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\t\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\t\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\t\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\t\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalScale.copy( source.normalScale );\n\t\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\t\n\t\tthis.roughnessMap = source.roughnessMap;\n\t\n\t\tthis.metalnessMap = source.metalnessMap;\n\t\n\t\tthis.alphaMap = source.alphaMap;\n\t\n\t\tthis.envMap = source.envMap;\n\t\tthis.envMapIntensity = source.envMapIntensity;\n\t\n\t\tthis.refractionRatio = source.refractionRatio;\n\t\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\t\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\t\tthis.morphNormals = source.morphNormals;\n\t\n\t\treturn this;\n\t\n\t};\n\t\n\t// File:src/materials/MeshPhysicalMaterial.js\n\t\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t *\n\t * parameters = {\n\t *  reflectivity: <float>\n\t * }\n\t */\n\t\n\tTHREE.MeshPhysicalMaterial = function ( parameters ) {\n\t\n\t\tTHREE.MeshStandardMaterial.call( this );\n\t\n\t\tthis.defines = { 'PHYSICAL': '' };\n\t\n\t\tthis.type = 'MeshPhysicalMaterial';\n\t\n\t\tthis.reflectivity = 0.5; // maps to F0 = 0.04\n\t\n\t\tthis.clearCoat = 0.0;\n\t\tthis.clearCoatRoughness = 0.0;\n\t\n\t\tthis.setValues( parameters );\n\t\n\t};\n\t\n\tTHREE.MeshPhysicalMaterial.prototype = Object.create( THREE.MeshStandardMaterial.prototype );\n\tTHREE.MeshPhysicalMaterial.prototype.constructor = THREE.MeshPhysicalMaterial;\n\t\n\tTHREE.MeshPhysicalMaterial.prototype.copy = function ( source ) {\n\t\n\t\tTHREE.MeshStandardMaterial.prototype.copy.call( this, source );\n\t\n\t\tthis.defines = { 'PHYSICAL': '' };\n\t\n\t\tthis.reflectivity = source.reflectivity;\n\t\n\t\tthis.clearCoat = source.clearCoat;\n\t\tthis.clearCoatRoughness = source.clearCoatRoughness;\n\t\n\t\treturn this;\n\t\n\t};\n\t\n\t// File:src/materials/MultiMaterial.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.MultiMaterial = function ( materials ) {\n\t\n\t\tthis.uuid = THREE.Math.generateUUID();\n\t\n\t\tthis.type = 'MultiMaterial';\n\t\n\t\tthis.materials = materials instanceof Array ? materials : [];\n\t\n\t\tthis.visible = true;\n\t\n\t};\n\t\n\tTHREE.MultiMaterial.prototype = {\n\t\n\t\tconstructor: THREE.MultiMaterial,\n\t\n\t\ttoJSON: function ( meta ) {\n\t\n\t\t\tvar output = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.2,\n\t\t\t\t\ttype: 'material',\n\t\t\t\t\tgenerator: 'MaterialExporter'\n\t\t\t\t},\n\t\t\t\tuuid: this.uuid,\n\t\t\t\ttype: this.type,\n\t\t\t\tmaterials: []\n\t\t\t};\n\t\n\t\t\tvar materials = this.materials;\n\t\n\t\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar material = materials[ i ].toJSON( meta );\n\t\t\t\tdelete material.metadata;\n\t\n\t\t\t\toutput.materials.push( material );\n\t\n\t\t\t}\n\t\n\t\t\toutput.visible = this.visible;\n\t\n\t\t\treturn output;\n\t\n\t\t},\n\t\n\t\tclone: function () {\n\t\n\t\t\tvar material = new this.constructor();\n\t\n\t\t\tfor ( var i = 0; i < this.materials.length; i ++ ) {\n\t\n\t\t\t\tmaterial.materials.push( this.materials[ i ].clone() );\n\t\n\t\t\t}\n\t\n\t\t\tmaterial.visible = this.visible;\n\t\n\t\t\treturn material;\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/materials/PointsMaterial.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  size: <float>,\n\t *  sizeAttenuation: <bool>\n\t * }\n\t */\n\t\n\tTHREE.PointsMaterial = function ( parameters ) {\n\t\n\t\tTHREE.Material.call( this );\n\t\n\t\tthis.type = 'PointsMaterial';\n\t\n\t\tthis.color = new THREE.Color( 0xffffff );\n\t\n\t\tthis.map = null;\n\t\n\t\tthis.size = 1;\n\t\tthis.sizeAttenuation = true;\n\t\n\t\tthis.lights = false;\n\t\n\t\tthis.setValues( parameters );\n\t\n\t};\n\t\n\tTHREE.PointsMaterial.prototype = Object.create( THREE.Material.prototype );\n\tTHREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial;\n\t\n\tTHREE.PointsMaterial.prototype.copy = function ( source ) {\n\t\n\t\tTHREE.Material.prototype.copy.call( this, source );\n\t\n\t\tthis.color.copy( source.color );\n\t\n\t\tthis.map = source.map;\n\t\n\t\tthis.size = source.size;\n\t\tthis.sizeAttenuation = source.sizeAttenuation;\n\t\n\t\treturn this;\n\t\n\t};\n\t\n\t// File:src/materials/ShaderMaterial.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  defines: { \"label\" : \"value\" },\n\t *  uniforms: { \"parameter1\": { value: 1.0 }, \"parameter2\": { value2: 2 } },\n\t *\n\t *  fragmentShader: <string>,\n\t *  vertexShader: <string>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>,\n\t *\n\t *  lights: <bool>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>,\n\t *  morphNormals: <bool>\n\t * }\n\t */\n\t\n\tTHREE.ShaderMaterial = function ( parameters ) {\n\t\n\t\tTHREE.Material.call( this );\n\t\n\t\tthis.type = 'ShaderMaterial';\n\t\n\t\tthis.defines = {};\n\t\tthis.uniforms = {};\n\t\n\t\tthis.vertexShader = 'void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}';\n\t\tthis.fragmentShader = 'void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}';\n\t\n\t\tthis.linewidth = 1;\n\t\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\n\t\tthis.fog = false; // set to use scene fog\n\t\tthis.lights = false; // set to use scene lights\n\t\tthis.clipping = false; // set to use user-defined clipping planes\n\t\n\t\tthis.skinning = false; // set to use skinning attribute streams\n\t\tthis.morphTargets = false; // set to use morph targets\n\t\tthis.morphNormals = false; // set to use morph normals\n\t\n\t\tthis.extensions = {\n\t\t\tderivatives: false, // set to use derivatives\n\t\t\tfragDepth: false, // set to use fragment depth values\n\t\t\tdrawBuffers: false, // set to use draw buffers\n\t\t\tshaderTextureLOD: false // set to use shader texture LOD\n\t\t};\n\t\n\t\t// When rendered geometry doesn't include these attributes but the material does,\n\t\t// use these default values in WebGL. This avoids errors when buffer data is missing.\n\t\tthis.defaultAttributeValues = {\n\t\t\t'color': [ 1, 1, 1 ],\n\t\t\t'uv': [ 0, 0 ],\n\t\t\t'uv2': [ 0, 0 ]\n\t\t};\n\t\n\t\tthis.index0AttributeName = undefined;\n\t\n\t\tif ( parameters !== undefined ) {\n\t\n\t\t\tif ( parameters.attributes !== undefined ) {\n\t\n\t\t\t\tconsole.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );\n\t\n\t\t\t}\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );\n\tTHREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;\n\t\n\tTHREE.ShaderMaterial.prototype.copy = function ( source ) {\n\t\n\t\tTHREE.Material.prototype.copy.call( this, source );\n\t\n\t\tthis.fragmentShader = source.fragmentShader;\n\t\tthis.vertexShader = source.vertexShader;\n\t\n\t\tthis.uniforms = THREE.UniformsUtils.clone( source.uniforms );\n\t\n\t\tthis.defines = source.defines;\n\t\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\n\t\tthis.lights = source.lights;\n\t\tthis.clipping = source.clipping;\n\t\n\t\tthis.skinning = source.skinning;\n\t\n\t\tthis.morphTargets = source.morphTargets;\n\t\tthis.morphNormals = source.morphNormals;\n\t\n\t\tthis.extensions = source.extensions;\n\t\n\t\treturn this;\n\t\n\t};\n\t\n\tTHREE.ShaderMaterial.prototype.toJSON = function ( meta ) {\n\t\n\t\tvar data = THREE.Material.prototype.toJSON.call( this, meta );\n\t\n\t\tdata.uniforms = this.uniforms;\n\t\tdata.vertexShader = this.vertexShader;\n\t\tdata.fragmentShader = this.fragmentShader;\n\t\n\t\treturn data;\n\t\n\t};\n\t\n\t// File:src/materials/RawShaderMaterial.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.RawShaderMaterial = function ( parameters ) {\n\t\n\t\tTHREE.ShaderMaterial.call( this, parameters );\n\t\n\t\tthis.type = 'RawShaderMaterial';\n\t\n\t};\n\t\n\tTHREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );\n\tTHREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;\n\t\n\t// File:src/materials/SpriteMaterial.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *\tuvOffset: new THREE.Vector2(),\n\t *\tuvScale: new THREE.Vector2()\n\t * }\n\t */\n\t\n\tTHREE.SpriteMaterial = function ( parameters ) {\n\t\n\t\tTHREE.Material.call( this );\n\t\n\t\tthis.type = 'SpriteMaterial';\n\t\n\t\tthis.color = new THREE.Color( 0xffffff );\n\t\tthis.map = null;\n\t\n\t\tthis.rotation = 0;\n\t\n\t\tthis.fog = false;\n\t\tthis.lights = false;\n\t\n\t\tthis.setValues( parameters );\n\t\n\t};\n\t\n\tTHREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );\n\tTHREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;\n\t\n\tTHREE.SpriteMaterial.prototype.copy = function ( source ) {\n\t\n\t\tTHREE.Material.prototype.copy.call( this, source );\n\t\n\t\tthis.color.copy( source.color );\n\t\tthis.map = source.map;\n\t\n\t\tthis.rotation = source.rotation;\n\t\n\t\treturn this;\n\t\n\t};\n\t\n\t// File:src/materials/ShadowMaterial.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.ShadowMaterial = function () {\n\t\n\t\tTHREE.ShaderMaterial.call( this, {\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\n\t\t\t\tTHREE.UniformsLib[ \"lights\" ],\n\t\t\t\t{\n\t\t\t\t\topacity: { value: 1.0 }\n\t\t\t\t}\n\t\t\t] ),\n\t\t\tvertexShader: THREE.ShaderChunk[ 'shadow_vert' ],\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'shadow_frag' ]\n\t\t} );\n\t\n\t\tthis.lights = true;\n\t\tthis.transparent = true;\n\t\n\t\tObject.defineProperties( this, {\n\t\t\topacity: {\n\t\t\t\tenumerable: true,\n\t\t\t\tget: function () {\n\t\t\t\t\treturn this.uniforms.opacity.value;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tthis.uniforms.opacity.value = value;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\n\t};\n\t\n\tTHREE.ShadowMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );\n\tTHREE.ShadowMaterial.prototype.constructor = THREE.ShadowMaterial;\n\t\n\t// File:src/textures/Texture.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author szimek / https://github.com/szimek/\n\t */\n\t\n\tTHREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\t\n\t\tObject.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );\n\t\n\t\tthis.uuid = THREE.Math.generateUUID();\n\t\n\t\tthis.name = '';\n\t\tthis.sourceFile = '';\n\t\n\t\tthis.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;\n\t\tthis.mipmaps = [];\n\t\n\t\tthis.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;\n\t\n\t\tthis.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;\n\t\tthis.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;\n\t\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;\n\t\n\t\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\n\t\n\t\tthis.format = format !== undefined ? format : THREE.RGBAFormat;\n\t\tthis.type = type !== undefined ? type : THREE.UnsignedByteType;\n\t\n\t\tthis.offset = new THREE.Vector2( 0, 0 );\n\t\tthis.repeat = new THREE.Vector2( 1, 1 );\n\t\n\t\tthis.generateMipmaps = true;\n\t\tthis.premultiplyAlpha = false;\n\t\tthis.flipY = true;\n\t\tthis.unpackAlignment = 4;\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\t\n\t\n\t\t// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\n\t\t//\n\t\t// Also changing the encoding after already used by a Material will not automatically make the Material\n\t\t// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.\n\t\tthis.encoding = encoding !== undefined ? encoding :  THREE.LinearEncoding;\n\t\n\t\tthis.version = 0;\n\t\tthis.onUpdate = null;\n\t\n\t};\n\t\n\tTHREE.Texture.DEFAULT_IMAGE = undefined;\n\tTHREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;\n\t\n\tTHREE.Texture.prototype = {\n\t\n\t\tconstructor: THREE.Texture,\n\t\n\t\tset needsUpdate( value ) {\n\t\n\t\t\tif ( value === true ) this.version ++;\n\t\n\t\t},\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t},\n\t\n\t\tcopy: function ( source ) {\n\t\n\t\t\tthis.image = source.image;\n\t\t\tthis.mipmaps = source.mipmaps.slice( 0 );\n\t\n\t\t\tthis.mapping = source.mapping;\n\t\n\t\t\tthis.wrapS = source.wrapS;\n\t\t\tthis.wrapT = source.wrapT;\n\t\n\t\t\tthis.magFilter = source.magFilter;\n\t\t\tthis.minFilter = source.minFilter;\n\t\n\t\t\tthis.anisotropy = source.anisotropy;\n\t\n\t\t\tthis.format = source.format;\n\t\t\tthis.type = source.type;\n\t\n\t\t\tthis.offset.copy( source.offset );\n\t\t\tthis.repeat.copy( source.repeat );\n\t\n\t\t\tthis.generateMipmaps = source.generateMipmaps;\n\t\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\n\t\t\tthis.flipY = source.flipY;\n\t\t\tthis.unpackAlignment = source.unpackAlignment;\n\t\t\tthis.encoding = source.encoding;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\ttoJSON: function ( meta ) {\n\t\n\t\t\tif ( meta.textures[ this.uuid ] !== undefined ) {\n\t\n\t\t\t\treturn meta.textures[ this.uuid ];\n\t\n\t\t\t}\n\t\n\t\t\tfunction getDataURL( image ) {\n\t\n\t\t\t\tvar canvas;\n\t\n\t\t\t\tif ( image.toDataURL !== undefined ) {\n\t\n\t\t\t\t\tcanvas = image;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tcanvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\t\t\tcanvas.width = image.width;\n\t\t\t\t\tcanvas.height = image.height;\n\t\n\t\t\t\t\tcanvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( canvas.width > 2048 || canvas.height > 2048 ) {\n\t\n\t\t\t\t\treturn canvas.toDataURL( 'image/jpeg', 0.6 );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\treturn canvas.toDataURL( 'image/png' );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tvar output = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.4,\n\t\t\t\t\ttype: 'Texture',\n\t\t\t\t\tgenerator: 'Texture.toJSON'\n\t\t\t\t},\n\t\n\t\t\t\tuuid: this.uuid,\n\t\t\t\tname: this.name,\n\t\n\t\t\t\tmapping: this.mapping,\n\t\n\t\t\t\trepeat: [ this.repeat.x, this.repeat.y ],\n\t\t\t\toffset: [ this.offset.x, this.offset.y ],\n\t\t\t\twrap: [ this.wrapS, this.wrapT ],\n\t\n\t\t\t\tminFilter: this.minFilter,\n\t\t\t\tmagFilter: this.magFilter,\n\t\t\t\tanisotropy: this.anisotropy\n\t\t\t};\n\t\n\t\t\tif ( this.image !== undefined ) {\n\t\n\t\t\t\t// TODO: Move to THREE.Image\n\t\n\t\t\t\tvar image = this.image;\n\t\n\t\t\t\tif ( image.uuid === undefined ) {\n\t\n\t\t\t\t\timage.uuid = THREE.Math.generateUUID(); // UGH\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( meta.images[ image.uuid ] === undefined ) {\n\t\n\t\t\t\t\tmeta.images[ image.uuid ] = {\n\t\t\t\t\t\tuuid: image.uuid,\n\t\t\t\t\t\turl: getDataURL( image )\n\t\t\t\t\t};\n\t\n\t\t\t\t}\n\t\n\t\t\t\toutput.image = image.uuid;\n\t\n\t\t\t}\n\t\n\t\t\tmeta.textures[ this.uuid ] = output;\n\t\n\t\t\treturn output;\n\t\n\t\t},\n\t\n\t\tdispose: function () {\n\t\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\t\n\t\t},\n\t\n\t\ttransformUv: function ( uv ) {\n\t\n\t\t\tif ( this.mapping !== THREE.UVMapping )  return;\n\t\n\t\t\tuv.multiply( this.repeat );\n\t\t\tuv.add( this.offset );\n\t\n\t\t\tif ( uv.x < 0 || uv.x > 1 ) {\n\t\n\t\t\t\tswitch ( this.wrapS ) {\n\t\n\t\t\t\t\tcase THREE.RepeatWrapping:\n\t\n\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase THREE.ClampToEdgeWrapping:\n\t\n\t\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase THREE.MirroredRepeatWrapping:\n\t\n\t\t\t\t\t\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\n\t\n\t\t\t\t\t\t\tuv.x = Math.ceil( uv.x ) - uv.x;\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif ( uv.y < 0 || uv.y > 1 ) {\n\t\n\t\t\t\tswitch ( this.wrapT ) {\n\t\n\t\t\t\t\tcase THREE.RepeatWrapping:\n\t\n\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase THREE.ClampToEdgeWrapping:\n\t\n\t\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase THREE.MirroredRepeatWrapping:\n\t\n\t\t\t\t\t\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\n\t\n\t\t\t\t\t\t\tuv.y = Math.ceil( uv.y ) - uv.y;\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif ( this.flipY ) {\n\t\n\t\t\t\tuv.y = 1 - uv.y;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t};\n\t\n\tObject.assign( THREE.Texture.prototype, THREE.EventDispatcher.prototype );\n\t\n\tTHREE.TextureIdCount = 0;\n\t\n\t// File:src/textures/DepthTexture.js\n\t\n\t/**\n\t * @author Matt DesLauriers / @mattdesl\n\t */\n\t\n\tTHREE.DepthTexture = function ( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {\n\t\n\t  THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, THREE.DepthFormat, type, anisotropy );\n\t\n\t  this.image = { width: width, height: height };\n\t\n\t  this.type = type !== undefined ? type : THREE.UnsignedShortType;\n\t\n\t  this.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;\n\t  this.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;\n\t\n\t  this.flipY = false;\n\t  this.generateMipmaps  = false;\n\t\n\t};\n\t\n\tTHREE.DepthTexture.prototype = Object.create( THREE.Texture.prototype );\n\tTHREE.DepthTexture.prototype.constructor = THREE.DepthTexture;\n\t\n\t// File:src/textures/CanvasTexture.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.CanvasTexture = function ( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\t\n\t\tTHREE.Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\t\n\t\tthis.needsUpdate = true;\n\t\n\t};\n\t\n\tTHREE.CanvasTexture.prototype = Object.create( THREE.Texture.prototype );\n\tTHREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;\n\t\n\t// File:src/textures/CubeTexture.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\t\n\t\timages = images !== undefined ? images : [];\n\t\tmapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;\n\t\n\t\tTHREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\t\n\t\tthis.flipY = false;\n\t\n\t};\n\t\n\tTHREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );\n\tTHREE.CubeTexture.prototype.constructor = THREE.CubeTexture;\n\t\n\tObject.defineProperty( THREE.CubeTexture.prototype, 'images', {\n\t\n\t\tget: function () {\n\t\n\t\t\treturn this.image;\n\t\n\t\t},\n\t\n\t\tset: function ( value ) {\n\t\n\t\t\tthis.image = value;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/textures/CompressedTexture.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\n\t\n\t\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\t\n\t\tthis.image = { width: width, height: height };\n\t\tthis.mipmaps = mipmaps;\n\t\n\t\t// no flipping for cube textures\n\t\t// (also flipping doesn't work for compressed textures )\n\t\n\t\tthis.flipY = false;\n\t\n\t\t// can't generate mipmaps for compressed textures\n\t\t// mips must be embedded in DDS files\n\t\n\t\tthis.generateMipmaps = false;\n\t\n\t};\n\t\n\tTHREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );\n\tTHREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;\n\t\n\t// File:src/textures/DataTexture.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\n\t\n\t\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\t\n\t\tthis.image = { data: data, width: width, height: height };\n\t\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;\n\t\n\t\tthis.flipY = false;\n\t\tthis.generateMipmaps  = false;\n\t\n\t};\n\t\n\tTHREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );\n\tTHREE.DataTexture.prototype.constructor = THREE.DataTexture;\n\t\n\t// File:src/textures/VideoTexture.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\t\n\t\tTHREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\t\n\t\tthis.generateMipmaps = false;\n\t\n\t\tvar scope = this;\n\t\n\t\tfunction update() {\n\t\n\t\t\trequestAnimationFrame( update );\n\t\n\t\t\tif ( video.readyState >= video.HAVE_CURRENT_DATA ) {\n\t\n\t\t\t\tscope.needsUpdate = true;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tupdate();\n\t\n\t};\n\t\n\tTHREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );\n\tTHREE.VideoTexture.prototype.constructor = THREE.VideoTexture;\n\t\n\t// File:src/objects/Group.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.Group = function () {\n\t\n\t\tTHREE.Object3D.call( this );\n\t\n\t\tthis.type = 'Group';\n\t\n\t};\n\t\n\tTHREE.Group.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\t\n\t\tconstructor: THREE.Group\n\t\n\t} );\n\t\n\t// File:src/objects/Points.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.Points = function ( geometry, material ) {\n\t\n\t\tTHREE.Object3D.call( this );\n\t\n\t\tthis.type = 'Points';\n\t\n\t\tthis.geometry = geometry !== undefined ? geometry : new THREE.BufferGeometry();\n\t\tthis.material = material !== undefined ? material : new THREE.PointsMaterial( { color: Math.random() * 0xffffff } );\n\t\n\t};\n\t\n\tTHREE.Points.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\t\n\t\tconstructor: THREE.Points,\n\t\n\t\traycast: ( function () {\n\t\n\t\t\tvar inverseMatrix = new THREE.Matrix4();\n\t\t\tvar ray = new THREE.Ray();\n\t\t\tvar sphere = new THREE.Sphere();\n\t\n\t\t\treturn function raycast( raycaster, intersects ) {\n\t\n\t\t\t\tvar object = this;\n\t\t\t\tvar geometry = this.geometry;\n\t\t\t\tvar matrixWorld = this.matrixWorld;\n\t\t\t\tvar threshold = raycaster.params.Points.threshold;\n\t\n\t\t\t\t// Checking boundingSphere distance to ray\n\t\n\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\t\n\t\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\t\tsphere.applyMatrix4( matrixWorld );\n\t\n\t\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\t\n\t\t\t\t//\n\t\n\t\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\t\n\t\t\t\tvar localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\t\t\tvar localThresholdSq = localThreshold * localThreshold;\n\t\t\t\tvar position = new THREE.Vector3();\n\t\n\t\t\t\tfunction testPoint( point, index ) {\n\t\n\t\t\t\t\tvar rayPointDistanceSq = ray.distanceSqToPoint( point );\n\t\n\t\t\t\t\tif ( rayPointDistanceSq < localThresholdSq ) {\n\t\n\t\t\t\t\t\tvar intersectPoint = ray.closestPointToPoint( point );\n\t\t\t\t\t\tintersectPoint.applyMatrix4( matrixWorld );\n\t\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\n\t\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\t\n\t\t\t\t\t\tintersects.push( {\n\t\n\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\tdistanceToRay: Math.sqrt( rayPointDistanceSq ),\n\t\t\t\t\t\t\tpoint: intersectPoint.clone(),\n\t\t\t\t\t\t\tindex: index,\n\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\tobject: object\n\t\n\t\t\t\t\t\t} );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\t\n\t\t\t\t\tvar index = geometry.index;\n\t\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\t\tvar positions = attributes.position.array;\n\t\n\t\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\t\tvar indices = index.array;\n\t\n\t\t\t\t\t\tfor ( var i = 0, il = indices.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\t\tvar a = indices[ i ];\n\t\n\t\t\t\t\t\t\tposition.fromArray( positions, a * 3 );\n\t\n\t\t\t\t\t\t\ttestPoint( position, a );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tfor ( var i = 0, l = positions.length / 3; i < l; i ++ ) {\n\t\n\t\t\t\t\t\t\tposition.fromArray( positions, i * 3 );\n\t\n\t\t\t\t\t\t\ttestPoint( position, i );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tvar vertices = geometry.vertices;\n\t\n\t\t\t\t\tfor ( var i = 0, l = vertices.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\ttestPoint( vertices[ i ], i );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t}() ),\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/objects/Line.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.Line = function ( geometry, material, mode ) {\n\t\n\t\tif ( mode === 1 ) {\n\t\n\t\t\tconsole.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );\n\t\t\treturn new THREE.LineSegments( geometry, material );\n\t\n\t\t}\n\t\n\t\tTHREE.Object3D.call( this );\n\t\n\t\tthis.type = 'Line';\n\t\n\t\tthis.geometry = geometry !== undefined ? geometry : new THREE.BufferGeometry();\n\t\tthis.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );\n\t\n\t};\n\t\n\tTHREE.Line.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\t\n\t\tconstructor: THREE.Line,\n\t\n\t\traycast: ( function () {\n\t\n\t\t\tvar inverseMatrix = new THREE.Matrix4();\n\t\t\tvar ray = new THREE.Ray();\n\t\t\tvar sphere = new THREE.Sphere();\n\t\n\t\t\treturn function raycast( raycaster, intersects ) {\n\t\n\t\t\t\tvar precision = raycaster.linePrecision;\n\t\t\t\tvar precisionSq = precision * precision;\n\t\n\t\t\t\tvar geometry = this.geometry;\n\t\t\t\tvar matrixWorld = this.matrixWorld;\n\t\n\t\t\t\t// Checking boundingSphere distance to ray\n\t\n\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\t\n\t\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\t\tsphere.applyMatrix4( matrixWorld );\n\t\n\t\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\t\n\t\t\t\t//\n\t\n\t\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\t\n\t\t\t\tvar vStart = new THREE.Vector3();\n\t\t\t\tvar vEnd = new THREE.Vector3();\n\t\t\t\tvar interSegment = new THREE.Vector3();\n\t\t\t\tvar interRay = new THREE.Vector3();\n\t\t\t\tvar step = this instanceof THREE.LineSegments ? 2 : 1;\n\t\n\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\t\n\t\t\t\t\tvar index = geometry.index;\n\t\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\t\tvar positions = attributes.position.array;\n\t\n\t\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\t\tvar indices = index.array;\n\t\n\t\t\t\t\t\tfor ( var i = 0, l = indices.length - 1; i < l; i += step ) {\n\t\n\t\t\t\t\t\t\tvar a = indices[ i ];\n\t\t\t\t\t\t\tvar b = indices[ i + 1 ];\n\t\n\t\t\t\t\t\t\tvStart.fromArray( positions, a * 3 );\n\t\t\t\t\t\t\tvEnd.fromArray( positions, b * 3 );\n\t\n\t\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\t\n\t\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\t\n\t\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\t\n\t\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\t\n\t\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\t\n\t\t\t\t\t\t\tintersects.push( {\n\t\n\t\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\t\tobject: this\n\t\n\t\t\t\t\t\t\t} );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tfor ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {\n\t\n\t\t\t\t\t\t\tvStart.fromArray( positions, 3 * i );\n\t\t\t\t\t\t\tvEnd.fromArray( positions, 3 * i + 3 );\n\t\n\t\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\t\n\t\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\t\n\t\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\t\n\t\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\t\n\t\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\t\n\t\t\t\t\t\t\tintersects.push( {\n\t\n\t\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\t\tobject: this\n\t\n\t\t\t\t\t\t\t} );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\t\n\t\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\t\tvar nbVertices = vertices.length;\n\t\n\t\t\t\t\tfor ( var i = 0; i < nbVertices - 1; i += step ) {\n\t\n\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\n\t\n\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\t\n\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\t\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\t\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\t\n\t\t\t\t\t\tintersects.push( {\n\t\n\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\tobject: this\n\t\n\t\t\t\t\t\t} );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t}() ),\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/objects/LineSegments.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.LineSegments = function ( geometry, material ) {\n\t\n\t\tTHREE.Line.call( this, geometry, material );\n\t\n\t\tthis.type = 'LineSegments';\n\t\n\t};\n\t\n\tTHREE.LineSegments.prototype = Object.assign( Object.create( THREE.Line.prototype ), {\n\t\n\t\tconstructor: THREE.LineSegments\n\t\n\t} );\n\t\n\t// File:src/objects/Mesh.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author jonobr1 / http://jonobr1.com/\n\t */\n\t\n\tTHREE.Mesh = function ( geometry, material ) {\n\t\n\t\tTHREE.Object3D.call( this );\n\t\n\t\tthis.type = 'Mesh';\n\t\n\t\tthis.geometry = geometry !== undefined ? geometry : new THREE.BufferGeometry();\n\t\tthis.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );\n\t\n\t\tthis.drawMode = THREE.TrianglesDrawMode;\n\t\n\t\tthis.updateMorphTargets();\n\t\n\t};\n\t\n\tTHREE.Mesh.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\t\n\t\tconstructor: THREE.Mesh,\n\t\n\t\tsetDrawMode: function ( value ) {\n\t\n\t\t\tthis.drawMode = value;\n\t\n\t\t},\n\t\n\t\tcopy: function ( source ) {\n\t\n\t\t\tTHREE.Object3D.prototype.copy.call( this, source );\n\t\n\t\t\tthis.drawMode = source.drawMode;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tupdateMorphTargets: function () {\n\t\n\t\t\tif ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {\n\t\n\t\t\t\tthis.morphTargetBase = - 1;\n\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\tthis.morphTargetDictionary = {};\n\t\n\t\t\t\tfor ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {\n\t\n\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\tthis.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tgetMorphTargetIndexByName: function ( name ) {\n\t\n\t\t\tif ( this.morphTargetDictionary[ name ] !== undefined ) {\n\t\n\t\t\t\treturn this.morphTargetDictionary[ name ];\n\t\n\t\t\t}\n\t\n\t\t\tconsole.warn( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );\n\t\n\t\t\treturn 0;\n\t\n\t\t},\n\t\n\t\traycast: ( function () {\n\t\n\t\t\tvar inverseMatrix = new THREE.Matrix4();\n\t\t\tvar ray = new THREE.Ray();\n\t\t\tvar sphere = new THREE.Sphere();\n\t\n\t\t\tvar vA = new THREE.Vector3();\n\t\t\tvar vB = new THREE.Vector3();\n\t\t\tvar vC = new THREE.Vector3();\n\t\n\t\t\tvar tempA = new THREE.Vector3();\n\t\t\tvar tempB = new THREE.Vector3();\n\t\t\tvar tempC = new THREE.Vector3();\n\t\n\t\t\tvar uvA = new THREE.Vector2();\n\t\t\tvar uvB = new THREE.Vector2();\n\t\t\tvar uvC = new THREE.Vector2();\n\t\n\t\t\tvar barycoord = new THREE.Vector3();\n\t\n\t\t\tvar intersectionPoint = new THREE.Vector3();\n\t\t\tvar intersectionPointWorld = new THREE.Vector3();\n\t\n\t\t\tfunction uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {\n\t\n\t\t\t\tTHREE.Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );\n\t\n\t\t\t\tuv1.multiplyScalar( barycoord.x );\n\t\t\t\tuv2.multiplyScalar( barycoord.y );\n\t\t\t\tuv3.multiplyScalar( barycoord.z );\n\t\n\t\t\t\tuv1.add( uv2 ).add( uv3 );\n\t\n\t\t\t\treturn uv1.clone();\n\t\n\t\t\t}\n\t\n\t\t\tfunction checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {\n\t\n\t\t\t\tvar intersect;\n\t\t\t\tvar material = object.material;\n\t\n\t\t\t\tif ( material.side === THREE.BackSide ) {\n\t\n\t\t\t\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tintersect = ray.intersectTriangle( pA, pB, pC, material.side !== THREE.DoubleSide, point );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( intersect === null ) return null;\n\t\n\t\t\t\tintersectionPointWorld.copy( point );\n\t\t\t\tintersectionPointWorld.applyMatrix4( object.matrixWorld );\n\t\n\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );\n\t\n\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\n\t\n\t\t\t\treturn {\n\t\t\t\t\tdistance: distance,\n\t\t\t\t\tpoint: intersectionPointWorld.clone(),\n\t\t\t\t\tobject: object\n\t\t\t\t};\n\t\n\t\t\t}\n\t\n\t\t\tfunction checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {\n\t\n\t\t\t\tvA.fromArray( positions, a * 3 );\n\t\t\t\tvB.fromArray( positions, b * 3 );\n\t\t\t\tvC.fromArray( positions, c * 3 );\n\t\n\t\t\t\tvar intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );\n\t\n\t\t\t\tif ( intersection ) {\n\t\n\t\t\t\t\tif ( uvs ) {\n\t\n\t\t\t\t\t\tuvA.fromArray( uvs, a * 2 );\n\t\t\t\t\t\tuvB.fromArray( uvs, b * 2 );\n\t\t\t\t\t\tuvC.fromArray( uvs, c * 2 );\n\t\n\t\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tintersection.face = new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) );\n\t\t\t\t\tintersection.faceIndex = a;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn intersection;\n\t\n\t\t\t}\n\t\n\t\t\treturn function raycast( raycaster, intersects ) {\n\t\n\t\t\t\tvar geometry = this.geometry;\n\t\t\t\tvar material = this.material;\n\t\t\t\tvar matrixWorld = this.matrixWorld;\n\t\n\t\t\t\tif ( material === undefined ) return;\n\t\n\t\t\t\t// Checking boundingSphere distance to ray\n\t\n\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\t\n\t\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\t\tsphere.applyMatrix4( matrixWorld );\n\t\n\t\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\t\n\t\t\t\t//\n\t\n\t\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\t\n\t\t\t\t// Check boundingBox before continuing\n\t\n\t\t\t\tif ( geometry.boundingBox !== null ) {\n\t\n\t\t\t\t\tif ( ray.intersectsBox( geometry.boundingBox ) === false ) return;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar uvs, intersection;\n\t\n\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\t\n\t\t\t\t\tvar a, b, c;\n\t\t\t\t\tvar index = geometry.index;\n\t\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\t\tvar positions = attributes.position.array;\n\t\n\t\t\t\t\tif ( attributes.uv !== undefined ) {\n\t\n\t\t\t\t\t\tuvs = attributes.uv.array;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\t\tvar indices = index.array;\n\t\n\t\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += 3 ) {\n\t\n\t\t\t\t\t\t\ta = indices[ i ];\n\t\t\t\t\t\t\tb = indices[ i + 1 ];\n\t\t\t\t\t\t\tc = indices[ i + 2 ];\n\t\n\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\n\t\n\t\t\t\t\t\t\tif ( intersection ) {\n\t\n\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics\n\t\t\t\t\t\t\t\tintersects.push( intersection );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\n\t\t\t\t\t\tfor ( var i = 0, l = positions.length; i < l; i += 9 ) {\n\t\n\t\t\t\t\t\t\ta = i / 3;\n\t\t\t\t\t\t\tb = a + 1;\n\t\t\t\t\t\t\tc = a + 2;\n\t\n\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\n\t\n\t\t\t\t\t\t\tif ( intersection ) {\n\t\n\t\t\t\t\t\t\t\tintersection.index = a; // triangle number in positions buffer semantics\n\t\t\t\t\t\t\t\tintersects.push( intersection );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\t\n\t\t\t\t\tvar fvA, fvB, fvC;\n\t\t\t\t\tvar isFaceMaterial = material instanceof THREE.MultiMaterial;\n\t\t\t\t\tvar materials = isFaceMaterial === true ? material.materials : null;\n\t\n\t\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\t\tvar faces = geometry.faces;\n\t\t\t\t\tvar faceVertexUvs = geometry.faceVertexUvs[ 0 ];\n\t\t\t\t\tif ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;\n\t\n\t\t\t\t\tfor ( var f = 0, fl = faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\t\tvar face = faces[ f ];\n\t\t\t\t\t\tvar faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;\n\t\n\t\t\t\t\t\tif ( faceMaterial === undefined ) continue;\n\t\n\t\t\t\t\t\tfvA = vertices[ face.a ];\n\t\t\t\t\t\tfvB = vertices[ face.b ];\n\t\t\t\t\t\tfvC = vertices[ face.c ];\n\t\n\t\t\t\t\t\tif ( faceMaterial.morphTargets === true ) {\n\t\n\t\t\t\t\t\t\tvar morphTargets = geometry.morphTargets;\n\t\t\t\t\t\t\tvar morphInfluences = this.morphTargetInfluences;\n\t\n\t\t\t\t\t\t\tvA.set( 0, 0, 0 );\n\t\t\t\t\t\t\tvB.set( 0, 0, 0 );\n\t\t\t\t\t\t\tvC.set( 0, 0, 0 );\n\t\n\t\t\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\n\t\n\t\t\t\t\t\t\t\tvar influence = morphInfluences[ t ];\n\t\n\t\t\t\t\t\t\t\tif ( influence === 0 ) continue;\n\t\n\t\t\t\t\t\t\t\tvar targets = morphTargets[ t ].vertices;\n\t\n\t\t\t\t\t\t\t\tvA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );\n\t\t\t\t\t\t\t\tvB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );\n\t\t\t\t\t\t\t\tvC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tvA.add( fvA );\n\t\t\t\t\t\t\tvB.add( fvB );\n\t\t\t\t\t\t\tvC.add( fvC );\n\t\n\t\t\t\t\t\t\tfvA = vA;\n\t\t\t\t\t\t\tfvB = vB;\n\t\t\t\t\t\t\tfvC = vC;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tintersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );\n\t\n\t\t\t\t\t\tif ( intersection ) {\n\t\n\t\t\t\t\t\t\tif ( uvs ) {\n\t\n\t\t\t\t\t\t\t\tvar uvs_f = uvs[ f ];\n\t\t\t\t\t\t\t\tuvA.copy( uvs_f[ 0 ] );\n\t\t\t\t\t\t\t\tuvB.copy( uvs_f[ 1 ] );\n\t\t\t\t\t\t\t\tuvC.copy( uvs_f[ 2 ] );\n\t\n\t\t\t\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tintersection.face = face;\n\t\t\t\t\t\t\tintersection.faceIndex = f;\n\t\t\t\t\t\t\tintersects.push( intersection );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t}() ),\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/objects/Bone.js\n\t\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author ikerr / http://verold.com\n\t */\n\t\n\tTHREE.Bone = function ( skin ) {\n\t\n\t\tTHREE.Object3D.call( this );\n\t\n\t\tthis.type = 'Bone';\n\t\n\t\tthis.skin = skin;\n\t\n\t};\n\t\n\tTHREE.Bone.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\t\n\t\tconstructor: THREE.Bone,\n\t\n\t\tcopy: function ( source ) {\n\t\n\t\t\tTHREE.Object3D.prototype.copy.call( this, source );\n\t\n\t\t\tthis.skin = source.skin;\n\t\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/objects/Skeleton.js\n\t\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author michael guerrero / http://realitymeltdown.com\n\t * @author ikerr / http://verold.com\n\t */\n\t\n\tTHREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {\n\t\n\t\tthis.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;\n\t\n\t\tthis.identityMatrix = new THREE.Matrix4();\n\t\n\t\t// copy the bone array\n\t\n\t\tbones = bones || [];\n\t\n\t\tthis.bones = bones.slice( 0 );\n\t\n\t\t// create a bone texture or an array of floats\n\t\n\t\tif ( this.useVertexTexture ) {\n\t\n\t\t\t// layout (1 matrix = 4 pixels)\n\t\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n\t\t\t//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\n\t\t\t//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\n\t\t\t//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\n\t\t\t//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\n\t\n\t\n\t\t\tvar size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix\n\t\t\tsize = THREE.Math.nextPowerOfTwo( Math.ceil( size ) );\n\t\t\tsize = Math.max( size, 4 );\n\t\n\t\t\tthis.boneTextureWidth = size;\n\t\t\tthis.boneTextureHeight = size;\n\t\n\t\t\tthis.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel\n\t\t\tthis.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );\n\t\n\t\t} else {\n\t\n\t\t\tthis.boneMatrices = new Float32Array( 16 * this.bones.length );\n\t\n\t\t}\n\t\n\t\t// use the supplied bone inverses or calculate the inverses\n\t\n\t\tif ( boneInverses === undefined ) {\n\t\n\t\t\tthis.calculateInverses();\n\t\n\t\t} else {\n\t\n\t\t\tif ( this.bones.length === boneInverses.length ) {\n\t\n\t\t\t\tthis.boneInverses = boneInverses.slice( 0 );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tconsole.warn( 'THREE.Skeleton bonInverses is the wrong length.' );\n\t\n\t\t\t\tthis.boneInverses = [];\n\t\n\t\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\t\n\t\t\t\t\tthis.boneInverses.push( new THREE.Matrix4() );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t};\n\t\n\tObject.assign( THREE.Skeleton.prototype, {\n\t\n\t\tcalculateInverses: function () {\n\t\n\t\t\tthis.boneInverses = [];\n\t\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\t\n\t\t\t\tvar inverse = new THREE.Matrix4();\n\t\n\t\t\t\tif ( this.bones[ b ] ) {\n\t\n\t\t\t\t\tinverse.getInverse( this.bones[ b ].matrixWorld );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.boneInverses.push( inverse );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tpose: function () {\n\t\n\t\t\tvar bone;\n\t\n\t\t\t// recover the bind-time world matrices\n\t\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\t\n\t\t\t\tbone = this.bones[ b ];\n\t\n\t\t\t\tif ( bone ) {\n\t\n\t\t\t\t\tbone.matrixWorld.getInverse( this.boneInverses[ b ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// compute the local matrices, positions, rotations and scales\n\t\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\t\n\t\t\t\tbone = this.bones[ b ];\n\t\n\t\t\t\tif ( bone ) {\n\t\n\t\t\t\t\tif ( bone.parent instanceof THREE.Bone ) {\n\t\n\t\t\t\t\t\tbone.matrix.getInverse( bone.parent.matrixWorld );\n\t\t\t\t\t\tbone.matrix.multiply( bone.matrixWorld );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tbone.matrix.copy( bone.matrixWorld );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tupdate: ( function () {\n\t\n\t\t\tvar offsetMatrix = new THREE.Matrix4();\n\t\n\t\t\treturn function update() {\n\t\n\t\t\t\t// flatten bone matrices to array\n\t\n\t\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\t\n\t\t\t\t\t// compute the offset between the current and the original transform\n\t\n\t\t\t\t\tvar matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;\n\t\n\t\t\t\t\toffsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );\n\t\t\t\t\toffsetMatrix.toArray( this.boneMatrices, b * 16 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.useVertexTexture ) {\n\t\n\t\t\t\t\tthis.boneTexture.needsUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t} )(),\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new THREE.Skeleton( this.bones, this.boneInverses, this.useVertexTexture );\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/objects/SkinnedMesh.js\n\t\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author ikerr / http://verold.com\n\t */\n\t\n\tTHREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {\n\t\n\t\tTHREE.Mesh.call( this, geometry, material );\n\t\n\t\tthis.type = 'SkinnedMesh';\n\t\n\t\tthis.bindMode = \"attached\";\n\t\tthis.bindMatrix = new THREE.Matrix4();\n\t\tthis.bindMatrixInverse = new THREE.Matrix4();\n\t\n\t\t// init bones\n\t\n\t\t// TODO: remove bone creation as there is no reason (other than\n\t\t// convenience) for THREE.SkinnedMesh to do this.\n\t\n\t\tvar bones = [];\n\t\n\t\tif ( this.geometry && this.geometry.bones !== undefined ) {\n\t\n\t\t\tvar bone, gbone;\n\t\n\t\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\n\t\n\t\t\t\tgbone = this.geometry.bones[ b ];\n\t\n\t\t\t\tbone = new THREE.Bone( this );\n\t\t\t\tbones.push( bone );\n\t\n\t\t\t\tbone.name = gbone.name;\n\t\t\t\tbone.position.fromArray( gbone.pos );\n\t\t\t\tbone.quaternion.fromArray( gbone.rotq );\n\t\t\t\tif ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );\n\t\n\t\t\t}\n\t\n\t\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\n\t\n\t\t\t\tgbone = this.geometry.bones[ b ];\n\t\n\t\t\t\tif ( gbone.parent !== - 1 && gbone.parent !== null &&\n\t\t\t\t\t\tbones[ gbone.parent ] !== undefined ) {\n\t\n\t\t\t\t\tbones[ gbone.parent ].add( bones[ b ] );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.add( bones[ b ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tthis.normalizeSkinWeights();\n\t\n\t\tthis.updateMatrixWorld( true );\n\t\tthis.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );\n\t\n\t};\n\t\n\t\n\tTHREE.SkinnedMesh.prototype = Object.assign( Object.create( THREE.Mesh.prototype ), {\n\t\n\t\tconstructor: THREE.SkinnedMesh,\n\t\n\t\tbind: function( skeleton, bindMatrix ) {\n\t\n\t\t\tthis.skeleton = skeleton;\n\t\n\t\t\tif ( bindMatrix === undefined ) {\n\t\n\t\t\t\tthis.updateMatrixWorld( true );\n\t\n\t\t\t\tthis.skeleton.calculateInverses();\n\t\n\t\t\t\tbindMatrix = this.matrixWorld;\n\t\n\t\t\t}\n\t\n\t\t\tthis.bindMatrix.copy( bindMatrix );\n\t\t\tthis.bindMatrixInverse.getInverse( bindMatrix );\n\t\n\t\t},\n\t\n\t\tpose: function () {\n\t\n\t\t\tthis.skeleton.pose();\n\t\n\t\t},\n\t\n\t\tnormalizeSkinWeights: function () {\n\t\n\t\t\tif ( this.geometry instanceof THREE.Geometry ) {\n\t\n\t\t\t\tfor ( var i = 0; i < this.geometry.skinWeights.length; i ++ ) {\n\t\n\t\t\t\t\tvar sw = this.geometry.skinWeights[ i ];\n\t\n\t\t\t\t\tvar scale = 1.0 / sw.lengthManhattan();\n\t\n\t\t\t\t\tif ( scale !== Infinity ) {\n\t\n\t\t\t\t\t\tsw.multiplyScalar( scale );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tsw.set( 1, 0, 0, 0 ); // do something reasonable\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t} else if ( this.geometry instanceof THREE.BufferGeometry ) {\n\t\n\t\t\t\tvar vec = new THREE.Vector4();\n\t\n\t\t\t\tvar skinWeight = this.geometry.attributes.skinWeight;\n\t\n\t\t\t\tfor ( var i = 0; i < skinWeight.count; i ++ ) {\n\t\n\t\t\t\t\tvec.x = skinWeight.getX( i );\n\t\t\t\t\tvec.y = skinWeight.getY( i );\n\t\t\t\t\tvec.z = skinWeight.getZ( i );\n\t\t\t\t\tvec.w = skinWeight.getW( i );\n\t\n\t\t\t\t\tvar scale = 1.0 / vec.lengthManhattan();\n\t\n\t\t\t\t\tif ( scale !== Infinity ) {\n\t\n\t\t\t\t\t\tvec.multiplyScalar( scale );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tvec.set( 1, 0, 0, 0 ); // do something reasonable\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tskinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tupdateMatrixWorld: function( force ) {\n\t\n\t\t\tTHREE.Mesh.prototype.updateMatrixWorld.call( this, true );\n\t\n\t\t\tif ( this.bindMode === \"attached\" ) {\n\t\n\t\t\t\tthis.bindMatrixInverse.getInverse( this.matrixWorld );\n\t\n\t\t\t} else if ( this.bindMode === \"detached\" ) {\n\t\n\t\t\t\tthis.bindMatrixInverse.getInverse( this.bindMatrix );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tconsole.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tclone: function() {\n\t\n\t\t\treturn new this.constructor( this.geometry, this.material, this.skeleton.useVertexTexture ).copy( this );\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/objects/LOD.js\n\t\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.LOD = function () {\n\t\n\t\tTHREE.Object3D.call( this );\n\t\n\t\tthis.type = 'LOD';\n\t\n\t\tObject.defineProperties( this, {\n\t\t\tlevels: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: []\n\t\t\t}\n\t\t} );\n\t\n\t};\n\t\n\t\n\tTHREE.LOD.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\t\n\t\tconstructor: THREE.LOD,\n\t\n\t\tcopy: function ( source ) {\n\t\n\t\t\tTHREE.Object3D.prototype.copy.call( this, source, false );\n\t\n\t\t\tvar levels = source.levels;\n\t\n\t\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar level = levels[ i ];\n\t\n\t\t\t\tthis.addLevel( level.object.clone(), level.distance );\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\taddLevel: function ( object, distance ) {\n\t\n\t\t\tif ( distance === undefined ) distance = 0;\n\t\n\t\t\tdistance = Math.abs( distance );\n\t\n\t\t\tvar levels = this.levels;\n\t\n\t\t\tfor ( var l = 0; l < levels.length; l ++ ) {\n\t\n\t\t\t\tif ( distance < levels[ l ].distance ) {\n\t\n\t\t\t\t\tbreak;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tlevels.splice( l, 0, { distance: distance, object: object } );\n\t\n\t\t\tthis.add( object );\n\t\n\t\t},\n\t\n\t\tgetObjectForDistance: function ( distance ) {\n\t\n\t\t\tvar levels = this.levels;\n\t\n\t\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\n\t\n\t\t\t\tif ( distance < levels[ i ].distance ) {\n\t\n\t\t\t\t\tbreak;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn levels[ i - 1 ].object;\n\t\n\t\t},\n\t\n\t\traycast: ( function () {\n\t\n\t\t\tvar matrixPosition = new THREE.Vector3();\n\t\n\t\t\treturn function raycast( raycaster, intersects ) {\n\t\n\t\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\n\t\n\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( matrixPosition );\n\t\n\t\t\t\tthis.getObjectForDistance( distance ).raycast( raycaster, intersects );\n\t\n\t\t\t};\n\t\n\t\t}() ),\n\t\n\t\tupdate: function () {\n\t\n\t\t\tvar v1 = new THREE.Vector3();\n\t\t\tvar v2 = new THREE.Vector3();\n\t\n\t\t\treturn function update( camera ) {\n\t\n\t\t\t\tvar levels = this.levels;\n\t\n\t\t\t\tif ( levels.length > 1 ) {\n\t\n\t\t\t\t\tv1.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t\t\tv2.setFromMatrixPosition( this.matrixWorld );\n\t\n\t\t\t\t\tvar distance = v1.distanceTo( v2 );\n\t\n\t\t\t\t\tlevels[ 0 ].object.visible = true;\n\t\n\t\t\t\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tif ( distance >= levels[ i ].distance ) {\n\t\n\t\t\t\t\t\t\tlevels[ i - 1 ].object.visible = false;\n\t\t\t\t\t\t\tlevels[ i ].object.visible = true;\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( ; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tlevels[ i ].object.visible = false;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\ttoJSON: function ( meta ) {\n\t\n\t\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\n\t\n\t\t\tdata.object.levels = [];\n\t\n\t\t\tvar levels = this.levels;\n\t\n\t\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar level = levels[ i ];\n\t\n\t\t\t\tdata.object.levels.push( {\n\t\t\t\t\tobject: level.object.uuid,\n\t\t\t\t\tdistance: level.distance\n\t\t\t\t} );\n\t\n\t\t\t}\n\t\n\t\t\treturn data;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/objects/Sprite.js\n\t\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.Sprite = function ( material ) {\n\t\n\t\tTHREE.Object3D.call( this );\n\t\n\t\tthis.type = 'Sprite';\n\t\n\t\tthis.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();\n\t\n\t};\n\t\n\tTHREE.Sprite.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\t\n\t\tconstructor: THREE.Sprite,\n\t\n\t\traycast: ( function () {\n\t\n\t\t\tvar matrixPosition = new THREE.Vector3();\n\t\n\t\t\treturn function raycast( raycaster, intersects ) {\n\t\n\t\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\n\t\n\t\t\t\tvar distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );\n\t\t\t\tvar guessSizeSq = this.scale.x * this.scale.y / 4;\n\t\n\t\t\t\tif ( distanceSq > guessSizeSq ) {\n\t\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tintersects.push( {\n\t\n\t\t\t\t\tdistance: Math.sqrt( distanceSq ),\n\t\t\t\t\tpoint: this.position,\n\t\t\t\t\tface: null,\n\t\t\t\t\tobject: this\n\t\n\t\t\t\t} );\n\t\n\t\t\t};\n\t\n\t\t}() ),\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor( this.material ).copy( this );\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/objects/LensFlare.js\n\t\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.LensFlare = function ( texture, size, distance, blending, color ) {\n\t\n\t\tTHREE.Object3D.call( this );\n\t\n\t\tthis.lensFlares = [];\n\t\n\t\tthis.positionScreen = new THREE.Vector3();\n\t\tthis.customUpdateCallback = undefined;\n\t\n\t\tif ( texture !== undefined ) {\n\t\n\t\t\tthis.add( texture, size, distance, blending, color );\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.LensFlare.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\t\n\t\tconstructor: THREE.LensFlare,\n\t\n\t\tcopy: function ( source ) {\n\t\n\t\t\tTHREE.Object3D.prototype.copy.call( this, source );\n\t\n\t\t\tthis.positionScreen.copy( source.positionScreen );\n\t\t\tthis.customUpdateCallback = source.customUpdateCallback;\n\t\n\t\t\tfor ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {\n\t\n\t\t\t\tthis.lensFlares.push( source.lensFlares[ i ] );\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tadd: function ( texture, size, distance, blending, color, opacity ) {\n\t\n\t\t\tif ( size === undefined ) size = - 1;\n\t\t\tif ( distance === undefined ) distance = 0;\n\t\t\tif ( opacity === undefined ) opacity = 1;\n\t\t\tif ( color === undefined ) color = new THREE.Color( 0xffffff );\n\t\t\tif ( blending === undefined ) blending = THREE.NormalBlending;\n\t\n\t\t\tdistance = Math.min( distance, Math.max( 0, distance ) );\n\t\n\t\t\tthis.lensFlares.push( {\n\t\t\t\ttexture: texture,\t// THREE.Texture\n\t\t\t\tsize: size, \t\t// size in pixels (-1 = use texture.width)\n\t\t\t\tdistance: distance, \t// distance (0-1) from light source (0=at light source)\n\t\t\t\tx: 0, y: 0, z: 0,\t// screen position (-1 => 1) z = 0 is in front z = 1 is back\n\t\t\t\tscale: 1, \t\t// scale\n\t\t\t\trotation: 0, \t\t// rotation\n\t\t\t\topacity: opacity,\t// opacity\n\t\t\t\tcolor: color,\t\t// color\n\t\t\t\tblending: blending\t// blending\n\t\t\t} );\n\t\n\t\t},\n\t\n\t\t/*\n\t\t * Update lens flares update positions on all flares based on the screen position\n\t\t * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.\n\t\t */\n\t\n\t\tupdateLensFlares: function () {\n\t\n\t\t\tvar f, fl = this.lensFlares.length;\n\t\t\tvar flare;\n\t\t\tvar vecX = - this.positionScreen.x * 2;\n\t\t\tvar vecY = - this.positionScreen.y * 2;\n\t\n\t\t\tfor ( f = 0; f < fl; f ++ ) {\n\t\n\t\t\t\tflare = this.lensFlares[ f ];\n\t\n\t\t\t\tflare.x = this.positionScreen.x + vecX * flare.distance;\n\t\t\t\tflare.y = this.positionScreen.y + vecY * flare.distance;\n\t\n\t\t\t\tflare.wantedRotation = flare.x * Math.PI * 0.25;\n\t\t\t\tflare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/scenes/Scene.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.Scene = function () {\n\t\n\t\tTHREE.Object3D.call( this );\n\t\n\t\tthis.type = 'Scene';\n\t\n\t\tthis.background = null;\n\t\tthis.fog = null;\n\t\tthis.overrideMaterial = null;\n\t\n\t\tthis.autoUpdate = true; // checked by the renderer\n\t\n\t};\n\t\n\tTHREE.Scene.prototype = Object.create( THREE.Object3D.prototype );\n\tTHREE.Scene.prototype.constructor = THREE.Scene;\n\t\n\tTHREE.Scene.prototype.copy = function ( source, recursive ) {\n\t\n\t\tTHREE.Object3D.prototype.copy.call( this, source, recursive );\n\t\n\t\tif ( source.background !== null ) this.background = source.background.clone();\n\t\tif ( source.fog !== null ) this.fog = source.fog.clone();\n\t\tif ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();\n\t\n\t\tthis.autoUpdate = source.autoUpdate;\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\n\t\treturn this;\n\t\n\t};\n\t\n\t// File:src/scenes/Fog.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.Fog = function ( color, near, far ) {\n\t\n\t\tthis.name = '';\n\t\n\t\tthis.color = new THREE.Color( color );\n\t\n\t\tthis.near = ( near !== undefined ) ? near : 1;\n\t\tthis.far = ( far !== undefined ) ? far : 1000;\n\t\n\t};\n\t\n\tTHREE.Fog.prototype.clone = function () {\n\t\n\t\treturn new THREE.Fog( this.color.getHex(), this.near, this.far );\n\t\n\t};\n\t\n\t// File:src/scenes/FogExp2.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.FogExp2 = function ( color, density ) {\n\t\n\t\tthis.name = '';\n\t\n\t\tthis.color = new THREE.Color( color );\n\t\tthis.density = ( density !== undefined ) ? density : 0.00025;\n\t\n\t};\n\t\n\tTHREE.FogExp2.prototype.clone = function () {\n\t\n\t\treturn new THREE.FogExp2( this.color.getHex(), this.density );\n\t\n\t};\n\t\n\t// File:src/renderers/shaders/ShaderChunk.js\n\t\n\tTHREE.ShaderChunk = {};\n\t\n\t// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'alphamap_fragment' ] = \"#ifdef USE_ALPHAMAP\\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'alphamap_pars_fragment' ] = \"#ifdef USE_ALPHAMAP\\n\tuniform sampler2D alphaMap;\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'alphatest_fragment' ] = \"#ifdef ALPHATEST\\n\tif ( diffuseColor.a < ALPHATEST ) discard;\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/aomap_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'aomap_fragment' ] = \"#ifdef USE_AOMAP\\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\n\t#endif\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'aomap_pars_fragment' ] = \"#ifdef USE_AOMAP\\n\tuniform sampler2D aoMap;\\n\tuniform float aoMapIntensity;\\n#endif\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/begin_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'begin_vertex' ] = \"\\nvec3 transformed = vec3( position );\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/beginnormal_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'beginnormal_vertex' ] = \"\\nvec3 objectNormal = vec3( normal );\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/bsdfs.glsl\n\t\n\tTHREE.ShaderChunk[ 'bsdfs' ] = \"bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\\n\treturn any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\\n}\\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n\t\tif( decayExponent > 0.0 ) {\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\t\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\t\t\treturn distanceFalloff * maxDistanceCutoffFactor;\\n#else\\n\t\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n#endif\\n\t\t}\\n\t\treturn 1.0;\\n}\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\n}\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\treturn 1.0 / ( gl * gv );\\n}\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\tfloat alpha = pow2( roughness );\\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\tvec3 F = F_Schlick( specularColor, dotLH );\\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\tfloat D = D_GGX( alpha, dotNH );\\n\treturn F * ( G * D );\\n}\\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\tvec4 r = roughness * c0 + c1;\\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\\n\treturn specularColor * AB.x + AB.y;\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\tvec3 F = F_Schlick( specularColor, dotLH );\\n\tfloat G = G_BlinnPhong_Implicit( );\\n\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\treturn F * ( G * D );\\n}\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\n}\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'bumpmap_pars_fragment' ] = \"#ifdef USE_BUMPMAP\\n\tuniform sampler2D bumpMap;\\n\tuniform float bumpScale;\\n\tvec2 dHdxy_fwd() {\\n\t\tvec2 dSTdx = dFdx( vUv );\\n\t\tvec2 dSTdy = dFdy( vUv );\\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\t\treturn vec2( dBx, dBy );\\n\t}\\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n\t\tvec3 vSigmaX = dFdx( surf_pos );\\n\t\tvec3 vSigmaY = dFdy( surf_pos );\\n\t\tvec3 vN = surf_norm;\\n\t\tvec3 R1 = cross( vSigmaY, vN );\\n\t\tvec3 R2 = cross( vN, vSigmaX );\\n\t\tfloat fDet = dot( vSigmaX, R1 );\\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\t}\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/clipping_planes_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'clipping_planes_fragment' ] = \"#if NUM_CLIPPING_PLANES > 0\\n\tfor ( int i = 0; i < NUM_CLIPPING_PLANES; ++ i ) {\\n\t\tvec4 plane = clippingPlanes[ i ];\\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\\n\t}\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/clipping_planes_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'clipping_planes_pars_fragment' ] = \"#if NUM_CLIPPING_PLANES > 0\\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\\n\t\tvarying vec3 vViewPosition;\\n\t#endif\\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/clipping_planes_pars_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'clipping_planes_pars_vertex' ] = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\tvarying vec3 vViewPosition;\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/clipping_planes_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'clipping_planes_vertex' ] = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\tvViewPosition = - mvPosition.xyz;\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'color_fragment' ] = \"#ifdef USE_COLOR\\n\tdiffuseColor.rgb *= vColor;\\n#endif\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'color_pars_fragment' ] = \"#ifdef USE_COLOR\\n\tvarying vec3 vColor;\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'color_pars_vertex' ] = \"#ifdef USE_COLOR\\n\tvarying vec3 vColor;\\n#endif\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'color_vertex' ] = \"#ifdef USE_COLOR\\n\tvColor.xyz = color.xyz;\\n#endif\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/common.glsl\n\t\n\tTHREE.ShaderChunk[ 'common' ] = \"#define PI 3.14159265359\\n#define PI2 6.28318530718\\n#define RECIPROCAL_PI 0.31830988618\\n#define RECIPROCAL_PI2 0.15915494\\n#define LOG2 1.442695\\n#define EPSILON 1e-6\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\treturn fract(sin(sn) * c);\\n}\\nstruct IncidentLight {\\n\tvec3 color;\\n\tvec3 direction;\\n\tbool visible;\\n};\\nstruct ReflectedLight {\\n\tvec3 directDiffuse;\\n\tvec3 directSpecular;\\n\tvec3 indirectDiffuse;\\n\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\tvec3 position;\\n\tvec3 normal;\\n\tvec3 viewDir;\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\\n\treturn - distance * planeNormal + point;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/cube_uv_reflection_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'cube_uv_reflection_fragment' ] = \"#ifdef ENVMAP_TYPE_CUBE_UV\\n#define cubeUV_textureSize (1024.0)\\nint getFaceFromDirection(vec3 direction) {\\n\tvec3 absDirection = abs(direction);\\n\tint face = -1;\\n\tif( absDirection.x > absDirection.z ) {\\n\t\tif(absDirection.x > absDirection.y )\\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\\n\t\telse\\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\\n\t}\\n\telse {\\n\t\tif(absDirection.z > absDirection.y )\\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\\n\t\telse\\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\\n\t}\\n\treturn face;\\n}\\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\\n\tfloat dxRoughness = dFdx(roughness);\\n\tfloat dyRoughness = dFdy(roughness);\\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\\n\tfloat mipLevel = 0.5 * log2(d);\\n\treturn vec2(floor(mipLevel), fract(mipLevel));\\n}\\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\\n\tbool bRes = mipLevel == 0.0;\\n\tscale =  bRes && (scale < a) ? a : scale;\\n\tvec3 r;\\n\tvec2 offset;\\n\tint face = getFaceFromDirection(direction);\\n\tfloat rcpPowScale = 1.0 / powScale;\\n\tif( face == 0) {\\n\t\tr = vec3(direction.x, -direction.z, direction.y);\\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\t}\\n\telse if( face == 1) {\\n\t\tr = vec3(direction.y, direction.x, direction.z);\\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\t}\\n\telse if( face == 2) {\\n\t\tr = vec3(direction.z, direction.x, direction.y);\\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\t}\\n\telse if( face == 3) {\\n\t\tr = vec3(direction.x, direction.z, direction.y);\\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\t}\\n\telse if( face == 4) {\\n\t\tr = vec3(direction.y, direction.x, -direction.z);\\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\t}\\n\telse {\\n\t\tr = vec3(direction.z, -direction.x, direction.y);\\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\t}\\n\tr = normalize(r);\\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\\n\tvec2 base = offset + vec2( texelOffset );\\n\treturn base + s * ( scale - 2.0 * texelOffset );\\n}\\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\\n\tfloat r1 = floor(roughnessVal);\\n\tfloat r2 = r1 + 1.0;\\n\tfloat t = fract(roughnessVal);\\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\\n\tfloat s = mipInfo.y;\\n\tfloat level0 = mipInfo.x;\\n\tfloat level1 = level0 + 1.0;\\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\\n\tvec4 result = mix(color10, color20, t);\\n\treturn vec4(result.rgb, 1.0);\\n}\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'defaultnormal_vertex' ] = \"#ifdef FLIP_SIDED\\n\tobjectNormal = -objectNormal;\\n#endif\\nvec3 transformedNormal = normalMatrix * objectNormal;\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/displacementmap_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'displacementmap_vertex' ] = \"#ifdef USE_DISPLACEMENTMAP\\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/displacementmap_pars_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'displacementmap_pars_vertex' ] = \"#ifdef USE_DISPLACEMENTMAP\\n\tuniform sampler2D displacementMap;\\n\tuniform float displacementScale;\\n\tuniform float displacementBias;\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/emissivemap_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'emissivemap_fragment' ] = \"#ifdef USE_EMISSIVEMAP\\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/emissivemap_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'emissivemap_pars_fragment' ] = \"#ifdef USE_EMISSIVEMAP\\n\tuniform sampler2D emissiveMap;\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/encodings_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'encodings_pars_fragment' ] = \"\\nvec4 LinearToLinear( in vec4 value ) {\\n  return value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n  float maxComponent = max( max( value.r, value.g ), value.b );\\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n  float maxRGB = max( value.x, max( value.g, value.b ) );\\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n  M            = ceil( M * 255.0 ) / 255.0;\\n  return vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n    float maxRGB = max( value.x, max( value.g, value.b ) );\\n    float D      = max( maxRange / maxRGB, 1.0 );\\n    D            = min( floor( D ) / 255.0, 1.0 );\\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value )  {\\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\\n  vec4 vResult;\\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n  vResult.w = fract(Le);\\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\\n  return vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n  float Le = value.z * 255.0 + value.w;\\n  vec3 Xp_Y_XYZp;\\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\\n  return vec4( max(vRGB, 0.0), 1.0 );\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/encodings_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'encodings_fragment' ] = \"  gl_FragColor = linearToOutputTexel( gl_FragColor );\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'envmap_fragment' ] = \"#ifdef USE_ENVMAP\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\n\t\t#else\\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\n\t\t#endif\\n\t#else\\n\t\tvec3 reflectVec = vReflect;\\n\t#endif\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\t\tvec2 sampleUV;\\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\\n\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\n\t#endif\\n\tenvColor = envMapTexelToLinear( envColor );\\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\t#elif defined( ENVMAP_BLENDING_MIX )\\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\t#elif defined( ENVMAP_BLENDING_ADD )\\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\t#endif\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'envmap_pars_fragment' ] = \"#if defined( USE_ENVMAP ) || defined( PHYSICAL )\\n\tuniform float reflectivity;\\n\tuniform float envMapIntenstiy;\\n#endif\\n#ifdef USE_ENVMAP\\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\\n\t\tvarying vec3 vWorldPosition;\\n\t#endif\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tuniform samplerCube envMap;\\n\t#else\\n\t\tuniform sampler2D envMap;\\n\t#endif\\n\tuniform float flipEnvMap;\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\\n\t\tuniform float refractionRatio;\\n\t#else\\n\t\tvarying vec3 vReflect;\\n\t#endif\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'envmap_pars_vertex' ] = \"#ifdef USE_ENVMAP\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\t\tvarying vec3 vWorldPosition;\\n\t#else\\n\t\tvarying vec3 vReflect;\\n\t\tuniform float refractionRatio;\\n\t#endif\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'envmap_vertex' ] = \"#ifdef USE_ENVMAP\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\t\tvWorldPosition = worldPosition.xyz;\\n\t#else\\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\\n\t\t#else\\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\t\t#endif\\n\t#endif\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'fog_fragment' ] = \"#ifdef USE_FOG\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\\n\t#else\\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\n\t#endif\\n\t#ifdef FOG_EXP2\\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\\n\t#else\\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\\n\t#endif\\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'fog_pars_fragment' ] = \"#ifdef USE_FOG\\n\tuniform vec3 fogColor;\\n\t#ifdef FOG_EXP2\\n\t\tuniform float fogDensity;\\n\t#else\\n\t\tuniform float fogNear;\\n\t\tuniform float fogFar;\\n\t#endif\\n#endif\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'lightmap_fragment' ] = \"#ifdef USE_LIGHTMAP\\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'lightmap_pars_fragment' ] = \"#ifdef USE_LIGHTMAP\\n\tuniform sampler2D lightMap;\\n\tuniform float lightMapIntensity;\\n#endif\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'lights_lambert_vertex' ] = \"vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n\tvLightBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\n#if NUM_POINT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\\n\t\tdotNL = dot( geometry.normal, directLight.direction );\\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\t\t#endif\\n\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\\n\t\tdotNL = dot( geometry.normal, directLight.direction );\\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\t\t#endif\\n\t}\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\\n\t\tdotNL = dot( geometry.normal, directLight.direction );\\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\t\t#endif\\n\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\n\t\t#endif\\n\t}\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/lights_pars.glsl\n\t\n\tTHREE.ShaderChunk[ 'lights_pars' ] = \"uniform vec3 ambientLightColor;\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\tvec3 irradiance = ambientLightColor;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\treturn irradiance;\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\tstruct DirectionalLight {\\n\t\tvec3 direction;\\n\t\tvec3 color;\\n\t\tint shadow;\\n\t\tfloat shadowBias;\\n\t\tfloat shadowRadius;\\n\t\tvec2 shadowMapSize;\\n\t};\\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\t\tdirectLight.color = directionalLight.color;\\n\t\tdirectLight.direction = directionalLight.direction;\\n\t\tdirectLight.visible = true;\\n\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\tstruct PointLight {\\n\t\tvec3 position;\\n\t\tvec3 color;\\n\t\tfloat distance;\\n\t\tfloat decay;\\n\t\tint shadow;\\n\t\tfloat shadowBias;\\n\t\tfloat shadowRadius;\\n\t\tvec2 shadowMapSize;\\n\t};\\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\t\tvec3 lVector = pointLight.position - geometry.position;\\n\t\tdirectLight.direction = normalize( lVector );\\n\t\tfloat lightDistance = length( lVector );\\n\t\tif ( testLightInRange( lightDistance, pointLight.distance ) ) {\\n\t\t\tdirectLight.color = pointLight.color;\\n\t\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\n\t\t\tdirectLight.visible = true;\\n\t\t} else {\\n\t\t\tdirectLight.color = vec3( 0.0 );\\n\t\t\tdirectLight.visible = false;\\n\t\t}\\n\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\tstruct SpotLight {\\n\t\tvec3 position;\\n\t\tvec3 direction;\\n\t\tvec3 color;\\n\t\tfloat distance;\\n\t\tfloat decay;\\n\t\tfloat coneCos;\\n\t\tfloat penumbraCos;\\n\t\tint shadow;\\n\t\tfloat shadowBias;\\n\t\tfloat shadowRadius;\\n\t\tvec2 shadowMapSize;\\n\t};\\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\\n\t\tvec3 lVector = spotLight.position - geometry.position;\\n\t\tdirectLight.direction = normalize( lVector );\\n\t\tfloat lightDistance = length( lVector );\\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\n\t\tif ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\t\t\tdirectLight.color = spotLight.color;\\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\n\t\t\tdirectLight.visible = true;\\n\t\t} else {\\n\t\t\tdirectLight.color = vec3( 0.0 );\\n\t\t\tdirectLight.visible = false;\\n\t\t}\\n\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\tstruct HemisphereLight {\\n\t\tvec3 direction;\\n\t\tvec3 skyColor;\\n\t\tvec3 groundColor;\\n\t};\\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\t\tirradiance *= PI;\\n\t\t#endif\\n\t\treturn irradiance;\\n\t}\\n#endif\\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\n\t\t#include <normal_flip>\\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\t\t#ifdef ENVMAP_TYPE_CUBE\\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\\n\t\t#else\\n\t\t\tvec4 envMapColor = vec4( 0.0 );\\n\t\t#endif\\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\\n\t}\\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\n\t}\\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\\n\t\t#else\\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\\n\t\t#endif\\n\t\t#include <normal_flip>\\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\\n\t\t#ifdef ENVMAP_TYPE_CUBE\\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\t\t\tvec2 sampleUV;\\n\t\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\t\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\t\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#endif\\n\t\treturn envMapColor.rgb * envMapIntensity;\\n\t}\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'lights_phong_fragment' ] = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'lights_phong_pars_fragment' ] = \"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\nstruct BlinnPhongMaterial {\\n\tvec3\tdiffuseColor;\\n\tvec3\tspecularColor;\\n\tfloat\tspecularShininess;\\n\tfloat\tspecularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\tvec3 irradiance = dotNL * directLight.color;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\t(0)\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/lights_physical_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'lights_physical_fragment' ] = \"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\\n#ifdef STANDARD\\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\\n#else\\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/lights_physical_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'lights_physical_pars_fragment' ] = \"struct PhysicalMaterial {\\n\tvec3\tdiffuseColor;\\n\tfloat\tspecularRoughness;\\n\tvec3\tspecularColor;\\n\t#ifndef STANDARD\\n\t\tfloat clearCoat;\\n\t\tfloat clearCoatRoughness;\\n\t#endif\\n};\\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\tvec3 irradiance = dotNL * directLight.color;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\t#ifndef STANDARD\\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\t#endif\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectSpecular += radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\\n\t#ifndef STANDARD\\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\t#endif\\n}\\n#define RE_Direct\t\t\t\tRE_Direct_Physical\\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/lights_template.glsl\n\t\n\tTHREE.ShaderChunk[ 'lights_template' ] = \"\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = normalize( vViewPosition );\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\tPointLight pointLight;\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tpointLight = pointLights[ i ];\\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\t\t#ifdef USE_SHADOWMAP\\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\t}\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\tSpotLight spotLight;\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tspotLight = spotLights[ i ];\\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\t\t#ifdef USE_SHADOWMAP\\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\t}\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\tDirectionalLight directionalLight;\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tdirectionalLight = directionalLights[ i ];\\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\t\t#ifdef USE_SHADOWMAP\\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\t}\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\t#ifdef USE_LIGHTMAP\\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\t\tlightMapIrradiance *= PI;\\n\t\t#endif\\n\t\tirradiance += lightMapIrradiance;\\n\t#endif\\n\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\t\t}\\n\t#endif\\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\t \tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\\n\t#endif\\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\\n\t#ifndef STANDARD\\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\\n\t#else\\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\\n\t#endif\\n\t\t\\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'logdepthbuf_fragment' ] = \"#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\\n#endif\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'logdepthbuf_pars_fragment' ] = \"#ifdef USE_LOGDEPTHBUF\\n\tuniform float logDepthBufFC;\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tvarying float vFragDepth;\\n\t#endif\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'logdepthbuf_pars_vertex' ] = \"#ifdef USE_LOGDEPTHBUF\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tvarying float vFragDepth;\\n\t#endif\\n\tuniform float logDepthBufFC;\\n#endif\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'logdepthbuf_vertex' ] = \"#ifdef USE_LOGDEPTHBUF\\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tvFragDepth = 1.0 + gl_Position.w;\\n\t#else\\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\\n\t#endif\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'map_fragment' ] = \"#ifdef USE_MAP\\n\tvec4 texelColor = texture2D( map, vUv );\\n\ttexelColor = mapTexelToLinear( texelColor );\\n\tdiffuseColor *= texelColor;\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'map_pars_fragment' ] = \"#ifdef USE_MAP\\n\tuniform sampler2D map;\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'map_particle_fragment' ] = \"#ifdef USE_MAP\\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'map_particle_pars_fragment' ] = \"#ifdef USE_MAP\\n\tuniform vec4 offsetRepeat;\\n\tuniform sampler2D map;\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/metalnessmap_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'metalnessmap_fragment' ] = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\tmetalnessFactor *= texelMetalness.r;\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/metalnessmap_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'metalnessmap_pars_fragment' ] = \"#ifdef USE_METALNESSMAP\\n\tuniform sampler2D metalnessMap;\\n#endif\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'morphnormal_vertex' ] = \"#ifdef USE_MORPHNORMALS\\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'morphtarget_pars_vertex' ] = \"#ifdef USE_MORPHTARGETS\\n\t#ifndef USE_MORPHNORMALS\\n\tuniform float morphTargetInfluences[ 8 ];\\n\t#else\\n\tuniform float morphTargetInfluences[ 4 ];\\n\t#endif\\n#endif\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'morphtarget_vertex' ] = \"#ifdef USE_MORPHTARGETS\\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n\t#ifndef USE_MORPHNORMALS\\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n\t#endif\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/normal_flip.glsl\n\t\n\tTHREE.ShaderChunk[ 'normal_flip' ] = \"#ifdef DOUBLE_SIDED\\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n#else\\n\tfloat flipNormal = 1.0;\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/normal_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'normal_fragment' ] = \"#ifdef FLAT_SHADED\\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\n\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\tvec3 normal = normalize( vNormal ) * flipNormal;\\n#endif\\n#ifdef USE_NORMALMAP\\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\n#elif defined( USE_BUMPMAP )\\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'normalmap_pars_fragment' ] = \"#ifdef USE_NORMALMAP\\n\tuniform sampler2D normalMap;\\n\tuniform vec2 normalScale;\\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\\n\t\tvec2 st0 = dFdx( vUv.st );\\n\t\tvec2 st1 = dFdy( vUv.st );\\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\n\t\tvec3 N = normalize( surf_norm );\\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\t\tmapN.xy = normalScale * mapN.xy;\\n\t\tmat3 tsn = mat3( S, T, N );\\n\t\treturn normalize( tsn * mapN );\\n\t}\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/packing.glsl\n\t\n\tTHREE.ShaderChunk[ 'packing' ] = \"vec3 packNormalToRGB( const in vec3 normal ) {\\n  return normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n  return 1.0 - 2.0 * rgb.xyz;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\treturn dot( v, UnpackFactors );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n  return ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\n  return linearClipZ * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/premultiplied_alpha_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'premultiplied_alpha_fragment' ] = \"#ifdef PREMULTIPLIED_ALPHA\\n\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/project_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'project_vertex' ] = \"#ifdef USE_SKINNING\\n\tvec4 mvPosition = modelViewMatrix * skinned;\\n#else\\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\n#endif\\ngl_Position = projectionMatrix * mvPosition;\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/roughnessmap_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'roughnessmap_fragment' ] = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\troughnessFactor *= texelRoughness.r;\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/roughnessmap_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'roughnessmap_pars_fragment' ] = \"#ifdef USE_ROUGHNESSMAP\\n\tuniform sampler2D roughnessMap;\\n#endif\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'shadowmap_pars_fragment' ] = \"#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\t#endif\\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\t}\\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\\n\t\tvec2 f = fract( uv * size + 0.5 );\\n\t\tfloat a = mix( lb, lt, f.y );\\n\t\tfloat b = mix( rb, rt, f.y );\\n\t\tfloat c = mix( a, b, f.x );\\n\t\treturn c;\\n\t}\\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\t\tshadowCoord.xyz /= shadowCoord.w;\\n\t\tshadowCoord.z += shadowBias;\\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\t\tbool inFrustum = all( inFrustumVec );\\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\t\tbool frustumTest = all( frustumTestVec );\\n\t\tif ( frustumTest ) {\\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\\n\t\t\treturn (\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\t\t\t) * ( 1.0 / 9.0 );\\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\\n\t\t\treturn (\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\t\t\t) * ( 1.0 / 9.0 );\\n\t\t#else\\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\t\t#endif\\n\t\t}\\n\t\treturn 1.0;\\n\t}\\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\t\tvec3 absV = abs( v );\\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\t\tabsV *= scaleToCube;\\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\t\tvec2 planar = v.xy;\\n\t\tfloat almostATexel = 1.5 * texelSizeY;\\n\t\tfloat almostOne = 1.0 - almostATexel;\\n\t\tif ( absV.z >= almostOne ) {\\n\t\t\tif ( v.z > 0.0 )\\n\t\t\t\tplanar.x = 4.0 - v.x;\\n\t\t} else if ( absV.x >= almostOne ) {\\n\t\t\tfloat signX = sign( v.x );\\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\\n\t\t} else if ( absV.y >= almostOne ) {\\n\t\t\tfloat signY = sign( v.y );\\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\t\t\tplanar.y = v.z * signY - 2.0;\\n\t\t}\\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\t}\\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\t\tvec3 lightToPosition = shadowCoord.xyz;\\n\t\tvec3 bd3D = normalize( lightToPosition );\\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\t\t\treturn (\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\t\t\t) * ( 1.0 / 9.0 );\\n\t\t#else\\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\t\t#endif\\n\t}\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'shadowmap_pars_vertex' ] = \"#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\t#endif\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'shadowmap_vertex' ] = \"#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\\n\t}\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\\n\t}\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\\n\t}\\n\t#endif\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/shadowmask_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'shadowmask_pars_fragment' ] = \"float getShadowMask() {\\n\tfloat shadow = 1.0;\\n\t#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\tDirectionalLight directionalLight;\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tdirectionalLight = directionalLights[ i ];\\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\t}\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\tSpotLight spotLight;\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tspotLight = spotLights[ i ];\\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\t}\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\tPointLight pointLight;\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tpointLight = pointLights[ i ];\\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\t}\\n\t#endif\\n\t#endif\\n\treturn shadow;\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'skinbase_vertex' ] = \"#ifdef USE_SKINNING\\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'skinning_pars_vertex' ] = \"#ifdef USE_SKINNING\\n\tuniform mat4 bindMatrix;\\n\tuniform mat4 bindMatrixInverse;\\n\t#ifdef BONE_TEXTURE\\n\t\tuniform sampler2D boneTexture;\\n\t\tuniform int boneTextureWidth;\\n\t\tuniform int boneTextureHeight;\\n\t\tmat4 getBoneMatrix( const in float i ) {\\n\t\t\tfloat j = i * 4.0;\\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\\n\t\t\ty = dy * ( y + 0.5 );\\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\t\t\treturn bone;\\n\t\t}\\n\t#else\\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\\n\t\tmat4 getBoneMatrix( const in float i ) {\\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\\n\t\t\treturn bone;\\n\t\t}\\n\t#endif\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'skinning_vertex' ] = \"#ifdef USE_SKINNING\\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\tvec4 skinned = vec4( 0.0 );\\n\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\tskinned  = bindMatrixInverse * skinned;\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'skinnormal_vertex' ] = \"#ifdef USE_SKINNING\\n\tmat4 skinMatrix = mat4( 0.0 );\\n\tskinMatrix += skinWeight.x * boneMatX;\\n\tskinMatrix += skinWeight.y * boneMatY;\\n\tskinMatrix += skinWeight.z * boneMatZ;\\n\tskinMatrix += skinWeight.w * boneMatW;\\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'specularmap_fragment' ] = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\tspecularStrength = texelSpecular.r;\\n#else\\n\tspecularStrength = 1.0;\\n#endif\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'specularmap_pars_fragment' ] = \"#ifdef USE_SPECULARMAP\\n\tuniform sampler2D specularMap;\\n#endif\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/tonemapping_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'tonemapping_fragment' ] = \"#if defined( TONE_MAPPING )\\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/tonemapping_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'tonemapping_pars_fragment' ] = \"#define saturate(a) clamp( a, 0.0, 1.0 )\\nuniform float toneMappingExposure;\\nuniform float toneMappingWhitePoint;\\nvec3 LinearToneMapping( vec3 color ) {\\n  return toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  return saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\\nvec3 Uncharted2ToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  color = max( vec3( 0.0 ), color - 0.004 );\\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'uv2_pars_fragment' ] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\tvarying vec2 vUv2;\\n#endif\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'uv2_pars_vertex' ] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\tattribute vec2 uv2;\\n\tvarying vec2 vUv2;\\n#endif\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/uv2_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'uv2_vertex' ] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\tvUv2 = uv2;\\n#endif\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'uv_pars_fragment' ] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\tvarying vec2 vUv;\\n#endif\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'uv_pars_vertex' ] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\tvarying vec2 vUv;\\n\tuniform vec4 offsetRepeat;\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/uv_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'uv_vertex' ] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\\n#endif\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'worldpos_vertex' ] = \"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\\n\t#ifdef USE_SKINNING\\n\t\tvec4 worldPosition = modelMatrix * skinned;\\n\t#else\\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n\t#endif\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/UniformsUtils.js\n\t\n\t/**\n\t * Uniform Utilities\n\t */\n\t\n\tTHREE.UniformsUtils = {\n\t\n\t\tmerge: function ( uniforms ) {\n\t\n\t\t\tvar merged = {};\n\t\n\t\t\tfor ( var u = 0; u < uniforms.length; u ++ ) {\n\t\n\t\t\t\tvar tmp = this.clone( uniforms[ u ] );\n\t\n\t\t\t\tfor ( var p in tmp ) {\n\t\n\t\t\t\t\tmerged[ p ] = tmp[ p ];\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn merged;\n\t\n\t\t},\n\t\n\t\tclone: function ( uniforms_src ) {\n\t\n\t\t\tvar uniforms_dst = {};\n\t\n\t\t\tfor ( var u in uniforms_src ) {\n\t\n\t\t\t\tuniforms_dst[ u ] = {};\n\t\n\t\t\t\tfor ( var p in uniforms_src[ u ] ) {\n\t\n\t\t\t\t\tvar parameter_src = uniforms_src[ u ][ p ];\n\t\n\t\t\t\t\tif ( parameter_src instanceof THREE.Color ||\n\t\t\t\t\t\t parameter_src instanceof THREE.Vector2 ||\n\t\t\t\t\t\t parameter_src instanceof THREE.Vector3 ||\n\t\t\t\t\t\t parameter_src instanceof THREE.Vector4 ||\n\t\t\t\t\t\t parameter_src instanceof THREE.Matrix3 ||\n\t\t\t\t\t\t parameter_src instanceof THREE.Matrix4 ||\n\t\t\t\t\t\t parameter_src instanceof THREE.Texture ) {\n\t\n\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.clone();\n\t\n\t\t\t\t\t} else if ( Array.isArray( parameter_src ) ) {\n\t\n\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.slice();\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn uniforms_dst;\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/renderers/shaders/UniformsLib.js\n\t\n\t/**\n\t * Uniforms library for shared webgl shaders\n\t */\n\t\n\tTHREE.UniformsLib = {\n\t\n\t\tcommon: {\n\t\n\t\t\t\"diffuse\": { value: new THREE.Color( 0xeeeeee ) },\n\t\t\t\"opacity\": { value: 1.0 },\n\t\n\t\t\t\"map\": { value: null },\n\t\t\t\"offsetRepeat\": { value: new THREE.Vector4( 0, 0, 1, 1 ) },\n\t\n\t\t\t\"specularMap\": { value: null },\n\t\t\t\"alphaMap\": { value: null },\n\t\n\t\t\t\"envMap\": { value: null },\n\t\t\t\"flipEnvMap\": { value: - 1 },\n\t\t\t\"reflectivity\": { value: 1.0 },\n\t\t\t\"refractionRatio\": { value: 0.98 }\n\t\n\t\t},\n\t\n\t\taomap: {\n\t\n\t\t\t\"aoMap\": { value: null },\n\t\t\t\"aoMapIntensity\": { value: 1 }\n\t\n\t\t},\n\t\n\t\tlightmap: {\n\t\n\t\t\t\"lightMap\": { value: null },\n\t\t\t\"lightMapIntensity\": { value: 1 }\n\t\n\t\t},\n\t\n\t\temissivemap: {\n\t\n\t\t\t\"emissiveMap\": { value: null }\n\t\n\t\t},\n\t\n\t\tbumpmap: {\n\t\n\t\t\t\"bumpMap\": { value: null },\n\t\t\t\"bumpScale\": { value: 1 }\n\t\n\t\t},\n\t\n\t\tnormalmap: {\n\t\n\t\t\t\"normalMap\": { value: null },\n\t\t\t\"normalScale\": { value: new THREE.Vector2( 1, 1 ) }\n\t\n\t\t},\n\t\n\t\tdisplacementmap: {\n\t\n\t\t\t\"displacementMap\": { value: null },\n\t\t\t\"displacementScale\": { value: 1 },\n\t\t\t\"displacementBias\": { value: 0 }\n\t\n\t\t},\n\t\n\t\troughnessmap: {\n\t\n\t\t\t\"roughnessMap\": { value: null }\n\t\n\t\t},\n\t\n\t\tmetalnessmap: {\n\t\n\t\t\t\"metalnessMap\": { value: null }\n\t\n\t\t},\n\t\n\t\tfog: {\n\t\n\t\t\t\"fogDensity\": { value: 0.00025 },\n\t\t\t\"fogNear\": { value: 1 },\n\t\t\t\"fogFar\": { value: 2000 },\n\t\t\t\"fogColor\": { value: new THREE.Color( 0xffffff ) }\n\t\n\t\t},\n\t\n\t\tlights: {\n\t\n\t\t\t\"ambientLightColor\": { value: [] },\n\t\n\t\t\t\"directionalLights\": { value: [], properties: {\n\t\t\t\t\"direction\": {},\n\t\t\t\t\"color\": {},\n\t\n\t\t\t\t\"shadow\": {},\n\t\t\t\t\"shadowBias\": {},\n\t\t\t\t\"shadowRadius\": {},\n\t\t\t\t\"shadowMapSize\": {}\n\t\t\t} },\n\t\n\t\t\t\"directionalShadowMap\": { value: [] },\n\t\t\t\"directionalShadowMatrix\": { value: [] },\n\t\n\t\t\t\"spotLights\": { value: [], properties: {\n\t\t\t\t\"color\": {},\n\t\t\t\t\"position\": {},\n\t\t\t\t\"direction\": {},\n\t\t\t\t\"distance\": {},\n\t\t\t\t\"coneCos\": {},\n\t\t\t\t\"penumbraCos\": {},\n\t\t\t\t\"decay\": {},\n\t\n\t\t\t\t\"shadow\": {},\n\t\t\t\t\"shadowBias\": {},\n\t\t\t\t\"shadowRadius\": {},\n\t\t\t\t\"shadowMapSize\": {}\n\t\t\t} },\n\t\n\t\t\t\"spotShadowMap\": { value: [] },\n\t\t\t\"spotShadowMatrix\": { value: [] },\n\t\n\t\t\t\"pointLights\": { value: [], properties: {\n\t\t\t\t\"color\": {},\n\t\t\t\t\"position\": {},\n\t\t\t\t\"decay\": {},\n\t\t\t\t\"distance\": {},\n\t\n\t\t\t\t\"shadow\": {},\n\t\t\t\t\"shadowBias\": {},\n\t\t\t\t\"shadowRadius\": {},\n\t\t\t\t\"shadowMapSize\": {}\n\t\t\t} },\n\t\n\t\t\t\"pointShadowMap\": { value: [] },\n\t\t\t\"pointShadowMatrix\": { value: [] },\n\t\n\t\t\t\"hemisphereLights\": { value: [], properties: {\n\t\t\t\t\"direction\": {},\n\t\t\t\t\"skyColor\": {},\n\t\t\t\t\"groundColor\": {}\n\t\t\t} }\n\t\n\t\t},\n\t\n\t\tpoints: {\n\t\n\t\t\t\"diffuse\": { value: new THREE.Color( 0xeeeeee ) },\n\t\t\t\"opacity\": { value: 1.0 },\n\t\t\t\"size\": { value: 1.0 },\n\t\t\t\"scale\": { value: 1.0 },\n\t\t\t\"map\": { value: null },\n\t\t\t\"offsetRepeat\": { value: new THREE.Vector4( 0, 0, 1, 1 ) }\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/renderers/shaders/ShaderLib/cube_frag.glsl\n\t\n\tTHREE.ShaderChunk[ 'cube_frag' ] = \"uniform samplerCube tCube;\\nuniform float tFlip;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\\n\t#include <logdepthbuf_fragment>\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/cube_vert.glsl\n\t\n\tTHREE.ShaderChunk[ 'cube_vert' ] = \"varying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\tvWorldPosition = transformDirection( position, modelMatrix );\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/depth_frag.glsl\n\t\n\tTHREE.ShaderChunk[ 'depth_frag' ] = \"#if DEPTH_PACKING == 3200\\n\tuniform float opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( 1.0 );\\n\t#if DEPTH_PACKING == 3200\\n\t\tdiffuseColor.a = opacity;\\n\t#endif\\n\t#include <map_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <logdepthbuf_fragment>\\n\t#if DEPTH_PACKING == 3200\\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\\n\t#elif DEPTH_PACKING == 3201\\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\\n\t#endif\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/depth_vert.glsl\n\t\n\tTHREE.ShaderChunk[ 'depth_vert' ] = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <begin_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/distanceRGBA_frag.glsl\n\t\n\tTHREE.ShaderChunk[ 'distanceRGBA_frag' ] = \"uniform vec3 lightPos;\\nvarying vec4 vWorldPosition;\\n#include <common>\\n#include <packing>\\n#include <clipping_planes_pars_fragment>\\nvoid main () {\\n\t#include <clipping_planes_fragment>\\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/distanceRGBA_vert.glsl\n\t\n\tTHREE.ShaderChunk[ 'distanceRGBA_vert' ] = \"varying vec4 vWorldPosition;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <skinbase_vertex>\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvWorldPosition = worldPosition;\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/equirect_frag.glsl\n\t\n\tTHREE.ShaderChunk[ 'equirect_frag' ] = \"uniform sampler2D tEquirect;\\nuniform float tFlip;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec3 direction = normalize( vWorldPosition );\\n\tvec2 sampleUV;\\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\\n\t#include <logdepthbuf_fragment>\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/equirect_vert.glsl\n\t\n\tTHREE.ShaderChunk[ 'equirect_vert' ] = \"varying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\tvWorldPosition = transformDirection( position, modelMatrix );\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/linedashed_frag.glsl\n\t\n\tTHREE.ShaderChunk[ 'linedashed_frag' ] = \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\t\tdiscard;\\n\t}\\n\tvec3 outgoingLight = vec3( 0.0 );\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <color_fragment>\\n\toutgoingLight = diffuseColor.rgb;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/linedashed_vert.glsl\n\t\n\tTHREE.ShaderChunk[ 'linedashed_vert' ] = \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <color_vertex>\\n\tvLineDistance = scale * lineDistance;\\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\tgl_Position = projectionMatrix * mvPosition;\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/meshbasic_frag.glsl\n\t\n\tTHREE.ShaderChunk[ 'meshbasic_frag' ] = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\tReflectedLight reflectedLight;\\n\treflectedLight.directDiffuse = vec3( 0.0 );\\n\treflectedLight.directSpecular = vec3( 0.0 );\\n\treflectedLight.indirectDiffuse = diffuseColor.rgb;\\n\treflectedLight.indirectSpecular = vec3( 0.0 );\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\t#include <normal_flip>\\n\t#include <envmap_fragment>\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/meshbasic_vert.glsl\n\t\n\tTHREE.ShaderChunk[ 'meshbasic_vert' ] = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <skinbase_vertex>\\n\t#ifdef USE_ENVMAP\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n\t#endif\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <envmap_vertex>\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/meshlambert_frag.glsl\n\t\n\tTHREE.ShaderChunk[ 'meshlambert_frag' ] = \"uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <emissivemap_fragment>\\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\\n\t#include <lightmap_fragment>\\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\n\t#ifdef DOUBLE_SIDED\\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\t#else\\n\t\treflectedLight.directDiffuse = vLightFront;\\n\t#endif\\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\t#include <normal_flip>\\n\t#include <envmap_fragment>\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/meshlambert_vert.glsl\n\t\n\tTHREE.ShaderChunk[ 'meshlambert_vert' ] = \"#define LAMBERT\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <envmap_vertex>\\n\t#include <lights_lambert_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/meshphong_frag.glsl\n\t\n\tTHREE.ShaderChunk[ 'meshphong_frag' ] = \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <normal_flip>\\n\t#include <normal_fragment>\\n\t#include <emissivemap_fragment>\\n\t#include <lights_phong_fragment>\\n\t#include <lights_template>\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\t#include <envmap_fragment>\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/meshphong_vert.glsl\n\t\n\tTHREE.ShaderChunk[ 'meshphong_vert' ] = \"#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\tvNormal = normalize( transformedNormal );\\n#endif\\n\t#include <begin_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvViewPosition = - mvPosition.xyz;\\n\t#include <worldpos_vertex>\\n\t#include <envmap_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/meshphysical_frag.glsl\n\t\n\tTHREE.ShaderChunk[ 'meshphysical_frag' ] = \"#define PHYSICAL\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n#ifndef STANDARD\\n\tuniform float clearCoat;\\n\tuniform float clearCoatRoughness;\\n#endif\\nuniform float envMapIntensity;\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <cube_uv_reflection_fragment>\\n#include <lights_pars>\\n#include <lights_physical_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <roughnessmap_fragment>\\n\t#include <metalnessmap_fragment>\\n\t#include <normal_flip>\\n\t#include <normal_fragment>\\n\t#include <emissivemap_fragment>\\n\t#include <lights_physical_fragment>\\n\t#include <lights_template>\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/meshphysical_vert.glsl\n\t\n\tTHREE.ShaderChunk[ 'meshphysical_vert' ] = \"#define PHYSICAL\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\tvNormal = normalize( transformedNormal );\\n#endif\\n\t#include <begin_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvViewPosition = - mvPosition.xyz;\\n\t#include <worldpos_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/normal_frag.glsl\n\t\n\tTHREE.ShaderChunk[ 'normal_frag' ] = \"uniform float opacity;\\nvarying vec3 vNormal;\\n#include <common>\\n#include <packing>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tgl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\\n\t#include <logdepthbuf_fragment>\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/normal_vert.glsl\n\t\n\tTHREE.ShaderChunk[ 'normal_vert' ] = \"varying vec3 vNormal;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\tvNormal = normalize( normalMatrix * normal );\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/points_frag.glsl\n\t\n\tTHREE.ShaderChunk[ 'points_frag' ] = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec3 outgoingLight = vec3( 0.0 );\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_particle_fragment>\\n\t#include <color_fragment>\\n\t#include <alphatest_fragment>\\n\toutgoingLight = diffuseColor.rgb;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/points_vert.glsl\n\t\n\tTHREE.ShaderChunk[ 'points_vert' ] = \"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <color_vertex>\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\t#ifdef USE_SIZEATTENUATION\\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\\n\t#else\\n\t\tgl_PointSize = size;\\n\t#endif\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/shadow_frag.glsl\n\t\n\tTHREE.ShaderChunk[ 'shadow_frag' ] = \"uniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\nvoid main() {\\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/shadow_vert.glsl\n\t\n\tTHREE.ShaderChunk[ 'shadow_vert' ] = \"#include <shadowmap_pars_vertex>\\nvoid main() {\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib.js\n\t\n\t/**\n\t * Webgl Shader Library for three.js\n\t *\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t */\n\t\n\t\n\tTHREE.ShaderLib = {\n\t\n\t\t'basic': {\n\t\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\n\t\n\t\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\t\tTHREE.UniformsLib[ 'aomap' ],\n\t\t\t\tTHREE.UniformsLib[ 'fog' ]\n\t\n\t\t\t] ),\n\t\n\t\t\tvertexShader: THREE.ShaderChunk[ 'meshbasic_vert' ],\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'meshbasic_frag' ]\n\t\n\t\t},\n\t\n\t\t'lambert': {\n\t\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\n\t\n\t\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\t\tTHREE.UniformsLib[ 'aomap' ],\n\t\t\t\tTHREE.UniformsLib[ 'lightmap' ],\n\t\t\t\tTHREE.UniformsLib[ 'emissivemap' ],\n\t\t\t\tTHREE.UniformsLib[ 'fog' ],\n\t\t\t\tTHREE.UniformsLib[ 'lights' ],\n\t\n\t\t\t\t{\n\t\t\t\t\t\"emissive\" : { value: new THREE.Color( 0x000000 ) }\n\t\t\t\t}\n\t\n\t\t\t] ),\n\t\n\t\t\tvertexShader: THREE.ShaderChunk[ 'meshlambert_vert' ],\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'meshlambert_frag' ]\n\t\n\t\t},\n\t\n\t\t'phong': {\n\t\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\n\t\n\t\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\t\tTHREE.UniformsLib[ 'aomap' ],\n\t\t\t\tTHREE.UniformsLib[ 'lightmap' ],\n\t\t\t\tTHREE.UniformsLib[ 'emissivemap' ],\n\t\t\t\tTHREE.UniformsLib[ 'bumpmap' ],\n\t\t\t\tTHREE.UniformsLib[ 'normalmap' ],\n\t\t\t\tTHREE.UniformsLib[ 'displacementmap' ],\n\t\t\t\tTHREE.UniformsLib[ 'fog' ],\n\t\t\t\tTHREE.UniformsLib[ 'lights' ],\n\t\n\t\t\t\t{\n\t\t\t\t\t\"emissive\" : { value: new THREE.Color( 0x000000 ) },\n\t\t\t\t\t\"specular\" : { value: new THREE.Color( 0x111111 ) },\n\t\t\t\t\t\"shininess\": { value: 30 }\n\t\t\t\t}\n\t\n\t\t\t] ),\n\t\n\t\t\tvertexShader: THREE.ShaderChunk[ 'meshphong_vert' ],\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'meshphong_frag' ]\n\t\n\t\t},\n\t\n\t\t'standard': {\n\t\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\n\t\n\t\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\t\tTHREE.UniformsLib[ 'aomap' ],\n\t\t\t\tTHREE.UniformsLib[ 'lightmap' ],\n\t\t\t\tTHREE.UniformsLib[ 'emissivemap' ],\n\t\t\t\tTHREE.UniformsLib[ 'bumpmap' ],\n\t\t\t\tTHREE.UniformsLib[ 'normalmap' ],\n\t\t\t\tTHREE.UniformsLib[ 'displacementmap' ],\n\t\t\t\tTHREE.UniformsLib[ 'roughnessmap' ],\n\t\t\t\tTHREE.UniformsLib[ 'metalnessmap' ],\n\t\t\t\tTHREE.UniformsLib[ 'fog' ],\n\t\t\t\tTHREE.UniformsLib[ 'lights' ],\n\t\n\t\t\t\t{\n\t\t\t\t\t\"emissive\" : { value: new THREE.Color( 0x000000 ) },\n\t\t\t\t\t\"roughness\": { value: 0.5 },\n\t\t\t\t\t\"metalness\": { value: 0 },\n\t\t\t\t\t\"envMapIntensity\" : { value: 1 }, // temporary\n\t\t\t\t}\n\t\n\t\t\t] ),\n\t\n\t\t\tvertexShader: THREE.ShaderChunk[ 'meshphysical_vert' ],\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'meshphysical_frag' ]\n\t\n\t\t},\n\t\n\t\t'points': {\n\t\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\n\t\n\t\t\t\tTHREE.UniformsLib[ 'points' ],\n\t\t\t\tTHREE.UniformsLib[ 'fog' ]\n\t\n\t\t\t] ),\n\t\n\t\t\tvertexShader: THREE.ShaderChunk[ 'points_vert' ],\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'points_frag' ]\n\t\n\t\t},\n\t\n\t\t'dashed': {\n\t\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\n\t\n\t\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\t\tTHREE.UniformsLib[ 'fog' ],\n\t\n\t\t\t\t{\n\t\t\t\t\t\"scale\"    : { value: 1 },\n\t\t\t\t\t\"dashSize\" : { value: 1 },\n\t\t\t\t\t\"totalSize\": { value: 2 }\n\t\t\t\t}\n\t\n\t\t\t] ),\n\t\n\t\t\tvertexShader: THREE.ShaderChunk[ 'linedashed_vert' ],\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'linedashed_frag' ]\n\t\n\t\t},\n\t\n\t\t'depth': {\n\t\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\n\t\n\t\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\t\tTHREE.UniformsLib[ 'displacementmap' ]\n\t\n\t\t\t] ),\n\t\n\t\t\tvertexShader: THREE.ShaderChunk[ 'depth_vert' ],\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'depth_frag' ]\n\t\n\t\t},\n\t\n\t\t'normal': {\n\t\n\t\t\tuniforms: {\n\t\n\t\t\t\t\"opacity\" : { value: 1.0 }\n\t\n\t\t\t},\n\t\n\t\t\tvertexShader: THREE.ShaderChunk[ 'normal_vert' ],\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'normal_frag' ]\n\t\n\t\t},\n\t\n\t\t/* -------------------------------------------------------------------------\n\t\t//\tCube map shader\n\t\t ------------------------------------------------------------------------- */\n\t\n\t\t'cube': {\n\t\n\t\t\tuniforms: {\n\t\t\t\t\"tCube\": { value: null },\n\t\t\t\t\"tFlip\": { value: - 1 }\n\t\t\t},\n\t\n\t\t\tvertexShader: THREE.ShaderChunk[ 'cube_vert' ],\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'cube_frag' ]\n\t\n\t\t},\n\t\n\t\t/* -------------------------------------------------------------------------\n\t\t//\tCube map shader\n\t\t ------------------------------------------------------------------------- */\n\t\n\t\t'equirect': {\n\t\n\t\t\tuniforms: {\n\t\t\t\t\"tEquirect\": { value: null },\n\t\t\t\t\"tFlip\": { value: - 1 }\n\t\t\t},\n\t\n\t\t\tvertexShader: THREE.ShaderChunk[ 'equirect_vert' ],\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'equirect_frag' ]\n\t\n\t\t},\n\t\n\t\t'distanceRGBA': {\n\t\n\t\t\tuniforms: {\n\t\n\t\t\t\t\"lightPos\": { value: new THREE.Vector3() }\n\t\n\t\t\t},\n\t\n\t\t\tvertexShader: THREE.ShaderChunk[ 'distanceRGBA_vert' ],\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'distanceRGBA_frag' ]\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.ShaderLib[ 'physical' ] = {\n\t\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\t\n\t\t\tTHREE.ShaderLib[ 'standard' ].uniforms,\n\t\n\t\t\t{\n\t\t\t\t\"clearCoat\": { value: 0 },\n\t\t\t\t\"clearCoatRoughness\": { value: 0 }\n\t\t\t}\n\t\n\t\t] ),\n\t\n\t\tvertexShader: THREE.ShaderChunk[ 'meshphysical_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'meshphysical_frag' ]\n\t\n\t};\n\t\n\t// File:src/renderers/WebGLRenderer.js\n\t\n\t/**\n\t * @author supereggbert / http://www.paulbrunt.co.uk/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author szimek / https://github.com/szimek/\n\t * @author tschw\n\t */\n\t\n\tTHREE.WebGLRenderer = function ( parameters ) {\n\t\n\t\tconsole.log( 'THREE.WebGLRenderer', THREE.REVISION );\n\t\n\t\tparameters = parameters || {};\n\t\n\t\tvar _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),\n\t\t_context = parameters.context !== undefined ? parameters.context : null,\n\t\n\t\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\n\t\t_depth = parameters.depth !== undefined ? parameters.depth : true,\n\t\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\n\t\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\n\t\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\n\t\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;\n\t\n\t\tvar lights = [];\n\t\n\t\tvar opaqueObjects = [];\n\t\tvar opaqueObjectsLastIndex = - 1;\n\t\tvar transparentObjects = [];\n\t\tvar transparentObjectsLastIndex = - 1;\n\t\n\t\tvar morphInfluences = new Float32Array( 8 );\n\t\n\t\tvar sprites = [];\n\t\tvar lensFlares = [];\n\t\n\t\t// public properties\n\t\n\t\tthis.domElement = _canvas;\n\t\tthis.context = null;\n\t\n\t\t// clearing\n\t\n\t\tthis.autoClear = true;\n\t\tthis.autoClearColor = true;\n\t\tthis.autoClearDepth = true;\n\t\tthis.autoClearStencil = true;\n\t\n\t\t// scene graph\n\t\n\t\tthis.sortObjects = true;\n\t\n\t\t// user-defined clipping\n\t\n\t\tthis.clippingPlanes = [];\n\t\tthis.localClippingEnabled = false;\n\t\n\t\t// physically based shading\n\t\n\t\tthis.gammaFactor = 2.0;\t// for backwards compatibility\n\t\tthis.gammaInput = false;\n\t\tthis.gammaOutput = false;\n\t\n\t\t// physical lights\n\t\n\t\tthis.physicallyCorrectLights = false;\n\t\n\t\t// tone mapping\n\t\n\t\tthis.toneMapping = THREE.LinearToneMapping;\n\t\tthis.toneMappingExposure = 1.0;\n\t\tthis.toneMappingWhitePoint = 1.0;\n\t\n\t\t// morphs\n\t\n\t\tthis.maxMorphTargets = 8;\n\t\tthis.maxMorphNormals = 4;\n\t\n\t\t// internal properties\n\t\n\t\tvar _this = this,\n\t\n\t\t// internal state cache\n\t\n\t\t_currentProgram = null,\n\t\t_currentRenderTarget = null,\n\t\t_currentFramebuffer = null,\n\t\t_currentMaterialId = - 1,\n\t\t_currentGeometryProgram = '',\n\t\t_currentCamera = null,\n\t\n\t\t_currentScissor = new THREE.Vector4(),\n\t\t_currentScissorTest = null,\n\t\n\t\t_currentViewport = new THREE.Vector4(),\n\t\n\t\t//\n\t\n\t\t_usedTextureUnits = 0,\n\t\n\t\t//\n\t\n\t\t_clearColor = new THREE.Color( 0x000000 ),\n\t\t_clearAlpha = 0,\n\t\n\t\t_width = _canvas.width,\n\t\t_height = _canvas.height,\n\t\n\t\t_pixelRatio = 1,\n\t\n\t\t_scissor = new THREE.Vector4( 0, 0, _width, _height ),\n\t\t_scissorTest = false,\n\t\n\t\t_viewport = new THREE.Vector4( 0, 0, _width, _height ),\n\t\n\t\t// frustum\n\t\n\t\t_frustum = new THREE.Frustum(),\n\t\n\t\t// clipping\n\t\n\t\t_clipping = new THREE.WebGLClipping(),\n\t\t_clippingEnabled = false,\n\t\t_localClippingEnabled = false,\n\t\n\t\t_sphere = new THREE.Sphere(),\n\t\n\t\t// camera matrices cache\n\t\n\t\t_projScreenMatrix = new THREE.Matrix4(),\n\t\n\t\t_vector3 = new THREE.Vector3(),\n\t\n\t\t// light arrays cache\n\t\n\t\t_lights = {\n\t\n\t\t\thash: '',\n\t\n\t\t\tambient: [ 0, 0, 0 ],\n\t\t\tdirectional: [],\n\t\t\tdirectionalShadowMap: [],\n\t\t\tdirectionalShadowMatrix: [],\n\t\t\tspot: [],\n\t\t\tspotShadowMap: [],\n\t\t\tspotShadowMatrix: [],\n\t\t\tpoint: [],\n\t\t\tpointShadowMap: [],\n\t\t\tpointShadowMatrix: [],\n\t\t\themi: [],\n\t\n\t\t\tshadows: []\n\t\n\t\t},\n\t\n\t\t// info\n\t\n\t\t_infoRender = {\n\t\n\t\t\tcalls: 0,\n\t\t\tvertices: 0,\n\t\t\tfaces: 0,\n\t\t\tpoints: 0\n\t\n\t\t};\n\t\n\t\tthis.info = {\n\t\n\t\t\trender: _infoRender,\n\t\t\tmemory: {\n\t\n\t\t\t\tgeometries: 0,\n\t\t\t\ttextures: 0\n\t\n\t\t\t},\n\t\t\tprograms: null\n\t\n\t\t};\n\t\n\t\n\t\t// initialize\n\t\n\t\tvar _gl;\n\t\n\t\ttry {\n\t\n\t\t\tvar attributes = {\n\t\t\t\talpha: _alpha,\n\t\t\t\tdepth: _depth,\n\t\t\t\tstencil: _stencil,\n\t\t\t\tantialias: _antialias,\n\t\t\t\tpremultipliedAlpha: _premultipliedAlpha,\n\t\t\t\tpreserveDrawingBuffer: _preserveDrawingBuffer\n\t\t\t};\n\t\n\t\t\t_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );\n\t\n\t\t\tif ( _gl === null ) {\n\t\n\t\t\t\tif ( _canvas.getContext( 'webgl' ) !== null ) {\n\t\n\t\t\t\t\tthrow 'Error creating WebGL context with your selected attributes.';\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthrow 'Error creating WebGL context.';\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// Some experimental-webgl implementations do not have getShaderPrecisionFormat\n\t\n\t\t\tif ( _gl.getShaderPrecisionFormat === undefined ) {\n\t\n\t\t\t\t_gl.getShaderPrecisionFormat = function () {\n\t\n\t\t\t\t\treturn { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };\n\t\n\t\t\t\t};\n\t\n\t\t\t}\n\t\n\t\t\t_canvas.addEventListener( 'webglcontextlost', onContextLost, false );\n\t\n\t\t} catch ( error ) {\n\t\n\t\t\tconsole.error( 'THREE.WebGLRenderer: ' + error );\n\t\n\t\t}\n\t\n\t\tvar extensions = new THREE.WebGLExtensions( _gl );\n\t\n\t\textensions.get( 'WEBGL_depth_texture' );\n\t\textensions.get( 'OES_texture_float' );\n\t\textensions.get( 'OES_texture_float_linear' );\n\t\textensions.get( 'OES_texture_half_float' );\n\t\textensions.get( 'OES_texture_half_float_linear' );\n\t\textensions.get( 'OES_standard_derivatives' );\n\t\textensions.get( 'ANGLE_instanced_arrays' );\n\t\n\t\tif ( extensions.get( 'OES_element_index_uint' ) ) {\n\t\n\t\t\tTHREE.BufferGeometry.MaxIndex = 4294967296;\n\t\n\t\t}\n\t\n\t\tvar capabilities = new THREE.WebGLCapabilities( _gl, extensions, parameters );\n\t\n\t\tvar state = new THREE.WebGLState( _gl, extensions, paramThreeToGL );\n\t\tvar properties = new THREE.WebGLProperties();\n\t\tvar textures = new THREE.WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, this.info );\n\t\tvar objects = new THREE.WebGLObjects( _gl, properties, this.info );\n\t\tvar programCache = new THREE.WebGLPrograms( this, capabilities );\n\t\tvar lightCache = new THREE.WebGLLights();\n\t\n\t\tthis.info.programs = programCache.programs;\n\t\n\t\tvar bufferRenderer = new THREE.WebGLBufferRenderer( _gl, extensions, _infoRender );\n\t\tvar indexedBufferRenderer = new THREE.WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );\n\t\n\t\t//\n\t\n\t\tvar backgroundCamera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\t\tvar backgroundCamera2 = new THREE.PerspectiveCamera();\n\t\tvar backgroundPlaneMesh = new THREE.Mesh(\n\t\t\tnew THREE.PlaneBufferGeometry( 2, 2 ),\n\t\t\tnew THREE.MeshBasicMaterial( { depthTest: false, depthWrite: false } )\n\t\t);\n\t\tvar backgroundBoxShader = THREE.ShaderLib[ 'cube' ];\n\t\tvar backgroundBoxMesh = new THREE.Mesh(\n\t\t\tnew THREE.BoxBufferGeometry( 5, 5, 5 ),\n\t\t\tnew THREE.ShaderMaterial( {\n\t\t\t\tuniforms: backgroundBoxShader.uniforms,\n\t\t\t\tvertexShader: backgroundBoxShader.vertexShader,\n\t\t\t\tfragmentShader: backgroundBoxShader.fragmentShader,\n\t\t\t\tdepthTest: false,\n\t\t\t\tdepthWrite: false,\n\t\t\t\tside: THREE.BackSide\n\t\t\t} )\n\t\t);\n\t\tobjects.update( backgroundPlaneMesh );\n\t\tobjects.update( backgroundBoxMesh );\n\t\n\t\t//\n\t\n\t\tfunction getTargetPixelRatio() {\n\t\n\t\t\treturn _currentRenderTarget === null ? _pixelRatio : 1;\n\t\n\t\t}\n\t\n\t\tfunction glClearColor( r, g, b, a ) {\n\t\n\t\t\tif ( _premultipliedAlpha === true ) {\n\t\n\t\t\t\tr *= a; g *= a; b *= a;\n\t\n\t\t\t}\n\t\n\t\t\tstate.clearColor( r, g, b, a );\n\t\n\t\t}\n\t\n\t\tfunction setDefaultGLState() {\n\t\n\t\t\tstate.init();\n\t\n\t\t\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );\n\t\t\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );\n\t\n\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\t\n\t\t}\n\t\n\t\tfunction resetGLState() {\n\t\n\t\t\t_currentProgram = null;\n\t\t\t_currentCamera = null;\n\t\n\t\t\t_currentGeometryProgram = '';\n\t\t\t_currentMaterialId = - 1;\n\t\n\t\t\tstate.reset();\n\t\n\t\t}\n\t\n\t\tsetDefaultGLState();\n\t\n\t\tthis.context = _gl;\n\t\tthis.capabilities = capabilities;\n\t\tthis.extensions = extensions;\n\t\tthis.properties = properties;\n\t\tthis.state = state;\n\t\n\t\t// shadow map\n\t\n\t\tvar shadowMap = new THREE.WebGLShadowMap( this, _lights, objects );\n\t\n\t\tthis.shadowMap = shadowMap;\n\t\n\t\n\t\t// Plugins\n\t\n\t\tvar spritePlugin = new THREE.SpritePlugin( this, sprites );\n\t\tvar lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );\n\t\n\t\t// API\n\t\n\t\tthis.getContext = function () {\n\t\n\t\t\treturn _gl;\n\t\n\t\t};\n\t\n\t\tthis.getContextAttributes = function () {\n\t\n\t\t\treturn _gl.getContextAttributes();\n\t\n\t\t};\n\t\n\t\tthis.forceContextLoss = function () {\n\t\n\t\t\textensions.get( 'WEBGL_lose_context' ).loseContext();\n\t\n\t\t};\n\t\n\t\tthis.getMaxAnisotropy = function () {\n\t\n\t\t\treturn capabilities.getMaxAnisotropy();\n\t\n\t\t};\n\t\n\t\tthis.getPrecision = function () {\n\t\n\t\t\treturn capabilities.precision;\n\t\n\t\t};\n\t\n\t\tthis.getPixelRatio = function () {\n\t\n\t\t\treturn _pixelRatio;\n\t\n\t\t};\n\t\n\t\tthis.setPixelRatio = function ( value ) {\n\t\n\t\t\tif ( value === undefined ) return;\n\t\n\t\t\t_pixelRatio = value;\n\t\n\t\t\tthis.setSize( _viewport.z, _viewport.w, false );\n\t\n\t\t};\n\t\n\t\tthis.getSize = function () {\n\t\n\t\t\treturn {\n\t\t\t\twidth: _width,\n\t\t\t\theight: _height\n\t\t\t};\n\t\n\t\t};\n\t\n\t\tthis.setSize = function ( width, height, updateStyle ) {\n\t\n\t\t\t_width = width;\n\t\t\t_height = height;\n\t\n\t\t\t_canvas.width = width * _pixelRatio;\n\t\t\t_canvas.height = height * _pixelRatio;\n\t\n\t\t\tif ( updateStyle !== false ) {\n\t\n\t\t\t\t_canvas.style.width = width + 'px';\n\t\t\t\t_canvas.style.height = height + 'px';\n\t\n\t\t\t}\n\t\n\t\t\tthis.setViewport( 0, 0, width, height );\n\t\n\t\t};\n\t\n\t\tthis.setViewport = function ( x, y, width, height ) {\n\t\n\t\t\tstate.viewport( _viewport.set( x, y, width, height ) );\n\t\n\t\t};\n\t\n\t\tthis.setScissor = function ( x, y, width, height ) {\n\t\n\t\t\tstate.scissor( _scissor.set( x, y, width, height ) );\n\t\n\t\t};\n\t\n\t\tthis.setScissorTest = function ( boolean ) {\n\t\n\t\t\tstate.setScissorTest( _scissorTest = boolean );\n\t\n\t\t};\n\t\n\t\t// Clearing\n\t\n\t\tthis.getClearColor = function () {\n\t\n\t\t\treturn _clearColor;\n\t\n\t\t};\n\t\n\t\tthis.setClearColor = function ( color, alpha ) {\n\t\n\t\t\t_clearColor.set( color );\n\t\n\t\t\t_clearAlpha = alpha !== undefined ? alpha : 1;\n\t\n\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\t\n\t\t};\n\t\n\t\tthis.getClearAlpha = function () {\n\t\n\t\t\treturn _clearAlpha;\n\t\n\t\t};\n\t\n\t\tthis.setClearAlpha = function ( alpha ) {\n\t\n\t\t\t_clearAlpha = alpha;\n\t\n\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\t\n\t\t};\n\t\n\t\tthis.clear = function ( color, depth, stencil ) {\n\t\n\t\t\tvar bits = 0;\n\t\n\t\t\tif ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;\n\t\t\tif ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;\n\t\t\tif ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\n\t\n\t\t\t_gl.clear( bits );\n\t\n\t\t};\n\t\n\t\tthis.clearColor = function () {\n\t\n\t\t\tthis.clear( true, false, false );\n\t\n\t\t};\n\t\n\t\tthis.clearDepth = function () {\n\t\n\t\t\tthis.clear( false, true, false );\n\t\n\t\t};\n\t\n\t\tthis.clearStencil = function () {\n\t\n\t\t\tthis.clear( false, false, true );\n\t\n\t\t};\n\t\n\t\tthis.clearTarget = function ( renderTarget, color, depth, stencil ) {\n\t\n\t\t\tthis.setRenderTarget( renderTarget );\n\t\t\tthis.clear( color, depth, stencil );\n\t\n\t\t};\n\t\n\t\t// Reset\n\t\n\t\tthis.resetGLState = resetGLState;\n\t\n\t\tthis.dispose = function() {\n\t\n\t\t\ttransparentObjects = [];\n\t\t\ttransparentObjectsLastIndex = -1;\n\t\t\topaqueObjects = [];\n\t\t\topaqueObjectsLastIndex = -1;\n\t\n\t\t\t_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );\n\t\n\t\t};\n\t\n\t\t// Events\n\t\n\t\tfunction onContextLost( event ) {\n\t\n\t\t\tevent.preventDefault();\n\t\n\t\t\tresetGLState();\n\t\t\tsetDefaultGLState();\n\t\n\t\t\tproperties.clear();\n\t\n\t\t}\n\t\n\t\tfunction onMaterialDispose( event ) {\n\t\n\t\t\tvar material = event.target;\n\t\n\t\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\n\t\n\t\t\tdeallocateMaterial( material );\n\t\n\t\t}\n\t\n\t\t// Buffer deallocation\n\t\n\t\tfunction deallocateMaterial( material ) {\n\t\n\t\t\treleaseMaterialProgramReference( material );\n\t\n\t\t\tproperties.delete( material );\n\t\n\t\t}\n\t\n\t\n\t\tfunction releaseMaterialProgramReference( material ) {\n\t\n\t\t\tvar programInfo = properties.get( material ).program;\n\t\n\t\t\tmaterial.program = undefined;\n\t\n\t\t\tif ( programInfo !== undefined ) {\n\t\n\t\t\t\tprogramCache.releaseProgram( programInfo );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// Buffer rendering\n\t\n\t\tthis.renderBufferImmediate = function ( object, program, material ) {\n\t\n\t\t\tstate.initAttributes();\n\t\n\t\t\tvar buffers = properties.get( object );\n\t\n\t\t\tif ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();\n\t\t\tif ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();\n\t\t\tif ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();\n\t\t\tif ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();\n\t\n\t\t\tvar attributes = program.getAttributes();\n\t\n\t\t\tif ( object.hasPositions ) {\n\t\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );\n\t\n\t\t\t\tstate.enableAttribute( attributes.position );\n\t\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\n\t\n\t\t\t}\n\t\n\t\t\tif ( object.hasNormals ) {\n\t\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );\n\t\n\t\t\t\tif ( material.type !== 'MeshPhongMaterial' && material.type !== 'MeshStandardMaterial' && material.type !== 'MeshPhysicalMaterial' && material.shading === THREE.FlatShading ) {\n\t\n\t\t\t\t\tfor ( var i = 0, l = object.count * 3; i < l; i += 9 ) {\n\t\n\t\t\t\t\t\tvar array = object.normalArray;\n\t\n\t\t\t\t\t\tvar nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;\n\t\t\t\t\t\tvar ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;\n\t\t\t\t\t\tvar nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;\n\t\n\t\t\t\t\t\tarray[ i + 0 ] = nx;\n\t\t\t\t\t\tarray[ i + 1 ] = ny;\n\t\t\t\t\t\tarray[ i + 2 ] = nz;\n\t\n\t\t\t\t\t\tarray[ i + 3 ] = nx;\n\t\t\t\t\t\tarray[ i + 4 ] = ny;\n\t\t\t\t\t\tarray[ i + 5 ] = nz;\n\t\n\t\t\t\t\t\tarray[ i + 6 ] = nx;\n\t\t\t\t\t\tarray[ i + 7 ] = ny;\n\t\t\t\t\t\tarray[ i + 8 ] = nz;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );\n\t\n\t\t\t\tstate.enableAttribute( attributes.normal );\n\t\n\t\t\t\t_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\n\t\n\t\t\t}\n\t\n\t\t\tif ( object.hasUvs && material.map ) {\n\t\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );\n\t\n\t\t\t\tstate.enableAttribute( attributes.uv );\n\t\n\t\t\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\n\t\n\t\t\t}\n\t\n\t\t\tif ( object.hasColors && material.vertexColors !== THREE.NoColors ) {\n\t\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );\n\t\n\t\t\t\tstate.enableAttribute( attributes.color );\n\t\n\t\t\t\t_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );\n\t\n\t\t\t}\n\t\n\t\t\tstate.disableUnusedAttributes();\n\t\n\t\t\t_gl.drawArrays( _gl.TRIANGLES, 0, object.count );\n\t\n\t\t\tobject.count = 0;\n\t\n\t\t};\n\t\n\t\tthis.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {\n\t\n\t\t\tsetMaterial( material );\n\t\n\t\t\tvar program = setProgram( camera, fog, material, object );\n\t\n\t\t\tvar updateBuffers = false;\n\t\t\tvar geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;\n\t\n\t\t\tif ( geometryProgram !== _currentGeometryProgram ) {\n\t\n\t\t\t\t_currentGeometryProgram = geometryProgram;\n\t\t\t\tupdateBuffers = true;\n\t\n\t\t\t}\n\t\n\t\t\t// morph targets\n\t\n\t\t\tvar morphTargetInfluences = object.morphTargetInfluences;\n\t\n\t\t\tif ( morphTargetInfluences !== undefined ) {\n\t\n\t\t\t\tvar activeInfluences = [];\n\t\n\t\t\t\tfor ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar influence = morphTargetInfluences[ i ];\n\t\t\t\t\tactiveInfluences.push( [ influence, i ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tactiveInfluences.sort( absNumericalSort );\n\t\n\t\t\t\tif ( activeInfluences.length > 8 ) {\n\t\n\t\t\t\t\tactiveInfluences.length = 8;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar morphAttributes = geometry.morphAttributes;\n\t\n\t\t\t\tfor ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar influence = activeInfluences[ i ];\n\t\t\t\t\tmorphInfluences[ i ] = influence[ 0 ];\n\t\n\t\t\t\t\tif ( influence[ 0 ] !== 0 ) {\n\t\n\t\t\t\t\t\tvar index = influence[ 1 ];\n\t\n\t\t\t\t\t\tif ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );\n\t\t\t\t\t\tif ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tif ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );\n\t\t\t\t\t\tif ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tprogram.getUniforms().setValue(\n\t\t\t\t\t\t_gl, 'morphTargetInfluences', morphInfluences );\n\t\n\t\t\t\tupdateBuffers = true;\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tvar index = geometry.index;\n\t\t\tvar position = geometry.attributes.position;\n\t\n\t\t\tif ( material.wireframe === true ) {\n\t\n\t\t\t\tindex = objects.getWireframeAttribute( geometry );\n\t\n\t\t\t}\n\t\n\t\t\tvar renderer;\n\t\n\t\t\tif ( index !== null ) {\n\t\n\t\t\t\trenderer = indexedBufferRenderer;\n\t\t\t\trenderer.setIndex( index );\n\t\n\t\t\t} else {\n\t\n\t\t\t\trenderer = bufferRenderer;\n\t\n\t\t\t}\n\t\n\t\t\tif ( updateBuffers ) {\n\t\n\t\t\t\tsetupVertexAttributes( material, program, geometry );\n\t\n\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tvar dataStart = 0;\n\t\t\tvar dataCount = Infinity;\n\t\n\t\t\tif ( index !== null ) {\n\t\n\t\t\t\tdataCount = index.count;\n\t\n\t\t\t} else if ( position !== undefined ) {\n\t\n\t\t\t\tdataCount = position.count;\n\t\n\t\t\t}\n\t\n\t\t\tvar rangeStart = geometry.drawRange.start;\n\t\t\tvar rangeCount = geometry.drawRange.count;\n\t\n\t\t\tvar groupStart = group !== null ? group.start : 0;\n\t\t\tvar groupCount = group !== null ? group.count : Infinity;\n\t\n\t\t\tvar drawStart = Math.max( dataStart, rangeStart, groupStart );\n\t\t\tvar drawEnd = Math.min( dataStart + dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;\n\t\n\t\t\tvar drawCount = Math.max( 0, drawEnd - drawStart + 1 );\n\t\n\t\t\t//\n\t\n\t\t\tif ( object instanceof THREE.Mesh ) {\n\t\n\t\t\t\tif ( material.wireframe === true ) {\n\t\n\t\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );\n\t\t\t\t\trenderer.setMode( _gl.LINES );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tswitch ( object.drawMode ) {\n\t\n\t\t\t\t\t\tcase THREE.TrianglesDrawMode:\n\t\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLES );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase THREE.TriangleStripDrawMode:\n\t\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_STRIP );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase THREE.TriangleFanDrawMode:\n\t\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_FAN );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\n\t\t\t} else if ( object instanceof THREE.Line ) {\n\t\n\t\t\t\tvar lineWidth = material.linewidth;\n\t\n\t\t\t\tif ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material\n\t\n\t\t\t\tstate.setLineWidth( lineWidth * getTargetPixelRatio() );\n\t\n\t\t\t\tif ( object instanceof THREE.LineSegments ) {\n\t\n\t\t\t\t\trenderer.setMode( _gl.LINES );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\trenderer.setMode( _gl.LINE_STRIP );\n\t\n\t\t\t\t}\n\t\n\t\t\t} else if ( object instanceof THREE.Points ) {\n\t\n\t\t\t\trenderer.setMode( _gl.POINTS );\n\t\n\t\t\t}\n\t\n\t\t\tif ( geometry instanceof THREE.InstancedBufferGeometry ) {\n\t\n\t\t\t\tif ( geometry.maxInstancedCount > 0 ) {\n\t\n\t\t\t\t\trenderer.renderInstances( geometry, drawStart, drawCount );\n\t\n\t\t\t\t}\n\t\n\t\t\t} else {\n\t\n\t\t\t\trenderer.render( drawStart, drawCount );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tfunction setupVertexAttributes( material, program, geometry, startIndex ) {\n\t\n\t\t\tvar extension;\n\t\n\t\t\tif ( geometry instanceof THREE.InstancedBufferGeometry ) {\n\t\n\t\t\t\textension = extensions.get( 'ANGLE_instanced_arrays' );\n\t\n\t\t\t\tif ( extension === null ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif ( startIndex === undefined ) startIndex = 0;\n\t\n\t\t\tstate.initAttributes();\n\t\n\t\t\tvar geometryAttributes = geometry.attributes;\n\t\n\t\t\tvar programAttributes = program.getAttributes();\n\t\n\t\t\tvar materialDefaultAttributeValues = material.defaultAttributeValues;\n\t\n\t\t\tfor ( var name in programAttributes ) {\n\t\n\t\t\t\tvar programAttribute = programAttributes[ name ];\n\t\n\t\t\t\tif ( programAttribute >= 0 ) {\n\t\n\t\t\t\t\tvar geometryAttribute = geometryAttributes[ name ];\n\t\n\t\t\t\t\tif ( geometryAttribute !== undefined ) {\n\t\n\t\t\t\t\t\tvar type = _gl.FLOAT;\n\t\t\t\t\t\tvar array = geometryAttribute.array;\n\t\t\t\t\t\tvar normalized = geometryAttribute.normalized;\n\t\n\t\t\t\t\t\tif ( array instanceof Float32Array ) {\n\t\n\t\t\t\t\t\t\ttype = _gl.FLOAT;\n\t\n\t\t\t\t\t\t} else if ( array instanceof Float64Array ) {\n\t\n\t\t\t\t\t\t\tconsole.warn(\"Unsupported data buffer format: Float64Array\");\n\t\n\t\t\t\t\t\t} else if ( array instanceof Uint16Array ) {\n\t\n\t\t\t\t\t\t\ttype = _gl.UNSIGNED_SHORT;\n\t\n\t\t\t\t\t\t} else if ( array instanceof Int16Array ) {\n\t\n\t\t\t\t\t\t\ttype = _gl.SHORT;\n\t\n\t\t\t\t\t\t} else if ( array instanceof Uint32Array ) {\n\t\n\t\t\t\t\t\t\ttype = _gl.UNSIGNED_INT;\n\t\n\t\t\t\t\t\t} else if ( array instanceof Int32Array ) {\n\t\n\t\t\t\t\t\t\ttype = _gl.INT;\n\t\n\t\t\t\t\t\t} else if ( array instanceof Int8Array ) {\n\t\n\t\t\t\t\t\t\ttype = _gl.BYTE;\n\t\n\t\t\t\t\t\t} else if ( array instanceof Uint8Array ) {\n\t\n\t\t\t\t\t\t\ttype = _gl.UNSIGNED_BYTE;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tvar size = geometryAttribute.itemSize;\n\t\t\t\t\t\tvar buffer = objects.getAttributeBuffer( geometryAttribute );\n\t\n\t\t\t\t\t\tif ( geometryAttribute instanceof THREE.InterleavedBufferAttribute ) {\n\t\n\t\t\t\t\t\t\tvar data = geometryAttribute.data;\n\t\t\t\t\t\t\tvar stride = data.stride;\n\t\t\t\t\t\t\tvar offset = geometryAttribute.offset;\n\t\n\t\t\t\t\t\t\tif ( data instanceof THREE.InstancedInterleavedBuffer ) {\n\t\n\t\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );\n\t\n\t\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\n\t\n\t\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = data.meshPerAttribute * data.count;\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tif ( geometryAttribute instanceof THREE.InstancedBufferAttribute ) {\n\t\n\t\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );\n\t\n\t\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\n\t\n\t\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * geometryAttribute.array.BYTES_PER_ELEMENT );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( materialDefaultAttributeValues !== undefined ) {\n\t\n\t\t\t\t\t\tvar value = materialDefaultAttributeValues[ name ];\n\t\n\t\t\t\t\t\tif ( value !== undefined ) {\n\t\n\t\t\t\t\t\t\tswitch ( value.length ) {\n\t\n\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib2fv( programAttribute, value );\n\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib3fv( programAttribute, value );\n\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib4fv( programAttribute, value );\n\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib1fv( programAttribute, value );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tstate.disableUnusedAttributes();\n\t\n\t\t}\n\t\n\t\t// Sorting\n\t\n\t\tfunction absNumericalSort( a, b ) {\n\t\n\t\t\treturn Math.abs( b[ 0 ] ) - Math.abs( a[ 0 ] );\n\t\n\t\t}\n\t\n\t\tfunction painterSortStable ( a, b ) {\n\t\n\t\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\n\t\n\t\t\t\treturn a.object.renderOrder - b.object.renderOrder;\n\t\n\t\t\t} else if ( a.material.id !== b.material.id ) {\n\t\n\t\t\t\treturn a.material.id - b.material.id;\n\t\n\t\t\t} else if ( a.z !== b.z ) {\n\t\n\t\t\t\treturn a.z - b.z;\n\t\n\t\t\t} else {\n\t\n\t\t\t\treturn a.id - b.id;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction reversePainterSortStable ( a, b ) {\n\t\n\t\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\n\t\n\t\t\t\treturn a.object.renderOrder - b.object.renderOrder;\n\t\n\t\t\t} if ( a.z !== b.z ) {\n\t\n\t\t\t\treturn b.z - a.z;\n\t\n\t\t\t} else {\n\t\n\t\t\t\treturn a.id - b.id;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// Rendering\n\t\n\t\tthis.render = function ( scene, camera, renderTarget, forceClear ) {\n\t\n\t\t\tif ( camera instanceof THREE.Camera === false ) {\n\t\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\n\t\t\t\treturn;\n\t\n\t\t\t}\n\t\n\t\t\tvar fog = scene.fog;\n\t\n\t\t\t// reset caching for this frame\n\t\n\t\t\t_currentGeometryProgram = '';\n\t\t\t_currentMaterialId = - 1;\n\t\t\t_currentCamera = null;\n\t\n\t\t\t// update scene graph\n\t\n\t\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\n\t\n\t\t\t// update camera matrices and frustum\n\t\n\t\t\tif ( camera.parent === null ) camera.updateMatrixWorld();\n\t\n\t\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\n\t\n\t\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\t\n\t\t\tlights.length = 0;\n\t\n\t\t\topaqueObjectsLastIndex = - 1;\n\t\t\ttransparentObjectsLastIndex = - 1;\n\t\n\t\t\tsprites.length = 0;\n\t\t\tlensFlares.length = 0;\n\t\n\t\t\t_localClippingEnabled = this.localClippingEnabled;\n\t\t\t_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );\n\t\n\t\t\tprojectObject( scene, camera );\n\t\n\t\t\topaqueObjects.length = opaqueObjectsLastIndex + 1;\n\t\t\ttransparentObjects.length = transparentObjectsLastIndex + 1;\n\t\n\t\t\tif ( _this.sortObjects === true ) {\n\t\n\t\t\t\topaqueObjects.sort( painterSortStable );\n\t\t\t\ttransparentObjects.sort( reversePainterSortStable );\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tif ( _clippingEnabled ) _clipping.beginShadows();\n\t\n\t\t\tsetupShadows( lights );\n\t\n\t\t\tshadowMap.render( scene, camera );\n\t\n\t\t\tsetupLights( lights, camera );\n\t\n\t\t\tif ( _clippingEnabled ) _clipping.endShadows();\n\t\n\t\t\t//\n\t\n\t\t\t_infoRender.calls = 0;\n\t\t\t_infoRender.vertices = 0;\n\t\t\t_infoRender.faces = 0;\n\t\t\t_infoRender.points = 0;\n\t\n\t\t\tif ( renderTarget === undefined ) {\n\t\n\t\t\t\trenderTarget = null;\n\t\n\t\t\t}\n\t\n\t\t\tthis.setRenderTarget( renderTarget );\n\t\n\t\t\t//\n\t\n\t\t\tvar background = scene.background;\n\t\n\t\t\tif ( background === null ) {\n\t\n\t\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\t\n\t\t\t} else if ( background instanceof THREE.Color ) {\n\t\n\t\t\t\tglClearColor( background.r, background.g, background.b, 1 );\n\t\n\t\t\t}\n\t\n\t\t\tif ( this.autoClear || forceClear ) {\n\t\n\t\t\t\tthis.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );\n\t\n\t\t\t}\n\t\n\t\t\tif ( background instanceof THREE.CubeTexture ) {\n\t\n\t\t\t\tbackgroundCamera2.projectionMatrix.copy( camera.projectionMatrix );\n\t\n\t\t\t\tbackgroundCamera2.matrixWorld.extractRotation( camera.matrixWorld );\n\t\t\t\tbackgroundCamera2.matrixWorldInverse.getInverse( backgroundCamera2.matrixWorld );\n\t\n\t\t\t\tbackgroundBoxMesh.material.uniforms[ \"tCube\" ].value = background;\n\t\t\t\tbackgroundBoxMesh.modelViewMatrix.multiplyMatrices( backgroundCamera2.matrixWorldInverse, backgroundBoxMesh.matrixWorld );\n\t\n\t\t\t\t_this.renderBufferDirect( backgroundCamera2, null, backgroundBoxMesh.geometry, backgroundBoxMesh.material, backgroundBoxMesh, null );\n\t\n\t\t\t} else if ( background instanceof THREE.Texture ) {\n\t\n\t\t\t\tbackgroundPlaneMesh.material.map = background;\n\t\n\t\t\t\t_this.renderBufferDirect( backgroundCamera, null, backgroundPlaneMesh.geometry, backgroundPlaneMesh.material, backgroundPlaneMesh, null );\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tif ( scene.overrideMaterial ) {\n\t\n\t\t\t\tvar overrideMaterial = scene.overrideMaterial;\n\t\n\t\t\t\trenderObjects( opaqueObjects, camera, fog, overrideMaterial );\n\t\t\t\trenderObjects( transparentObjects, camera, fog, overrideMaterial );\n\t\n\t\t\t} else {\n\t\n\t\t\t\t// opaque pass (front-to-back order)\n\t\n\t\t\t\tstate.setBlending( THREE.NoBlending );\n\t\t\t\trenderObjects( opaqueObjects, camera, fog );\n\t\n\t\t\t\t// transparent pass (back-to-front order)\n\t\n\t\t\t\trenderObjects( transparentObjects, camera, fog );\n\t\n\t\t\t}\n\t\n\t\t\t// custom render plugins (post pass)\n\t\n\t\t\tspritePlugin.render( scene, camera );\n\t\t\tlensFlarePlugin.render( scene, camera, _currentViewport );\n\t\n\t\t\t// Generate mipmap if we're using any kind of mipmap filtering\n\t\n\t\t\tif ( renderTarget ) {\n\t\n\t\t\t\ttextures.updateRenderTargetMipmap( renderTarget );\n\t\n\t\t\t}\n\t\n\t\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\n\t\n\t\t\tstate.setDepthTest( true );\n\t\t\tstate.setDepthWrite( true );\n\t\t\tstate.setColorWrite( true );\n\t\n\t\t\t// _gl.finish();\n\t\n\t\t};\n\t\n\t\tfunction pushRenderItem( object, geometry, material, z, group ) {\n\t\n\t\t\tvar array, index;\n\t\n\t\t\t// allocate the next position in the appropriate array\n\t\n\t\t\tif ( material.transparent ) {\n\t\n\t\t\t\tarray = transparentObjects;\n\t\t\t\tindex = ++ transparentObjectsLastIndex;\n\t\n\t\t\t} else {\n\t\n\t\t\t\tarray = opaqueObjects;\n\t\t\t\tindex = ++ opaqueObjectsLastIndex;\n\t\n\t\t\t}\n\t\n\t\t\t// recycle existing render item or grow the array\n\t\n\t\t\tvar renderItem = array[ index ];\n\t\n\t\t\tif ( renderItem !== undefined ) {\n\t\n\t\t\t\trenderItem.id = object.id;\n\t\t\t\trenderItem.object = object;\n\t\t\t\trenderItem.geometry = geometry;\n\t\t\t\trenderItem.material = material;\n\t\t\t\trenderItem.z = _vector3.z;\n\t\t\t\trenderItem.group = group;\n\t\n\t\t\t} else {\n\t\n\t\t\t\trenderItem = {\n\t\t\t\t\tid: object.id,\n\t\t\t\t\tobject: object,\n\t\t\t\t\tgeometry: geometry,\n\t\t\t\t\tmaterial: material,\n\t\t\t\t\tz: _vector3.z,\n\t\t\t\t\tgroup: group\n\t\t\t\t};\n\t\n\t\t\t\t// assert( index === array.length );\n\t\t\t\tarray.push( renderItem );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// TODO Duplicated code (Frustum)\n\t\n\t\tfunction isObjectViewable( object ) {\n\t\n\t\t\tvar geometry = object.geometry;\n\t\n\t\t\tif ( geometry.boundingSphere === null )\n\t\t\t\tgeometry.computeBoundingSphere();\n\t\n\t\t\t_sphere.copy( geometry.boundingSphere ).\n\t\t\t\tapplyMatrix4( object.matrixWorld );\n\t\n\t\t\treturn isSphereViewable( _sphere );\n\t\n\t\t}\n\t\n\t\tfunction isSpriteViewable( sprite ) {\n\t\n\t\t\t_sphere.center.set( 0, 0, 0 );\n\t\t\t_sphere.radius = 0.7071067811865476;\n\t\t\t_sphere.applyMatrix4( sprite.matrixWorld );\n\t\n\t\t\treturn isSphereViewable( _sphere );\n\t\n\t\t}\n\t\n\t\tfunction isSphereViewable( sphere ) {\n\t\n\t\t\tif ( ! _frustum.intersectsSphere( sphere ) ) return false;\n\t\n\t\t\tvar numPlanes = _clipping.numPlanes;\n\t\n\t\t\tif ( numPlanes === 0 ) return true;\n\t\n\t\t\tvar planes = _this.clippingPlanes,\n\t\n\t\t\t\tcenter = sphere.center,\n\t\t\t\tnegRad = - sphere.radius,\n\t\t\t\ti = 0;\n\t\n\t\t\tdo {\n\t\n\t\t\t\t// out when deeper than radius in the negative halfspace\n\t\t\t\tif ( planes[ i ].distanceToPoint( center ) < negRad ) return false;\n\t\n\t\t\t} while ( ++ i !== numPlanes );\n\t\n\t\t\treturn true;\n\t\n\t\t}\n\t\n\t\tfunction projectObject( object, camera ) {\n\t\n\t\t\tif ( object.visible === false ) return;\n\t\n\t\t\tif ( object.layers.test( camera.layers ) ) {\n\t\n\t\t\t\tif ( object instanceof THREE.Light ) {\n\t\n\t\t\t\t\tlights.push( object );\n\t\n\t\t\t\t} else if ( object instanceof THREE.Sprite ) {\n\t\n\t\t\t\t\tif ( object.frustumCulled === false || isSpriteViewable( object ) === true ) {\n\t\n\t\t\t\t\t\tsprites.push( object );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( object instanceof THREE.LensFlare ) {\n\t\n\t\t\t\t\tlensFlares.push( object );\n\t\n\t\t\t\t} else if ( object instanceof THREE.ImmediateRenderObject ) {\n\t\n\t\t\t\t\tif ( _this.sortObjects === true ) {\n\t\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\n\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tpushRenderItem( object, null, object.material, _vector3.z, null );\n\t\n\t\t\t\t} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {\n\t\n\t\t\t\t\tif ( object instanceof THREE.SkinnedMesh ) {\n\t\n\t\t\t\t\t\tobject.skeleton.update();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( object.frustumCulled === false || isObjectViewable( object ) === true ) {\n\t\n\t\t\t\t\t\tvar material = object.material;\n\t\n\t\t\t\t\t\tif ( material.visible === true ) {\n\t\n\t\t\t\t\t\t\tif ( _this.sortObjects === true ) {\n\t\n\t\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\n\t\t\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tvar geometry = objects.update( object );\n\t\n\t\t\t\t\t\t\tif ( material instanceof THREE.MultiMaterial ) {\n\t\n\t\t\t\t\t\t\t\tvar groups = geometry.groups;\n\t\t\t\t\t\t\t\tvar materials = material.materials;\n\t\n\t\t\t\t\t\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tvar group = groups[ i ];\n\t\t\t\t\t\t\t\t\tvar groupMaterial = materials[ group.materialIndex ];\n\t\n\t\t\t\t\t\t\t\t\tif ( groupMaterial.visible === true ) {\n\t\n\t\t\t\t\t\t\t\t\t\tpushRenderItem( object, geometry, groupMaterial, _vector3.z, group );\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tpushRenderItem( object, geometry, material, _vector3.z, null );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tvar children = object.children;\n\t\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\t\n\t\t\t\tprojectObject( children[ i ], camera );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction renderObjects( renderList, camera, fog, overrideMaterial ) {\n\t\n\t\t\tfor ( var i = 0, l = renderList.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar renderItem = renderList[ i ];\n\t\n\t\t\t\tvar object = renderItem.object;\n\t\t\t\tvar geometry = renderItem.geometry;\n\t\t\t\tvar material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;\n\t\t\t\tvar group = renderItem.group;\n\t\n\t\t\t\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\t\t\t\tobject.normalMatrix.getNormalMatrix( object.modelViewMatrix );\n\t\n\t\t\t\tif ( object instanceof THREE.ImmediateRenderObject ) {\n\t\n\t\t\t\t\tsetMaterial( material );\n\t\n\t\t\t\t\tvar program = setProgram( camera, fog, material, object );\n\t\n\t\t\t\t\t_currentGeometryProgram = '';\n\t\n\t\t\t\t\tobject.render( function ( object ) {\n\t\n\t\t\t\t\t\t_this.renderBufferImmediate( object, program, material );\n\t\n\t\t\t\t\t} );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t_this.renderBufferDirect( camera, fog, geometry, material, object, group );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction initMaterial( material, fog, object ) {\n\t\n\t\t\tvar materialProperties = properties.get( material );\n\t\n\t\t\tvar parameters = programCache.getParameters(\n\t\t\t\t\tmaterial, _lights, fog, _clipping.numPlanes, object );\n\t\n\t\t\tvar code = programCache.getProgramCode( material, parameters );\n\t\n\t\t\tvar program = materialProperties.program;\n\t\t\tvar programChange = true;\n\t\n\t\t\tif ( program === undefined ) {\n\t\n\t\t\t\t// new material\n\t\t\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\n\t\n\t\t\t} else if ( program.code !== code ) {\n\t\n\t\t\t\t// changed glsl or parameters\n\t\t\t\treleaseMaterialProgramReference( material );\n\t\n\t\t\t} else if ( parameters.shaderID !== undefined ) {\n\t\n\t\t\t\t// same glsl and uniform list\n\t\t\t\treturn;\n\t\n\t\t\t} else {\n\t\n\t\t\t\t// only rebuild uniform list\n\t\t\t\tprogramChange = false;\n\t\n\t\t\t}\n\t\n\t\t\tif ( programChange ) {\n\t\n\t\t\t\tif ( parameters.shaderID ) {\n\t\n\t\t\t\t\tvar shader = THREE.ShaderLib[ parameters.shaderID ];\n\t\n\t\t\t\t\tmaterialProperties.__webglShader = {\n\t\t\t\t\t\tname: material.type,\n\t\t\t\t\t\tuniforms: THREE.UniformsUtils.clone( shader.uniforms ),\n\t\t\t\t\t\tvertexShader: shader.vertexShader,\n\t\t\t\t\t\tfragmentShader: shader.fragmentShader\n\t\t\t\t\t};\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tmaterialProperties.__webglShader = {\n\t\t\t\t\t\tname: material.type,\n\t\t\t\t\t\tuniforms: material.uniforms,\n\t\t\t\t\t\tvertexShader: material.vertexShader,\n\t\t\t\t\t\tfragmentShader: material.fragmentShader\n\t\t\t\t\t};\n\t\n\t\t\t\t}\n\t\n\t\t\t\tmaterial.__webglShader = materialProperties.__webglShader;\n\t\n\t\t\t\tprogram = programCache.acquireProgram( material, parameters, code );\n\t\n\t\t\t\tmaterialProperties.program = program;\n\t\t\t\tmaterial.program = program;\n\t\n\t\t\t}\n\t\n\t\t\tvar attributes = program.getAttributes();\n\t\n\t\t\tif ( material.morphTargets ) {\n\t\n\t\t\t\tmaterial.numSupportedMorphTargets = 0;\n\t\n\t\t\t\tfor ( var i = 0; i < _this.maxMorphTargets; i ++ ) {\n\t\n\t\t\t\t\tif ( attributes[ 'morphTarget' + i ] >= 0 ) {\n\t\n\t\t\t\t\t\tmaterial.numSupportedMorphTargets ++;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif ( material.morphNormals ) {\n\t\n\t\t\t\tmaterial.numSupportedMorphNormals = 0;\n\t\n\t\t\t\tfor ( var i = 0; i < _this.maxMorphNormals; i ++ ) {\n\t\n\t\t\t\t\tif ( attributes[ 'morphNormal' + i ] >= 0 ) {\n\t\n\t\t\t\t\t\tmaterial.numSupportedMorphNormals ++;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tvar uniforms = materialProperties.__webglShader.uniforms;\n\t\n\t\t\tif ( ! ( material instanceof THREE.ShaderMaterial ) &&\n\t\t\t\t\t! ( material instanceof THREE.RawShaderMaterial ) ||\n\t\t\t\t\tmaterial.clipping === true ) {\n\t\n\t\t\t\tmaterialProperties.numClippingPlanes = _clipping.numPlanes;\n\t\t\t\tuniforms.clippingPlanes = _clipping.uniform;\n\t\n\t\t\t}\n\t\n\t\t\tif ( material.lights ) {\n\t\n\t\t\t\t// store the light setup it was created for\n\t\n\t\t\t\tmaterialProperties.lightsHash = _lights.hash;\n\t\n\t\t\t\t// wire up the material to this renderer's lighting state\n\t\n\t\t\t\tuniforms.ambientLightColor.value = _lights.ambient;\n\t\t\t\tuniforms.directionalLights.value = _lights.directional;\n\t\t\t\tuniforms.spotLights.value = _lights.spot;\n\t\t\t\tuniforms.pointLights.value = _lights.point;\n\t\t\t\tuniforms.hemisphereLights.value = _lights.hemi;\n\t\n\t\t\t\tuniforms.directionalShadowMap.value = _lights.directionalShadowMap;\n\t\t\t\tuniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;\n\t\t\t\tuniforms.spotShadowMap.value = _lights.spotShadowMap;\n\t\t\t\tuniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;\n\t\t\t\tuniforms.pointShadowMap.value = _lights.pointShadowMap;\n\t\t\t\tuniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;\n\t\n\t\t\t}\n\t\n\t\t\tvar progUniforms = materialProperties.program.getUniforms(),\n\t\t\t\tuniformsList =\n\t\t\t\t\t\tTHREE.WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );\n\t\n\t\t\tmaterialProperties.uniformsList = uniformsList;\n\t\t\tmaterialProperties.dynamicUniforms =\n\t\t\t\t\tTHREE.WebGLUniforms.splitDynamic( uniformsList, uniforms );\n\t\n\t\t}\n\t\n\t\tfunction setMaterial( material ) {\n\t\n\t\t\tif ( material.side !== THREE.DoubleSide )\n\t\t\t\tstate.enable( _gl.CULL_FACE );\n\t\t\telse\n\t\t\t\tstate.disable( _gl.CULL_FACE );\n\t\n\t\t\tstate.setFlipSided( material.side === THREE.BackSide );\n\t\n\t\t\tif ( material.transparent === true ) {\n\t\n\t\t\t\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tstate.setBlending( THREE.NoBlending );\n\t\n\t\t\t}\n\t\n\t\t\tstate.setDepthFunc( material.depthFunc );\n\t\t\tstate.setDepthTest( material.depthTest );\n\t\t\tstate.setDepthWrite( material.depthWrite );\n\t\t\tstate.setColorWrite( material.colorWrite );\n\t\t\tstate.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\t\n\t\t}\n\t\n\t\tfunction setProgram( camera, fog, material, object ) {\n\t\n\t\t\t_usedTextureUnits = 0;\n\t\n\t\t\tvar materialProperties = properties.get( material );\n\t\n\t\t\tif ( _clippingEnabled ) {\n\t\n\t\t\t\tif ( _localClippingEnabled || camera !== _currentCamera ) {\n\t\n\t\t\t\t\tvar useCache =\n\t\t\t\t\t\t\tcamera === _currentCamera &&\n\t\t\t\t\t\t\tmaterial.id === _currentMaterialId;\n\t\n\t\t\t\t\t// we might want to call this function with some ClippingGroup\n\t\t\t\t\t// object instead of the material, once it becomes feasible\n\t\t\t\t\t// (#8465, #8379)\n\t\t\t\t\t_clipping.setState(\n\t\t\t\t\t\t\tmaterial.clippingPlanes, material.clipShadows,\n\t\t\t\t\t\t\tcamera, materialProperties, useCache );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( materialProperties.numClippingPlanes !== undefined &&\n\t\t\t\t\tmaterialProperties.numClippingPlanes !== _clipping.numPlanes ) {\n\t\n\t\t\t\t\tmaterial.needsUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif ( materialProperties.program === undefined ) {\n\t\n\t\t\t\tmaterial.needsUpdate = true;\n\t\n\t\t\t}\n\t\n\t\t\tif ( materialProperties.lightsHash !== undefined &&\n\t\t\t\tmaterialProperties.lightsHash !== _lights.hash ) {\n\t\n\t\t\t\tmaterial.needsUpdate = true;\n\t\n\t\t\t}\n\t\n\t\t\tif ( material.needsUpdate ) {\n\t\n\t\t\t\tinitMaterial( material, fog, object );\n\t\t\t\tmaterial.needsUpdate = false;\n\t\n\t\t\t}\n\t\n\t\t\tvar refreshProgram = false;\n\t\t\tvar refreshMaterial = false;\n\t\t\tvar refreshLights = false;\n\t\n\t\t\tvar program = materialProperties.program,\n\t\t\t\tp_uniforms = program.getUniforms(),\n\t\t\t\tm_uniforms = materialProperties.__webglShader.uniforms;\n\t\n\t\t\tif ( program.id !== _currentProgram ) {\n\t\n\t\t\t\t_gl.useProgram( program.program );\n\t\t\t\t_currentProgram = program.id;\n\t\n\t\t\t\trefreshProgram = true;\n\t\t\t\trefreshMaterial = true;\n\t\t\t\trefreshLights = true;\n\t\n\t\t\t}\n\t\n\t\t\tif ( material.id !== _currentMaterialId ) {\n\t\n\t\t\t\t_currentMaterialId = material.id;\n\t\n\t\t\t\trefreshMaterial = true;\n\t\n\t\t\t}\n\t\n\t\t\tif ( refreshProgram || camera !== _currentCamera ) {\n\t\n\t\t\t\tp_uniforms.set( _gl, camera, 'projectionMatrix' );\n\t\n\t\t\t\tif ( capabilities.logarithmicDepthBuffer ) {\n\t\n\t\t\t\t\tp_uniforms.setValue( _gl, 'logDepthBufFC',\n\t\t\t\t\t\t\t2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\n\t\n\t\t\t\t}\n\t\n\t\n\t\t\t\tif ( camera !== _currentCamera ) {\n\t\n\t\t\t\t\t_currentCamera = camera;\n\t\n\t\t\t\t\t// lighting uniforms depend on the camera so enforce an update\n\t\t\t\t\t// now, in case this material supports lights - or later, when\n\t\t\t\t\t// the next material that does gets activated:\n\t\n\t\t\t\t\trefreshMaterial = true;\t\t// set to true on material change\n\t\t\t\t\trefreshLights = true;\t\t// remains set until update done\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// load material specific uniforms\n\t\t\t\t// (shader material also gets them for the sake of genericity)\n\t\n\t\t\t\tif ( material instanceof THREE.ShaderMaterial ||\n\t\t\t\t\t material instanceof THREE.MeshPhongMaterial ||\n\t\t\t\t\t material instanceof THREE.MeshStandardMaterial ||\n\t\t\t\t\t material.envMap ) {\n\t\n\t\t\t\t\tvar uCamPos = p_uniforms.map.cameraPosition;\n\t\n\t\t\t\t\tif ( uCamPos !== undefined ) {\n\t\n\t\t\t\t\t\tuCamPos.setValue( _gl,\n\t\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( camera.matrixWorld ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material instanceof THREE.MeshPhongMaterial ||\n\t\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\n\t\t\t\t\t material instanceof THREE.MeshBasicMaterial ||\n\t\t\t\t\t material instanceof THREE.MeshStandardMaterial ||\n\t\t\t\t\t material instanceof THREE.ShaderMaterial ||\n\t\t\t\t\t material.skinning ) {\n\t\n\t\t\t\t\tp_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tp_uniforms.set( _gl, _this, 'toneMappingExposure' );\n\t\t\t\tp_uniforms.set( _gl, _this, 'toneMappingWhitePoint' );\n\t\n\t\t\t}\n\t\n\t\t\t// skinning uniforms must be set even if material didn't change\n\t\t\t// auto-setting of texture unit for bone texture must go before other textures\n\t\t\t// not sure why, but otherwise weird things happen\n\t\n\t\t\tif ( material.skinning ) {\n\t\n\t\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrix' );\n\t\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );\n\t\n\t\t\t\tvar skeleton = object.skeleton;\n\t\n\t\t\t\tif ( skeleton ) {\n\t\n\t\t\t\t\tif ( capabilities.floatVertexTextures && skeleton.useVertexTexture ) {\n\t\n\t\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTexture' );\n\t\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTextureWidth' );\n\t\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTextureHeight' );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tp_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif ( refreshMaterial ) {\n\t\n\t\t\t\tif ( material.lights ) {\n\t\n\t\t\t\t\t// the current material requires lighting info\n\t\n\t\t\t\t\t// note: all lighting uniforms are always set correctly\n\t\t\t\t\t// they simply reference the renderer's state for their\n\t\t\t\t\t// values\n\t\t\t\t\t//\n\t\t\t\t\t// use the current material's .needsUpdate flags to set\n\t\t\t\t\t// the GL state when required\n\t\n\t\t\t\t\tmarkUniformsLightsNeedsUpdate( m_uniforms, refreshLights );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// refresh uniforms common to several materials\n\t\n\t\t\t\tif ( fog && material.fog ) {\n\t\n\t\t\t\t\trefreshUniformsFog( m_uniforms, fog );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material instanceof THREE.MeshBasicMaterial ||\n\t\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\n\t\t\t\t\t material instanceof THREE.MeshPhongMaterial ||\n\t\t\t\t\t material instanceof THREE.MeshStandardMaterial ||\n\t\t\t\t\t material instanceof THREE.MeshDepthMaterial ) {\n\t\n\t\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// refresh single material specific uniforms\n\t\n\t\t\t\tif ( material instanceof THREE.LineBasicMaterial ) {\n\t\n\t\t\t\t\trefreshUniformsLine( m_uniforms, material );\n\t\n\t\t\t\t} else if ( material instanceof THREE.LineDashedMaterial ) {\n\t\n\t\t\t\t\trefreshUniformsLine( m_uniforms, material );\n\t\t\t\t\trefreshUniformsDash( m_uniforms, material );\n\t\n\t\t\t\t} else if ( material instanceof THREE.PointsMaterial ) {\n\t\n\t\t\t\t\trefreshUniformsPoints( m_uniforms, material );\n\t\n\t\t\t\t} else if ( material instanceof THREE.MeshLambertMaterial ) {\n\t\n\t\t\t\t\trefreshUniformsLambert( m_uniforms, material );\n\t\n\t\t\t\t} else if ( material instanceof THREE.MeshPhongMaterial ) {\n\t\n\t\t\t\t\trefreshUniformsPhong( m_uniforms, material );\n\t\n\t\t\t\t} else if ( material instanceof THREE.MeshPhysicalMaterial ) {\n\t\n\t\t\t\t\trefreshUniformsPhysical( m_uniforms, material );\n\t\n\t\t\t\t} else if ( material instanceof THREE.MeshStandardMaterial ) {\n\t\n\t\t\t\t\trefreshUniformsStandard( m_uniforms, material );\n\t\n\t\t\t\t} else if ( material instanceof THREE.MeshDepthMaterial ) {\n\t\n\t\t\t\t\tif ( material.displacementMap ) {\n\t\n\t\t\t\t\t\tm_uniforms.displacementMap.value = material.displacementMap;\n\t\t\t\t\t\tm_uniforms.displacementScale.value = material.displacementScale;\n\t\t\t\t\t\tm_uniforms.displacementBias.value = material.displacementBias;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\n\t\n\t\t\t\t\tm_uniforms.opacity.value = material.opacity;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tTHREE.WebGLUniforms.upload(\n\t\t\t\t\t\t_gl, materialProperties.uniformsList, m_uniforms, _this );\n\t\n\t\t\t}\n\t\n\t\n\t\t\t// common matrices\n\t\n\t\t\tp_uniforms.set( _gl, object, 'modelViewMatrix' );\n\t\t\tp_uniforms.set( _gl, object, 'normalMatrix' );\n\t\t\tp_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );\n\t\n\t\n\t\t\t// dynamic uniforms\n\t\n\t\t\tvar dynUniforms = materialProperties.dynamicUniforms;\n\t\n\t\t\tif ( dynUniforms !== null ) {\n\t\n\t\t\t\tTHREE.WebGLUniforms.evalDynamic(\n\t\t\t\t\t\tdynUniforms, m_uniforms, object, camera );\n\t\n\t\t\t\tTHREE.WebGLUniforms.upload( _gl, dynUniforms, m_uniforms, _this );\n\t\n\t\t\t}\n\t\n\t\t\treturn program;\n\t\n\t\t}\n\t\n\t\t// Uniforms (refresh uniforms objects)\n\t\n\t\tfunction refreshUniformsCommon ( uniforms, material ) {\n\t\n\t\t\tuniforms.opacity.value = material.opacity;\n\t\n\t\t\tuniforms.diffuse.value = material.color;\n\t\n\t\t\tif ( material.emissive ) {\n\t\n\t\t\t\tuniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );\n\t\n\t\t\t}\n\t\n\t\t\tuniforms.map.value = material.map;\n\t\t\tuniforms.specularMap.value = material.specularMap;\n\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\t\n\t\t\tif ( material.aoMap ) {\n\t\n\t\t\t\tuniforms.aoMap.value = material.aoMap;\n\t\t\t\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\n\t\n\t\t\t}\n\t\n\t\t\t// uv repeat and offset setting priorities\n\t\t\t// 1. color map\n\t\t\t// 2. specular map\n\t\t\t// 3. normal map\n\t\t\t// 4. bump map\n\t\t\t// 5. alpha map\n\t\t\t// 6. emissive map\n\t\n\t\t\tvar uvScaleMap;\n\t\n\t\t\tif ( material.map ) {\n\t\n\t\t\t\tuvScaleMap = material.map;\n\t\n\t\t\t} else if ( material.specularMap ) {\n\t\n\t\t\t\tuvScaleMap = material.specularMap;\n\t\n\t\t\t} else if ( material.displacementMap ) {\n\t\n\t\t\t\tuvScaleMap = material.displacementMap;\n\t\n\t\t\t} else if ( material.normalMap ) {\n\t\n\t\t\t\tuvScaleMap = material.normalMap;\n\t\n\t\t\t} else if ( material.bumpMap ) {\n\t\n\t\t\t\tuvScaleMap = material.bumpMap;\n\t\n\t\t\t} else if ( material.roughnessMap ) {\n\t\n\t\t\t\tuvScaleMap = material.roughnessMap;\n\t\n\t\t\t} else if ( material.metalnessMap ) {\n\t\n\t\t\t\tuvScaleMap = material.metalnessMap;\n\t\n\t\t\t} else if ( material.alphaMap ) {\n\t\n\t\t\t\tuvScaleMap = material.alphaMap;\n\t\n\t\t\t} else if ( material.emissiveMap ) {\n\t\n\t\t\t\tuvScaleMap = material.emissiveMap;\n\t\n\t\t\t}\n\t\n\t\t\tif ( uvScaleMap !== undefined ) {\n\t\n\t\t\t\t// backwards compatibility\n\t\t\t\tif ( uvScaleMap instanceof THREE.WebGLRenderTarget ) {\n\t\n\t\t\t\t\tuvScaleMap = uvScaleMap.texture;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar offset = uvScaleMap.offset;\n\t\t\t\tvar repeat = uvScaleMap.repeat;\n\t\n\t\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\n\t\n\t\t\t}\n\t\n\t\t\tuniforms.envMap.value = material.envMap;\n\t\n\t\t\t// don't flip CubeTexture envMaps, flip everything else:\n\t\t\t//  WebGLRenderTargetCube will be flipped for backwards compatibility\n\t\t\t//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture\n\t\t\t// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future\n\t\t\tuniforms.flipEnvMap.value = ( ! ( material.envMap instanceof THREE.CubeTexture ) ) ? 1 : - 1;\n\t\n\t\t\tuniforms.reflectivity.value = material.reflectivity;\n\t\t\tuniforms.refractionRatio.value = material.refractionRatio;\n\t\n\t\t}\n\t\n\t\tfunction refreshUniformsLine ( uniforms, material ) {\n\t\n\t\t\tuniforms.diffuse.value = material.color;\n\t\t\tuniforms.opacity.value = material.opacity;\n\t\n\t\t}\n\t\n\t\tfunction refreshUniformsDash ( uniforms, material ) {\n\t\n\t\t\tuniforms.dashSize.value = material.dashSize;\n\t\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\n\t\t\tuniforms.scale.value = material.scale;\n\t\n\t\t}\n\t\n\t\tfunction refreshUniformsPoints ( uniforms, material ) {\n\t\n\t\t\tuniforms.diffuse.value = material.color;\n\t\t\tuniforms.opacity.value = material.opacity;\n\t\t\tuniforms.size.value = material.size * _pixelRatio;\n\t\t\tuniforms.scale.value = _canvas.clientHeight * 0.5;\n\t\n\t\t\tuniforms.map.value = material.map;\n\t\n\t\t\tif ( material.map !== null ) {\n\t\n\t\t\t\tvar offset = material.map.offset;\n\t\t\t\tvar repeat = material.map.repeat;\n\t\n\t\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction refreshUniformsFog ( uniforms, fog ) {\n\t\n\t\t\tuniforms.fogColor.value = fog.color;\n\t\n\t\t\tif ( fog instanceof THREE.Fog ) {\n\t\n\t\t\t\tuniforms.fogNear.value = fog.near;\n\t\t\t\tuniforms.fogFar.value = fog.far;\n\t\n\t\t\t} else if ( fog instanceof THREE.FogExp2 ) {\n\t\n\t\t\t\tuniforms.fogDensity.value = fog.density;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction refreshUniformsLambert ( uniforms, material ) {\n\t\n\t\t\tif ( material.lightMap ) {\n\t\n\t\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\t\n\t\t\t}\n\t\n\t\t\tif ( material.emissiveMap ) {\n\t\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction refreshUniformsPhong ( uniforms, material ) {\n\t\n\t\t\tuniforms.specular.value = material.specular;\n\t\t\tuniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )\n\t\n\t\t\tif ( material.lightMap ) {\n\t\n\t\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\t\n\t\t\t}\n\t\n\t\t\tif ( material.emissiveMap ) {\n\t\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\t\n\t\t\t}\n\t\n\t\t\tif ( material.bumpMap ) {\n\t\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\n\t\t\t}\n\t\n\t\t\tif ( material.normalMap ) {\n\t\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\t\n\t\t\t}\n\t\n\t\t\tif ( material.displacementMap ) {\n\t\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction refreshUniformsStandard ( uniforms, material ) {\n\t\n\t\t\tuniforms.roughness.value = material.roughness;\n\t\t\tuniforms.metalness.value = material.metalness;\n\t\n\t\t\tif ( material.roughnessMap ) {\n\t\n\t\t\t\tuniforms.roughnessMap.value = material.roughnessMap;\n\t\n\t\t\t}\n\t\n\t\t\tif ( material.metalnessMap ) {\n\t\n\t\t\t\tuniforms.metalnessMap.value = material.metalnessMap;\n\t\n\t\t\t}\n\t\n\t\t\tif ( material.lightMap ) {\n\t\n\t\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\t\n\t\t\t}\n\t\n\t\t\tif ( material.emissiveMap ) {\n\t\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\t\n\t\t\t}\n\t\n\t\t\tif ( material.bumpMap ) {\n\t\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\n\t\t\t}\n\t\n\t\t\tif ( material.normalMap ) {\n\t\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\t\n\t\t\t}\n\t\n\t\t\tif ( material.displacementMap ) {\n\t\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\t\n\t\t\t}\n\t\n\t\t\tif ( material.envMap ) {\n\t\n\t\t\t\t//uniforms.envMap.value = material.envMap; // part of uniforms common\n\t\t\t\tuniforms.envMapIntensity.value = material.envMapIntensity;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction refreshUniformsPhysical ( uniforms, material ) {\n\t\n\t\t\tuniforms.clearCoat.value = material.clearCoat;\n\t\t\tuniforms.clearCoatRoughness.value = material.clearCoatRoughness;\n\t\n\t\t\trefreshUniformsStandard( uniforms, material );\n\t\n\t\t}\n\t\n\t\t// If uniforms are marked as clean, they don't need to be loaded to the GPU.\n\t\n\t\tfunction markUniformsLightsNeedsUpdate ( uniforms, value ) {\n\t\n\t\t\tuniforms.ambientLightColor.needsUpdate = value;\n\t\n\t\t\tuniforms.directionalLights.needsUpdate = value;\n\t\t\tuniforms.pointLights.needsUpdate = value;\n\t\t\tuniforms.spotLights.needsUpdate = value;\n\t\t\tuniforms.hemisphereLights.needsUpdate = value;\n\t\n\t\t}\n\t\n\t\t// Lighting\n\t\n\t\tfunction setupShadows ( lights ) {\n\t\n\t\t\tvar lightShadowsLength = 0;\n\t\n\t\t\tfor ( var i = 0, l = lights.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar light = lights[ i ];\n\t\n\t\t\t\tif ( light.castShadow ) {\n\t\n\t\t\t\t\t_lights.shadows[ lightShadowsLength ++ ] = light;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t_lights.shadows.length = lightShadowsLength;\n\t\n\t\t}\n\t\n\t\tfunction setupLights ( lights, camera ) {\n\t\n\t\t\tvar l, ll, light,\n\t\t\tr = 0, g = 0, b = 0,\n\t\t\tcolor,\n\t\t\tintensity,\n\t\t\tdistance,\n\t\t\tshadowMap,\n\t\n\t\t\tviewMatrix = camera.matrixWorldInverse,\n\t\n\t\t\tdirectionalLength = 0,\n\t\t\tpointLength = 0,\n\t\t\tspotLength = 0,\n\t\t\themiLength = 0;\n\t\n\t\t\tfor ( l = 0, ll = lights.length; l < ll; l ++ ) {\n\t\n\t\t\t\tlight = lights[ l ];\n\t\n\t\t\t\tcolor = light.color;\n\t\t\t\tintensity = light.intensity;\n\t\t\t\tdistance = light.distance;\n\t\n\t\t\t\tshadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;\n\t\n\t\t\t\tif ( light instanceof THREE.AmbientLight ) {\n\t\n\t\t\t\t\tr += color.r * intensity;\n\t\t\t\t\tg += color.g * intensity;\n\t\t\t\t\tb += color.b * intensity;\n\t\n\t\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\n\t\n\t\t\t\t\tvar uniforms = lightCache.get( light );\n\t\n\t\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\t\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t\tuniforms.direction.sub( _vector3 );\n\t\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\t\n\t\t\t\t\tuniforms.shadow = light.castShadow;\n\t\n\t\t\t\t\tif ( light.castShadow ) {\n\t\n\t\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t_lights.directionalShadowMap[ directionalLength ] = shadowMap;\n\t\t\t\t\t_lights.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;\n\t\t\t\t\t_lights.directional[ directionalLength ++ ] = uniforms;\n\t\n\t\t\t\t} else if ( light instanceof THREE.SpotLight ) {\n\t\n\t\t\t\t\tvar uniforms = lightCache.get( light );\n\t\n\t\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\t\n\t\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity );\n\t\t\t\t\tuniforms.distance = distance;\n\t\n\t\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t\tuniforms.direction.sub( _vector3 );\n\t\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\t\n\t\t\t\t\tuniforms.coneCos = Math.cos( light.angle );\n\t\t\t\t\tuniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );\n\t\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\n\t\n\t\t\t\t\tuniforms.shadow = light.castShadow;\n\t\n\t\t\t\t\tif ( light.castShadow ) {\n\t\n\t\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t_lights.spotShadowMap[ spotLength ] = shadowMap;\n\t\t\t\t\t_lights.spotShadowMatrix[ spotLength ] = light.shadow.matrix;\n\t\t\t\t\t_lights.spot[ spotLength ++ ] = uniforms;\n\t\n\t\t\t\t} else if ( light instanceof THREE.PointLight ) {\n\t\n\t\t\t\t\tvar uniforms = lightCache.get( light );\n\t\n\t\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\t\n\t\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\t\t\t\t\tuniforms.distance = light.distance;\n\t\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\n\t\n\t\t\t\t\tuniforms.shadow = light.castShadow;\n\t\n\t\t\t\t\tif ( light.castShadow ) {\n\t\n\t\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t_lights.pointShadowMap[ pointLength ] = shadowMap;\n\t\n\t\t\t\t\tif ( _lights.pointShadowMatrix[ pointLength ] === undefined ) {\n\t\n\t\t\t\t\t\t_lights.pointShadowMatrix[ pointLength ] = new THREE.Matrix4();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// for point lights we set the shadow matrix to be a translation-only matrix\n\t\t\t\t\t// equal to inverse of the light's position\n\t\t\t\t\t_vector3.setFromMatrixPosition( light.matrixWorld ).negate();\n\t\t\t\t\t_lights.pointShadowMatrix[ pointLength ].identity().setPosition( _vector3 );\n\t\n\t\t\t\t\t_lights.point[ pointLength ++ ] = uniforms;\n\t\n\t\t\t\t} else if ( light instanceof THREE.HemisphereLight ) {\n\t\n\t\t\t\t\tvar uniforms = lightCache.get( light );\n\t\n\t\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\t\t\t\t\tuniforms.direction.normalize();\n\t\n\t\t\t\t\tuniforms.skyColor.copy( light.color ).multiplyScalar( intensity );\n\t\t\t\t\tuniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );\n\t\n\t\t\t\t\t_lights.hemi[ hemiLength ++ ] = uniforms;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t_lights.ambient[ 0 ] = r;\n\t\t\t_lights.ambient[ 1 ] = g;\n\t\t\t_lights.ambient[ 2 ] = b;\n\t\n\t\t\t_lights.directional.length = directionalLength;\n\t\t\t_lights.spot.length = spotLength;\n\t\t\t_lights.point.length = pointLength;\n\t\t\t_lights.hemi.length = hemiLength;\n\t\n\t\t\t_lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + hemiLength + ',' + _lights.shadows.length;\n\t\n\t\t}\n\t\n\t\t// GL state setting\n\t\n\t\tthis.setFaceCulling = function ( cullFace, frontFaceDirection ) {\n\t\n\t\t\tstate.setCullFace( cullFace );\n\t\t\tstate.setFlipSided( frontFaceDirection === THREE.FrontFaceDirectionCW );\n\t\n\t\t};\n\t\n\t\t// Textures\n\t\n\t\tfunction allocTextureUnit() {\n\t\n\t\t\tvar textureUnit = _usedTextureUnits;\n\t\n\t\t\tif ( textureUnit >= capabilities.maxTextures ) {\n\t\n\t\t\t\tconsole.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );\n\t\n\t\t\t}\n\t\n\t\t\t_usedTextureUnits += 1;\n\t\n\t\t\treturn textureUnit;\n\t\n\t\t}\n\t\n\t\tthis.allocTextureUnit = allocTextureUnit;\n\t\n\t\t// this.setTexture2D = setTexture2D;\n\t\tthis.setTexture2D = ( function() {\n\t\n\t\t\tvar warned = false;\n\t\n\t\t\t// backwards compatibility: peel texture.texture\n\t\t\treturn function setTexture2D( texture, slot ) {\n\t\n\t\t\t\tif ( texture instanceof THREE.WebGLRenderTarget ) {\n\t\n\t\t\t\t\tif ( ! warned ) {\n\t\n\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.\" );\n\t\t\t\t\t\twarned = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttexture = texture.texture;\n\t\n\t\t\t\t}\n\t\n\t\t\t\ttextures.setTexture2D( texture, slot );\n\t\n\t\t\t};\n\t\n\t\t}() );\n\t\n\t\tthis.setTexture = ( function() {\n\t\n\t\t\tvar warned = false;\n\t\n\t\t\treturn function setTexture( texture, slot ) {\n\t\n\t\t\t\tif ( ! warned ) {\n\t\n\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.\" );\n\t\t\t\t\twarned = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\ttextures.setTexture2D( texture, slot );\n\t\n\t\t\t};\n\t\n\t\t}() );\n\t\n\t\tthis.setTextureCube = ( function() {\n\t\n\t\t\tvar warned = false;\n\t\n\t\t\treturn function setTextureCube( texture, slot ) {\n\t\n\t\t\t\t// backwards compatibility: peel texture.texture\n\t\t\t\tif ( texture instanceof THREE.WebGLRenderTargetCube ) {\n\t\n\t\t\t\t\tif ( ! warned ) {\n\t\n\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.\" );\n\t\t\t\t\t\twarned = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttexture = texture.texture;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture\n\t\t\t\t// TODO: unify these code paths\n\t\t\t\tif ( texture instanceof THREE.CubeTexture ||\n\t\t\t\t\t ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {\n\t\n\t\t\t\t\t// CompressedTexture can have Array in image :/\n\t\n\t\t\t\t\t// this function alone should take care of cube textures\n\t\t\t\t\ttextures.setTextureCube( texture, slot );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// assumed: texture property of THREE.WebGLRenderTargetCube\n\t\n\t\t\t\t\ttextures.setTextureCubeDynamic( texture, slot );\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t}() );\n\t\n\t\tthis.getCurrentRenderTarget = function() {\n\t\n\t\t\treturn _currentRenderTarget;\n\t\n\t\t};\n\t\n\t\tthis.setRenderTarget = function ( renderTarget ) {\n\t\n\t\t\t_currentRenderTarget = renderTarget;\n\t\n\t\t\tif ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {\n\t\n\t\t\t\ttextures.setupRenderTarget( renderTarget );\n\t\n\t\t\t}\n\t\n\t\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\n\t\t\tvar framebuffer;\n\t\n\t\t\tif ( renderTarget ) {\n\t\n\t\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\n\t\t\t\tif ( isCube ) {\n\t\n\t\t\t\t\tframebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tframebuffer = renderTargetProperties.__webglFramebuffer;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t_currentScissor.copy( renderTarget.scissor );\n\t\t\t\t_currentScissorTest = renderTarget.scissorTest;\n\t\n\t\t\t\t_currentViewport.copy( renderTarget.viewport );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tframebuffer = null;\n\t\n\t\t\t\t_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );\n\t\t\t\t_currentScissorTest = _scissorTest;\n\t\n\t\t\t\t_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );\n\t\n\t\t\t}\n\t\n\t\t\tif ( _currentFramebuffer !== framebuffer ) {\n\t\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\t\t\t_currentFramebuffer = framebuffer;\n\t\n\t\t\t}\n\t\n\t\t\tstate.scissor( _currentScissor );\n\t\t\tstate.setScissorTest( _currentScissorTest );\n\t\n\t\t\tstate.viewport( _currentViewport );\n\t\n\t\t\tif ( isCube ) {\n\t\n\t\t\t\tvar textureProperties = properties.get( renderTarget.texture );\n\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {\n\t\n\t\t\tif ( renderTarget instanceof THREE.WebGLRenderTarget === false ) {\n\t\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\n\t\t\t\treturn;\n\t\n\t\t\t}\n\t\n\t\t\tvar framebuffer = properties.get( renderTarget ).__webglFramebuffer;\n\t\n\t\t\tif ( framebuffer ) {\n\t\n\t\t\t\tvar restore = false;\n\t\n\t\t\t\tif ( framebuffer !== _currentFramebuffer ) {\n\t\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\n\t\t\t\t\trestore = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\ttry {\n\t\n\t\t\t\t\tvar texture = renderTarget.texture;\n\t\n\t\t\t\t\tif ( texture.format !== THREE.RGBAFormat && paramThreeToGL( texture.format ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {\n\t\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );\n\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( texture.type !== THREE.UnsignedByteType &&\n\t\t\t\t\t     paramThreeToGL( texture.type ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) &&\n\t\t\t\t\t     ! ( texture.type === THREE.FloatType && extensions.get( 'WEBGL_color_buffer_float' ) ) &&\n\t\t\t\t\t     ! ( texture.type === THREE.HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {\n\t\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );\n\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {\n\t\n\t\t\t\t\t\t// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\n\t\n\t\t\t\t\t\tif ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {\n\t\n\t\t\t\t\t\t\t_gl.readPixels( x, y, width, height, paramThreeToGL( texture.format ), paramThreeToGL( texture.type ), buffer );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} finally {\n\t\n\t\t\t\t\tif ( restore ) {\n\t\n\t\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t// Map three.js constants to WebGL constants\n\t\n\t\tfunction paramThreeToGL ( p ) {\n\t\n\t\t\tvar extension;\n\t\n\t\t\tif ( p === THREE.RepeatWrapping ) return _gl.REPEAT;\n\t\t\tif ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;\n\t\t\tif ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;\n\t\n\t\t\tif ( p === THREE.NearestFilter ) return _gl.NEAREST;\n\t\t\tif ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;\n\t\t\tif ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;\n\t\n\t\t\tif ( p === THREE.LinearFilter ) return _gl.LINEAR;\n\t\t\tif ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;\n\t\t\tif ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;\n\t\n\t\t\tif ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;\n\t\t\tif ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;\n\t\t\tif ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;\n\t\t\tif ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;\n\t\n\t\t\tif ( p === THREE.ByteType ) return _gl.BYTE;\n\t\t\tif ( p === THREE.ShortType ) return _gl.SHORT;\n\t\t\tif ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;\n\t\t\tif ( p === THREE.IntType ) return _gl.INT;\n\t\t\tif ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;\n\t\t\tif ( p === THREE.FloatType ) return _gl.FLOAT;\n\t\n\t\t\textension = extensions.get( 'OES_texture_half_float' );\n\t\n\t\t\tif ( extension !== null ) {\n\t\n\t\t\t\tif ( p === THREE.HalfFloatType ) return extension.HALF_FLOAT_OES;\n\t\n\t\t\t}\n\t\n\t\t\tif ( p === THREE.AlphaFormat ) return _gl.ALPHA;\n\t\t\tif ( p === THREE.RGBFormat ) return _gl.RGB;\n\t\t\tif ( p === THREE.RGBAFormat ) return _gl.RGBA;\n\t\t\tif ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;\n\t\t\tif ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;\n\t\t\tif ( p === THREE.DepthFormat ) return _gl.DEPTH_COMPONENT;\n\t\n\t\t\tif ( p === THREE.AddEquation ) return _gl.FUNC_ADD;\n\t\t\tif ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;\n\t\t\tif ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;\n\t\n\t\t\tif ( p === THREE.ZeroFactor ) return _gl.ZERO;\n\t\t\tif ( p === THREE.OneFactor ) return _gl.ONE;\n\t\t\tif ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;\n\t\t\tif ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;\n\t\t\tif ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;\n\t\t\tif ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;\n\t\t\tif ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;\n\t\t\tif ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;\n\t\n\t\t\tif ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;\n\t\t\tif ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;\n\t\t\tif ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;\n\t\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\t\n\t\t\tif ( extension !== null ) {\n\t\n\t\t\t\tif ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n\t\t\t\tif ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n\t\t\t\tif ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n\t\t\t\tif ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n\t\n\t\t\t}\n\t\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\t\n\t\t\tif ( extension !== null ) {\n\t\n\t\t\t\tif ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n\t\t\t\tif ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n\t\t\t\tif ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n\t\t\t\tif ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n\t\n\t\t\t}\n\t\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_etc1' );\n\t\n\t\t\tif ( extension !== null ) {\n\t\n\t\t\t\tif ( p === THREE.RGB_ETC1_Format ) return extension.COMPRESSED_RGB_ETC1_WEBGL;\n\t\n\t\t\t}\n\t\n\t\t\textension = extensions.get( 'EXT_blend_minmax' );\n\t\n\t\t\tif ( extension !== null ) {\n\t\n\t\t\t\tif ( p === THREE.MinEquation ) return extension.MIN_EXT;\n\t\t\t\tif ( p === THREE.MaxEquation ) return extension.MAX_EXT;\n\t\n\t\t\t}\n\t\n\t\t\treturn 0;\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/renderers/WebGLRenderTarget.js\n\t\n\t/**\n\t * @author szimek / https://github.com/szimek/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author Marius Kintel / https://github.com/kintel\n\t */\n\t\n\t/*\n\t In options, we can specify:\n\t * Texture parameters for an auto-generated target texture\n\t * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\n\t*/\n\tTHREE.WebGLRenderTarget = function ( width, height, options ) {\n\t\n\t\tthis.uuid = THREE.Math.generateUUID();\n\t\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\n\t\tthis.scissor = new THREE.Vector4( 0, 0, width, height );\n\t\tthis.scissorTest = false;\n\t\n\t\tthis.viewport = new THREE.Vector4( 0, 0, width, height );\n\t\n\t\toptions = options || {};\n\t\n\t\tif ( options.minFilter === undefined ) options.minFilter = THREE.LinearFilter;\n\t\n\t\tthis.texture = new THREE.Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );\n\t\n\t\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\n\t\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\n\t\tthis.depthTexture = null;\n\t\n\t};\n\t\n\tObject.assign( THREE.WebGLRenderTarget.prototype, THREE.EventDispatcher.prototype, {\n\t\n\t\tsetSize: function ( width, height ) {\n\t\n\t\t\tif ( this.width !== width || this.height !== height ) {\n\t\n\t\t\t\tthis.width = width;\n\t\t\t\tthis.height = height;\n\t\n\t\t\t\tthis.dispose();\n\t\n\t\t\t}\n\t\n\t\t\tthis.viewport.set( 0, 0, width, height );\n\t\t\tthis.scissor.set( 0, 0, width, height );\n\t\n\t\t},\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t},\n\t\n\t\tcopy: function ( source ) {\n\t\n\t\t\tthis.width = source.width;\n\t\t\tthis.height = source.height;\n\t\n\t\t\tthis.viewport.copy( source.viewport );\n\t\n\t\t\tthis.texture = source.texture.clone();\n\t\n\t\t\tthis.depthBuffer = source.depthBuffer;\n\t\t\tthis.stencilBuffer = source.stencilBuffer;\n\t\t\tthis.depthTexture = source.depthTexture;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tdispose: function () {\n\t\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/renderers/WebGLRenderTargetCube.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com\n\t */\n\t\n\tTHREE.WebGLRenderTargetCube = function ( width, height, options ) {\n\t\n\t\tTHREE.WebGLRenderTarget.call( this, width, height, options );\n\t\n\t\tthis.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\n\t\tthis.activeMipMapLevel = 0;\n\t\n\t};\n\t\n\tTHREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );\n\tTHREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;\n\t\n\t// File:src/renderers/webgl/WebGLBufferRenderer.js\n\t\n\t/**\n\t* @author mrdoob / http://mrdoob.com/\n\t*/\n\t\n\tTHREE.WebGLBufferRenderer = function ( _gl, extensions, _infoRender ) {\n\t\n\t\tvar mode;\n\t\n\t\tfunction setMode( value ) {\n\t\n\t\t\tmode = value;\n\t\n\t\t}\n\t\n\t\tfunction render( start, count ) {\n\t\n\t\t\t_gl.drawArrays( mode, start, count );\n\t\n\t\t\t_infoRender.calls ++;\n\t\t\t_infoRender.vertices += count;\n\t\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;\n\t\n\t\t}\n\t\n\t\tfunction renderInstances( geometry ) {\n\t\n\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\t\n\t\t\tif ( extension === null ) {\n\t\n\t\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\treturn;\n\t\n\t\t\t}\n\t\n\t\t\tvar position = geometry.attributes.position;\n\t\n\t\t\tvar count = 0;\n\t\n\t\t\tif ( position instanceof THREE.InterleavedBufferAttribute ) {\n\t\n\t\t\t\tcount = position.data.count;\n\t\n\t\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tcount = position.count;\n\t\n\t\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\n\t\n\t\t\t}\n\t\n\t\t\t_infoRender.calls ++;\n\t\t\t_infoRender.vertices += count * geometry.maxInstancedCount;\n\t\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += geometry.maxInstancedCount * count / 3;\n\t\n\t\t}\n\t\n\t\tthis.setMode = setMode;\n\t\tthis.render = render;\n\t\tthis.renderInstances = renderInstances;\n\t\n\t};\n\t\n\t// File:src/renderers/webgl/WebGLClipping.js\n\t\n\tTHREE.WebGLClipping = function() {\n\t\n\t\tvar scope = this,\n\t\n\t\t\tglobalState = null,\n\t\t\tnumGlobalPlanes = 0,\n\t\t\tlocalClippingEnabled = false,\n\t\t\trenderingShadows = false,\n\t\n\t\t\tplane = new THREE.Plane(),\n\t\t\tviewNormalMatrix = new THREE.Matrix3(),\n\t\n\t\t\tuniform = { value: null, needsUpdate: false };\n\t\n\t\tthis.uniform = uniform;\n\t\tthis.numPlanes = 0;\n\t\n\t\tthis.init = function( planes, enableLocalClipping, camera ) {\n\t\n\t\t\tvar enabled =\n\t\t\t\tplanes.length !== 0 ||\n\t\t\t\tenableLocalClipping ||\n\t\t\t\t// enable state of previous frame - the clipping code has to\n\t\t\t\t// run another frame in order to reset the state:\n\t\t\t\tnumGlobalPlanes !== 0 ||\n\t\t\t\tlocalClippingEnabled;\n\t\n\t\t\tlocalClippingEnabled = enableLocalClipping;\n\t\n\t\t\tglobalState = projectPlanes( planes, camera, 0 );\n\t\t\tnumGlobalPlanes = planes.length;\n\t\n\t\t\treturn enabled;\n\t\n\t\t};\n\t\n\t\tthis.beginShadows = function() {\n\t\n\t\t\trenderingShadows = true;\n\t\t\tprojectPlanes( null );\n\t\n\t\t};\n\t\n\t\tthis.endShadows = function() {\n\t\n\t\t\trenderingShadows = false;\n\t\t\tresetGlobalState();\n\t\n\t\t};\n\t\n\t\tthis.setState = function( planes, clipShadows, camera, cache, fromCache ) {\n\t\n\t\t\tif ( ! localClippingEnabled ||\n\t\t\t\t\tplanes === null || planes.length === 0 ||\n\t\t\t\t\trenderingShadows && ! clipShadows ) {\n\t\t\t\t// there's no local clipping\n\t\n\t\t\t\tif ( renderingShadows ) {\n\t\t\t\t\t// there's no global clipping\n\t\n\t\t\t\t\tprojectPlanes( null );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tresetGlobalState();\n\t\t\t\t}\n\t\n\t\t\t} else {\n\t\n\t\t\t\tvar nGlobal = renderingShadows ? 0 : numGlobalPlanes,\n\t\t\t\t\tlGlobal = nGlobal * 4,\n\t\n\t\t\t\t\tdstArray = cache.clippingState || null;\n\t\n\t\t\t\tuniform.value = dstArray; // ensure unique state\n\t\n\t\t\t\tdstArray = projectPlanes( planes, camera, lGlobal, fromCache );\n\t\n\t\t\t\tfor ( var i = 0; i !== lGlobal; ++ i ) {\n\t\n\t\t\t\t\tdstArray[ i ] = globalState[ i ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tcache.clippingState = dstArray;\n\t\t\t\tthis.numPlanes += nGlobal;\n\t\n\t\t\t}\n\t\n\t\n\t\t};\n\t\n\t\tfunction resetGlobalState() {\n\t\n\t\t\tif ( uniform.value !== globalState ) {\n\t\n\t\t\t\tuniform.value = globalState;\n\t\t\t\tuniform.needsUpdate = numGlobalPlanes > 0;\n\t\n\t\t\t}\n\t\n\t\t\tscope.numPlanes = numGlobalPlanes;\n\t\n\t\t}\n\t\n\t\tfunction projectPlanes( planes, camera, dstOffset, skipTransform ) {\n\t\n\t\t\tvar nPlanes = planes !== null ? planes.length : 0,\n\t\t\t\tdstArray = null;\n\t\n\t\t\tif ( nPlanes !== 0 ) {\n\t\n\t\t\t\tdstArray = uniform.value;\n\t\n\t\t\t\tif ( skipTransform !== true || dstArray === null ) {\n\t\n\t\t\t\t\tvar flatSize = dstOffset + nPlanes * 4,\n\t\t\t\t\t\tviewMatrix = camera.matrixWorldInverse;\n\t\n\t\t\t\t\tviewNormalMatrix.getNormalMatrix( viewMatrix );\n\t\n\t\t\t\t\tif ( dstArray === null || dstArray.length < flatSize ) {\n\t\n\t\t\t\t\t\tdstArray = new Float32Array( flatSize );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( var i = 0, i4 = dstOffset;\n\t\t\t\t\t\t\t\t\t\ti !== nPlanes; ++ i, i4 += 4 ) {\n\t\n\t\t\t\t\t\tplane.copy( planes[ i ] ).\n\t\t\t\t\t\t\t\tapplyMatrix4( viewMatrix, viewNormalMatrix );\n\t\n\t\t\t\t\t\tplane.normal.toArray( dstArray, i4 );\n\t\t\t\t\t\tdstArray[ i4 + 3 ] = plane.constant;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tuniform.value = dstArray;\n\t\t\t\tuniform.needsUpdate = true;\n\t\n\t\t\t}\n\t\n\t\t\tscope.numPlanes = nPlanes;\n\t\t\treturn dstArray;\n\t\n\t\t}\n\t\n\t};\n\t\n\t\n\t// File:src/renderers/webgl/WebGLIndexedBufferRenderer.js\n\t\n\t/**\n\t* @author mrdoob / http://mrdoob.com/\n\t*/\n\t\n\tTHREE.WebGLIndexedBufferRenderer = function ( _gl, extensions, _infoRender ) {\n\t\n\t\tvar mode;\n\t\n\t\tfunction setMode( value ) {\n\t\n\t\t\tmode = value;\n\t\n\t\t}\n\t\n\t\tvar type, size;\n\t\n\t\tfunction setIndex( index ) {\n\t\n\t\t\tif ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {\n\t\n\t\t\t\ttype = _gl.UNSIGNED_INT;\n\t\t\t\tsize = 4;\n\t\n\t\t\t} else {\n\t\n\t\t\t\ttype = _gl.UNSIGNED_SHORT;\n\t\t\t\tsize = 2;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction render( start, count ) {\n\t\n\t\t\t_gl.drawElements( mode, count, type, start * size );\n\t\n\t\t\t_infoRender.calls ++;\n\t\t\t_infoRender.vertices += count;\n\t\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;\n\t\n\t\t}\n\t\n\t\tfunction renderInstances( geometry, start, count ) {\n\t\n\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\t\n\t\t\tif ( extension === null ) {\n\t\n\t\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\treturn;\n\t\n\t\t\t}\n\t\n\t\t\textension.drawElementsInstancedANGLE( mode, count, type, start * size, geometry.maxInstancedCount );\n\t\n\t\t\t_infoRender.calls ++;\n\t\t\t_infoRender.vertices += count * geometry.maxInstancedCount;\n\t\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += geometry.maxInstancedCount * count / 3;\n\t\t}\n\t\n\t\tthis.setMode = setMode;\n\t\tthis.setIndex = setIndex;\n\t\tthis.render = render;\n\t\tthis.renderInstances = renderInstances;\n\t\n\t};\n\t\n\t// File:src/renderers/webgl/WebGLExtensions.js\n\t\n\t/**\n\t* @author mrdoob / http://mrdoob.com/\n\t*/\n\t\n\tTHREE.WebGLExtensions = function ( gl ) {\n\t\n\t\tvar extensions = {};\n\t\n\t\tthis.get = function ( name ) {\n\t\n\t\t\tif ( extensions[ name ] !== undefined ) {\n\t\n\t\t\t\treturn extensions[ name ];\n\t\n\t\t\t}\n\t\n\t\t\tvar extension;\n\t\n\t\t\tswitch ( name ) {\n\t\n\t\t\t\tcase 'WEBGL_depth_texture':\n\t\t\t\t\textension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase 'EXT_texture_filter_anisotropic':\n\t\t\t\t\textension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase 'WEBGL_compressed_texture_s3tc':\n\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase 'WEBGL_compressed_texture_pvrtc':\n\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase 'WEBGL_compressed_texture_etc1':\n\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tdefault:\n\t\t\t\t\textension = gl.getExtension( name );\n\t\n\t\t\t}\n\t\n\t\t\tif ( extension === null ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\n\t\n\t\t\t}\n\t\n\t\t\textensions[ name ] = extension;\n\t\n\t\t\treturn extension;\n\t\n\t\t};\n\t\n\t};\n\t\n\t// File:src/renderers/webgl/WebGLCapabilities.js\n\t\n\tTHREE.WebGLCapabilities = function ( gl, extensions, parameters ) {\n\t\n\t\tvar maxAnisotropy;\n\t\n\t\tfunction getMaxAnisotropy() {\n\t\n\t\t\tif ( maxAnisotropy !== undefined ) return maxAnisotropy;\n\t\n\t\t\tvar extension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\t\n\t\t\tif ( extension !== null ) {\n\t\n\t\t\t\tmaxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tmaxAnisotropy = 0;\n\t\n\t\t\t}\n\t\n\t\t\treturn maxAnisotropy;\n\t\n\t\t}\n\t\n\t\tfunction getMaxPrecision( precision ) {\n\t\n\t\t\tif ( precision === 'highp' ) {\n\t\n\t\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&\n\t\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {\n\t\n\t\t\t\t\treturn 'highp';\n\t\n\t\t\t\t}\n\t\n\t\t\t\tprecision = 'mediump';\n\t\n\t\t\t}\n\t\n\t\t\tif ( precision === 'mediump' ) {\n\t\n\t\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&\n\t\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {\n\t\n\t\t\t\t\treturn 'mediump';\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn 'lowp';\n\t\n\t\t}\n\t\n\t\tthis.getMaxAnisotropy = getMaxAnisotropy;\n\t\tthis.getMaxPrecision = getMaxPrecision;\n\t\n\t\tthis.precision = parameters.precision !== undefined ? parameters.precision : 'highp';\n\t\tthis.logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false;\n\t\n\t\tthis.maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\n\t\tthis.maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\n\t\tthis.maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );\n\t\tthis.maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );\n\t\n\t\tthis.maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\t\tthis.maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );\n\t\tthis.maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );\n\t\tthis.maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );\n\t\n\t\tthis.vertexTextures = this.maxVertexTextures > 0;\n\t\tthis.floatFragmentTextures = !! extensions.get( 'OES_texture_float' );\n\t\tthis.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;\n\t\n\t\tvar _maxPrecision = getMaxPrecision( this.precision );\n\t\n\t\tif ( _maxPrecision !== this.precision ) {\n\t\n\t\t\tconsole.warn( 'THREE.WebGLRenderer:', this.precision, 'not supported, using', _maxPrecision, 'instead.' );\n\t\t\tthis.precision = _maxPrecision;\n\t\n\t\t}\n\t\n\t\tif ( this.logarithmicDepthBuffer ) {\n\t\n\t\t\tthis.logarithmicDepthBuffer = !! extensions.get( 'EXT_frag_depth' );\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/renderers/webgl/WebGLGeometries.js\n\t\n\t/**\n\t* @author mrdoob / http://mrdoob.com/\n\t*/\n\t\n\tTHREE.WebGLGeometries = function ( gl, properties, info ) {\n\t\n\t\tvar geometries = {};\n\t\n\t\tfunction get( object ) {\n\t\n\t\t\tvar geometry = object.geometry;\n\t\n\t\t\tif ( geometries[ geometry.id ] !== undefined ) {\n\t\n\t\t\t\treturn geometries[ geometry.id ];\n\t\n\t\t\t}\n\t\n\t\t\tgeometry.addEventListener( 'dispose', onGeometryDispose );\n\t\n\t\t\tvar buffergeometry;\n\t\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\t\n\t\t\t\tbuffergeometry = geometry;\n\t\n\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\t\n\t\t\t\tif ( geometry._bufferGeometry === undefined ) {\n\t\n\t\t\t\t\tgeometry._bufferGeometry = new THREE.BufferGeometry().setFromObject( object );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tbuffergeometry = geometry._bufferGeometry;\n\t\n\t\t\t}\n\t\n\t\t\tgeometries[ geometry.id ] = buffergeometry;\n\t\n\t\t\tinfo.memory.geometries ++;\n\t\n\t\t\treturn buffergeometry;\n\t\n\t\t}\n\t\n\t\tfunction onGeometryDispose( event ) {\n\t\n\t\t\tvar geometry = event.target;\n\t\t\tvar buffergeometry = geometries[ geometry.id ];\n\t\n\t\t\tif ( buffergeometry.index !== null ) {\n\t\n\t\t\t\tdeleteAttribute( buffergeometry.index );\n\t\n\t\t\t}\n\t\n\t\t\tdeleteAttributes( buffergeometry.attributes );\n\t\n\t\t\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\n\t\n\t\t\tdelete geometries[ geometry.id ];\n\t\n\t\t\t// TODO\n\t\n\t\t\tvar property = properties.get( geometry );\n\t\n\t\t\tif ( property.wireframe ) {\n\t\n\t\t\t\tdeleteAttribute( property.wireframe );\n\t\n\t\t\t}\n\t\n\t\t\tproperties.delete( geometry );\n\t\n\t\t\tvar bufferproperty = properties.get( buffergeometry );\n\t\n\t\t\tif ( bufferproperty.wireframe ) {\n\t\n\t\t\t\tdeleteAttribute( bufferproperty.wireframe );\n\t\n\t\t\t}\n\t\n\t\t\tproperties.delete( buffergeometry );\n\t\n\t\t\t//\n\t\n\t\t\tinfo.memory.geometries --;\n\t\n\t\t}\n\t\n\t\tfunction getAttributeBuffer( attribute ) {\n\t\n\t\t\tif ( attribute instanceof THREE.InterleavedBufferAttribute ) {\n\t\n\t\t\t\treturn properties.get( attribute.data ).__webglBuffer;\n\t\n\t\t\t}\n\t\n\t\t\treturn properties.get( attribute ).__webglBuffer;\n\t\n\t\t}\n\t\n\t\tfunction deleteAttribute( attribute ) {\n\t\n\t\t\tvar buffer = getAttributeBuffer( attribute );\n\t\n\t\t\tif ( buffer !== undefined ) {\n\t\n\t\t\t\tgl.deleteBuffer( buffer );\n\t\t\t\tremoveAttributeBuffer( attribute );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction deleteAttributes( attributes ) {\n\t\n\t\t\tfor ( var name in attributes ) {\n\t\n\t\t\t\tdeleteAttribute( attributes[ name ] );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction removeAttributeBuffer( attribute ) {\n\t\n\t\t\tif ( attribute instanceof THREE.InterleavedBufferAttribute ) {\n\t\n\t\t\t\tproperties.delete( attribute.data );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tproperties.delete( attribute );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tthis.get = get;\n\t\n\t};\n\t\n\t// File:src/renderers/webgl/WebGLLights.js\n\t\n\t/**\n\t* @author mrdoob / http://mrdoob.com/\n\t*/\n\t\n\tTHREE.WebGLLights = function () {\n\t\n\t\tvar lights = {};\n\t\n\t\tthis.get = function ( light ) {\n\t\n\t\t\tif ( lights[ light.id ] !== undefined ) {\n\t\n\t\t\t\treturn lights[ light.id ];\n\t\n\t\t\t}\n\t\n\t\t\tvar uniforms;\n\t\n\t\t\tswitch ( light.type ) {\n\t\n\t\t\t\tcase 'DirectionalLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tdirection: new THREE.Vector3(),\n\t\t\t\t\t\tcolor: new THREE.Color(),\n\t\n\t\t\t\t\t\tshadow: false,\n\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\tshadowMapSize: new THREE.Vector2()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase 'SpotLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tposition: new THREE.Vector3(),\n\t\t\t\t\t\tdirection: new THREE.Vector3(),\n\t\t\t\t\t\tcolor: new THREE.Color(),\n\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\tconeCos: 0,\n\t\t\t\t\t\tpenumbraCos: 0,\n\t\t\t\t\t\tdecay: 0,\n\t\n\t\t\t\t\t\tshadow: false,\n\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\tshadowMapSize: new THREE.Vector2()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase 'PointLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tposition: new THREE.Vector3(),\n\t\t\t\t\t\tcolor: new THREE.Color(),\n\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\tdecay: 0,\n\t\n\t\t\t\t\t\tshadow: false,\n\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\tshadowMapSize: new THREE.Vector2()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase 'HemisphereLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tdirection: new THREE.Vector3(),\n\t\t\t\t\t\tskyColor: new THREE.Color(),\n\t\t\t\t\t\tgroundColor: new THREE.Color()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\n\t\t\t}\n\t\n\t\t\tlights[ light.id ] = uniforms;\n\t\n\t\t\treturn uniforms;\n\t\n\t\t};\n\t\n\t};\n\t\n\t// File:src/renderers/webgl/WebGLObjects.js\n\t\n\t/**\n\t* @author mrdoob / http://mrdoob.com/\n\t*/\n\t\n\tTHREE.WebGLObjects = function ( gl, properties, info ) {\n\t\n\t\tvar geometries = new THREE.WebGLGeometries( gl, properties, info );\n\t\n\t\t//\n\t\n\t\tfunction update( object ) {\n\t\n\t\t\t// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.\n\t\n\t\t\tvar geometry = geometries.get( object );\n\t\n\t\t\tif ( object.geometry instanceof THREE.Geometry ) {\n\t\n\t\t\t\tgeometry.updateFromObject( object );\n\t\n\t\t\t}\n\t\n\t\t\tvar index = geometry.index;\n\t\t\tvar attributes = geometry.attributes;\n\t\n\t\t\tif ( index !== null ) {\n\t\n\t\t\t\tupdateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );\n\t\n\t\t\t}\n\t\n\t\t\tfor ( var name in attributes ) {\n\t\n\t\t\t\tupdateAttribute( attributes[ name ], gl.ARRAY_BUFFER );\n\t\n\t\t\t}\n\t\n\t\t\t// morph targets\n\t\n\t\t\tvar morphAttributes = geometry.morphAttributes;\n\t\n\t\t\tfor ( var name in morphAttributes ) {\n\t\n\t\t\t\tvar array = morphAttributes[ name ];\n\t\n\t\t\t\tfor ( var i = 0, l = array.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tupdateAttribute( array[ i ], gl.ARRAY_BUFFER );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn geometry;\n\t\n\t\t}\n\t\n\t\tfunction updateAttribute( attribute, bufferType ) {\n\t\n\t\t\tvar data = ( attribute instanceof THREE.InterleavedBufferAttribute ) ? attribute.data : attribute;\n\t\n\t\t\tvar attributeProperties = properties.get( data );\n\t\n\t\t\tif ( attributeProperties.__webglBuffer === undefined ) {\n\t\n\t\t\t\tcreateBuffer( attributeProperties, data, bufferType );\n\t\n\t\t\t} else if ( attributeProperties.version !== data.version ) {\n\t\n\t\t\t\tupdateBuffer( attributeProperties, data, bufferType );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction createBuffer( attributeProperties, data, bufferType ) {\n\t\n\t\t\tattributeProperties.__webglBuffer = gl.createBuffer();\n\t\t\tgl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\n\t\n\t\t\tvar usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;\n\t\n\t\t\tgl.bufferData( bufferType, data.array, usage );\n\t\n\t\t\tattributeProperties.version = data.version;\n\t\n\t\t}\n\t\n\t\tfunction updateBuffer( attributeProperties, data, bufferType ) {\n\t\n\t\t\tgl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\n\t\n\t\t\tif ( data.dynamic === false || data.updateRange.count === - 1 ) {\n\t\n\t\t\t\t// Not using update ranges\n\t\n\t\t\t\tgl.bufferSubData( bufferType, 0, data.array );\n\t\n\t\t\t} else if ( data.updateRange.count === 0 ) {\n\t\n\t\t\t\tconsole.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tgl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,\n\t\t\t\t\t\t\t\t  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );\n\t\n\t\t\t\tdata.updateRange.count = 0; // reset range\n\t\n\t\t\t}\n\t\n\t\t\tattributeProperties.version = data.version;\n\t\n\t\t}\n\t\n\t\tfunction getAttributeBuffer( attribute ) {\n\t\n\t\t\tif ( attribute instanceof THREE.InterleavedBufferAttribute ) {\n\t\n\t\t\t\treturn properties.get( attribute.data ).__webglBuffer;\n\t\n\t\t\t}\n\t\n\t\t\treturn properties.get( attribute ).__webglBuffer;\n\t\n\t\t}\n\t\n\t\tfunction getWireframeAttribute( geometry ) {\n\t\n\t\t\tvar property = properties.get( geometry );\n\t\n\t\t\tif ( property.wireframe !== undefined ) {\n\t\n\t\t\t\treturn property.wireframe;\n\t\n\t\t\t}\n\t\n\t\t\tvar indices = [];\n\t\n\t\t\tvar index = geometry.index;\n\t\t\tvar attributes = geometry.attributes;\n\t\t\tvar position = attributes.position;\n\t\n\t\t\t// console.time( 'wireframe' );\n\t\n\t\t\tif ( index !== null ) {\n\t\n\t\t\t\tvar edges = {};\n\t\t\t\tvar array = index.array;\n\t\n\t\t\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\n\t\n\t\t\t\t\tvar a = array[ i + 0 ];\n\t\t\t\t\tvar b = array[ i + 1 ];\n\t\t\t\t\tvar c = array[ i + 2 ];\n\t\n\t\t\t\t\tif ( checkEdge( edges, a, b ) ) indices.push( a, b );\n\t\t\t\t\tif ( checkEdge( edges, b, c ) ) indices.push( b, c );\n\t\t\t\t\tif ( checkEdge( edges, c, a ) ) indices.push( c, a );\n\t\n\t\t\t\t}\n\t\n\t\t\t} else {\n\t\n\t\t\t\tvar array = attributes.position.array;\n\t\n\t\t\t\tfor ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\n\t\n\t\t\t\t\tvar a = i + 0;\n\t\t\t\t\tvar b = i + 1;\n\t\t\t\t\tvar c = i + 2;\n\t\n\t\t\t\t\tindices.push( a, b, b, c, c, a );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// console.timeEnd( 'wireframe' );\n\t\n\t\t\tvar TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;\n\t\t\tvar attribute = new THREE.BufferAttribute( new TypeArray( indices ), 1 );\n\t\n\t\t\tupdateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );\n\t\n\t\t\tproperty.wireframe = attribute;\n\t\n\t\t\treturn attribute;\n\t\n\t\t}\n\t\n\t\tfunction checkEdge( edges, a, b ) {\n\t\n\t\t\tif ( a > b ) {\n\t\n\t\t\t\tvar tmp = a;\n\t\t\t\ta = b;\n\t\t\t\tb = tmp;\n\t\n\t\t\t}\n\t\n\t\t\tvar list = edges[ a ];\n\t\n\t\t\tif ( list === undefined ) {\n\t\n\t\t\t\tedges[ a ] = [ b ];\n\t\t\t\treturn true;\n\t\n\t\t\t} else if ( list.indexOf( b ) === -1 ) {\n\t\n\t\t\t\tlist.push( b );\n\t\t\t\treturn true;\n\t\n\t\t\t}\n\t\n\t\t\treturn false;\n\t\n\t\t}\n\t\n\t\tthis.getAttributeBuffer = getAttributeBuffer;\n\t\tthis.getWireframeAttribute = getWireframeAttribute;\n\t\n\t\tthis.update = update;\n\t\n\t};\n\t\n\t// File:src/renderers/webgl/WebGLProgram.js\n\t\n\tTHREE.WebGLProgram = ( function () {\n\t\n\t\tvar programIdCount = 0;\n\t\n\t\tfunction getEncodingComponents( encoding ) {\n\t\n\t\t\tswitch ( encoding ) {\n\t\n\t\t\t\tcase THREE.LinearEncoding:\n\t\t\t\t\treturn [ 'Linear','( value )' ];\n\t\t\t\tcase THREE.sRGBEncoding:\n\t\t\t\t\treturn [ 'sRGB','( value )' ];\n\t\t\t\tcase THREE.RGBEEncoding:\n\t\t\t\t\treturn [ 'RGBE','( value )' ];\n\t\t\t\tcase THREE.RGBM7Encoding:\n\t\t\t\t\treturn [ 'RGBM','( value, 7.0 )' ];\n\t\t\t\tcase THREE.RGBM16Encoding:\n\t\t\t\t\treturn [ 'RGBM','( value, 16.0 )' ];\n\t\t\t\tcase THREE.RGBDEncoding:\n\t\t\t\t\treturn [ 'RGBD','( value, 256.0 )' ];\n\t\t\t\tcase THREE.GammaEncoding:\n\t\t\t\t\treturn [ 'Gamma','( value, float( GAMMA_FACTOR ) )' ];\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'unsupported encoding: ' + encoding );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction getTexelDecodingFunction( functionName, encoding ) {\n\t\n\t\t\tvar components = getEncodingComponents( encoding );\n\t\t\treturn \"vec4 \" + functionName + \"( vec4 value ) { return \" + components[ 0 ] + \"ToLinear\" + components[ 1 ] + \"; }\";\n\t\n\t\t}\n\t\n\t\tfunction getTexelEncodingFunction( functionName, encoding ) {\n\t\n\t\t\tvar components = getEncodingComponents( encoding );\n\t\t\treturn \"vec4 \" + functionName + \"( vec4 value ) { return LinearTo\" + components[ 0 ] + components[ 1 ] + \"; }\";\n\t\n\t\t}\n\t\n\t\tfunction getToneMappingFunction( functionName, toneMapping ) {\n\t\n\t\t\tvar toneMappingName;\n\t\n\t\t\tswitch ( toneMapping ) {\n\t\n\t\t\t\tcase THREE.LinearToneMapping:\n\t\t\t\t\ttoneMappingName = \"Linear\";\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase THREE.ReinhardToneMapping:\n\t\t\t\t\ttoneMappingName = \"Reinhard\";\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase THREE.Uncharted2ToneMapping:\n\t\t\t\t\ttoneMappingName = \"Uncharted2\";\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase THREE.CineonToneMapping:\n\t\t\t\t\ttoneMappingName = \"OptimizedCineon\";\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'unsupported toneMapping: ' + toneMapping );\n\t\n\t\t\t}\n\t\n\t\t\treturn \"vec3 \" + functionName + \"( vec3 color ) { return \" + toneMappingName + \"ToneMapping( color ); }\";\n\t\n\t\t}\n\t\n\t\tfunction generateExtensions( extensions, parameters, rendererExtensions ) {\n\t\n\t\t\textensions = extensions || {};\n\t\n\t\t\tvar chunks = [\n\t\t\t\t( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',\n\t\t\t\t( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',\n\t\t\t\t( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',\n\t\t\t\t( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : '',\n\t\t\t];\n\t\n\t\t\treturn chunks.filter( filterEmptyLine ).join( '\\n' );\n\t\n\t\t}\n\t\n\t\tfunction generateDefines( defines ) {\n\t\n\t\t\tvar chunks = [];\n\t\n\t\t\tfor ( var name in defines ) {\n\t\n\t\t\t\tvar value = defines[ name ];\n\t\n\t\t\t\tif ( value === false ) continue;\n\t\n\t\t\t\tchunks.push( '#define ' + name + ' ' + value );\n\t\n\t\t\t}\n\t\n\t\t\treturn chunks.join( '\\n' );\n\t\n\t\t}\n\t\n\t\tfunction fetchAttributeLocations( gl, program, identifiers ) {\n\t\n\t\t\tvar attributes = {};\n\t\n\t\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );\n\t\n\t\t\tfor ( var i = 0; i < n; i ++ ) {\n\t\n\t\t\t\tvar info = gl.getActiveAttrib( program, i );\n\t\t\t\tvar name = info.name;\n\t\n\t\t\t\t// console.log(\"THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:\", name, i );\n\t\n\t\t\t\tattributes[ name ] = gl.getAttribLocation( program, name );\n\t\n\t\t\t}\n\t\n\t\t\treturn attributes;\n\t\n\t\t}\n\t\n\t\tfunction filterEmptyLine( string ) {\n\t\n\t\t\treturn string !== '';\n\t\n\t\t}\n\t\n\t\tfunction replaceLightNums( string, parameters ) {\n\t\n\t\t\treturn string\n\t\t\t\t.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )\n\t\t\t\t.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )\n\t\t\t\t.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )\n\t\t\t\t.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );\n\t\n\t\t}\n\t\n\t\tfunction parseIncludes( string ) {\n\t\n\t\t\tvar pattern = /#include +<([\\w\\d.]+)>/g;\n\t\n\t\t\tfunction replace( match, include ) {\n\t\n\t\t\t\tvar replace = THREE.ShaderChunk[ include ];\n\t\n\t\t\t\tif ( replace === undefined ) {\n\t\n\t\t\t\t\tthrow new Error( 'Can not resolve #include <' + include + '>' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn parseIncludes( replace );\n\t\n\t\t\t}\n\t\n\t\t\treturn string.replace( pattern, replace );\n\t\n\t\t}\n\t\n\t\tfunction unrollLoops( string ) {\n\t\n\t\t\tvar pattern = /for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g;\n\t\n\t\t\tfunction replace( match, start, end, snippet ) {\n\t\n\t\t\t\tvar unroll = '';\n\t\n\t\t\t\tfor ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {\n\t\n\t\t\t\t\tunroll += snippet.replace( /\\[ i \\]/g, '[ ' + i + ' ]' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn unroll;\n\t\n\t\t\t}\n\t\n\t\t\treturn string.replace( pattern, replace );\n\t\n\t\t}\n\t\n\t\treturn function WebGLProgram( renderer, code, material, parameters ) {\n\t\n\t\t\tvar gl = renderer.context;\n\t\n\t\t\tvar extensions = material.extensions;\n\t\t\tvar defines = material.defines;\n\t\n\t\t\tvar vertexShader = material.__webglShader.vertexShader;\n\t\t\tvar fragmentShader = material.__webglShader.fragmentShader;\n\t\n\t\t\tvar shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\n\t\n\t\t\tif ( parameters.shadowMapType === THREE.PCFShadowMap ) {\n\t\n\t\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\n\t\n\t\t\t} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {\n\t\n\t\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\n\t\n\t\t\t}\n\t\n\t\t\tvar envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\t\tvar envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\n\t\t\tvar envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\t\n\t\t\tif ( parameters.envMap ) {\n\t\n\t\t\t\tswitch ( material.envMap.mapping ) {\n\t\n\t\t\t\t\tcase THREE.CubeReflectionMapping:\n\t\t\t\t\tcase THREE.CubeRefractionMapping:\n\t\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase THREE.CubeUVReflectionMapping:\n\t\t\t\t\tcase THREE.CubeUVRefractionMapping:\n\t\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase THREE.EquirectangularReflectionMapping:\n\t\t\t\t\tcase THREE.EquirectangularRefractionMapping:\n\t\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase THREE.SphericalReflectionMapping:\n\t\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_SPHERE';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tswitch ( material.envMap.mapping ) {\n\t\n\t\t\t\t\tcase THREE.CubeRefractionMapping:\n\t\t\t\t\tcase THREE.EquirectangularRefractionMapping:\n\t\t\t\t\t\tenvMapModeDefine = 'ENVMAP_MODE_REFRACTION';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tswitch ( material.combine ) {\n\t\n\t\t\t\t\tcase THREE.MultiplyOperation:\n\t\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase THREE.MixOperation:\n\t\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase THREE.AddOperation:\n\t\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tvar gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;\n\t\n\t\t\t// console.log( 'building new program ' );\n\t\n\t\t\t//\n\t\n\t\t\tvar customExtensions = generateExtensions( extensions, parameters, renderer.extensions );\n\t\n\t\t\tvar customDefines = generateDefines( defines );\n\t\n\t\t\t//\n\t\n\t\t\tvar program = gl.createProgram();\n\t\n\t\t\tvar prefixVertex, prefixFragment;\n\t\n\t\t\tif ( material instanceof THREE.RawShaderMaterial ) {\n\t\n\t\t\t\tprefixVertex = [\n\t\n\t\t\t\t\tcustomDefines\n\t\n\t\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\t\n\t\t\t\tprefixFragment = [\n\t\n\t\t\t\t\tcustomDefines\n\t\n\t\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tprefixVertex = [\n\t\n\t\t\t\t\t'precision ' + parameters.precision + ' float;',\n\t\t\t\t\t'precision ' + parameters.precision + ' int;',\n\t\n\t\t\t\t\t'#define SHADER_NAME ' + material.__webglShader.name,\n\t\n\t\t\t\t\tcustomDefines,\n\t\n\t\t\t\t\tparameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',\n\t\n\t\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\n\t\n\t\t\t\t\t'#define MAX_BONES ' + parameters.maxBones,\n\t\n\t\t\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\t\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\t\t\tparameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',\n\t\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\t\n\t\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\t\n\t\t\t\t\tparameters.skinning ? '#define USE_SKINNING' : '',\n\t\t\t\t\tparameters.useVertexTexture ? '#define BONE_TEXTURE' : '',\n\t\n\t\t\t\t\tparameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\n\t\t\t\t\tparameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',\n\t\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\t\n\t\t\t\t\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\n\t\n\t\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\t\n\t\t\t\t\tparameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\n\t\n\t\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\t\t\tparameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\t\n\t\t\t\t\t'uniform mat4 modelMatrix;',\n\t\t\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t\t\t'uniform mat3 normalMatrix;',\n\t\t\t\t\t'uniform vec3 cameraPosition;',\n\t\n\t\t\t\t\t'attribute vec3 position;',\n\t\t\t\t\t'attribute vec3 normal;',\n\t\t\t\t\t'attribute vec2 uv;',\n\t\n\t\t\t\t\t'#ifdef USE_COLOR',\n\t\n\t\t\t\t\t'\tattribute vec3 color;',\n\t\n\t\t\t\t\t'#endif',\n\t\n\t\t\t\t\t'#ifdef USE_MORPHTARGETS',\n\t\n\t\t\t\t\t'\tattribute vec3 morphTarget0;',\n\t\t\t\t\t'\tattribute vec3 morphTarget1;',\n\t\t\t\t\t'\tattribute vec3 morphTarget2;',\n\t\t\t\t\t'\tattribute vec3 morphTarget3;',\n\t\n\t\t\t\t\t'\t#ifdef USE_MORPHNORMALS',\n\t\n\t\t\t\t\t'\t\tattribute vec3 morphNormal0;',\n\t\t\t\t\t'\t\tattribute vec3 morphNormal1;',\n\t\t\t\t\t'\t\tattribute vec3 morphNormal2;',\n\t\t\t\t\t'\t\tattribute vec3 morphNormal3;',\n\t\n\t\t\t\t\t'\t#else',\n\t\n\t\t\t\t\t'\t\tattribute vec3 morphTarget4;',\n\t\t\t\t\t'\t\tattribute vec3 morphTarget5;',\n\t\t\t\t\t'\t\tattribute vec3 morphTarget6;',\n\t\t\t\t\t'\t\tattribute vec3 morphTarget7;',\n\t\n\t\t\t\t\t'\t#endif',\n\t\n\t\t\t\t\t'#endif',\n\t\n\t\t\t\t\t'#ifdef USE_SKINNING',\n\t\n\t\t\t\t\t'\tattribute vec4 skinIndex;',\n\t\t\t\t\t'\tattribute vec4 skinWeight;',\n\t\n\t\t\t\t\t'#endif',\n\t\n\t\t\t\t\t'\\n'\n\t\n\t\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\t\n\t\t\t\tprefixFragment = [\n\t\n\t\t\t\t\tcustomExtensions,\n\t\n\t\t\t\t\t'precision ' + parameters.precision + ' float;',\n\t\t\t\t\t'precision ' + parameters.precision + ' int;',\n\t\n\t\t\t\t\t'#define SHADER_NAME ' + material.__webglShader.name,\n\t\n\t\t\t\t\tcustomDefines,\n\t\n\t\t\t\t\tparameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',\n\t\n\t\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\n\t\n\t\t\t\t\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\n\t\t\t\t\t( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\n\t\n\t\t\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\t\t\tparameters.envMap ? '#define ' + envMapTypeDefine : '',\n\t\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\t\t\tparameters.envMap ? '#define ' + envMapBlendingDefine : '',\n\t\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\t\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\t\n\t\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\t\n\t\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\t\n\t\t\t\t\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\n\t\n\t\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\t\n\t\t\t\t\tparameters.premultipliedAlpha ? \"#define PREMULTIPLIED_ALPHA\" : '',\n\t\n\t\t\t\t\tparameters.physicallyCorrectLights ? \"#define PHYSICALLY_CORRECT_LIGHTS\" : '',\n\t\n\t\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\t\t\tparameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\t\n\t\t\t\t\tparameters.envMap && renderer.extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',\n\t\n\t\t\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t\t\t'uniform vec3 cameraPosition;',\n\t\n\t\t\t\t\t( parameters.toneMapping !== THREE.NoToneMapping ) ? \"#define TONE_MAPPING\" : '',\n\t\t\t\t\t( parameters.toneMapping !== THREE.NoToneMapping ) ? THREE.ShaderChunk[ 'tonemapping_pars_fragment' ] : '',  // this code is required here because it is used by the toneMapping() function defined below\n\t\t\t\t\t( parameters.toneMapping !== THREE.NoToneMapping ) ? getToneMappingFunction( \"toneMapping\", parameters.toneMapping ) : '',\n\t\n\t\t\t\t\t( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? THREE.ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below\n\t\t\t\t\tparameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',\n\t\t\t\t\tparameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',\n\t\t\t\t\tparameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',\n\t\t\t\t\tparameters.outputEncoding ? getTexelEncodingFunction( \"linearToOutputTexel\", parameters.outputEncoding ) : '',\n\t\n\t\t\t\t\tparameters.depthPacking ? \"#define DEPTH_PACKING \" + material.depthPacking : '',\n\t\n\t\t\t\t\t'\\n'\n\t\n\t\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\t\n\t\t\t}\n\t\n\t\t\tvertexShader = parseIncludes( vertexShader, parameters );\n\t\t\tvertexShader = replaceLightNums( vertexShader, parameters );\n\t\n\t\t\tfragmentShader = parseIncludes( fragmentShader, parameters );\n\t\t\tfragmentShader = replaceLightNums( fragmentShader, parameters );\n\t\n\t\t\tif ( material instanceof THREE.ShaderMaterial === false ) {\n\t\n\t\t\t\tvertexShader = unrollLoops( vertexShader );\n\t\t\t\tfragmentShader = unrollLoops( fragmentShader );\n\t\n\t\t\t}\n\t\n\t\t\tvar vertexGlsl = prefixVertex + vertexShader;\n\t\t\tvar fragmentGlsl = prefixFragment + fragmentShader;\n\t\n\t\t\t// console.log( '*VERTEX*', vertexGlsl );\n\t\t\t// console.log( '*FRAGMENT*', fragmentGlsl );\n\t\n\t\t\tvar glVertexShader = THREE.WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );\n\t\t\tvar glFragmentShader = THREE.WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );\n\t\n\t\t\tgl.attachShader( program, glVertexShader );\n\t\t\tgl.attachShader( program, glFragmentShader );\n\t\n\t\t\t// Force a particular attribute to index 0.\n\t\n\t\t\tif ( material.index0AttributeName !== undefined ) {\n\t\n\t\t\t\tgl.bindAttribLocation( program, 0, material.index0AttributeName );\n\t\n\t\t\t} else if ( parameters.morphTargets === true ) {\n\t\n\t\t\t\t// programs with morphTargets displace position out of attribute 0\n\t\t\t\tgl.bindAttribLocation( program, 0, 'position' );\n\t\n\t\t\t}\n\t\n\t\t\tgl.linkProgram( program );\n\t\n\t\t\tvar programLog = gl.getProgramInfoLog( program );\n\t\t\tvar vertexLog = gl.getShaderInfoLog( glVertexShader );\n\t\t\tvar fragmentLog = gl.getShaderInfoLog( glFragmentShader );\n\t\n\t\t\tvar runnable = true;\n\t\t\tvar haveDiagnostics = true;\n\t\n\t\t\t// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );\n\t\t\t// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );\n\t\n\t\t\tif ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {\n\t\n\t\t\t\trunnable = false;\n\t\n\t\t\t\tconsole.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );\n\t\n\t\t\t} else if ( programLog !== '' ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );\n\t\n\t\t\t} else if ( vertexLog === '' || fragmentLog === '' ) {\n\t\n\t\t\t\thaveDiagnostics = false;\n\t\n\t\t\t}\n\t\n\t\t\tif ( haveDiagnostics ) {\n\t\n\t\t\t\tthis.diagnostics = {\n\t\n\t\t\t\t\trunnable: runnable,\n\t\t\t\t\tmaterial: material,\n\t\n\t\t\t\t\tprogramLog: programLog,\n\t\n\t\t\t\t\tvertexShader: {\n\t\n\t\t\t\t\t\tlog: vertexLog,\n\t\t\t\t\t\tprefix: prefixVertex\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tfragmentShader: {\n\t\n\t\t\t\t\t\tlog: fragmentLog,\n\t\t\t\t\t\tprefix: prefixFragment\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t}\n\t\n\t\t\t// clean up\n\t\n\t\t\tgl.deleteShader( glVertexShader );\n\t\t\tgl.deleteShader( glFragmentShader );\n\t\n\t\t\t// set up caching for uniform locations\n\t\n\t\t\tvar cachedUniforms;\n\t\n\t\t\tthis.getUniforms = function() {\n\t\n\t\t\t\tif ( cachedUniforms === undefined ) {\n\t\n\t\t\t\t\tcachedUniforms =\n\t\t\t\t\t\t\tnew THREE.WebGLUniforms( gl, program, renderer );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn cachedUniforms;\n\t\n\t\t\t};\n\t\n\t\t\t// set up caching for attribute locations\n\t\n\t\t\tvar cachedAttributes;\n\t\n\t\t\tthis.getAttributes = function() {\n\t\n\t\t\t\tif ( cachedAttributes === undefined ) {\n\t\n\t\t\t\t\tcachedAttributes = fetchAttributeLocations( gl, program );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn cachedAttributes;\n\t\n\t\t\t};\n\t\n\t\t\t// free resource\n\t\n\t\t\tthis.destroy = function() {\n\t\n\t\t\t\tgl.deleteProgram( program );\n\t\t\t\tthis.program = undefined;\n\t\n\t\t\t};\n\t\n\t\t\t// DEPRECATED\n\t\n\t\t\tObject.defineProperties( this, {\n\t\n\t\t\t\tuniforms: {\n\t\t\t\t\tget: function() {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );\n\t\t\t\t\t\treturn this.getUniforms();\n\t\n\t\t\t\t\t}\n\t\t\t\t},\n\t\n\t\t\t\tattributes: {\n\t\t\t\t\tget: function() {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );\n\t\t\t\t\t\treturn this.getAttributes();\n\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t} );\n\t\n\t\n\t\t\t//\n\t\n\t\t\tthis.id = programIdCount ++;\n\t\t\tthis.code = code;\n\t\t\tthis.usedTimes = 1;\n\t\t\tthis.program = program;\n\t\t\tthis.vertexShader = glVertexShader;\n\t\t\tthis.fragmentShader = glFragmentShader;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t} )();\n\t\n\t// File:src/renderers/webgl/WebGLPrograms.js\n\t\n\tTHREE.WebGLPrograms = function ( renderer, capabilities ) {\n\t\n\t\tvar programs = [];\n\t\n\t\tvar shaderIDs = {\n\t\t\tMeshDepthMaterial: 'depth',\n\t\t\tMeshNormalMaterial: 'normal',\n\t\t\tMeshBasicMaterial: 'basic',\n\t\t\tMeshLambertMaterial: 'lambert',\n\t\t\tMeshPhongMaterial: 'phong',\n\t\t\tMeshStandardMaterial: 'physical',\n\t\t\tMeshPhysicalMaterial: 'physical',\n\t\t\tLineBasicMaterial: 'basic',\n\t\t\tLineDashedMaterial: 'dashed',\n\t\t\tPointsMaterial: 'points'\n\t\t};\n\t\n\t\tvar parameterNames = [\n\t\t\t\"precision\", \"supportsVertexTextures\", \"map\", \"mapEncoding\", \"envMap\", \"envMapMode\", \"envMapEncoding\",\n\t\t\t\"lightMap\", \"aoMap\", \"emissiveMap\", \"emissiveMapEncoding\", \"bumpMap\", \"normalMap\", \"displacementMap\", \"specularMap\",\n\t\t\t\"roughnessMap\", \"metalnessMap\",\n\t\t\t\"alphaMap\", \"combine\", \"vertexColors\", \"fog\", \"useFog\", \"fogExp\",\n\t\t\t\"flatShading\", \"sizeAttenuation\", \"logarithmicDepthBuffer\", \"skinning\",\n\t\t\t\"maxBones\", \"useVertexTexture\", \"morphTargets\", \"morphNormals\",\n\t\t\t\"maxMorphTargets\", \"maxMorphNormals\", \"premultipliedAlpha\",\n\t\t\t\"numDirLights\", \"numPointLights\", \"numSpotLights\", \"numHemiLights\",\n\t\t\t\"shadowMapEnabled\", \"shadowMapType\", \"toneMapping\", 'physicallyCorrectLights',\n\t\t\t\"alphaTest\", \"doubleSided\", \"flipSided\", \"numClippingPlanes\", \"depthPacking\"\n\t\t];\n\t\n\t\n\t\tfunction allocateBones ( object ) {\n\t\n\t\t\tif ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {\n\t\n\t\t\t\treturn 1024;\n\t\n\t\t\t} else {\n\t\n\t\t\t\t// default for when object is not specified\n\t\t\t\t// ( for example when prebuilding shader to be used with multiple objects )\n\t\t\t\t//\n\t\t\t\t//  - leave some extra space for other uniforms\n\t\t\t\t//  - limit here is ANGLE's 254 max uniform vectors\n\t\t\t\t//    (up to 54 should be safe)\n\t\n\t\t\t\tvar nVertexUniforms = capabilities.maxVertexUniforms;\n\t\t\t\tvar nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\n\t\n\t\t\t\tvar maxBones = nVertexMatrices;\n\t\n\t\t\t\tif ( object !== undefined && object instanceof THREE.SkinnedMesh ) {\n\t\n\t\t\t\t\tmaxBones = Math.min( object.skeleton.bones.length, maxBones );\n\t\n\t\t\t\t\tif ( maxBones < object.skeleton.bones.length ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn maxBones;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction getTextureEncodingFromMap( map, gammaOverrideLinear ) {\n\t\n\t\t\tvar encoding;\n\t\n\t\t\tif ( ! map ) {\n\t\n\t\t\t\tencoding = THREE.LinearEncoding;\n\t\n\t\t\t} else if ( map instanceof THREE.Texture ) {\n\t\n\t\t\t\tencoding = map.encoding;\n\t\n\t\t\t} else if ( map instanceof THREE.WebGLRenderTarget ) {\n\t\n\t\t\t\tconsole.warn( \"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.\" );\n\t\t\t\tencoding = map.texture.encoding;\n\t\n\t\t\t}\n\t\n\t\t\t// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.\n\t\t\tif ( encoding === THREE.LinearEncoding && gammaOverrideLinear ) {\n\t\n\t\t\t\tencoding = THREE.GammaEncoding;\n\t\n\t\t\t}\n\t\n\t\t\treturn encoding;\n\t\n\t\t}\n\t\n\t\tthis.getParameters = function ( material, lights, fog, nClipPlanes, object ) {\n\t\n\t\t\tvar shaderID = shaderIDs[ material.type ];\n\t\n\t\t\t// heuristics to create shader parameters according to lights in the scene\n\t\t\t// (not to blow over maxLights budget)\n\t\n\t\t\tvar maxBones = allocateBones( object );\n\t\t\tvar precision = renderer.getPrecision();\n\t\n\t\t\tif ( material.precision !== null ) {\n\t\n\t\t\t\tprecision = capabilities.getMaxPrecision( material.precision );\n\t\n\t\t\t\tif ( precision !== material.precision ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tvar currentRenderTarget = renderer.getCurrentRenderTarget();\n\t\n\t\t\tvar parameters = {\n\t\n\t\t\t\tshaderID: shaderID,\n\t\n\t\t\t\tprecision: precision,\n\t\t\t\tsupportsVertexTextures: capabilities.vertexTextures,\n\t\t\t\toutputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),\n\t\t\t\tmap: !! material.map,\n\t\t\t\tmapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),\n\t\t\t\tenvMap: !! material.envMap,\n\t\t\t\tenvMapMode: material.envMap && material.envMap.mapping,\n\t\t\t\tenvMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),\n\t\t\t\tenvMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === THREE.CubeUVReflectionMapping ) || ( material.envMap.mapping === THREE.CubeUVRefractionMapping ) ),\n\t\t\t\tlightMap: !! material.lightMap,\n\t\t\t\taoMap: !! material.aoMap,\n\t\t\t\temissiveMap: !! material.emissiveMap,\n\t\t\t\temissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),\n\t\t\t\tbumpMap: !! material.bumpMap,\n\t\t\t\tnormalMap: !! material.normalMap,\n\t\t\t\tdisplacementMap: !! material.displacementMap,\n\t\t\t\troughnessMap: !! material.roughnessMap,\n\t\t\t\tmetalnessMap: !! material.metalnessMap,\n\t\t\t\tspecularMap: !! material.specularMap,\n\t\t\t\talphaMap: !! material.alphaMap,\n\t\n\t\t\t\tcombine: material.combine,\n\t\n\t\t\t\tvertexColors: material.vertexColors,\n\t\n\t\t\t\tfog: fog,\n\t\t\t\tuseFog: material.fog,\n\t\t\t\tfogExp: fog instanceof THREE.FogExp2,\n\t\n\t\t\t\tflatShading: material.shading === THREE.FlatShading,\n\t\n\t\t\t\tsizeAttenuation: material.sizeAttenuation,\n\t\t\t\tlogarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,\n\t\n\t\t\t\tskinning: material.skinning,\n\t\t\t\tmaxBones: maxBones,\n\t\t\t\tuseVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,\n\t\n\t\t\t\tmorphTargets: material.morphTargets,\n\t\t\t\tmorphNormals: material.morphNormals,\n\t\t\t\tmaxMorphTargets: renderer.maxMorphTargets,\n\t\t\t\tmaxMorphNormals: renderer.maxMorphNormals,\n\t\n\t\t\t\tnumDirLights: lights.directional.length,\n\t\t\t\tnumPointLights: lights.point.length,\n\t\t\t\tnumSpotLights: lights.spot.length,\n\t\t\t\tnumHemiLights: lights.hemi.length,\n\t\n\t\t\t\tnumClippingPlanes: nClipPlanes,\n\t\n\t\t\t\tshadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,\n\t\t\t\tshadowMapType: renderer.shadowMap.type,\n\t\n\t\t\t\ttoneMapping: renderer.toneMapping,\n\t\t\t\tphysicallyCorrectLights: renderer.physicallyCorrectLights,\n\t\n\t\t\t\tpremultipliedAlpha: material.premultipliedAlpha,\n\t\n\t\t\t\talphaTest: material.alphaTest,\n\t\t\t\tdoubleSided: material.side === THREE.DoubleSide,\n\t\t\t\tflipSided: material.side === THREE.BackSide,\n\t\n\t\t\t\tdepthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false\n\t\n\t\t\t};\n\t\n\t\t\treturn parameters;\n\t\n\t\t};\n\t\n\t\tthis.getProgramCode = function ( material, parameters ) {\n\t\n\t\t\tvar array = [];\n\t\n\t\t\tif ( parameters.shaderID ) {\n\t\n\t\t\t\tarray.push( parameters.shaderID );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tarray.push( material.fragmentShader );\n\t\t\t\tarray.push( material.vertexShader );\n\t\n\t\t\t}\n\t\n\t\t\tif ( material.defines !== undefined ) {\n\t\n\t\t\t\tfor ( var name in material.defines ) {\n\t\n\t\t\t\t\tarray.push( name );\n\t\t\t\t\tarray.push( material.defines[ name ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfor ( var i = 0; i < parameterNames.length; i ++ ) {\n\t\n\t\t\t\tarray.push( parameters[ parameterNames[ i ] ] );\n\t\n\t\t\t}\n\t\n\t\t\treturn array.join();\n\t\n\t\t};\n\t\n\t\tthis.acquireProgram = function ( material, parameters, code ) {\n\t\n\t\t\tvar program;\n\t\n\t\t\t// Check if code has been already compiled\n\t\t\tfor ( var p = 0, pl = programs.length; p < pl; p ++ ) {\n\t\n\t\t\t\tvar programInfo = programs[ p ];\n\t\n\t\t\t\tif ( programInfo.code === code ) {\n\t\n\t\t\t\t\tprogram = programInfo;\n\t\t\t\t\t++ program.usedTimes;\n\t\n\t\t\t\t\tbreak;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif ( program === undefined ) {\n\t\n\t\t\t\tprogram = new THREE.WebGLProgram( renderer, code, material, parameters );\n\t\t\t\tprograms.push( program );\n\t\n\t\t\t}\n\t\n\t\t\treturn program;\n\t\n\t\t};\n\t\n\t\tthis.releaseProgram = function( program ) {\n\t\n\t\t\tif ( -- program.usedTimes === 0 ) {\n\t\n\t\t\t\t// Remove from unordered set\n\t\t\t\tvar i = programs.indexOf( program );\n\t\t\t\tprograms[ i ] = programs[ programs.length - 1 ];\n\t\t\t\tprograms.pop();\n\t\n\t\t\t\t// Free WebGL resources\n\t\t\t\tprogram.destroy();\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t// Exposed for resource monitoring & error feedback via renderer.info:\n\t\tthis.programs = programs;\n\t\n\t};\n\t\n\t// File:src/renderers/webgl/WebGLProperties.js\n\t\n\t/**\n\t* @author fordacious / fordacious.github.io\n\t*/\n\t\n\tTHREE.WebGLProperties = function () {\n\t\n\t\tvar properties = {};\n\t\n\t\tthis.get = function ( object ) {\n\t\n\t\t\tvar uuid = object.uuid;\n\t\t\tvar map = properties[ uuid ];\n\t\n\t\t\tif ( map === undefined ) {\n\t\n\t\t\t\tmap = {};\n\t\t\t\tproperties[ uuid ] = map;\n\t\n\t\t\t}\n\t\n\t\t\treturn map;\n\t\n\t\t};\n\t\n\t\tthis.delete = function ( object ) {\n\t\n\t\t\tdelete properties[ object.uuid ];\n\t\n\t\t};\n\t\n\t\tthis.clear = function () {\n\t\n\t\t\tproperties = {};\n\t\n\t\t};\n\t\n\t};\n\t\n\t// File:src/renderers/webgl/WebGLShader.js\n\t\n\tTHREE.WebGLShader = ( function () {\n\t\n\t\tfunction addLineNumbers( string ) {\n\t\n\t\t\tvar lines = string.split( '\\n' );\n\t\n\t\t\tfor ( var i = 0; i < lines.length; i ++ ) {\n\t\n\t\t\t\tlines[ i ] = ( i + 1 ) + ': ' + lines[ i ];\n\t\n\t\t\t}\n\t\n\t\t\treturn lines.join( '\\n' );\n\t\n\t\t}\n\t\n\t\treturn function WebGLShader( gl, type, string ) {\n\t\n\t\t\tvar shader = gl.createShader( type );\n\t\n\t\t\tgl.shaderSource( shader, string );\n\t\t\tgl.compileShader( shader );\n\t\n\t\t\tif ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {\n\t\n\t\t\t\tconsole.error( 'THREE.WebGLShader: Shader couldn\\'t compile.' );\n\t\n\t\t\t}\n\t\n\t\t\tif ( gl.getShaderInfoLog( shader ) !== '' ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );\n\t\n\t\t\t}\n\t\n\t\t\t// --enable-privileged-webgl-extension\n\t\t\t// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\n\t\n\t\t\treturn shader;\n\t\n\t\t};\n\t\n\t} )();\n\t\n\t// File:src/renderers/webgl/WebGLShadowMap.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.WebGLShadowMap = function ( _renderer, _lights, _objects ) {\n\t\n\t\tvar _gl = _renderer.context,\n\t\t_state = _renderer.state,\n\t\t_frustum = new THREE.Frustum(),\n\t\t_projScreenMatrix = new THREE.Matrix4(),\n\t\n\t\t_lightShadows = _lights.shadows,\n\t\n\t\t_shadowMapSize = new THREE.Vector2(),\n\t\n\t\t_lookTarget = new THREE.Vector3(),\n\t\t_lightPositionWorld = new THREE.Vector3(),\n\t\n\t\t_renderList = [],\n\t\n\t\t_MorphingFlag = 1,\n\t\t_SkinningFlag = 2,\n\t\n\t\t_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,\n\t\n\t\t_depthMaterials = new Array( _NumberOfMaterialVariants ),\n\t\t_distanceMaterials = new Array( _NumberOfMaterialVariants ),\n\t\n\t\t_materialCache = {};\n\t\n\t\tvar cubeDirections = [\n\t\t\tnew THREE.Vector3( 1, 0, 0 ), new THREE.Vector3( - 1, 0, 0 ), new THREE.Vector3( 0, 0, 1 ),\n\t\t\tnew THREE.Vector3( 0, 0, - 1 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, - 1, 0 )\n\t\t];\n\t\n\t\tvar cubeUps = [\n\t\t\tnew THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ),\n\t\t\tnew THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 0, 1 ),\tnew THREE.Vector3( 0, 0, - 1 )\n\t\t];\n\t\n\t\tvar cube2DViewPorts = [\n\t\t\tnew THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(),\n\t\t\tnew THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4()\n\t\t];\n\t\n\t\t// init\n\t\n\t\tvar depthMaterialTemplate = new THREE.MeshDepthMaterial();\n\t\tdepthMaterialTemplate.depthPacking = THREE.RGBADepthPacking;\n\t\tdepthMaterialTemplate.clipping = true;\n\t\n\t\tvar distanceShader = THREE.ShaderLib[ \"distanceRGBA\" ];\n\t\tvar distanceUniforms = THREE.UniformsUtils.clone( distanceShader.uniforms );\n\t\n\t\tfor ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {\n\t\n\t\t\tvar useMorphing = ( i & _MorphingFlag ) !== 0;\n\t\t\tvar useSkinning = ( i & _SkinningFlag ) !== 0;\n\t\n\t\t\tvar depthMaterial = depthMaterialTemplate.clone();\n\t\t\tdepthMaterial.morphTargets = useMorphing;\n\t\t\tdepthMaterial.skinning = useSkinning;\n\t\n\t\t\t_depthMaterials[ i ] = depthMaterial;\n\t\n\t\t\tvar distanceMaterial = new THREE.ShaderMaterial( {\n\t\t\t\tdefines: {\n\t\t\t\t\t'USE_SHADOWMAP': ''\n\t\t\t\t},\n\t\t\t\tuniforms: distanceUniforms,\n\t\t\t\tvertexShader: distanceShader.vertexShader,\n\t\t\t\tfragmentShader: distanceShader.fragmentShader,\n\t\t\t\tmorphTargets: useMorphing,\n\t\t\t\tskinning: useSkinning,\n\t\t\t\tclipping: true\n\t\t\t} );\n\t\n\t\t\t_distanceMaterials[ i ] = distanceMaterial;\n\t\n\t\t}\n\t\n\t\t//\n\t\n\t\tvar scope = this;\n\t\n\t\tthis.enabled = false;\n\t\n\t\tthis.autoUpdate = true;\n\t\tthis.needsUpdate = false;\n\t\n\t\tthis.type = THREE.PCFShadowMap;\n\t\n\t\tthis.renderReverseSided = true;\n\t\tthis.renderSingleSided = true;\n\t\n\t\tthis.render = function ( scene, camera ) {\n\t\n\t\t\tif ( scope.enabled === false ) return;\n\t\t\tif ( scope.autoUpdate === false && scope.needsUpdate === false ) return;\n\t\n\t\t\tif ( _lightShadows.length === 0 ) return;\n\t\n\t\t\t// Set GL state for depth map.\n\t\t\t_state.clearColor( 1, 1, 1, 1 );\n\t\t\t_state.disable( _gl.BLEND );\n\t\t\t_state.setDepthTest( true );\n\t\t\t_state.setScissorTest( false );\n\t\n\t\t\t// render depth map\n\t\n\t\t\tvar faceCount, isPointLight;\n\t\n\t\t\tfor ( var i = 0, il = _lightShadows.length; i < il; i ++ ) {\n\t\n\t\t\t\tvar light = _lightShadows[ i ];\n\t\t\t\tvar shadow = light.shadow;\n\t\n\t\t\t\tif ( shadow === undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );\n\t\t\t\t\tcontinue;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar shadowCamera = shadow.camera;\n\t\n\t\t\t\t_shadowMapSize.copy( shadow.mapSize );\n\t\n\t\t\t\tif ( light instanceof THREE.PointLight ) {\n\t\n\t\t\t\t\tfaceCount = 6;\n\t\t\t\t\tisPointLight = true;\n\t\n\t\t\t\t\tvar vpWidth = _shadowMapSize.x;\n\t\t\t\t\tvar vpHeight = _shadowMapSize.y;\n\t\n\t\t\t\t\t// These viewports map a cube-map onto a 2D texture with the\n\t\t\t\t\t// following orientation:\n\t\t\t\t\t//\n\t\t\t\t\t//  xzXZ\n\t\t\t\t\t//   y Y\n\t\t\t\t\t//\n\t\t\t\t\t// X - Positive x direction\n\t\t\t\t\t// x - Negative x direction\n\t\t\t\t\t// Y - Positive y direction\n\t\t\t\t\t// y - Negative y direction\n\t\t\t\t\t// Z - Positive z direction\n\t\t\t\t\t// z - Negative z direction\n\t\n\t\t\t\t\t// positive X\n\t\t\t\t\tcube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t// negative X\n\t\t\t\t\tcube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t// positive Z\n\t\t\t\t\tcube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t// negative Z\n\t\t\t\t\tcube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t// positive Y\n\t\t\t\t\tcube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );\n\t\t\t\t\t// negative Y\n\t\t\t\t\tcube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );\n\t\n\t\t\t\t\t_shadowMapSize.x *= 4.0;\n\t\t\t\t\t_shadowMapSize.y *= 2.0;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tfaceCount = 1;\n\t\t\t\t\tisPointLight = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( shadow.map === null ) {\n\t\n\t\t\t\t\tvar pars = { minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat };\n\t\n\t\t\t\t\tshadow.map = new THREE.WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\n\t\n\t\t\t\t\tshadowCamera.updateProjectionMatrix();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( shadow instanceof THREE.SpotLightShadow ) {\n\t\n\t\t\t\t\tshadow.update( light );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar shadowMap = shadow.map;\n\t\t\t\tvar shadowMatrix = shadow.matrix;\n\t\n\t\t\t\t_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tshadowCamera.position.copy( _lightPositionWorld );\n\t\n\t\t\t\t_renderer.setRenderTarget( shadowMap );\n\t\t\t\t_renderer.clear();\n\t\n\t\t\t\t// render shadow map for each cube face (if omni-directional) or\n\t\t\t\t// run a single pass if not\n\t\n\t\t\t\tfor ( var face = 0; face < faceCount; face ++ ) {\n\t\n\t\t\t\t\tif ( isPointLight ) {\n\t\n\t\t\t\t\t\t_lookTarget.copy( shadowCamera.position );\n\t\t\t\t\t\t_lookTarget.add( cubeDirections[ face ] );\n\t\t\t\t\t\tshadowCamera.up.copy( cubeUps[ face ] );\n\t\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\n\t\n\t\t\t\t\t\tvar vpDimensions = cube2DViewPorts[ face ];\n\t\t\t\t\t\t_state.viewport( vpDimensions );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t_lookTarget.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tshadowCamera.updateMatrixWorld();\n\t\t\t\t\tshadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );\n\t\n\t\t\t\t\t// compute shadow matrix\n\t\n\t\t\t\t\tshadowMatrix.set(\n\t\t\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t\t\t);\n\t\n\t\t\t\t\tshadowMatrix.multiply( shadowCamera.projectionMatrix );\n\t\t\t\t\tshadowMatrix.multiply( shadowCamera.matrixWorldInverse );\n\t\n\t\t\t\t\t// update camera matrices and frustum\n\t\n\t\t\t\t\t_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\n\t\t\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\t\n\t\t\t\t\t// set object matrices & frustum culling\n\t\n\t\t\t\t\t_renderList.length = 0;\n\t\n\t\t\t\t\tprojectObject( scene, camera, shadowCamera );\n\t\n\t\t\t\t\t// render shadow map\n\t\t\t\t\t// render regular objects\n\t\n\t\t\t\t\tfor ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\tvar object = _renderList[ j ];\n\t\t\t\t\t\tvar geometry = _objects.update( object );\n\t\t\t\t\t\tvar material = object.material;\n\t\n\t\t\t\t\t\tif ( material instanceof THREE.MultiMaterial ) {\n\t\n\t\t\t\t\t\t\tvar groups = geometry.groups;\n\t\t\t\t\t\t\tvar materials = material.materials;\n\t\n\t\t\t\t\t\t\tfor ( var k = 0, kl = groups.length; k < kl; k ++ ) {\n\t\n\t\t\t\t\t\t\t\tvar group = groups[ k ];\n\t\t\t\t\t\t\t\tvar groupMaterial = materials[ group.materialIndex ];\n\t\n\t\t\t\t\t\t\t\tif ( groupMaterial.visible === true ) {\n\t\n\t\t\t\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );\n\t\t\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );\n\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// Restore GL state.\n\t\t\tvar clearColor = _renderer.getClearColor(),\n\t\t\tclearAlpha = _renderer.getClearAlpha();\n\t\t\t_renderer.setClearColor( clearColor, clearAlpha );\n\t\n\t\t\tscope.needsUpdate = false;\n\t\n\t\t};\n\t\n\t\tfunction getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {\n\t\n\t\t\tvar geometry = object.geometry;\n\t\n\t\t\tvar result = null;\n\t\n\t\t\tvar materialVariants = _depthMaterials;\n\t\t\tvar customMaterial = object.customDepthMaterial;\n\t\n\t\t\tif ( isPointLight ) {\n\t\n\t\t\t\tmaterialVariants = _distanceMaterials;\n\t\t\t\tcustomMaterial = object.customDistanceMaterial;\n\t\n\t\t\t}\n\t\n\t\t\tif ( ! customMaterial ) {\n\t\n\t\t\t\tvar useMorphing = geometry.morphTargets !== undefined &&\n\t\t\t\t\t\tgeometry.morphTargets.length > 0 && material.morphTargets;\n\t\n\t\t\t\tvar useSkinning = object instanceof THREE.SkinnedMesh && material.skinning;\n\t\n\t\t\t\tvar variantIndex = 0;\n\t\n\t\t\t\tif ( useMorphing ) variantIndex |= _MorphingFlag;\n\t\t\t\tif ( useSkinning ) variantIndex |= _SkinningFlag;\n\t\n\t\t\t\tresult = materialVariants[ variantIndex ];\n\t\n\t\t\t} else {\n\t\n\t\t\t\tresult = customMaterial;\n\t\n\t\t\t}\n\t\n\t\t\tif ( _renderer.localClippingEnabled &&\n\t\t\t\t material.clipShadows === true &&\n\t\t\t\t\tmaterial.clippingPlanes.length !== 0 ) {\n\t\n\t\t\t\t// in this case we need a unique material instance reflecting the\n\t\t\t\t// appropriate state\n\t\n\t\t\t\tvar keyA = result.uuid, keyB = material.uuid;\n\t\n\t\t\t\tvar materialsForVariant = _materialCache[ keyA ];\n\t\n\t\t\t\tif ( materialsForVariant === undefined ) {\n\t\n\t\t\t\t\tmaterialsForVariant = {};\n\t\t\t\t\t_materialCache[ keyA ] = materialsForVariant;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar cachedMaterial = materialsForVariant[ keyB ];\n\t\n\t\t\t\tif ( cachedMaterial === undefined ) {\n\t\n\t\t\t\t\tcachedMaterial = result.clone();\n\t\t\t\t\tmaterialsForVariant[ keyB ] = cachedMaterial;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tresult = cachedMaterial;\n\t\n\t\t\t}\n\t\n\t\t\tresult.visible = material.visible;\n\t\t\tresult.wireframe = material.wireframe;\n\t\n\t\t\tvar side = material.side;\n\t\n\t\t\tif ( scope.renderSingleSided && side == THREE.DoubleSide ) {\n\t\n\t\t\t\tside = THREE.FrontSide;\n\t\n\t\t\t}\n\t\n\t\t\tif ( scope.renderReverseSided ) {\n\t\n\t\t\t\tif ( side === THREE.FrontSide ) side = THREE.BackSide;\n\t\t\t\telse if ( side === THREE.BackSide ) side = THREE.FrontSide;\n\t\n\t\t\t}\n\t\n\t\t\tresult.side = side;\n\t\n\t\t\tresult.clipShadows = material.clipShadows;\n\t\t\tresult.clippingPlanes = material.clippingPlanes;\n\t\n\t\t\tresult.wireframeLinewidth = material.wireframeLinewidth;\n\t\t\tresult.linewidth = material.linewidth;\n\t\n\t\t\tif ( isPointLight && result.uniforms.lightPos !== undefined ) {\n\t\n\t\t\t\tresult.uniforms.lightPos.value.copy( lightPositionWorld );\n\t\n\t\t\t}\n\t\n\t\t\treturn result;\n\t\n\t\t}\n\t\n\t\tfunction projectObject( object, camera, shadowCamera ) {\n\t\n\t\t\tif ( object.visible === false ) return;\n\t\n\t\t\tif ( object.layers.test( camera.layers ) && ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) ) {\n\t\n\t\t\t\tif ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {\n\t\n\t\t\t\t\tvar material = object.material;\n\t\n\t\t\t\t\tif ( material.visible === true ) {\n\t\n\t\t\t\t\t\tobject.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\n\t\t\t\t\t\t_renderList.push( object );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tvar children = object.children;\n\t\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\t\n\t\t\t\tprojectObject( children[ i ], camera, shadowCamera );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/renderers/webgl/WebGLState.js\n\t\n\t/**\n\t* @author mrdoob / http://mrdoob.com/\n\t*/\n\t\n\tTHREE.WebGLState = function ( gl, extensions, paramThreeToGL ) {\n\t\n\t\tvar _this = this;\n\t\n\t\tthis.buffers = {\n\t\t\tcolor: new THREE.WebGLColorBuffer( gl, this ),\n\t\t\tdepth: new THREE.WebGLDepthBuffer( gl, this ),\n\t\t\tstencil: new THREE.WebGLStencilBuffer( gl, this )\n\t\t};\n\t\n\t\tvar maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\t\tvar newAttributes = new Uint8Array( maxVertexAttributes );\n\t\tvar enabledAttributes = new Uint8Array( maxVertexAttributes );\n\t\tvar attributeDivisors = new Uint8Array( maxVertexAttributes );\n\t\n\t\tvar capabilities = {};\n\t\n\t\tvar compressedTextureFormats = null;\n\t\n\t\tvar currentBlending = null;\n\t\tvar currentBlendEquation = null;\n\t\tvar currentBlendSrc = null;\n\t\tvar currentBlendDst = null;\n\t\tvar currentBlendEquationAlpha = null;\n\t\tvar currentBlendSrcAlpha = null;\n\t\tvar currentBlendDstAlpha = null;\n\t\tvar currentPremultipledAlpha = false;\n\t\n\t\tvar currentFlipSided = null;\n\t\tvar currentCullFace = null;\n\t\n\t\tvar currentLineWidth = null;\n\t\n\t\tvar currentPolygonOffsetFactor = null;\n\t\tvar currentPolygonOffsetUnits = null;\n\t\n\t\tvar currentScissorTest = null;\n\t\n\t\tvar maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\n\t\n\t\tvar currentTextureSlot = null;\n\t\tvar currentBoundTextures = {};\n\t\n\t\tvar currentScissor = new THREE.Vector4();\n\t\tvar currentViewport = new THREE.Vector4();\n\t\n\t\tfunction createTexture( type, target, count ) {\n\t\n\t\t\tvar data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.\n\t\t\tvar texture = gl.createTexture();\n\t\n\t\t\tgl.bindTexture( type, texture );\n\t\t\tgl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\t\t\tgl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\t\n\t\t\tfor ( var i = 0; i < count; i ++ ) {\n\t\n\t\t\t\tgl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );\n\t\n\t\t\t}\n\t\n\t\t\treturn texture;\n\t\n\t\t}\n\t\n\t\tvar emptyTextures = {};\n\t\temptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );\n\t\temptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );\n\t\n\t\t//\n\t\n\t\tthis.init = function () {\n\t\n\t\t\tthis.clearColor( 0, 0, 0, 1 );\n\t\t\tthis.clearDepth( 1 );\n\t\t\tthis.clearStencil( 0 );\n\t\n\t\t\tthis.enable( gl.DEPTH_TEST );\n\t\t\tthis.setDepthFunc( THREE.LessEqualDepth );\n\t\n\t\t\tthis.setFlipSided( false );\n\t\t\tthis.setCullFace( THREE.CullFaceBack );\n\t\t\tthis.enable( gl.CULL_FACE );\n\t\n\t\t\tthis.enable( gl.BLEND );\n\t\t\tthis.setBlending( THREE.NormalBlending );\n\t\n\t\t};\n\t\n\t\tthis.initAttributes = function () {\n\t\n\t\t\tfor ( var i = 0, l = newAttributes.length; i < l; i ++ ) {\n\t\n\t\t\t\tnewAttributes[ i ] = 0;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.enableAttribute = function ( attribute ) {\n\t\n\t\t\tnewAttributes[ attribute ] = 1;\n\t\n\t\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\t\n\t\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\t\tenabledAttributes[ attribute ] = 1;\n\t\n\t\t\t}\n\t\n\t\t\tif ( attributeDivisors[ attribute ] !== 0 ) {\n\t\n\t\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\t\n\t\t\t\textension.vertexAttribDivisorANGLE( attribute, 0 );\n\t\t\t\tattributeDivisors[ attribute ] = 0;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.enableAttributeAndDivisor = function ( attribute, meshPerAttribute, extension ) {\n\t\n\t\t\tnewAttributes[ attribute ] = 1;\n\t\n\t\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\t\n\t\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\t\tenabledAttributes[ attribute ] = 1;\n\t\n\t\t\t}\n\t\n\t\t\tif ( attributeDivisors[ attribute ] !== meshPerAttribute ) {\n\t\n\t\t\t\textension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );\n\t\t\t\tattributeDivisors[ attribute ] = meshPerAttribute;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.disableUnusedAttributes = function () {\n\t\n\t\t\tfor ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {\n\t\n\t\t\t\tif ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\n\t\n\t\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\t\tenabledAttributes[ i ] = 0;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.enable = function ( id ) {\n\t\n\t\t\tif ( capabilities[ id ] !== true ) {\n\t\n\t\t\t\tgl.enable( id );\n\t\t\t\tcapabilities[ id ] = true;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.disable = function ( id ) {\n\t\n\t\t\tif ( capabilities[ id ] !== false ) {\n\t\n\t\t\t\tgl.disable( id );\n\t\t\t\tcapabilities[ id ] = false;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.getCompressedTextureFormats = function () {\n\t\n\t\t\tif ( compressedTextureFormats === null ) {\n\t\n\t\t\t\tcompressedTextureFormats = [];\n\t\n\t\t\t\tif ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||\n\t\t\t\t     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||\n\t\t\t\t     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {\n\t\n\t\t\t\t\tvar formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );\n\t\n\t\t\t\t\tfor ( var i = 0; i < formats.length; i ++ ) {\n\t\n\t\t\t\t\t\tcompressedTextureFormats.push( formats[ i ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn compressedTextureFormats;\n\t\n\t\t};\n\t\n\t\tthis.setBlending = function ( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {\n\t\n\t\t\tif ( blending !== THREE.NoBlending ) {\n\t\n\t\t\t\tthis.enable( gl.BLEND );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.disable( gl.BLEND );\n\t\t\t\tcurrentBlending = blending; // no blending, that is\n\t\t\t\treturn;\n\t\n\t\t\t}\n\t\n\t\t\tif ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {\n\t\n\t\t\t\tif ( blending === THREE.AdditiveBlending ) {\n\t\n\t\t\t\t\tif ( premultipliedAlpha ) {\n\t\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( blending === THREE.SubtractiveBlending ) {\n\t\n\t\t\t\t\tif ( premultipliedAlpha ) {\n\t\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( blending === THREE.MultiplyBlending ) {\n\t\n\t\t\t\t\tif ( premultipliedAlpha ) {\n\t\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.SRC_COLOR );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tif ( premultipliedAlpha ) {\n\t\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tcurrentBlending = blending;\n\t\t\t\tcurrentPremultipledAlpha = premultipliedAlpha;\n\t\n\t\t\t}\n\t\n\t\t\tif ( blending === THREE.CustomBlending ) {\n\t\n\t\t\t\tblendEquationAlpha = blendEquationAlpha || blendEquation;\n\t\t\t\tblendSrcAlpha = blendSrcAlpha || blendSrc;\n\t\t\t\tblendDstAlpha = blendDstAlpha || blendDst;\n\t\n\t\t\t\tif ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {\n\t\n\t\t\t\t\tgl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );\n\t\n\t\t\t\t\tcurrentBlendEquation = blendEquation;\n\t\t\t\t\tcurrentBlendEquationAlpha = blendEquationAlpha;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {\n\t\n\t\t\t\t\tgl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );\n\t\n\t\t\t\t\tcurrentBlendSrc = blendSrc;\n\t\t\t\t\tcurrentBlendDst = blendDst;\n\t\t\t\t\tcurrentBlendSrcAlpha = blendSrcAlpha;\n\t\t\t\t\tcurrentBlendDstAlpha = blendDstAlpha;\n\t\n\t\t\t\t}\n\t\n\t\t\t} else {\n\t\n\t\t\t\tcurrentBlendEquation = null;\n\t\t\t\tcurrentBlendSrc = null;\n\t\t\t\tcurrentBlendDst = null;\n\t\t\t\tcurrentBlendEquationAlpha = null;\n\t\t\t\tcurrentBlendSrcAlpha = null;\n\t\t\t\tcurrentBlendDstAlpha = null;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t// TODO Deprecate\n\t\n\t\tthis.setColorWrite = function ( colorWrite ) {\n\t\n\t\t\tthis.buffers.color.setMask( colorWrite );\n\t\n\t\t};\n\t\n\t\tthis.setDepthTest = function ( depthTest ) {\n\t\n\t\t\tthis.buffers.depth.setTest( depthTest );\n\t\n\t\t};\n\t\n\t\tthis.setDepthWrite = function ( depthWrite ) {\n\t\n\t\t\tthis.buffers.depth.setMask( depthWrite );\n\t\n\t\t};\n\t\n\t\tthis.setDepthFunc = function ( depthFunc ) {\n\t\n\t\t\tthis.buffers.depth.setFunc( depthFunc );\n\t\n\t\t};\n\t\n\t\tthis.setStencilTest = function ( stencilTest ) {\n\t\n\t\t\tthis.buffers.stencil.setTest( stencilTest );\n\t\n\t\t};\n\t\n\t\tthis.setStencilWrite = function ( stencilWrite ) {\n\t\n\t\t\tthis.buffers.stencil.setMask( stencilWrite );\n\t\n\t\t};\n\t\n\t\tthis.setStencilFunc = function ( stencilFunc, stencilRef, stencilMask ) {\n\t\n\t\t\tthis.buffers.stencil.setFunc( stencilFunc, stencilRef, stencilMask );\n\t\n\t\t};\n\t\n\t\tthis.setStencilOp = function ( stencilFail, stencilZFail, stencilZPass ) {\n\t\n\t\t\tthis.buffers.stencil.setOp( stencilFail, stencilZFail, stencilZPass );\n\t\n\t\t};\n\t\n\t\t//\n\t\n\t\tthis.setFlipSided = function ( flipSided ) {\n\t\n\t\t\tif ( currentFlipSided !== flipSided ) {\n\t\n\t\t\t\tif ( flipSided ) {\n\t\n\t\t\t\t\tgl.frontFace( gl.CW );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tgl.frontFace( gl.CCW );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tcurrentFlipSided = flipSided;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.setCullFace = function ( cullFace ) {\n\t\n\t\t\tif ( cullFace !== THREE.CullFaceNone ) {\n\t\n\t\t\t\tthis.enable( gl.CULL_FACE );\n\t\n\t\t\t\tif ( cullFace !== currentCullFace ) {\n\t\n\t\t\t\t\tif ( cullFace === THREE.CullFaceBack ) {\n\t\n\t\t\t\t\t\tgl.cullFace( gl.BACK );\n\t\n\t\t\t\t\t} else if ( cullFace === THREE.CullFaceFront ) {\n\t\n\t\t\t\t\t\tgl.cullFace( gl.FRONT );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tgl.cullFace( gl.FRONT_AND_BACK );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.disable( gl.CULL_FACE );\n\t\n\t\t\t}\n\t\n\t\t\tcurrentCullFace = cullFace;\n\t\n\t\t};\n\t\n\t\tthis.setLineWidth = function ( width ) {\n\t\n\t\t\tif ( width !== currentLineWidth ) {\n\t\n\t\t\t\tgl.lineWidth( width );\n\t\n\t\t\t\tcurrentLineWidth = width;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.setPolygonOffset = function ( polygonOffset, factor, units ) {\n\t\n\t\t\tif ( polygonOffset ) {\n\t\n\t\t\t\tthis.enable( gl.POLYGON_OFFSET_FILL );\n\t\n\t\t\t\tif ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {\n\t\n\t\t\t\t\tgl.polygonOffset( factor, units );\n\t\n\t\t\t\t\tcurrentPolygonOffsetFactor = factor;\n\t\t\t\t\tcurrentPolygonOffsetUnits = units;\n\t\n\t\t\t\t}\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.disable( gl.POLYGON_OFFSET_FILL );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.getScissorTest = function () {\n\t\n\t\t\treturn currentScissorTest;\n\t\n\t\t};\n\t\n\t\tthis.setScissorTest = function ( scissorTest ) {\n\t\n\t\t\tcurrentScissorTest = scissorTest;\n\t\n\t\t\tif ( scissorTest ) {\n\t\n\t\t\t\tthis.enable( gl.SCISSOR_TEST );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.disable( gl.SCISSOR_TEST );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t// texture\n\t\n\t\tthis.activeTexture = function ( webglSlot ) {\n\t\n\t\t\tif ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;\n\t\n\t\t\tif ( currentTextureSlot !== webglSlot ) {\n\t\n\t\t\t\tgl.activeTexture( webglSlot );\n\t\t\t\tcurrentTextureSlot = webglSlot;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.bindTexture = function ( webglType, webglTexture ) {\n\t\n\t\t\tif ( currentTextureSlot === null ) {\n\t\n\t\t\t\t_this.activeTexture();\n\t\n\t\t\t}\n\t\n\t\t\tvar boundTexture = currentBoundTextures[ currentTextureSlot ];\n\t\n\t\t\tif ( boundTexture === undefined ) {\n\t\n\t\t\t\tboundTexture = { type: undefined, texture: undefined };\n\t\t\t\tcurrentBoundTextures[ currentTextureSlot ] = boundTexture;\n\t\n\t\t\t}\n\t\n\t\t\tif ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\n\t\n\t\t\t\tgl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );\n\t\n\t\t\t\tboundTexture.type = webglType;\n\t\t\t\tboundTexture.texture = webglTexture;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.compressedTexImage2D = function () {\n\t\n\t\t\ttry {\n\t\n\t\t\t\tgl.compressedTexImage2D.apply( gl, arguments );\n\t\n\t\t\t} catch ( error ) {\n\t\n\t\t\t\tconsole.error( error );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.texImage2D = function () {\n\t\n\t\t\ttry {\n\t\n\t\t\t\tgl.texImage2D.apply( gl, arguments );\n\t\n\t\t\t} catch ( error ) {\n\t\n\t\t\t\tconsole.error( error );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t// TODO Deprecate\n\t\n\t\tthis.clearColor = function ( r, g, b, a ) {\n\t\n\t\t\tthis.buffers.color.setClear( r, g, b, a );\n\t\n\t\t};\n\t\n\t\tthis.clearDepth = function ( depth ) {\n\t\n\t\t\tthis.buffers.depth.setClear( depth );\n\t\n\t\t};\n\t\n\t\tthis.clearStencil = function ( stencil ) {\n\t\n\t\t\tthis.buffers.stencil.setClear( stencil );\n\t\n\t\t};\n\t\n\t\t//\n\t\n\t\tthis.scissor = function ( scissor ) {\n\t\n\t\t\tif ( currentScissor.equals( scissor ) === false ) {\n\t\n\t\t\t\tgl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );\n\t\t\t\tcurrentScissor.copy( scissor );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.viewport = function ( viewport ) {\n\t\n\t\t\tif ( currentViewport.equals( viewport ) === false ) {\n\t\n\t\t\t\tgl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );\n\t\t\t\tcurrentViewport.copy( viewport );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t//\n\t\n\t\tthis.reset = function () {\n\t\n\t\t\tfor ( var i = 0; i < enabledAttributes.length; i ++ ) {\n\t\n\t\t\t\tif ( enabledAttributes[ i ] === 1 ) {\n\t\n\t\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\t\tenabledAttributes[ i ] = 0;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tcapabilities = {};\n\t\n\t\t\tcompressedTextureFormats = null;\n\t\n\t\t\tcurrentTextureSlot = null;\n\t\t\tcurrentBoundTextures = {};\n\t\n\t\t\tcurrentBlending = null;\n\t\n\t\t\tcurrentFlipSided = null;\n\t\t\tcurrentCullFace = null;\n\t\n\t\t\tthis.buffers.color.reset();\n\t\t\tthis.buffers.depth.reset();\n\t\t\tthis.buffers.stencil.reset();\n\t\n\t\t};\n\t\n\t};\n\t\n\tTHREE.WebGLColorBuffer = function ( gl, state ) {\n\t\n\t\tvar locked = false;\n\t\n\t\tvar color = new THREE.Vector4();\n\t\tvar currentColorMask = null;\n\t\tvar currentColorClear = new THREE.Vector4();\n\t\n\t\tthis.setMask = function ( colorMask ) {\n\t\n\t\t\tif ( currentColorMask !== colorMask && ! locked ) {\n\t\n\t\t\t\tgl.colorMask( colorMask, colorMask, colorMask, colorMask );\n\t\t\t\tcurrentColorMask = colorMask;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.setLocked = function ( lock ) {\n\t\n\t\t\tlocked = lock;\n\t\n\t\t};\n\t\n\t\tthis.setClear = function ( r, g, b, a ) {\n\t\n\t\t\tcolor.set( r, g, b, a );\n\t\n\t\t\tif ( currentColorClear.equals( color ) === false ) {\n\t\n\t\t\t\tgl.clearColor( r, g, b, a );\n\t\t\t\tcurrentColorClear.copy( color );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.reset = function () {\n\t\n\t\t\tlocked = false;\n\t\n\t\t\tcurrentColorMask = null;\n\t\t\tcurrentColorClear = new THREE.Vector4();\n\t\n\t\t};\n\t\n\t};\n\t\n\tTHREE.WebGLDepthBuffer = function( gl, state ) {\n\t\n\t\tvar locked = false;\n\t\n\t\tvar currentDepthMask = null;\n\t\tvar currentDepthFunc = null;\n\t\tvar currentDepthClear = null;\n\t\n\t\tthis.setTest = function ( depthTest ) {\n\t\n\t\t\tif ( depthTest ) {\n\t\n\t\t\t\tstate.enable( gl.DEPTH_TEST );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tstate.disable( gl.DEPTH_TEST );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.setMask = function( depthMask ){\n\t\n\t\t\tif ( currentDepthMask !== depthMask && ! locked ) {\n\t\n\t\t\t\tgl.depthMask( depthMask );\n\t\t\t\tcurrentDepthMask = depthMask;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.setFunc = function ( depthFunc ) {\n\t\n\t\t\tif ( currentDepthFunc !== depthFunc ) {\n\t\n\t\t\t\tif ( depthFunc ) {\n\t\n\t\t\t\t\tswitch ( depthFunc ) {\n\t\n\t\t\t\t\t\tcase THREE.NeverDepth:\n\t\n\t\t\t\t\t\t\tgl.depthFunc( gl.NEVER );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase THREE.AlwaysDepth:\n\t\n\t\t\t\t\t\t\tgl.depthFunc( gl.ALWAYS );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase THREE.LessDepth:\n\t\n\t\t\t\t\t\t\tgl.depthFunc( gl.LESS );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase THREE.LessEqualDepth:\n\t\n\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase THREE.EqualDepth:\n\t\n\t\t\t\t\t\t\tgl.depthFunc( gl.EQUAL );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase THREE.GreaterEqualDepth:\n\t\n\t\t\t\t\t\t\tgl.depthFunc( gl.GEQUAL );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase THREE.GreaterDepth:\n\t\n\t\t\t\t\t\t\tgl.depthFunc( gl.GREATER );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase THREE.NotEqualDepth:\n\t\n\t\t\t\t\t\t\tgl.depthFunc( gl.NOTEQUAL );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tdefault:\n\t\n\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tcurrentDepthFunc = depthFunc;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.setLocked = function ( lock ) {\n\t\n\t\t\tlocked = lock;\n\t\n\t\t};\n\t\n\t\tthis.setClear = function ( depth ) {\n\t\n\t\t\tif ( currentDepthClear !== depth ) {\n\t\n\t\t\t\tgl.clearDepth( depth );\n\t\t\t\tcurrentDepthClear = depth;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.reset = function () {\n\t\n\t\t\tlocked = false;\n\t\n\t\t\tcurrentDepthMask = null;\n\t\t\tcurrentDepthFunc = null;\n\t\t\tcurrentDepthClear = null;\n\t\n\t\t};\n\t\n\t};\n\t\n\tTHREE.WebGLStencilBuffer = function ( gl, state ) {\n\t\n\t\tvar locked = false;\n\t\n\t\tvar currentStencilMask = null;\n\t\tvar currentStencilFunc = null;\n\t\tvar currentStencilRef = null;\n\t\tvar currentStencilFuncMask = null;\n\t\tvar currentStencilFail  = null;\n\t\tvar currentStencilZFail = null;\n\t\tvar currentStencilZPass = null;\n\t\tvar currentStencilClear = null;\n\t\n\t\tthis.setTest = function ( stencilTest ) {\n\t\n\t\t\tif ( stencilTest ) {\n\t\n\t\t\t\tstate.enable( gl.STENCIL_TEST );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tstate.disable( gl.STENCIL_TEST );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.setMask = function ( stencilMask ) {\n\t\n\t\t\tif ( currentStencilMask !== stencilMask && ! locked ) {\n\t\n\t\t\t\tgl.stencilMask( stencilMask );\n\t\t\t\tcurrentStencilMask = stencilMask;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.setFunc = function ( stencilFunc, stencilRef, stencilMask ) {\n\t\n\t\t\tif ( currentStencilFunc !== stencilFunc ||\n\t\t\t     currentStencilRef \t!== stencilRef \t||\n\t\t\t     currentStencilFuncMask !== stencilMask ) {\n\t\n\t\t\t\tgl.stencilFunc( stencilFunc,  stencilRef, stencilMask );\n\t\n\t\t\t\tcurrentStencilFunc = stencilFunc;\n\t\t\t\tcurrentStencilRef  = stencilRef;\n\t\t\t\tcurrentStencilFuncMask = stencilMask;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.setOp\t = function ( stencilFail, stencilZFail, stencilZPass ) {\n\t\n\t\t\tif ( currentStencilFail\t !== stencilFail \t||\n\t\t\t     currentStencilZFail !== stencilZFail ||\n\t\t\t     currentStencilZPass !== stencilZPass ) {\n\t\n\t\t\t\tgl.stencilOp( stencilFail,  stencilZFail, stencilZPass );\n\t\n\t\t\t\tcurrentStencilFail  = stencilFail;\n\t\t\t\tcurrentStencilZFail = stencilZFail;\n\t\t\t\tcurrentStencilZPass = stencilZPass;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.setLocked = function ( lock ) {\n\t\n\t\t\tlocked = lock;\n\t\n\t\t};\n\t\n\t\tthis.setClear = function ( stencil ) {\n\t\n\t\t\tif ( currentStencilClear !== stencil ) {\n\t\n\t\t\t\tgl.clearStencil( stencil );\n\t\t\t\tcurrentStencilClear = stencil;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.reset = function () {\n\t\n\t\t\tlocked = false;\n\t\n\t\t\tcurrentStencilMask = null;\n\t\t\tcurrentStencilFunc = null;\n\t\t\tcurrentStencilRef = null;\n\t\t\tcurrentStencilFuncMask = null;\n\t\t\tcurrentStencilFail = null;\n\t\t\tcurrentStencilZFail = null;\n\t\t\tcurrentStencilZPass = null;\n\t\t\tcurrentStencilClear = null;\n\t\n\t\t};\n\t\n\t};\n\t\n\t// File:src/renderers/webgl/WebGLTextures.js\n\t\n\t/**\n\t* @author mrdoob / http://mrdoob.com/\n\t*/\n\t\n\tTHREE.WebGLTextures = function ( _gl, extensions, state, properties, capabilities, paramThreeToGL, info ) {\n\t\n\t\tvar _infoMemory = info.memory;\n\t\tvar _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext );\n\t\n\t\t//\n\t\n\t\tfunction clampToMaxSize ( image, maxSize ) {\n\t\n\t\t\tif ( image.width > maxSize || image.height > maxSize ) {\n\t\n\t\t\t\t// Warning: Scaling through the canvas will only work with images that use\n\t\t\t\t// premultiplied alpha.\n\t\n\t\t\t\tvar scale = maxSize / Math.max( image.width, image.height );\n\t\n\t\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\t\tcanvas.width = Math.floor( image.width * scale );\n\t\t\t\tcanvas.height = Math.floor( image.height * scale );\n\t\n\t\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );\n\t\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\n\t\n\t\t\t\treturn canvas;\n\t\n\t\t\t}\n\t\n\t\t\treturn image;\n\t\n\t\t}\n\t\n\t\tfunction isPowerOfTwo( image ) {\n\t\n\t\t\treturn THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height );\n\t\n\t\t}\n\t\n\t\tfunction makePowerOfTwo( image ) {\n\t\n\t\t\tif ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {\n\t\n\t\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\t\tcanvas.width = THREE.Math.nearestPowerOfTwo( image.width );\n\t\t\t\tcanvas.height = THREE.Math.nearestPowerOfTwo( image.height );\n\t\n\t\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\t\tcontext.drawImage( image, 0, 0, canvas.width, canvas.height );\n\t\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\n\t\n\t\t\t\treturn canvas;\n\t\n\t\t\t}\n\t\n\t\t\treturn image;\n\t\n\t\t}\n\t\n\t\tfunction textureNeedsPowerOfTwo( texture ) {\n\t\n\t\t\tif ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) return true;\n\t\t\tif ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) return true;\n\t\n\t\t\treturn false;\n\t\n\t\t}\n\t\n\t\t// Fallback filters for non-power-of-2 textures\n\t\n\t\tfunction filterFallback ( f ) {\n\t\n\t\t\tif ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {\n\t\n\t\t\t\treturn _gl.NEAREST;\n\t\n\t\t\t}\n\t\n\t\t\treturn _gl.LINEAR;\n\t\n\t\t}\n\t\n\t\t//\n\t\n\t\tfunction onTextureDispose( event ) {\n\t\n\t\t\tvar texture = event.target;\n\t\n\t\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\t\n\t\t\tdeallocateTexture( texture );\n\t\n\t\t\t_infoMemory.textures --;\n\t\n\t\n\t\t}\n\t\n\t\tfunction onRenderTargetDispose( event ) {\n\t\n\t\t\tvar renderTarget = event.target;\n\t\n\t\t\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\n\t\n\t\t\tdeallocateRenderTarget( renderTarget );\n\t\n\t\t\t_infoMemory.textures --;\n\t\n\t\t}\n\t\n\t\t//\n\t\n\t\tfunction deallocateTexture( texture ) {\n\t\n\t\t\tvar textureProperties = properties.get( texture );\n\t\n\t\t\tif ( texture.image && textureProperties.__image__webglTextureCube ) {\n\t\n\t\t\t\t// cube texture\n\t\n\t\t\t\t_gl.deleteTexture( textureProperties.__image__webglTextureCube );\n\t\n\t\t\t} else {\n\t\n\t\t\t\t// 2D texture\n\t\n\t\t\t\tif ( textureProperties.__webglInit === undefined ) return;\n\t\n\t\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\t\n\t\t\t}\n\t\n\t\t\t// remove all webgl properties\n\t\t\tproperties.delete( texture );\n\t\n\t\t}\n\t\n\t\tfunction deallocateRenderTarget( renderTarget ) {\n\t\n\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\t\tvar textureProperties = properties.get( renderTarget.texture );\n\t\n\t\t\tif ( ! renderTarget ) return;\n\t\n\t\t\tif ( textureProperties.__webglTexture !== undefined ) {\n\t\n\t\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\t\n\t\t\t}\n\t\n\t\t\tif ( renderTarget.depthTexture ) {\n\t\n\t\t\t\trenderTarget.depthTexture.dispose();\n\t\n\t\t\t}\n\t\n\t\t\tif ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {\n\t\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t} else {\n\t\n\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );\n\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );\n\t\n\t\t\t}\n\t\n\t\t\tproperties.delete( renderTarget.texture );\n\t\t\tproperties.delete( renderTarget );\n\t\n\t\t}\n\t\n\t\t//\n\t\n\t\n\t\n\t\tfunction setTexture2D( texture, slot ) {\n\t\n\t\t\tvar textureProperties = properties.get( texture );\n\t\n\t\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\t\n\t\t\t\tvar image = texture.image;\n\t\n\t\t\t\tif ( image === undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );\n\t\n\t\t\t\t} else if ( image.complete === false ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tuploadTexture( textureProperties, texture, slot );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\t\n\t\t}\n\t\n\t\tfunction setTextureCube ( texture, slot ) {\n\t\n\t\t\tvar textureProperties = properties.get( texture );\n\t\n\t\t\tif ( texture.image.length === 6 ) {\n\t\n\t\t\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\t\n\t\t\t\t\tif ( ! textureProperties.__image__webglTextureCube ) {\n\t\n\t\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\t\n\t\t\t\t\t\ttextureProperties.__image__webglTextureCube = _gl.createTexture();\n\t\n\t\t\t\t\t\t_infoMemory.textures ++;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\n\t\n\t\t\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\t\n\t\t\t\t\tvar isCompressed = texture instanceof THREE.CompressedTexture;\n\t\t\t\t\tvar isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;\n\t\n\t\t\t\t\tvar cubeImage = [];\n\t\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\t\tif ( ! isCompressed && ! isDataTexture ) {\n\t\n\t\t\t\t\t\t\tcubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tcubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar image = cubeImage[ 0 ],\n\t\t\t\t\tisPowerOfTwoImage = isPowerOfTwo( image ),\n\t\t\t\t\tglFormat = paramThreeToGL( texture.format ),\n\t\t\t\t\tglType = paramThreeToGL( texture.type );\n\t\n\t\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );\n\t\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\t\tif ( ! isCompressed ) {\n\t\n\t\t\t\t\t\t\tif ( isDataTexture ) {\n\t\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tvar mipmap, mipmaps = cubeImage[ i ].mipmaps;\n\t\n\t\t\t\t\t\t\tfor ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\t\t\tmipmap = mipmaps[ j ];\n\t\n\t\t\t\t\t\t\t\tif ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {\n\t\n\t\t\t\t\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\n\t\n\t\t\t\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\t\n\t\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()\" );\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( texture.generateMipmaps && isPowerOfTwoImage ) {\n\t\n\t\t\t\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttextureProperties.__version = texture.version;\n\t\n\t\t\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction setTextureCubeDynamic ( texture, slot ) {\n\t\n\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );\n\t\n\t\t}\n\t\n\t\tfunction setTextureParameters ( textureType, texture, isPowerOfTwoImage ) {\n\t\n\t\t\tvar extension;\n\t\n\t\t\tif ( isPowerOfTwoImage ) {\n\t\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );\n\t\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );\n\t\n\t\t\t} else {\n\t\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\n\t\n\t\t\t\tif ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\n\t\n\t\t\t\tif ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\textension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\t\n\t\t\tif ( extension ) {\n\t\n\t\t\t\tif ( texture.type === THREE.FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;\n\t\t\t\tif ( texture.type === THREE.HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;\n\t\n\t\t\t\tif ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {\n\t\n\t\t\t\t\t_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );\n\t\t\t\t\tproperties.get( texture ).__currentAnisotropy = texture.anisotropy;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction uploadTexture( textureProperties, texture, slot ) {\n\t\n\t\t\tif ( textureProperties.__webglInit === undefined ) {\n\t\n\t\t\t\ttextureProperties.__webglInit = true;\n\t\n\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\t\n\t\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\t\n\t\t\t\t_infoMemory.textures ++;\n\t\n\t\t\t}\n\t\n\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\t\n\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\n\t\n\t\t\tvar image = clampToMaxSize( texture.image, capabilities.maxTextureSize );\n\t\n\t\t\tif ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {\n\t\n\t\t\t\timage = makePowerOfTwo( image );\n\t\n\t\t\t}\n\t\n\t\t\tvar isPowerOfTwoImage = isPowerOfTwo( image ),\n\t\t\tglFormat = paramThreeToGL( texture.format ),\n\t\t\tglType = paramThreeToGL( texture.type );\n\t\n\t\t\tsetTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );\n\t\n\t\t\tvar mipmap, mipmaps = texture.mipmaps;\n\t\n\t\t\tif ( texture instanceof THREE.DepthTexture ) {\n\t\n\t\t\t\t// populate depth texture with dummy data\n\t\n\t\t\t\tvar internalFormat = _gl.DEPTH_COMPONENT;\n\t\n\t\t\t\tif ( texture.type === THREE.FloatType ) {\n\t\n\t\t\t\t\tif ( !_isWebGL2 ) throw new Error('Float Depth Texture only supported in WebGL2.0');\n\t\t\t\t\tinternalFormat = _gl.DEPTH_COMPONENT32F;\n\t\n\t\t\t\t} else if ( _isWebGL2 ) {\n\t\n\t\t\t\t\t// WebGL 2.0 requires signed internalformat for glTexImage2D\n\t\t\t\t\tinternalFormat = _gl.DEPTH_COMPONENT16;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );\n\t\n\t\t\t} else if ( texture instanceof THREE.DataTexture ) {\n\t\n\t\t\t\t// use manually created mipmaps if available\n\t\t\t\t// if there are no manual mipmaps\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\t\n\t\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\n\t\n\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttexture.generateMipmaps = false;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );\n\t\n\t\t\t\t}\n\t\n\t\t\t} else if ( texture instanceof THREE.CompressedTexture ) {\n\t\n\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\n\t\t\t\t\tif ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {\n\t\n\t\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\n\t\n\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()\" );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t} else {\n\t\n\t\t\t\t// regular Texture (image, video, canvas)\n\t\n\t\t\t\t// use manually created mipmaps if available\n\t\t\t\t// if there are no manual mipmaps\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\t\n\t\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\n\t\n\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttexture.generateMipmaps = false;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif ( texture.generateMipmaps && isPowerOfTwoImage ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\t\n\t\t\ttextureProperties.__version = texture.version;\n\t\n\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\t\n\t\t}\n\t\n\t\t// Render targets\n\t\n\t\t// Setup storage for target texture and bind it to correct framebuffer\n\t\tfunction setupFrameBufferTexture ( framebuffer, renderTarget, attachment, textureTarget ) {\n\t\n\t\t\tvar glFormat = paramThreeToGL( renderTarget.texture.format );\n\t\t\tvar glType = paramThreeToGL( renderTarget.texture.type );\n\t\t\tstate.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\t\n\t\t}\n\t\n\t\t// Setup storage for internal depth/stencil buffers and bind to correct framebuffer\n\t\tfunction setupRenderBufferStorage ( renderbuffer, renderTarget ) {\n\t\n\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\n\t\n\t\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\n\t\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );\n\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\t\n\t\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\n\t\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\n\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\t\n\t\t\t} else {\n\t\n\t\t\t\t// FIXME: We don't support !depth !stencil\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );\n\t\n\t\t\t}\n\t\n\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\n\t\n\t\t}\n\t\n\t\t// Setup resources for a Depth Texture for a FBO (needs an extension)\n\t\tfunction setupDepthTexture ( framebuffer, renderTarget ) {\n\t\n\t\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\n\t\t\tif ( isCube ) throw new Error('Depth Texture with cube render targets is not supported!');\n\t\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\n\t\t\tif ( !( renderTarget.depthTexture instanceof THREE.DepthTexture ) ) {\n\t\n\t\t\t\tthrow new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');\n\t\n\t\t\t}\n\t\n\t\t\t// upload an empty depth texture with framebuffer size\n\t\t\tif ( !properties.get( renderTarget.depthTexture ).__webglTexture ||\n\t\t\t\t\trenderTarget.depthTexture.image.width !== renderTarget.width ||\n\t\t\t\t\trenderTarget.depthTexture.image.height !== renderTarget.height ) {\n\t\t\t\trenderTarget.depthTexture.image.width = renderTarget.width;\n\t\t\t\trenderTarget.depthTexture.image.height = renderTarget.height;\n\t\t\t\trenderTarget.depthTexture.needsUpdate = true;\n\t\t\t}\n\t\n\t\t\tsetTexture2D( renderTarget.depthTexture, 0 );\n\t\n\t\t\tvar webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;\n\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\n\t\n\t\t}\n\t\n\t\t// Setup GL resources for a non-texture depth buffer\n\t\tfunction setupDepthRenderbuffer( renderTarget ) {\n\t\n\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\n\t\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\n\t\n\t\t\tif ( renderTarget.depthTexture ) {\n\t\n\t\t\t\tif ( isCube ) throw new Error('target.depthTexture not supported in Cube render targets');\n\t\n\t\t\t\tsetupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tif ( isCube ) {\n\t\n\t\t\t\t\trenderTargetProperties.__webglDepthbuffer = [];\n\t\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\t\t\trenderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();\n\t\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\n\t\t\t\t\trenderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\n\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\t\n\t\t}\n\t\n\t\t// Set up GL resources for the render target\n\t\tfunction setupRenderTarget( renderTarget ) {\n\t\n\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\t\tvar textureProperties = properties.get( renderTarget.texture );\n\t\n\t\t\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\n\t\n\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\t\n\t\t\t_infoMemory.textures ++;\n\t\n\t\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\n\t\t\tvar isTargetPowerOfTwo = isPowerOfTwo( renderTarget );\n\t\n\t\t\t// Setup framebuffer\n\t\n\t\t\tif ( isCube ) {\n\t\n\t\t\t\trenderTargetProperties.__webglFramebuffer = [];\n\t\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\trenderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();\n\t\n\t\t\t\t}\n\t\n\t\t\t} else {\n\t\n\t\t\t\trenderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\n\t\n\t\t\t}\n\t\n\t\t\t// Setup color buffer\n\t\n\t\t\tif ( isCube ) {\n\t\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );\n\t\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );\n\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );\n\t\n\t\t\t\tif ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_2D, null );\n\t\n\t\t\t}\n\t\n\t\t\t// Setup depth and stencil buffers\n\t\n\t\t\tif ( renderTarget.depthBuffer ) {\n\t\n\t\t\t\tsetupDepthRenderbuffer( renderTarget );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction updateRenderTargetMipmap( renderTarget ) {\n\t\n\t\t\tvar texture = renderTarget.texture;\n\t\n\t\t\tif ( texture.generateMipmaps && isPowerOfTwo( renderTarget ) &&\n\t\t\t\t\ttexture.minFilter !== THREE.NearestFilter &&\n\t\t\t\t\ttexture.minFilter !== THREE.LinearFilter ) {\n\t\n\t\t\t\tvar target = renderTarget instanceof THREE.WebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;\n\t\t\t\tvar webglTexture = properties.get( texture ).__webglTexture;\n\t\n\t\t\t\tstate.bindTexture( target, webglTexture );\n\t\t\t\t_gl.generateMipmap( target );\n\t\t\t\tstate.bindTexture( target, null );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tthis.setTexture2D = setTexture2D;\n\t\tthis.setTextureCube = setTextureCube;\n\t\tthis.setTextureCubeDynamic = setTextureCubeDynamic;\n\t\tthis.setupRenderTarget = setupRenderTarget;\n\t\tthis.updateRenderTargetMipmap = updateRenderTargetMipmap;\n\t\n\t};\n\t\n\t// File:src/renderers/webgl/WebGLUniforms.js\n\t\n\t/**\n\t *\n\t * Uniforms of a program.\n\t * Those form a tree structure with a special top-level container for the root,\n\t * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.\n\t *\n\t *\n\t * Properties of inner nodes including the top-level container:\n\t *\n\t * .seq - array of nested uniforms\n\t * .map - nested uniforms by name\n\t *\n\t *\n\t * Methods of all nodes except the top-level container:\n\t *\n\t * .setValue( gl, value, [renderer] )\n\t *\n\t * \t\tuploads a uniform value(s)\n\t *  \tthe 'renderer' parameter is needed for sampler uniforms\n\t *\n\t *\n\t * Static methods of the top-level container (renderer factorizations):\n\t *\n\t * .upload( gl, seq, values, renderer )\n\t *\n\t * \t\tsets uniforms in 'seq' to 'values[id].value'\n\t *\n\t * .seqWithValue( seq, values ) : filteredSeq\n\t *\n\t * \t\tfilters 'seq' entries with corresponding entry in values\n\t *\n\t * .splitDynamic( seq, values ) : filteredSeq\n\t *\n\t * \t\tfilters 'seq' entries with dynamic entry and removes them from 'seq'\n\t *\n\t *\n\t * Methods of the top-level container (renderer factorizations):\n\t *\n\t * .setValue( gl, name, value )\n\t *\n\t * \t\tsets uniform with  name 'name' to 'value'\n\t *\n\t * .set( gl, obj, prop )\n\t *\n\t * \t\tsets uniform from object and property with same name than uniform\n\t *\n\t * .setOptional( gl, obj, prop )\n\t *\n\t * \t\tlike .set for an optional property of the object\n\t *\n\t *\n\t * @author tschw\n\t *\n\t */\n\t\n\tTHREE.WebGLUniforms = ( function() { // scope\n\t\n\t\tvar emptyTexture = new THREE.Texture();\n\t\tvar emptyCubeTexture = new THREE.CubeTexture();\n\t\n\t\t// --- Base for inner nodes (including the root) ---\n\t\n\t\tvar UniformContainer = function() {\n\t\n\t\t\t\tthis.seq = [];\n\t\t\t\tthis.map = {};\n\t\n\t\t\t},\n\t\n\t\t// --- Utilities ---\n\t\n\t\t// Array Caches (provide typed arrays for temporary by size)\n\t\n\t\t\tarrayCacheF32 = [],\n\t\t\tarrayCacheI32 = [],\n\t\n\t\t\tuncacheTemporaryArrays = function() {\n\t\n\t\t\t\tarrayCacheF32.length = 0;\n\t\t\t\tarrayCacheI32.length = 0;\n\t\n\t\t\t},\n\t\n\t\t// Flattening for arrays of vectors and matrices\n\t\n\t\t\tflatten = function( array, nBlocks, blockSize ) {\n\t\n\t\t\t\tvar firstElem = array[ 0 ];\n\t\n\t\t\t\tif ( firstElem <= 0 || firstElem > 0 ) return array;\n\t\t\t\t// unoptimized: ! isNaN( firstElem )\n\t\t\t\t// see http://jacksondunstan.com/articles/983\n\t\n\t\t\t\tvar n = nBlocks * blockSize,\n\t\t\t\t\tr = arrayCacheF32[ n ];\n\t\n\t\t\t\tif ( r === undefined ) {\n\t\n\t\t\t\t\tr = new Float32Array( n );\n\t\t\t\t\tarrayCacheF32[ n ] = r;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( nBlocks !== 0 ) {\n\t\n\t\t\t\t\tfirstElem.toArray( r, 0 );\n\t\n\t\t\t\t\tfor ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {\n\t\n\t\t\t\t\t\toffset += blockSize;\n\t\t\t\t\t\tarray[ i ].toArray( r, offset );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn r;\n\t\n\t\t\t},\n\t\n\t\t// Texture unit allocation\n\t\n\t\t\tallocTexUnits = function( renderer, n ) {\n\t\n\t\t\t\tvar r = arrayCacheI32[ n ];\n\t\n\t\t\t\tif ( r === undefined ) {\n\t\n\t\t\t\t\tr = new Int32Array( n );\n\t\t\t\t\tarrayCacheI32[ n ] = r;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var i = 0; i !== n; ++ i )\n\t\t\t\t\tr[ i ] = renderer.allocTextureUnit();\n\t\n\t\t\t\treturn r;\n\t\n\t\t\t},\n\t\n\t\t// --- Setters ---\n\t\n\t\t// Note: Defining these methods externally, because they come in a bunch\n\t\t// and this way their names minify.\n\t\n\t\t\t// Single scalar\n\t\n\t\t\tsetValue1f = function( gl, v ) { gl.uniform1f( this.addr, v ); },\n\t\t\tsetValue1i = function( gl, v ) { gl.uniform1i( this.addr, v ); },\n\t\n\t\t\t// Single float vector (from flat array or THREE.VectorN)\n\t\n\t\t\tsetValue2fv = function( gl, v ) {\n\t\n\t\t\t\tif ( v.x === undefined ) gl.uniform2fv( this.addr, v );\n\t\t\t\telse gl.uniform2f( this.addr, v.x, v.y );\n\t\n\t\t\t},\n\t\n\t\t\tsetValue3fv = function( gl, v ) {\n\t\n\t\t\t\tif ( v.x !== undefined )\n\t\t\t\t\tgl.uniform3f( this.addr, v.x, v.y, v.z );\n\t\t\t\telse if ( v.r !== undefined )\n\t\t\t\t\tgl.uniform3f( this.addr, v.r, v.g, v.b );\n\t\t\t\telse\n\t\t\t\t\tgl.uniform3fv( this.addr, v );\n\t\n\t\t\t},\n\t\n\t\t\tsetValue4fv = function( gl, v ) {\n\t\n\t\t\t\tif ( v.x === undefined ) gl.uniform4fv( this.addr, v );\n\t\t\t\telse gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );\n\t\n\t\t\t},\n\t\n\t\t\t// Single matrix (from flat array or MatrixN)\n\t\n\t\t\tsetValue2fm = function( gl, v ) {\n\t\n\t\t\t\tgl.uniformMatrix2fv( this.addr, false, v.elements || v );\n\t\n\t\t\t},\n\t\n\t\t\tsetValue3fm = function( gl, v ) {\n\t\n\t\t\t\tgl.uniformMatrix3fv( this.addr, false, v.elements || v );\n\t\n\t\t\t},\n\t\n\t\t\tsetValue4fm = function( gl, v ) {\n\t\n\t\t\t\tgl.uniformMatrix4fv( this.addr, false, v.elements || v );\n\t\n\t\t\t},\n\t\n\t\t\t// Single texture (2D / Cube)\n\t\n\t\t\tsetValueT1 = function( gl, v, renderer ) {\n\t\n\t\t\t\tvar unit = renderer.allocTextureUnit();\n\t\t\t\tgl.uniform1i( this.addr, unit );\n\t\t\t\trenderer.setTexture2D( v || emptyTexture, unit );\n\t\n\t\t\t},\n\t\n\t\t\tsetValueT6 = function( gl, v, renderer ) {\n\t\n\t\t\t\tvar unit = renderer.allocTextureUnit();\n\t\t\t\tgl.uniform1i( this.addr, unit );\n\t\t\t\trenderer.setTextureCube( v || emptyCubeTexture, unit );\n\t\n\t\t\t},\n\t\n\t\t\t// Integer / Boolean vectors or arrays thereof (always flat arrays)\n\t\n\t\t\tsetValue2iv = function( gl, v ) { gl.uniform2iv( this.addr, v ); },\n\t\t\tsetValue3iv = function( gl, v ) { gl.uniform3iv( this.addr, v ); },\n\t\t\tsetValue4iv = function( gl, v ) { gl.uniform4iv( this.addr, v ); },\n\t\n\t\t\t// Helper to pick the right setter for the singular case\n\t\n\t\t\tgetSingularSetter = function( type ) {\n\t\n\t\t\t\tswitch ( type ) {\n\t\n\t\t\t\t\tcase 0x1406: return setValue1f; // FLOAT\n\t\t\t\t\tcase 0x8b50: return setValue2fv; // _VEC2\n\t\t\t\t\tcase 0x8b51: return setValue3fv; // _VEC3\n\t\t\t\t\tcase 0x8b52: return setValue4fv; // _VEC4\n\t\n\t\t\t\t\tcase 0x8b5a: return setValue2fm; // _MAT2\n\t\t\t\t\tcase 0x8b5b: return setValue3fm; // _MAT3\n\t\t\t\t\tcase 0x8b5c: return setValue4fm; // _MAT4\n\t\n\t\t\t\t\tcase 0x8b5e: return setValueT1; // SAMPLER_2D\n\t\t\t\t\tcase 0x8b60: return setValueT6; // SAMPLER_CUBE\n\t\n\t\t\t\t\tcase 0x1404: case 0x8b56: return setValue1i; // INT, BOOL\n\t\t\t\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\n\t\t\t\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\n\t\t\t\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t// Array of scalars\n\t\n\t\t\tsetValue1fv = function( gl, v ) { gl.uniform1fv( this.addr, v ); },\n\t\t\tsetValue1iv = function( gl, v ) { gl.uniform1iv( this.addr, v ); },\n\t\n\t\t\t// Array of vectors (flat or from THREE classes)\n\t\n\t\t\tsetValueV2a = function( gl, v ) {\n\t\n\t\t\t\tgl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );\n\t\n\t\t\t},\n\t\n\t\t\tsetValueV3a = function( gl, v ) {\n\t\n\t\t\t\tgl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );\n\t\n\t\t\t},\n\t\n\t\t\tsetValueV4a = function( gl, v ) {\n\t\n\t\t\t\tgl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );\n\t\n\t\t\t},\n\t\n\t\t\t// Array of matrices (flat or from THREE clases)\n\t\n\t\t\tsetValueM2a = function( gl, v ) {\n\t\n\t\t\t\tgl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );\n\t\n\t\t\t},\n\t\n\t\t\tsetValueM3a = function( gl, v ) {\n\t\n\t\t\t\tgl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );\n\t\n\t\t\t},\n\t\n\t\t\tsetValueM4a = function( gl, v ) {\n\t\n\t\t\t\tgl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );\n\t\n\t\t\t},\n\t\n\t\t\t// Array of textures (2D / Cube)\n\t\n\t\t\tsetValueT1a = function( gl, v, renderer ) {\n\t\n\t\t\t\tvar n = v.length,\n\t\t\t\t\tunits = allocTexUnits( renderer, n );\n\t\n\t\t\t\tgl.uniform1iv( this.addr, units );\n\t\n\t\t\t\tfor ( var i = 0; i !== n; ++ i ) {\n\t\n\t\t\t\t\trenderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tsetValueT6a = function( gl, v, renderer ) {\n\t\n\t\t\t\tvar n = v.length,\n\t\t\t\t\tunits = allocTexUnits( renderer, n );\n\t\n\t\t\t\tgl.uniform1iv( this.addr, units );\n\t\n\t\t\t\tfor ( var i = 0; i !== n; ++ i ) {\n\t\n\t\t\t\t\trenderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\n\t\t\t// Helper to pick the right setter for a pure (bottom-level) array\n\t\n\t\t\tgetPureArraySetter = function( type ) {\n\t\n\t\t\t\tswitch ( type ) {\n\t\n\t\t\t\t\tcase 0x1406: return setValue1fv; // FLOAT\n\t\t\t\t\tcase 0x8b50: return setValueV2a; // _VEC2\n\t\t\t\t\tcase 0x8b51: return setValueV3a; // _VEC3\n\t\t\t\t\tcase 0x8b52: return setValueV4a; // _VEC4\n\t\n\t\t\t\t\tcase 0x8b5a: return setValueM2a; // _MAT2\n\t\t\t\t\tcase 0x8b5b: return setValueM3a; // _MAT3\n\t\t\t\t\tcase 0x8b5c: return setValueM4a; // _MAT4\n\t\n\t\t\t\t\tcase 0x8b5e: return setValueT1a; // SAMPLER_2D\n\t\t\t\t\tcase 0x8b60: return setValueT6a; // SAMPLER_CUBE\n\t\n\t\t\t\t\tcase 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL\n\t\t\t\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\n\t\t\t\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\n\t\t\t\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t// --- Uniform Classes ---\n\t\n\t\t\tSingleUniform = function SingleUniform( id, activeInfo, addr ) {\n\t\n\t\t\t\tthis.id = id;\n\t\t\t\tthis.addr = addr;\n\t\t\t\tthis.setValue = getSingularSetter( activeInfo.type );\n\t\n\t\t\t\t// this.path = activeInfo.name; // DEBUG\n\t\n\t\t\t},\n\t\n\t\t\tPureArrayUniform = function( id, activeInfo, addr ) {\n\t\n\t\t\t\tthis.id = id;\n\t\t\t\tthis.addr = addr;\n\t\t\t\tthis.size = activeInfo.size;\n\t\t\t\tthis.setValue = getPureArraySetter( activeInfo.type );\n\t\n\t\t\t\t// this.path = activeInfo.name; // DEBUG\n\t\n\t\t\t},\n\t\n\t\t\tStructuredUniform = function( id ) {\n\t\n\t\t\t\tthis.id = id;\n\t\n\t\t\t\tUniformContainer.call( this ); // mix-in\n\t\n\t\t\t};\n\t\n\t\tStructuredUniform.prototype.setValue = function( gl, value ) {\n\t\n\t\t\t// Note: Don't need an extra 'renderer' parameter, since samplers\n\t\t\t// are not allowed in structured uniforms.\n\t\n\t\t\tvar seq = this.seq;\n\t\n\t\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\t\n\t\t\t\tvar u = seq[ i ];\n\t\t\t\tu.setValue( gl, value[ u.id ] );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t// --- Top-level ---\n\t\n\t\t// Parser - builds up the property tree from the path strings\n\t\n\t\tvar RePathPart = /([\\w\\d_]+)(\\])?(\\[|\\.)?/g,\n\t\t\t// extracts\n\t\t\t// \t- the identifier (member name or array index)\n\t\t\t//  - followed by an optional right bracket (found when array index)\n\t\t\t//  - followed by an optional left bracket or dot (type of subscript)\n\t\t\t//\n\t\t\t// Note: These portions can be read in a non-overlapping fashion and\n\t\t\t// allow straightforward parsing of the hierarchy that WebGL encodes\n\t\t\t// in the uniform names.\n\t\n\t\t\taddUniform = function( container, uniformObject ) {\n\t\n\t\t\t\tcontainer.seq.push( uniformObject );\n\t\t\t\tcontainer.map[ uniformObject.id ] = uniformObject;\n\t\n\t\t\t},\n\t\n\t\t\tparseUniform = function( activeInfo, addr, container ) {\n\t\n\t\t\t\tvar path = activeInfo.name,\n\t\t\t\t\tpathLength = path.length;\n\t\n\t\t\t\t// reset RegExp object, because of the early exit of a previous run\n\t\t\t\tRePathPart.lastIndex = 0;\n\t\n\t\t\t\tfor (; ;) {\n\t\n\t\t\t\t\tvar match = RePathPart.exec( path ),\n\t\t\t\t\t\tmatchEnd = RePathPart.lastIndex,\n\t\n\t\t\t\t\t\tid = match[ 1 ],\n\t\t\t\t\t\tidIsIndex = match[ 2 ] === ']',\n\t\t\t\t\t\tsubscript = match[ 3 ];\n\t\n\t\t\t\t\tif ( idIsIndex ) id = id | 0; // convert to integer\n\t\n\t\t\t\t\tif ( subscript === undefined ||\n\t\t\t\t\t\t\tsubscript === '[' && matchEnd + 2 === pathLength ) {\n\t\t\t\t\t\t// bare name or \"pure\" bottom-level array \"[0]\" suffix\n\t\n\t\t\t\t\t\taddUniform( container, subscript === undefined ?\n\t\t\t\t\t\t\t\tnew SingleUniform( id, activeInfo, addr ) :\n\t\t\t\t\t\t\t\tnew PureArrayUniform( id, activeInfo, addr ) );\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// step into inner node / create it in case it doesn't exist\n\t\n\t\t\t\t\t\tvar map = container.map,\n\t\t\t\t\t\t\tnext = map[ id ];\n\t\n\t\t\t\t\t\tif ( next === undefined ) {\n\t\n\t\t\t\t\t\t\tnext = new StructuredUniform( id );\n\t\t\t\t\t\t\taddUniform( container, next );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tcontainer = next;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t// Root Container\n\t\n\t\t\tWebGLUniforms = function WebGLUniforms( gl, program, renderer ) {\n\t\n\t\t\t\tUniformContainer.call( this );\n\t\n\t\t\t\tthis.renderer = renderer;\n\t\n\t\t\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );\n\t\n\t\t\t\tfor ( var i = 0; i !== n; ++ i ) {\n\t\n\t\t\t\t\tvar info = gl.getActiveUniform( program, i ),\n\t\t\t\t\t\tpath = info.name,\n\t\t\t\t\t\taddr = gl.getUniformLocation( program, path );\n\t\n\t\t\t\t\tparseUniform( info, addr, this );\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\n\t\tWebGLUniforms.prototype.setValue = function( gl, name, value ) {\n\t\n\t\t\tvar u = this.map[ name ];\n\t\n\t\t\tif ( u !== undefined ) u.setValue( gl, value, this.renderer );\n\t\n\t\t};\n\t\n\t\tWebGLUniforms.prototype.set = function( gl, object, name ) {\n\t\n\t\t\tvar u = this.map[ name ];\n\t\n\t\t\tif ( u !== undefined ) u.setValue( gl, object[ name ], this.renderer );\n\t\n\t\t};\n\t\n\t\tWebGLUniforms.prototype.setOptional = function( gl, object, name ) {\n\t\n\t\t\tvar v = object[ name ];\n\t\n\t\t\tif ( v !== undefined ) this.setValue( gl, name, v );\n\t\n\t\t};\n\t\n\t\n\t\t// Static interface\n\t\n\t\tWebGLUniforms.upload = function( gl, seq, values, renderer ) {\n\t\n\t\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\t\n\t\t\t\tvar u = seq[ i ],\n\t\t\t\t\tv = values[ u.id ];\n\t\n\t\t\t\tif ( v.needsUpdate !== false ) {\n\t\t\t\t\t// note: always updating when .needsUpdate is undefined\n\t\n\t\t\t\t\tu.setValue( gl, v.value, renderer );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tWebGLUniforms.seqWithValue = function( seq, values ) {\n\t\n\t\t\tvar r = [];\n\t\n\t\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\t\n\t\t\t\tvar u = seq[ i ];\n\t\t\t\tif ( u.id in values ) r.push( u );\n\t\n\t\t\t}\n\t\n\t\t\treturn r;\n\t\n\t\t};\n\t\n\t\tWebGLUniforms.splitDynamic = function( seq, values ) {\n\t\n\t\t\tvar r = null,\n\t\t\t\tn = seq.length,\n\t\t\t\tw = 0;\n\t\n\t\t\tfor ( var i = 0; i !== n; ++ i ) {\n\t\n\t\t\t\tvar u = seq[ i ],\n\t\t\t\t\tv = values[ u.id ];\n\t\n\t\t\t\tif ( v && v.dynamic === true ) {\n\t\n\t\t\t\t\tif ( r === null ) r = [];\n\t\t\t\t\tr.push( u );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// in-place compact 'seq', removing the matches\n\t\t\t\t\tif ( w < i ) seq[ w ] = u;\n\t\t\t\t\t++ w;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif ( w < n ) seq.length = w;\n\t\n\t\t\treturn r;\n\t\n\t\t};\n\t\n\t\tWebGLUniforms.evalDynamic = function( seq, values, object, camera ) {\n\t\n\t\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\t\n\t\t\t\tvar v = values[ seq[ i ].id ],\n\t\t\t\t\tf = v.onUpdateCallback;\n\t\n\t\t\t\tif ( f !== undefined ) f.call( v, object, camera );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\treturn WebGLUniforms;\n\t\n\t} )();\n\t\n\t// File:src/renderers/webgl/plugins/LensFlarePlugin.js\n\t\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.LensFlarePlugin = function ( renderer, flares ) {\n\t\n\t\tvar gl = renderer.context;\n\t\tvar state = renderer.state;\n\t\n\t\tvar vertexBuffer, elementBuffer;\n\t\tvar shader, program, attributes, uniforms;\n\t\n\t\tvar tempTexture, occlusionTexture;\n\t\n\t\tfunction init() {\n\t\n\t\t\tvar vertices = new Float32Array( [\n\t\t\t\t- 1, - 1,  0, 0,\n\t\t\t\t 1, - 1,  1, 0,\n\t\t\t\t 1,  1,  1, 1,\n\t\t\t\t- 1,  1,  0, 1\n\t\t\t] );\n\t\n\t\t\tvar faces = new Uint16Array( [\n\t\t\t\t0, 1, 2,\n\t\t\t\t0, 2, 3\n\t\t\t] );\n\t\n\t\t\t// buffers\n\t\n\t\t\tvertexBuffer     = gl.createBuffer();\n\t\t\telementBuffer    = gl.createBuffer();\n\t\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\n\t\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\n\t\n\t\t\t// textures\n\t\n\t\t\ttempTexture      = gl.createTexture();\n\t\t\tocclusionTexture = gl.createTexture();\n\t\n\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\t\n\t\t\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\n\t\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\t\n\t\t\tshader = {\n\t\n\t\t\t\tvertexShader: [\n\t\n\t\t\t\t\t\"uniform lowp int renderType;\",\n\t\n\t\t\t\t\t\"uniform vec3 screenPosition;\",\n\t\t\t\t\t\"uniform vec2 scale;\",\n\t\t\t\t\t\"uniform float rotation;\",\n\t\n\t\t\t\t\t\"uniform sampler2D occlusionMap;\",\n\t\n\t\t\t\t\t\"attribute vec2 position;\",\n\t\t\t\t\t\"attribute vec2 uv;\",\n\t\n\t\t\t\t\t\"varying vec2 vUV;\",\n\t\t\t\t\t\"varying float vVisibility;\",\n\t\n\t\t\t\t\t\"void main() {\",\n\t\n\t\t\t\t\t\t\"vUV = uv;\",\n\t\n\t\t\t\t\t\t\"vec2 pos = position;\",\n\t\n\t\t\t\t\t\t\"if ( renderType == 2 ) {\",\n\t\n\t\t\t\t\t\t\t\"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\",\n\t\n\t\t\t\t\t\t\t\"vVisibility =        visibility.r / 9.0;\",\n\t\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.g / 9.0;\",\n\t\t\t\t\t\t\t\"vVisibility *=       visibility.b / 9.0;\",\n\t\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.a / 9.0;\",\n\t\n\t\t\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\n\t\t\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\n\t\n\t\t\t\t\t\t\"}\",\n\t\n\t\t\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\n\t\n\t\t\t\t\t\"}\"\n\t\n\t\t\t\t].join( \"\\n\" ),\n\t\n\t\t\t\tfragmentShader: [\n\t\n\t\t\t\t\t\"uniform lowp int renderType;\",\n\t\n\t\t\t\t\t\"uniform sampler2D map;\",\n\t\t\t\t\t\"uniform float opacity;\",\n\t\t\t\t\t\"uniform vec3 color;\",\n\t\n\t\t\t\t\t\"varying vec2 vUV;\",\n\t\t\t\t\t\"varying float vVisibility;\",\n\t\n\t\t\t\t\t\"void main() {\",\n\t\n\t\t\t\t\t\t// pink square\n\t\n\t\t\t\t\t\t\"if ( renderType == 0 ) {\",\n\t\n\t\t\t\t\t\t\t\"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\",\n\t\n\t\t\t\t\t\t// restore\n\t\n\t\t\t\t\t\t\"} else if ( renderType == 1 ) {\",\n\t\n\t\t\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\n\t\n\t\t\t\t\t\t// flare\n\t\n\t\t\t\t\t\t\"} else {\",\n\t\n\t\t\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\n\t\t\t\t\t\t\t\"texture.a *= opacity * vVisibility;\",\n\t\t\t\t\t\t\t\"gl_FragColor = texture;\",\n\t\t\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\n\t\n\t\t\t\t\t\t\"}\",\n\t\n\t\t\t\t\t\"}\"\n\t\n\t\t\t\t].join( \"\\n\" )\n\t\n\t\t\t};\n\t\n\t\t\tprogram = createProgram( shader );\n\t\n\t\t\tattributes = {\n\t\t\t\tvertex: gl.getAttribLocation ( program, \"position\" ),\n\t\t\t\tuv:     gl.getAttribLocation ( program, \"uv\" )\n\t\t\t};\n\t\n\t\t\tuniforms = {\n\t\t\t\trenderType:     gl.getUniformLocation( program, \"renderType\" ),\n\t\t\t\tmap:            gl.getUniformLocation( program, \"map\" ),\n\t\t\t\tocclusionMap:   gl.getUniformLocation( program, \"occlusionMap\" ),\n\t\t\t\topacity:        gl.getUniformLocation( program, \"opacity\" ),\n\t\t\t\tcolor:          gl.getUniformLocation( program, \"color\" ),\n\t\t\t\tscale:          gl.getUniformLocation( program, \"scale\" ),\n\t\t\t\trotation:       gl.getUniformLocation( program, \"rotation\" ),\n\t\t\t\tscreenPosition: gl.getUniformLocation( program, \"screenPosition\" )\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t/*\n\t\t * Render lens flares\n\t\t * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,\n\t\t *         reads these back and calculates occlusion.\n\t\t */\n\t\n\t\tthis.render = function ( scene, camera, viewport ) {\n\t\n\t\t\tif ( flares.length === 0 ) return;\n\t\n\t\t\tvar tempPosition = new THREE.Vector3();\n\t\n\t\t\tvar invAspect = viewport.w / viewport.z,\n\t\t\t\thalfViewportWidth = viewport.z * 0.5,\n\t\t\t\thalfViewportHeight = viewport.w * 0.5;\n\t\n\t\t\tvar size = 16 / viewport.w,\n\t\t\t\tscale = new THREE.Vector2( size * invAspect, size );\n\t\n\t\t\tvar screenPosition = new THREE.Vector3( 1, 1, 0 ),\n\t\t\t\tscreenPositionPixels = new THREE.Vector2( 1, 1 );\n\t\n\t\t\tvar validArea = new THREE.Box2();\n\t\n\t\t\tvalidArea.min.set( 0, 0 );\n\t\t\tvalidArea.max.set( viewport.z - 16, viewport.w - 16 );\n\t\n\t\t\tif ( program === undefined ) {\n\t\n\t\t\t\tinit();\n\t\n\t\t\t}\n\t\n\t\t\tgl.useProgram( program );\n\t\n\t\t\tstate.initAttributes();\n\t\t\tstate.enableAttribute( attributes.vertex );\n\t\t\tstate.enableAttribute( attributes.uv );\n\t\t\tstate.disableUnusedAttributes();\n\t\n\t\t\t// loop through all lens flares to update their occlusion and positions\n\t\t\t// setup gl and common used attribs/uniforms\n\t\n\t\t\tgl.uniform1i( uniforms.occlusionMap, 0 );\n\t\t\tgl.uniform1i( uniforms.map, 1 );\n\t\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\t\tgl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );\n\t\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\n\t\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\n\t\t\tstate.disable( gl.CULL_FACE );\n\t\t\tstate.setDepthWrite( false );\n\t\n\t\t\tfor ( var i = 0, l = flares.length; i < l; i ++ ) {\n\t\n\t\t\t\tsize = 16 / viewport.w;\n\t\t\t\tscale.set( size * invAspect, size );\n\t\n\t\t\t\t// calc object screen position\n\t\n\t\t\t\tvar flare = flares[ i ];\n\t\n\t\t\t\ttempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );\n\t\n\t\t\t\ttempPosition.applyMatrix4( camera.matrixWorldInverse );\n\t\t\t\ttempPosition.applyProjection( camera.projectionMatrix );\n\t\n\t\t\t\t// setup arrays for gl programs\n\t\n\t\t\t\tscreenPosition.copy( tempPosition );\n\t\n\t\t\t\t// horizontal and vertical coordinate of the lower left corner of the pixels to copy\n\t\n\t\t\t\tscreenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;\n\t\t\t\tscreenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;\n\t\n\t\t\t\t// screen cull\n\t\n\t\t\t\tif ( validArea.containsPoint( screenPositionPixels ) === true ) {\n\t\n\t\t\t\t\t// save current RGB to temp texture\n\t\n\t\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, null );\n\t\t\t\t\tstate.activeTexture( gl.TEXTURE1 );\n\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\n\t\n\t\n\t\t\t\t\t// render pink quad\n\t\n\t\t\t\t\tgl.uniform1i( uniforms.renderType, 0 );\n\t\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\n\t\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\n\t\n\t\t\t\t\tstate.disable( gl.BLEND );\n\t\t\t\t\tstate.enable( gl.DEPTH_TEST );\n\t\n\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\t\n\t\n\t\t\t\t\t// copy result to occlusionMap\n\t\n\t\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\n\t\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\n\t\n\t\n\t\t\t\t\t// restore graphics\n\t\n\t\t\t\t\tgl.uniform1i( uniforms.renderType, 1 );\n\t\t\t\t\tstate.disable( gl.DEPTH_TEST );\n\t\n\t\t\t\t\tstate.activeTexture( gl.TEXTURE1 );\n\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\t\n\t\n\t\t\t\t\t// update object positions\n\t\n\t\t\t\t\tflare.positionScreen.copy( screenPosition );\n\t\n\t\t\t\t\tif ( flare.customUpdateCallback ) {\n\t\n\t\t\t\t\t\tflare.customUpdateCallback( flare );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tflare.updateLensFlares();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// render flares\n\t\n\t\t\t\t\tgl.uniform1i( uniforms.renderType, 2 );\n\t\t\t\t\tstate.enable( gl.BLEND );\n\t\n\t\t\t\t\tfor ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\tvar sprite = flare.lensFlares[ j ];\n\t\n\t\t\t\t\t\tif ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {\n\t\n\t\t\t\t\t\t\tscreenPosition.x = sprite.x;\n\t\t\t\t\t\t\tscreenPosition.y = sprite.y;\n\t\t\t\t\t\t\tscreenPosition.z = sprite.z;\n\t\n\t\t\t\t\t\t\tsize = sprite.size * sprite.scale / viewport.w;\n\t\n\t\t\t\t\t\t\tscale.x = size * invAspect;\n\t\t\t\t\t\t\tscale.y = size;\n\t\n\t\t\t\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\n\t\t\t\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\n\t\t\t\t\t\t\tgl.uniform1f( uniforms.rotation, sprite.rotation );\n\t\n\t\t\t\t\t\t\tgl.uniform1f( uniforms.opacity, sprite.opacity );\n\t\t\t\t\t\t\tgl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );\n\t\n\t\t\t\t\t\t\tstate.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );\n\t\t\t\t\t\t\trenderer.setTexture2D( sprite.texture, 1 );\n\t\n\t\t\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// restore gl\n\t\n\t\t\tstate.enable( gl.CULL_FACE );\n\t\t\tstate.enable( gl.DEPTH_TEST );\n\t\t\tstate.setDepthWrite( true );\n\t\n\t\t\trenderer.resetGLState();\n\t\n\t\t};\n\t\n\t\tfunction createProgram ( shader ) {\n\t\n\t\t\tvar program = gl.createProgram();\n\t\n\t\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\n\t\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\n\t\n\t\t\tvar prefix = \"precision \" + renderer.getPrecision() + \" float;\\n\";\n\t\n\t\t\tgl.shaderSource( fragmentShader, prefix + shader.fragmentShader );\n\t\t\tgl.shaderSource( vertexShader, prefix + shader.vertexShader );\n\t\n\t\t\tgl.compileShader( fragmentShader );\n\t\t\tgl.compileShader( vertexShader );\n\t\n\t\t\tgl.attachShader( program, fragmentShader );\n\t\t\tgl.attachShader( program, vertexShader );\n\t\n\t\t\tgl.linkProgram( program );\n\t\n\t\t\treturn program;\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/renderers/webgl/plugins/SpritePlugin.js\n\t\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.SpritePlugin = function ( renderer, sprites ) {\n\t\n\t\tvar gl = renderer.context;\n\t\tvar state = renderer.state;\n\t\n\t\tvar vertexBuffer, elementBuffer;\n\t\tvar program, attributes, uniforms;\n\t\n\t\tvar texture;\n\t\n\t\t// decompose matrixWorld\n\t\n\t\tvar spritePosition = new THREE.Vector3();\n\t\tvar spriteRotation = new THREE.Quaternion();\n\t\tvar spriteScale = new THREE.Vector3();\n\t\n\t\tfunction init() {\n\t\n\t\t\tvar vertices = new Float32Array( [\n\t\t\t\t- 0.5, - 0.5,  0, 0,\n\t\t\t\t  0.5, - 0.5,  1, 0,\n\t\t\t\t  0.5,   0.5,  1, 1,\n\t\t\t\t- 0.5,   0.5,  0, 1\n\t\t\t] );\n\t\n\t\t\tvar faces = new Uint16Array( [\n\t\t\t\t0, 1, 2,\n\t\t\t\t0, 2, 3\n\t\t\t] );\n\t\n\t\t\tvertexBuffer  = gl.createBuffer();\n\t\t\telementBuffer = gl.createBuffer();\n\t\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\n\t\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\n\t\n\t\t\tprogram = createProgram();\n\t\n\t\t\tattributes = {\n\t\t\t\tposition:\t\t\tgl.getAttribLocation ( program, 'position' ),\n\t\t\t\tuv:\t\t\t\t\tgl.getAttribLocation ( program, 'uv' )\n\t\t\t};\n\t\n\t\t\tuniforms = {\n\t\t\t\tuvOffset:\t\t\tgl.getUniformLocation( program, 'uvOffset' ),\n\t\t\t\tuvScale:\t\t\tgl.getUniformLocation( program, 'uvScale' ),\n\t\n\t\t\t\trotation:\t\t\tgl.getUniformLocation( program, 'rotation' ),\n\t\t\t\tscale:\t\t\t\tgl.getUniformLocation( program, 'scale' ),\n\t\n\t\t\t\tcolor:\t\t\t\tgl.getUniformLocation( program, 'color' ),\n\t\t\t\tmap:\t\t\t\tgl.getUniformLocation( program, 'map' ),\n\t\t\t\topacity:\t\t\tgl.getUniformLocation( program, 'opacity' ),\n\t\n\t\t\t\tmodelViewMatrix: \tgl.getUniformLocation( program, 'modelViewMatrix' ),\n\t\t\t\tprojectionMatrix:\tgl.getUniformLocation( program, 'projectionMatrix' ),\n\t\n\t\t\t\tfogType:\t\t\tgl.getUniformLocation( program, 'fogType' ),\n\t\t\t\tfogDensity:\t\t\tgl.getUniformLocation( program, 'fogDensity' ),\n\t\t\t\tfogNear:\t\t\tgl.getUniformLocation( program, 'fogNear' ),\n\t\t\t\tfogFar:\t\t\t\tgl.getUniformLocation( program, 'fogFar' ),\n\t\t\t\tfogColor:\t\t\tgl.getUniformLocation( program, 'fogColor' ),\n\t\n\t\t\t\talphaTest:\t\t\tgl.getUniformLocation( program, 'alphaTest' )\n\t\t\t};\n\t\n\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\tcanvas.width = 8;\n\t\t\tcanvas.height = 8;\n\t\n\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\tcontext.fillStyle = 'white';\n\t\t\tcontext.fillRect( 0, 0, 8, 8 );\n\t\n\t\t\ttexture = new THREE.Texture( canvas );\n\t\t\ttexture.needsUpdate = true;\n\t\n\t\t}\n\t\n\t\tthis.render = function ( scene, camera ) {\n\t\n\t\t\tif ( sprites.length === 0 ) return;\n\t\n\t\t\t// setup gl\n\t\n\t\t\tif ( program === undefined ) {\n\t\n\t\t\t\tinit();\n\t\n\t\t\t}\n\t\n\t\t\tgl.useProgram( program );\n\t\n\t\t\tstate.initAttributes();\n\t\t\tstate.enableAttribute( attributes.position );\n\t\t\tstate.enableAttribute( attributes.uv );\n\t\t\tstate.disableUnusedAttributes();\n\t\n\t\t\tstate.disable( gl.CULL_FACE );\n\t\t\tstate.enable( gl.BLEND );\n\t\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\t\tgl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );\n\t\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\n\t\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\n\t\t\tgl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\n\t\n\t\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\t\tgl.uniform1i( uniforms.map, 0 );\n\t\n\t\t\tvar oldFogType = 0;\n\t\t\tvar sceneFogType = 0;\n\t\t\tvar fog = scene.fog;\n\t\n\t\t\tif ( fog ) {\n\t\n\t\t\t\tgl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );\n\t\n\t\t\t\tif ( fog instanceof THREE.Fog ) {\n\t\n\t\t\t\t\tgl.uniform1f( uniforms.fogNear, fog.near );\n\t\t\t\t\tgl.uniform1f( uniforms.fogFar, fog.far );\n\t\n\t\t\t\t\tgl.uniform1i( uniforms.fogType, 1 );\n\t\t\t\t\toldFogType = 1;\n\t\t\t\t\tsceneFogType = 1;\n\t\n\t\t\t\t} else if ( fog instanceof THREE.FogExp2 ) {\n\t\n\t\t\t\t\tgl.uniform1f( uniforms.fogDensity, fog.density );\n\t\n\t\t\t\t\tgl.uniform1i( uniforms.fogType, 2 );\n\t\t\t\t\toldFogType = 2;\n\t\t\t\t\tsceneFogType = 2;\n\t\n\t\t\t\t}\n\t\n\t\t\t} else {\n\t\n\t\t\t\tgl.uniform1i( uniforms.fogType, 0 );\n\t\t\t\toldFogType = 0;\n\t\t\t\tsceneFogType = 0;\n\t\n\t\t\t}\n\t\n\t\n\t\t\t// update positions and sort\n\t\n\t\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar sprite = sprites[ i ];\n\t\n\t\t\t\tsprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );\n\t\t\t\tsprite.z = - sprite.modelViewMatrix.elements[ 14 ];\n\t\n\t\t\t}\n\t\n\t\t\tsprites.sort( painterSortStable );\n\t\n\t\t\t// render all sprites\n\t\n\t\t\tvar scale = [];\n\t\n\t\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar sprite = sprites[ i ];\n\t\t\t\tvar material = sprite.material;\n\t\n\t\t\t\tgl.uniform1f( uniforms.alphaTest, material.alphaTest );\n\t\t\t\tgl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );\n\t\n\t\t\t\tsprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );\n\t\n\t\t\t\tscale[ 0 ] = spriteScale.x;\n\t\t\t\tscale[ 1 ] = spriteScale.y;\n\t\n\t\t\t\tvar fogType = 0;\n\t\n\t\t\t\tif ( scene.fog && material.fog ) {\n\t\n\t\t\t\t\tfogType = sceneFogType;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( oldFogType !== fogType ) {\n\t\n\t\t\t\t\tgl.uniform1i( uniforms.fogType, fogType );\n\t\t\t\t\toldFogType = fogType;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.map !== null ) {\n\t\n\t\t\t\t\tgl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );\n\t\t\t\t\tgl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tgl.uniform2f( uniforms.uvOffset, 0, 0 );\n\t\t\t\t\tgl.uniform2f( uniforms.uvScale, 1, 1 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tgl.uniform1f( uniforms.opacity, material.opacity );\n\t\t\t\tgl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );\n\t\n\t\t\t\tgl.uniform1f( uniforms.rotation, material.rotation );\n\t\t\t\tgl.uniform2fv( uniforms.scale, scale );\n\t\n\t\t\t\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\n\t\t\t\tstate.setDepthTest( material.depthTest );\n\t\t\t\tstate.setDepthWrite( material.depthWrite );\n\t\n\t\t\t\tif ( material.map ) {\n\t\n\t\t\t\t\trenderer.setTexture2D( material.map, 0 );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\trenderer.setTexture2D( texture, 0 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\t\n\t\t\t}\n\t\n\t\t\t// restore gl\n\t\n\t\t\tstate.enable( gl.CULL_FACE );\n\t\n\t\t\trenderer.resetGLState();\n\t\n\t\t};\n\t\n\t\tfunction createProgram () {\n\t\n\t\t\tvar program = gl.createProgram();\n\t\n\t\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\n\t\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\n\t\n\t\t\tgl.shaderSource( vertexShader, [\n\t\n\t\t\t\t'precision ' + renderer.getPrecision() + ' float;',\n\t\n\t\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t\t'uniform float rotation;',\n\t\t\t\t'uniform vec2 scale;',\n\t\t\t\t'uniform vec2 uvOffset;',\n\t\t\t\t'uniform vec2 uvScale;',\n\t\n\t\t\t\t'attribute vec2 position;',\n\t\t\t\t'attribute vec2 uv;',\n\t\n\t\t\t\t'varying vec2 vUV;',\n\t\n\t\t\t\t'void main() {',\n\t\n\t\t\t\t\t'vUV = uvOffset + uv * uvScale;',\n\t\n\t\t\t\t\t'vec2 alignedPosition = position * scale;',\n\t\n\t\t\t\t\t'vec2 rotatedPosition;',\n\t\t\t\t\t'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',\n\t\t\t\t\t'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',\n\t\n\t\t\t\t\t'vec4 finalPosition;',\n\t\n\t\t\t\t\t'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',\n\t\t\t\t\t'finalPosition.xy += rotatedPosition;',\n\t\t\t\t\t'finalPosition = projectionMatrix * finalPosition;',\n\t\n\t\t\t\t\t'gl_Position = finalPosition;',\n\t\n\t\t\t\t'}'\n\t\n\t\t\t].join( '\\n' ) );\n\t\n\t\t\tgl.shaderSource( fragmentShader, [\n\t\n\t\t\t\t'precision ' + renderer.getPrecision() + ' float;',\n\t\n\t\t\t\t'uniform vec3 color;',\n\t\t\t\t'uniform sampler2D map;',\n\t\t\t\t'uniform float opacity;',\n\t\n\t\t\t\t'uniform int fogType;',\n\t\t\t\t'uniform vec3 fogColor;',\n\t\t\t\t'uniform float fogDensity;',\n\t\t\t\t'uniform float fogNear;',\n\t\t\t\t'uniform float fogFar;',\n\t\t\t\t'uniform float alphaTest;',\n\t\n\t\t\t\t'varying vec2 vUV;',\n\t\n\t\t\t\t'void main() {',\n\t\n\t\t\t\t\t'vec4 texture = texture2D( map, vUV );',\n\t\n\t\t\t\t\t'if ( texture.a < alphaTest ) discard;',\n\t\n\t\t\t\t\t'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',\n\t\n\t\t\t\t\t'if ( fogType > 0 ) {',\n\t\n\t\t\t\t\t\t'float depth = gl_FragCoord.z / gl_FragCoord.w;',\n\t\t\t\t\t\t'float fogFactor = 0.0;',\n\t\n\t\t\t\t\t\t'if ( fogType == 1 ) {',\n\t\n\t\t\t\t\t\t\t'fogFactor = smoothstep( fogNear, fogFar, depth );',\n\t\n\t\t\t\t\t\t'} else {',\n\t\n\t\t\t\t\t\t\t'const float LOG2 = 1.442695;',\n\t\t\t\t\t\t\t'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',\n\t\t\t\t\t\t\t'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',\n\t\n\t\t\t\t\t\t'}',\n\t\n\t\t\t\t\t\t'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',\n\t\n\t\t\t\t\t'}',\n\t\n\t\t\t\t'}'\n\t\n\t\t\t].join( '\\n' ) );\n\t\n\t\t\tgl.compileShader( vertexShader );\n\t\t\tgl.compileShader( fragmentShader );\n\t\n\t\t\tgl.attachShader( program, vertexShader );\n\t\t\tgl.attachShader( program, fragmentShader );\n\t\n\t\t\tgl.linkProgram( program );\n\t\n\t\t\treturn program;\n\t\n\t\t}\n\t\n\t\tfunction painterSortStable ( a, b ) {\n\t\t\t\n\t\t\tif ( a.renderOrder !== b.renderOrder ) {\n\t\n\t\t\t\treturn a.renderOrder - b.renderOrder;\n\t\n\t\t\t} else if ( a.z !== b.z ) {\n\t\n\t\t\t\treturn b.z - a.z;\n\t\n\t\t\t} else {\n\t\n\t\t\t\treturn b.id - a.id;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/Three.Legacy.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tObject.assign( THREE, {\n\t\tFace4: function ( a, b, c, d, normal, color, materialIndex ) {\n\t\t\tconsole.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );\n\t\t\treturn new THREE.Face3( a, b, c, normal, color, materialIndex );\n\t\t},\n\t\tLineStrip: 0,\n\t\tLinePieces: 1,\n\t\tMeshFaceMaterial: THREE.MultiMaterial,\n\t\tPointCloud: function ( geometry, material ) {\n\t\t\tconsole.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );\n\t\t\treturn new THREE.Points( geometry, material );\n\t\t},\n\t\tParticle: THREE.Sprite,\n\t\tParticleSystem: function ( geometry, material ) {\n\t\t\tconsole.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );\n\t\t\treturn new THREE.Points( geometry, material );\n\t\t},\n\t\tPointCloudMaterial: function ( parameters ) {\n\t\t\tconsole.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );\n\t\t\treturn new THREE.PointsMaterial( parameters );\n\t\t},\n\t\tParticleBasicMaterial: function ( parameters ) {\n\t\t\tconsole.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );\n\t\t\treturn new THREE.PointsMaterial( parameters );\n\t\t},\n\t\tParticleSystemMaterial: function ( parameters ) {\n\t\t\tconsole.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );\n\t\t\treturn new THREE.PointsMaterial( parameters );\n\t\t},\n\t\tVertex: function ( x, y, z ) {\n\t\t\tconsole.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );\n\t\t\treturn new THREE.Vector3( x, y, z );\n\t\t}\n\t} );\n\t\n\t//\n\t\n\tObject.assign( THREE.Box2.prototype, {\n\t\tempty: function () {\n\t\t\tconsole.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );\n\t\t\treturn this.isEmpty();\n\t\t},\n\t\tisIntersectionBox: function ( box ) {\n\t\t\tconsole.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\t\treturn this.intersectsBox( box );\n\t\t}\n\t} );\n\t\n\tObject.assign( THREE.Box3.prototype, {\n\t\tempty: function () {\n\t\t\tconsole.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );\n\t\t\treturn this.isEmpty();\n\t\t},\n\t\tisIntersectionBox: function ( box ) {\n\t\t\tconsole.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\t\treturn this.intersectsBox( box );\n\t\t},\n\t\tisIntersectionSphere: function ( sphere ) {\n\t\t\tconsole.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n\t\t\treturn this.intersectsSphere( sphere );\n\t\t}\n\t} );\n\t\n\tObject.assign( THREE.Matrix3.prototype, {\n\t\tmultiplyVector3: function ( vector ) {\n\t\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\n\t\t\treturn vector.applyMatrix3( this );\n\t\t},\n\t\tmultiplyVector3Array: function ( a ) {\n\t\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\n\t\t\treturn this.applyToVector3Array( a );\n\t\t}\n\t} );\n\t\n\tObject.assign( THREE.Matrix4.prototype, {\n\t\textractPosition: function ( m ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );\n\t\t\treturn this.copyPosition( m );\n\t\t},\n\t\tsetRotationFromQuaternion: function ( q ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );\n\t\t\treturn this.makeRotationFromQuaternion( q );\n\t\t},\n\t\tmultiplyVector3: function ( vector ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );\n\t\t\treturn vector.applyProjection( this );\n\t\t},\n\t\tmultiplyVector4: function ( vector ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\t\treturn vector.applyMatrix4( this );\n\t\t},\n\t\tmultiplyVector3Array: function ( a ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\n\t\t\treturn this.applyToVector3Array( a );\n\t\t},\n\t\trotateAxis: function ( v ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );\n\t\t\tv.transformDirection( this );\n\t\t},\n\t\tcrossVector: function ( vector ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\t\treturn vector.applyMatrix4( this );\n\t\t},\n\t\ttranslate: function ( v ) {\n\t\t\tconsole.error( 'THREE.Matrix4: .translate() has been removed.' );\n\t\t},\n\t\trotateX: function ( angle ) {\n\t\t\tconsole.error( 'THREE.Matrix4: .rotateX() has been removed.' );\n\t\t},\n\t\trotateY: function ( angle ) {\n\t\t\tconsole.error( 'THREE.Matrix4: .rotateY() has been removed.' );\n\t\t},\n\t\trotateZ: function ( angle ) {\n\t\t\tconsole.error( 'THREE.Matrix4: .rotateZ() has been removed.' );\n\t\t},\n\t\trotateByAxis: function ( axis, angle ) {\n\t\t\tconsole.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );\n\t\t}\n\t} );\n\t\n\tObject.assign( THREE.Plane.prototype, {\n\t\tisIntersectionLine: function ( line ) {\n\t\t\tconsole.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );\n\t\t\treturn this.intersectsLine( line );\n\t\t}\n\t} );\n\t\n\tObject.assign( THREE.Quaternion.prototype, {\n\t\tmultiplyVector3: function ( vector ) {\n\t\t\tconsole.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\n\t\t\treturn vector.applyQuaternion( this );\n\t\t}\n\t} );\n\t\n\tObject.assign( THREE.Ray.prototype, {\n\t\tisIntersectionBox: function ( box ) {\n\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\t\treturn this.intersectsBox( box );\n\t\t},\n\t\tisIntersectionPlane: function ( plane ) {\n\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );\n\t\t\treturn this.intersectsPlane( plane );\n\t\t},\n\t\tisIntersectionSphere: function ( sphere ) {\n\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n\t\t\treturn this.intersectsSphere( sphere );\n\t\t}\n\t} );\n\t\n\tObject.assign( THREE.Vector3.prototype, {\n\t\tsetEulerFromRotationMatrix: function () {\n\t\t\tconsole.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );\n\t\t},\n\t\tsetEulerFromQuaternion: function () {\n\t\t\tconsole.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );\n\t\t},\n\t\tgetPositionFromMatrix: function ( m ) {\n\t\t\tconsole.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );\n\t\t\treturn this.setFromMatrixPosition( m );\n\t\t},\n\t\tgetScaleFromMatrix: function ( m ) {\n\t\t\tconsole.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );\n\t\t\treturn this.setFromMatrixScale( m );\n\t\t},\n\t\tgetColumnFromMatrix: function ( index, matrix ) {\n\t\t\tconsole.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );\n\t\t\treturn this.setFromMatrixColumn( matrix, index );\n\t\t}\n\t} );\n\t\n\t//\n\t\n\tObject.assign( THREE.Object3D.prototype, {\n\t\tgetChildByName: function ( name ) {\n\t\t\tconsole.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );\n\t\t\treturn this.getObjectByName( name );\n\t\t},\n\t\trenderDepth: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );\n\t\t},\n\t\ttranslate: function ( distance, axis ) {\n\t\t\tconsole.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );\n\t\t\treturn this.translateOnAxis( axis, distance );\n\t\t}\n\t} );\n\t\n\tObject.defineProperties( THREE.Object3D.prototype, {\n\t\teulerOrder: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n\t\t\t\treturn this.rotation.order;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n\t\t\t\tthis.rotation.order = value;\n\t\t\t}\n\t\t},\n\t\tuseQuaternion: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\t\t\t}\n\t\t}\n\t} );\n\t\n\tObject.defineProperties( THREE.LOD.prototype, {\n\t\tobjects: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.LOD: .objects has been renamed to .levels.' );\n\t\t\t\treturn this.levels;\n\t\t\t}\n\t\t}\n\t} );\n\t\n\t//\n\t\n\tTHREE.PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {\n\t\n\t\tconsole.warn( \"THREE.PerspectiveCamera.setLens is deprecated. \" +\n\t\t\t\t\"Use .setFocalLength and .filmGauge for a photographic setup.\" );\n\t\n\t\tif ( filmGauge !== undefined ) this.filmGauge = filmGauge;\n\t\tthis.setFocalLength( focalLength );\n\t\n\t};\n\t\n\t//\n\t\n\tObject.defineProperties( THREE.Light.prototype, {\n\t\tonlyShadow: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .onlyShadow has been removed.' );\n\t\t\t}\n\t\t},\n\t\tshadowCameraFov: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );\n\t\t\t\tthis.shadow.camera.fov = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraLeft: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );\n\t\t\t\tthis.shadow.camera.left = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraRight: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );\n\t\t\t\tthis.shadow.camera.right = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraTop: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );\n\t\t\t\tthis.shadow.camera.top = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraBottom: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );\n\t\t\t\tthis.shadow.camera.bottom = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraNear: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );\n\t\t\t\tthis.shadow.camera.near = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraFar: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );\n\t\t\t\tthis.shadow.camera.far = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraVisible: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );\n\t\t\t}\n\t\t},\n\t\tshadowBias: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );\n\t\t\t\tthis.shadow.bias = value;\n\t\t\t}\n\t\t},\n\t\tshadowDarkness: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowDarkness has been removed.' );\n\t\t\t}\n\t\t},\n\t\tshadowMapWidth: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );\n\t\t\t\tthis.shadow.mapSize.width = value;\n\t\t\t}\n\t\t},\n\t\tshadowMapHeight: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );\n\t\t\t\tthis.shadow.mapSize.height = value;\n\t\t\t}\n\t\t}\n\t} );\n\t\n\t//\n\t\n\tObject.defineProperties( THREE.BufferAttribute.prototype, {\n\t\tlength: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );\n\t\t\t\treturn this.array.length;\n\t\t\t}\n\t\t}\n\t} );\n\t\n\tObject.assign( THREE.BufferGeometry.prototype, {\n\t\taddIndex: function ( index ) {\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );\n\t\t\tthis.setIndex( index );\n\t\t},\n\t\taddDrawCall: function ( start, count, indexOffset ) {\n\t\t\tif ( indexOffset !== undefined ) {\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );\n\t\t\t}\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );\n\t\t\tthis.addGroup( start, count );\n\t\t},\n\t\tclearDrawCalls: function () {\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );\n\t\t\tthis.clearGroups();\n\t\t},\n\t\tcomputeTangents: function () {\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );\n\t\t},\n\t\tcomputeOffsets: function () {\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );\n\t\t}\n\t} );\n\t\n\tObject.defineProperties( THREE.BufferGeometry.prototype, {\n\t\tdrawcalls: {\n\t\t\tget: function () {\n\t\t\t\tconsole.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );\n\t\t\t\treturn this.groups;\n\t\t\t}\n\t\t},\n\t\toffsets: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );\n\t\t\t\treturn this.groups;\n\t\t\t}\n\t\t}\n\t} );\n\t\n\t//\n\t\n\tObject.defineProperties( THREE.Material.prototype, {\n\t\twrapAround: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\n\t\t\t}\n\t\t},\n\t\twrapRGB: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );\n\t\t\t\treturn new THREE.Color();\n\t\t\t}\n\t\t}\n\t} );\n\t\n\tObject.defineProperties( THREE.MeshPhongMaterial.prototype, {\n\t\tmetal: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );\n\t\t\t}\n\t\t}\n\t} );\n\t\n\tObject.defineProperties( THREE.ShaderMaterial.prototype, {\n\t\tderivatives: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n\t\t\t\treturn this.extensions.derivatives;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n\t\t\t\tthis.extensions.derivatives = value;\n\t\t\t}\n\t\t}\n\t} );\n\t\n\t//\n\t\n\tTHREE.EventDispatcher.prototype = Object.assign( Object.create( {\n\t\n\t\t// Note: Extra base ensures these properties are not 'assign'ed.\n\t\n\t\tconstructor: THREE.EventDispatcher,\n\t\n\t\tapply: function ( target ) {\n\t\n\t\t\tconsole.warn( \"THREE.EventDispatcher: .apply is deprecated, \" +\n\t\t\t\t\t\"just inherit or Object.assign the prototype to mix-in.\" );\n\t\n\t\t\tObject.assign( target, this );\n\t\n\t\t}\n\t\n\t} ), THREE.EventDispatcher.prototype );\n\t\n\t//\n\t\n\tObject.assign( THREE.WebGLRenderer.prototype, {\n\t\tsupportsFloatTextures: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \\'OES_texture_float\\' ).' );\n\t\t\treturn this.extensions.get( 'OES_texture_float' );\n\t\t},\n\t\tsupportsHalfFloatTextures: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \\'OES_texture_half_float\\' ).' );\n\t\t\treturn this.extensions.get( 'OES_texture_half_float' );\n\t\t},\n\t\tsupportsStandardDerivatives: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \\'OES_standard_derivatives\\' ).' );\n\t\t\treturn this.extensions.get( 'OES_standard_derivatives' );\n\t\t},\n\t\tsupportsCompressedTextureS3TC: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \\'WEBGL_compressed_texture_s3tc\\' ).' );\n\t\t\treturn this.extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\t\t},\n\t\tsupportsCompressedTexturePVRTC: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \\'WEBGL_compressed_texture_pvrtc\\' ).' );\n\t\t\treturn this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\t\t},\n\t\tsupportsBlendMinMax: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \\'EXT_blend_minmax\\' ).' );\n\t\t\treturn this.extensions.get( 'EXT_blend_minmax' );\n\t\t},\n\t\tsupportsVertexTextures: function () {\n\t\t\treturn this.capabilities.vertexTextures;\n\t\t},\n\t\tsupportsInstancedArrays: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \\'ANGLE_instanced_arrays\\' ).' );\n\t\t\treturn this.extensions.get( 'ANGLE_instanced_arrays' );\n\t\t},\n\t\tenableScissorTest: function ( boolean ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );\n\t\t\tthis.setScissorTest( boolean );\n\t\t},\n\t\tinitMaterial: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );\n\t\t},\n\t\taddPrePlugin: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );\n\t\t},\n\t\taddPostPlugin: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );\n\t\t},\n\t\tupdateShadowMap: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );\n\t\t}\n\t} );\n\t\n\tObject.defineProperties( THREE.WebGLRenderer.prototype, {\n\t\tshadowMapEnabled: {\n\t\t\tget: function () {\n\t\t\t\treturn this.shadowMap.enabled;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );\n\t\t\t\tthis.shadowMap.enabled = value;\n\t\t\t}\n\t\t},\n\t\tshadowMapType: {\n\t\t\tget: function () {\n\t\t\t\treturn this.shadowMap.type;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );\n\t\t\t\tthis.shadowMap.type = value;\n\t\t\t}\n\t\t},\n\t\tshadowMapCullFace: {\n\t\t\tget: function () {\n\t\t\t\treturn this.shadowMap.cullFace;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );\n\t\t\t\tthis.shadowMap.cullFace = value;\n\t\t\t}\n\t\t}\n\t} );\n\t\n\tObject.defineProperties( THREE.WebGLShadowMap.prototype, {\n\t\tcullFace: {\n\t\t\tget: function () {\n\t\t\t\treturn this.renderReverseSided ? THREE.CullFaceFront : THREE.CullFaceBack;\n\t\t\t},\n\t\t\tset: function ( cullFace ) {\n\t\t\t\tvar value = ( cullFace !== THREE.CullFaceBack );\n\t\t\t\tconsole.warn( \"WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to \" + value + \".\" );\n\t\t\t\tthis.renderReverseSided = value;\n\t\t\t}\n\t\t}\n\t} );\n\t\n\t//\n\t\n\tObject.defineProperties( THREE.WebGLRenderTarget.prototype, {\n\t\twrapS: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n\t\t\t\treturn this.texture.wrapS;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n\t\t\t\tthis.texture.wrapS = value;\n\t\t\t}\n\t\t},\n\t\twrapT: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n\t\t\t\treturn this.texture.wrapT;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n\t\t\t\tthis.texture.wrapT = value;\n\t\t\t}\n\t\t},\n\t\tmagFilter: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n\t\t\t\treturn this.texture.magFilter;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n\t\t\t\tthis.texture.magFilter = value;\n\t\t\t}\n\t\t},\n\t\tminFilter: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n\t\t\t\treturn this.texture.minFilter;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n\t\t\t\tthis.texture.minFilter = value;\n\t\t\t}\n\t\t},\n\t\tanisotropy: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n\t\t\t\treturn this.texture.anisotropy;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n\t\t\t\tthis.texture.anisotropy = value;\n\t\t\t}\n\t\t},\n\t\toffset: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n\t\t\t\treturn this.texture.offset;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n\t\t\t\tthis.texture.offset = value;\n\t\t\t}\n\t\t},\n\t\trepeat: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n\t\t\t\treturn this.texture.repeat;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n\t\t\t\tthis.texture.repeat = value;\n\t\t\t}\n\t\t},\n\t\tformat: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n\t\t\t\treturn this.texture.format;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n\t\t\t\tthis.texture.format = value;\n\t\t\t}\n\t\t},\n\t\ttype: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n\t\t\t\treturn this.texture.type;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n\t\t\t\tthis.texture.type = value;\n\t\t\t}\n\t\t},\n\t\tgenerateMipmaps: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n\t\t\t\treturn this.texture.generateMipmaps;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n\t\t\t\tthis.texture.generateMipmaps = value;\n\t\t\t}\n\t\t}\n\t} );\n\t\n\t//\n\t\n\tObject.assign( THREE.Audio.prototype, {\n\t\tload: function ( file ) {\n\t\t\tconsole.warn( 'THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader.' );\n\t\t\tvar scope = this;\n\t\t\tvar audioLoader = new THREE.AudioLoader();\n\t\t\taudioLoader.load( file, function ( buffer ) {\n\t\t\t\tscope.setBuffer( buffer );\n\t\t\t} );\n\t\t\treturn this;\n\t\t}\n\t} );\n\t\n\tObject.assign( THREE.AudioAnalyser.prototype, {\n\t\tgetData: function ( file ) {\n\t\t\tconsole.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );\n\t\t\treturn this.getFrequencyData();\n\t\t}\n\t} );\n\t\n\t//\n\t\n\tTHREE.GeometryUtils = {\n\t\n\t\tmerge: function ( geometry1, geometry2, materialIndexOffset ) {\n\t\n\t\t\tconsole.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );\n\t\n\t\t\tvar matrix;\n\t\n\t\t\tif ( geometry2 instanceof THREE.Mesh ) {\n\t\n\t\t\t\tgeometry2.matrixAutoUpdate && geometry2.updateMatrix();\n\t\n\t\t\t\tmatrix = geometry2.matrix;\n\t\t\t\tgeometry2 = geometry2.geometry;\n\t\n\t\t\t}\n\t\n\t\t\tgeometry1.merge( geometry2, matrix, materialIndexOffset );\n\t\n\t\t},\n\t\n\t\tcenter: function ( geometry ) {\n\t\n\t\t\tconsole.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );\n\t\t\treturn geometry.center();\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.ImageUtils = {\n\t\n\t\tcrossOrigin: undefined,\n\t\n\t\tloadTexture: function ( url, mapping, onLoad, onError ) {\n\t\n\t\t\tconsole.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );\n\t\n\t\t\tvar loader = new THREE.TextureLoader();\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\n\t\t\tvar texture = loader.load( url, onLoad, undefined, onError );\n\t\n\t\t\tif ( mapping ) texture.mapping = mapping;\n\t\n\t\t\treturn texture;\n\t\n\t\t},\n\t\n\t\tloadTextureCube: function ( urls, mapping, onLoad, onError ) {\n\t\n\t\t\tconsole.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );\n\t\n\t\t\tvar loader = new THREE.CubeTextureLoader();\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\n\t\t\tvar texture = loader.load( urls, onLoad, undefined, onError );\n\t\n\t\t\tif ( mapping ) texture.mapping = mapping;\n\t\n\t\t\treturn texture;\n\t\n\t\t},\n\t\n\t\tloadCompressedTexture: function () {\n\t\n\t\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );\n\t\n\t\t},\n\t\n\t\tloadCompressedTextureCube: function () {\n\t\n\t\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );\n\t\n\t\t}\n\t\n\t};\n\t\n\t//\n\t\n\tTHREE.Projector = function () {\n\t\n\t\tconsole.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );\n\t\n\t\tthis.projectVector = function ( vector, camera ) {\n\t\n\t\t\tconsole.warn( 'THREE.Projector: .projectVector() is now vector.project().' );\n\t\t\tvector.project( camera );\n\t\n\t\t};\n\t\n\t\tthis.unprojectVector = function ( vector, camera ) {\n\t\n\t\t\tconsole.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );\n\t\t\tvector.unproject( camera );\n\t\n\t\t};\n\t\n\t\tthis.pickingRay = function ( vector, camera ) {\n\t\n\t\t\tconsole.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );\n\t\n\t\t};\n\t\n\t};\n\t\n\t//\n\t\n\tTHREE.CanvasRenderer = function () {\n\t\n\t\tconsole.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );\n\t\n\t\tthis.domElement = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\tthis.clear = function () {};\n\t\tthis.render = function () {};\n\t\tthis.setClearColor = function () {};\n\t\tthis.setSize = function () {};\n\t\n\t};\n\t\n\t// File:src/extras/CurveUtils.js\n\t\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t */\n\t\n\tTHREE.CurveUtils = {\n\t\n\t\ttangentQuadraticBezier: function ( t, p0, p1, p2 ) {\n\t\n\t\t\treturn 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );\n\t\n\t\t},\n\t\n\t\t// Puay Bing, thanks for helping with this derivative!\n\t\n\t\ttangentCubicBezier: function ( t, p0, p1, p2, p3 ) {\n\t\n\t\t\treturn - 3 * p0 * ( 1 - t ) * ( 1 - t )  +\n\t\t\t\t3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +\n\t\t\t\t6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +\n\t\t\t\t3 * t * t * p3;\n\t\n\t\t},\n\t\n\t\ttangentSpline: function ( t, p0, p1, p2, p3 ) {\n\t\n\t\t\t// To check if my formulas are correct\n\t\n\t\t\tvar h00 = 6 * t * t - 6 * t; \t// derived from 2t^3 − 3t^2 + 1\n\t\t\tvar h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t\n\t\t\tvar h01 = - 6 * t * t + 6 * t; \t// − 2t3 + 3t2\n\t\t\tvar h11 = 3 * t * t - 2 * t;\t// t3 − t2\n\t\n\t\t\treturn h00 + h10 + h01 + h11;\n\t\n\t\t},\n\t\n\t\t// Catmull-Rom\n\t\n\t\tinterpolate: function( p0, p1, p2, p3, t ) {\n\t\n\t\t\tvar v0 = ( p2 - p0 ) * 0.5;\n\t\t\tvar v1 = ( p3 - p1 ) * 0.5;\n\t\t\tvar t2 = t * t;\n\t\t\tvar t3 = t * t2;\n\t\t\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/extras/SceneUtils.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.SceneUtils = {\n\t\n\t\tcreateMultiMaterialObject: function ( geometry, materials ) {\n\t\n\t\t\tvar group = new THREE.Group();\n\t\n\t\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\n\t\n\t\t\t\tgroup.add( new THREE.Mesh( geometry, materials[ i ] ) );\n\t\n\t\t\t}\n\t\n\t\t\treturn group;\n\t\n\t\t},\n\t\n\t\tdetach: function ( child, parent, scene ) {\n\t\n\t\t\tchild.applyMatrix( parent.matrixWorld );\n\t\t\tparent.remove( child );\n\t\t\tscene.add( child );\n\t\n\t\t},\n\t\n\t\tattach: function ( child, scene, parent ) {\n\t\n\t\t\tvar matrixWorldInverse = new THREE.Matrix4();\n\t\t\tmatrixWorldInverse.getInverse( parent.matrixWorld );\n\t\t\tchild.applyMatrix( matrixWorldInverse );\n\t\n\t\t\tscene.remove( child );\n\t\t\tparent.add( child );\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/extras/ShapeUtils.js\n\t\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t */\n\t\n\tTHREE.ShapeUtils = {\n\t\n\t\t// calculate area of the contour polygon\n\t\n\t\tarea: function ( contour ) {\n\t\n\t\t\tvar n = contour.length;\n\t\t\tvar a = 0.0;\n\t\n\t\t\tfor ( var p = n - 1, q = 0; q < n; p = q ++ ) {\n\t\n\t\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\n\t\n\t\t\t}\n\t\n\t\t\treturn a * 0.5;\n\t\n\t\t},\n\t\n\t\ttriangulate: ( function () {\n\t\n\t\t\t/**\n\t\t\t * This code is a quick port of code written in C++ which was submitted to\n\t\t\t * flipcode.com by John W. Ratcliff  // July 22, 2000\n\t\t\t * See original code and more information here:\n\t\t\t * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml\n\t\t\t *\n\t\t\t * ported to actionscript by Zevan Rosser\n\t\t\t * www.actionsnippet.com\n\t\t\t *\n\t\t\t * ported to javascript by Joshua Koo\n\t\t\t * http://www.lab4games.net/zz85/blog\n\t\t\t *\n\t\t\t */\n\t\n\t\t\tfunction snip( contour, u, v, w, n, verts ) {\n\t\n\t\t\t\tvar p;\n\t\t\t\tvar ax, ay, bx, by;\n\t\t\t\tvar cx, cy, px, py;\n\t\n\t\t\t\tax = contour[ verts[ u ] ].x;\n\t\t\t\tay = contour[ verts[ u ] ].y;\n\t\n\t\t\t\tbx = contour[ verts[ v ] ].x;\n\t\t\t\tby = contour[ verts[ v ] ].y;\n\t\n\t\t\t\tcx = contour[ verts[ w ] ].x;\n\t\t\t\tcy = contour[ verts[ w ] ].y;\n\t\n\t\t\t\tif ( Number.EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;\n\t\n\t\t\t\tvar aX, aY, bX, bY, cX, cY;\n\t\t\t\tvar apx, apy, bpx, bpy, cpx, cpy;\n\t\t\t\tvar cCROSSap, bCROSScp, aCROSSbp;\n\t\n\t\t\t\taX = cx - bx;  aY = cy - by;\n\t\t\t\tbX = ax - cx;  bY = ay - cy;\n\t\t\t\tcX = bx - ax;  cY = by - ay;\n\t\n\t\t\t\tfor ( p = 0; p < n; p ++ ) {\n\t\n\t\t\t\t\tpx = contour[ verts[ p ] ].x;\n\t\t\t\t\tpy = contour[ verts[ p ] ].y;\n\t\n\t\t\t\t\tif ( ( ( px === ax ) && ( py === ay ) ) ||\n\t\t\t\t\t\t ( ( px === bx ) && ( py === by ) ) ||\n\t\t\t\t\t\t ( ( px === cx ) && ( py === cy ) ) )\tcontinue;\n\t\n\t\t\t\t\tapx = px - ax;  apy = py - ay;\n\t\t\t\t\tbpx = px - bx;  bpy = py - by;\n\t\t\t\t\tcpx = px - cx;  cpy = py - cy;\n\t\n\t\t\t\t\t// see if p is inside triangle abc\n\t\n\t\t\t\t\taCROSSbp = aX * bpy - aY * bpx;\n\t\t\t\t\tcCROSSap = cX * apy - cY * apx;\n\t\t\t\t\tbCROSScp = bX * cpy - bY * cpx;\n\t\n\t\t\t\t\tif ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn true;\n\t\n\t\t\t}\n\t\n\t\t\t// takes in an contour array and returns\n\t\n\t\t\treturn function triangulate( contour, indices ) {\n\t\n\t\t\t\tvar n = contour.length;\n\t\n\t\t\t\tif ( n < 3 ) return null;\n\t\n\t\t\t\tvar result = [],\n\t\t\t\t\tverts = [],\n\t\t\t\t\tvertIndices = [];\n\t\n\t\t\t\t/* we want a counter-clockwise polygon in verts */\n\t\n\t\t\t\tvar u, v, w;\n\t\n\t\t\t\tif ( THREE.ShapeUtils.area( contour ) > 0.0 ) {\n\t\n\t\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = v;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar nv = n;\n\t\n\t\t\t\t/*  remove nv - 2 vertices, creating 1 triangle every time */\n\t\n\t\t\t\tvar count = 2 * nv;   /* error detection */\n\t\n\t\t\t\tfor ( v = nv - 1; nv > 2; ) {\n\t\n\t\t\t\t\t/* if we loop, it is probably a non-simple polygon */\n\t\n\t\t\t\t\tif ( ( count -- ) <= 0 ) {\n\t\n\t\t\t\t\t\t//** Triangulate: ERROR - probable bad polygon!\n\t\n\t\t\t\t\t\t//throw ( \"Warning, unable to triangulate polygon!\" );\n\t\t\t\t\t\t//return null;\n\t\t\t\t\t\t// Sometimes warning is fine, especially polygons are triangulated in reverse.\n\t\t\t\t\t\tconsole.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );\n\t\n\t\t\t\t\t\tif ( indices ) return vertIndices;\n\t\t\t\t\t\treturn result;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t/* three consecutive vertices in current polygon, <u,v,w> */\n\t\n\t\t\t\t\tu = v; \t \tif ( nv <= u ) u = 0;     /* previous */\n\t\t\t\t\tv = u + 1;  if ( nv <= v ) v = 0;     /* new v    */\n\t\t\t\t\tw = v + 1;  if ( nv <= w ) w = 0;     /* next     */\n\t\n\t\t\t\t\tif ( snip( contour, u, v, w, nv, verts ) ) {\n\t\n\t\t\t\t\t\tvar a, b, c, s, t;\n\t\n\t\t\t\t\t\t/* true names of the vertices */\n\t\n\t\t\t\t\t\ta = verts[ u ];\n\t\t\t\t\t\tb = verts[ v ];\n\t\t\t\t\t\tc = verts[ w ];\n\t\n\t\t\t\t\t\t/* output Triangle */\n\t\n\t\t\t\t\t\tresult.push( [ contour[ a ],\n\t\t\t\t\t\t\tcontour[ b ],\n\t\t\t\t\t\t\tcontour[ c ] ] );\n\t\n\t\n\t\t\t\t\t\tvertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );\n\t\n\t\t\t\t\t\t/* remove v from the remaining polygon */\n\t\n\t\t\t\t\t\tfor ( s = v, t = v + 1; t < nv; s ++, t ++ ) {\n\t\n\t\t\t\t\t\t\tverts[ s ] = verts[ t ];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tnv --;\n\t\n\t\t\t\t\t\t/* reset error detection counter */\n\t\n\t\t\t\t\t\tcount = 2 * nv;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( indices ) return vertIndices;\n\t\t\t\treturn result;\n\t\n\t\t\t}\n\t\n\t\t} )(),\n\t\n\t\ttriangulateShape: function ( contour, holes ) {\n\t\n\t\t\tfunction point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {\n\t\n\t\t\t\t// inOtherPt needs to be collinear to the inSegment\n\t\t\t\tif ( inSegPt1.x !== inSegPt2.x ) {\n\t\n\t\t\t\t\tif ( inSegPt1.x < inSegPt2.x ) {\n\t\n\t\t\t\t\t\treturn\t( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\treturn\t( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tif ( inSegPt1.y < inSegPt2.y ) {\n\t\n\t\t\t\t\t\treturn\t( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\treturn\t( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {\n\t\n\t\t\t\tvar seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;\n\t\t\t\tvar seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;\n\t\n\t\t\t\tvar seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;\n\t\t\t\tvar seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;\n\t\n\t\t\t\tvar limit\t\t= seg1dy * seg2dx - seg1dx * seg2dy;\n\t\t\t\tvar perpSeg1\t= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;\n\t\n\t\t\t\tif ( Math.abs( limit ) > Number.EPSILON ) {\n\t\n\t\t\t\t\t// not parallel\n\t\n\t\t\t\t\tvar perpSeg2;\n\t\t\t\t\tif ( limit > 0 ) {\n\t\n\t\t\t\t\t\tif ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) \t\treturn [];\n\t\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\n\t\t\t\t\t\tif ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) \t\treturn [];\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tif ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) \t\treturn [];\n\t\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\n\t\t\t\t\t\tif ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) \t\treturn [];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// i.e. to reduce rounding errors\n\t\t\t\t\t// intersection at endpoint of segment#1?\n\t\t\t\t\tif ( perpSeg2 === 0 ) {\n\t\n\t\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\n\t\t\t\t\t\t\t ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )\t\treturn [];\n\t\t\t\t\t\treturn [ inSeg1Pt1 ];\n\t\n\t\t\t\t\t}\n\t\t\t\t\tif ( perpSeg2 === limit ) {\n\t\n\t\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\n\t\t\t\t\t\t\t ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )\t\treturn [];\n\t\t\t\t\t\treturn [ inSeg1Pt2 ];\n\t\n\t\t\t\t\t}\n\t\t\t\t\t// intersection at endpoint of segment#2?\n\t\t\t\t\tif ( perpSeg1 === 0 )\t\treturn [ inSeg2Pt1 ];\n\t\t\t\t\tif ( perpSeg1 === limit )\treturn [ inSeg2Pt2 ];\n\t\n\t\t\t\t\t// return real intersection point\n\t\t\t\t\tvar factorSeg1 = perpSeg2 / limit;\n\t\t\t\t\treturn\t[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,\n\t\t\t\t\t\t\t\ty: inSeg1Pt1.y + factorSeg1 * seg1dy } ];\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// parallel or collinear\n\t\t\t\t\tif ( ( perpSeg1 !== 0 ) ||\n\t\t\t\t\t\t ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) \t\t\treturn [];\n\t\n\t\t\t\t\t// they are collinear or degenerate\n\t\t\t\t\tvar seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );\t// segment1 is just a point?\n\t\t\t\t\tvar seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );\t// segment2 is just a point?\n\t\t\t\t\t// both segments are points\n\t\t\t\t\tif ( seg1Pt && seg2Pt ) {\n\t\n\t\t\t\t\t\tif ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||\n\t\t\t\t\t\t\t ( inSeg1Pt1.y !== inSeg2Pt1.y ) )\t\treturn [];\t// they are distinct  points\n\t\t\t\t\t\treturn [ inSeg1Pt1 ];                 \t\t\t\t\t\t// they are the same point\n\t\n\t\t\t\t\t}\n\t\t\t\t\t// segment#1  is a single point\n\t\t\t\t\tif ( seg1Pt ) {\n\t\n\t\t\t\t\t\tif ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )\t\treturn [];\t\t// but not in segment#2\n\t\t\t\t\t\treturn [ inSeg1Pt1 ];\n\t\n\t\t\t\t\t}\n\t\t\t\t\t// segment#2  is a single point\n\t\t\t\t\tif ( seg2Pt ) {\n\t\n\t\t\t\t\t\tif ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )\t\treturn [];\t\t// but not in segment#1\n\t\t\t\t\t\treturn [ inSeg2Pt1 ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// they are collinear segments, which might overlap\n\t\t\t\t\tvar seg1min, seg1max, seg1minVal, seg1maxVal;\n\t\t\t\t\tvar seg2min, seg2max, seg2minVal, seg2maxVal;\n\t\t\t\t\tif ( seg1dx !== 0 ) {\n\t\n\t\t\t\t\t\t// the segments are NOT on a vertical line\n\t\t\t\t\t\tif ( inSeg1Pt1.x < inSeg1Pt2.x ) {\n\t\n\t\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;\n\t\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;\n\t\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( inSeg2Pt1.x < inSeg2Pt2.x ) {\n\t\n\t\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;\n\t\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;\n\t\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// the segments are on a vertical line\n\t\t\t\t\t\tif ( inSeg1Pt1.y < inSeg1Pt2.y ) {\n\t\n\t\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;\n\t\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;\n\t\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( inSeg2Pt1.y < inSeg2Pt2.y ) {\n\t\n\t\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;\n\t\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;\n\t\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\t\t\t\tif ( seg1minVal <= seg2minVal ) {\n\t\n\t\t\t\t\t\tif ( seg1maxVal <  seg2minVal )\treturn [];\n\t\t\t\t\t\tif ( seg1maxVal === seg2minVal )\t{\n\t\n\t\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\n\t\t\t\t\t\t\treturn [ seg2min ];\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg2min, seg1max ];\n\t\t\t\t\t\treturn\t[ seg2min, seg2max ];\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tif ( seg1minVal >  seg2maxVal )\treturn [];\n\t\t\t\t\t\tif ( seg1minVal === seg2maxVal )\t{\n\t\n\t\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\n\t\t\t\t\t\t\treturn [ seg1min ];\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg1min, seg1max ];\n\t\t\t\t\t\treturn\t[ seg1min, seg2max ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {\n\t\n\t\t\t\t// The order of legs is important\n\t\n\t\t\t\t// translation of all points, so that Vertex is at (0,0)\n\t\t\t\tvar legFromPtX\t= inLegFromPt.x - inVertex.x,  legFromPtY\t= inLegFromPt.y - inVertex.y;\n\t\t\t\tvar legToPtX\t= inLegToPt.x\t- inVertex.x,  legToPtY\t\t= inLegToPt.y\t- inVertex.y;\n\t\t\t\tvar otherPtX\t= inOtherPt.x\t- inVertex.x,  otherPtY\t\t= inOtherPt.y\t- inVertex.y;\n\t\n\t\t\t\t// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.\n\t\t\t\tvar from2toAngle\t= legFromPtX * legToPtY - legFromPtY * legToPtX;\n\t\t\t\tvar from2otherAngle\t= legFromPtX * otherPtY - legFromPtY * otherPtX;\n\t\n\t\t\t\tif ( Math.abs( from2toAngle ) > Number.EPSILON ) {\n\t\n\t\t\t\t\t// angle != 180 deg.\n\t\n\t\t\t\t\tvar other2toAngle\t\t= otherPtX * legToPtY - otherPtY * legToPtX;\n\t\t\t\t\t// console.log( \"from2to: \" + from2toAngle + \", from2other: \" + from2otherAngle + \", other2to: \" + other2toAngle );\n\t\n\t\t\t\t\tif ( from2toAngle > 0 ) {\n\t\n\t\t\t\t\t\t// main angle < 180 deg.\n\t\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// main angle > 180 deg.\n\t\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// angle == 180 deg.\n\t\t\t\t\t// console.log( \"from2to: 180 deg., from2other: \" + from2otherAngle  );\n\t\t\t\t\treturn\t( from2otherAngle > 0 );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\n\t\t\tfunction removeHoles( contour, holes ) {\n\t\n\t\t\t\tvar shape = contour.concat(); // work on this shape\n\t\t\t\tvar hole;\n\t\n\t\t\t\tfunction isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {\n\t\n\t\t\t\t\t// Check if hole point lies within angle around shape point\n\t\t\t\t\tvar lastShapeIdx = shape.length - 1;\n\t\n\t\t\t\t\tvar prevShapeIdx = inShapeIdx - 1;\n\t\t\t\t\tif ( prevShapeIdx < 0 )\t\t\tprevShapeIdx = lastShapeIdx;\n\t\n\t\t\t\t\tvar nextShapeIdx = inShapeIdx + 1;\n\t\t\t\t\tif ( nextShapeIdx > lastShapeIdx )\tnextShapeIdx = 0;\n\t\n\t\t\t\t\tvar insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );\n\t\t\t\t\tif ( ! insideAngle ) {\n\t\n\t\t\t\t\t\t// console.log( \"Vertex (Shape): \" + inShapeIdx + \", Point: \" + hole[inHoleIdx].x + \"/\" + hole[inHoleIdx].y );\n\t\t\t\t\t\treturn\tfalse;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Check if shape point lies within angle around hole point\n\t\t\t\t\tvar lastHoleIdx = hole.length - 1;\n\t\n\t\t\t\t\tvar prevHoleIdx = inHoleIdx - 1;\n\t\t\t\t\tif ( prevHoleIdx < 0 )\t\t\tprevHoleIdx = lastHoleIdx;\n\t\n\t\t\t\t\tvar nextHoleIdx = inHoleIdx + 1;\n\t\t\t\t\tif ( nextHoleIdx > lastHoleIdx )\tnextHoleIdx = 0;\n\t\n\t\t\t\t\tinsideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );\n\t\t\t\t\tif ( ! insideAngle ) {\n\t\n\t\t\t\t\t\t// console.log( \"Vertex (Hole): \" + inHoleIdx + \", Point: \" + shape[inShapeIdx].x + \"/\" + shape[inShapeIdx].y );\n\t\t\t\t\t\treturn\tfalse;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn\ttrue;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction intersectsShapeEdge( inShapePt, inHolePt ) {\n\t\n\t\t\t\t\t// checks for intersections with shape edges\n\t\t\t\t\tvar sIdx, nextIdx, intersection;\n\t\t\t\t\tfor ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {\n\t\n\t\t\t\t\t\tnextIdx = sIdx + 1; nextIdx %= shape.length;\n\t\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );\n\t\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn\tfalse;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar indepHoles = [];\n\t\n\t\t\t\tfunction intersectsHoleEdge( inShapePt, inHolePt ) {\n\t\n\t\t\t\t\t// checks for intersections with hole edges\n\t\t\t\t\tvar ihIdx, chkHole,\n\t\t\t\t\t\thIdx, nextIdx, intersection;\n\t\t\t\t\tfor ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {\n\t\n\t\t\t\t\t\tchkHole = holes[ indepHoles[ ihIdx ]];\n\t\t\t\t\t\tfor ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {\n\t\n\t\t\t\t\t\t\tnextIdx = hIdx + 1; nextIdx %= chkHole.length;\n\t\t\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );\n\t\t\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\t\t\t\treturn\tfalse;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar holeIndex, shapeIndex,\n\t\t\t\t\tshapePt, holePt,\n\t\t\t\t\tholeIdx, cutKey, failedCuts = [],\n\t\t\t\t\ttmpShape1, tmpShape2,\n\t\t\t\t\ttmpHole1, tmpHole2;\n\t\n\t\t\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\t\t\tindepHoles.push( h );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar minShapeIndex = 0;\n\t\t\t\tvar counter = indepHoles.length * 2;\n\t\t\t\twhile ( indepHoles.length > 0 ) {\n\t\n\t\t\t\t\tcounter --;\n\t\t\t\t\tif ( counter < 0 ) {\n\t\n\t\t\t\t\t\tconsole.log( \"Infinite Loop! Holes left:\" + indepHoles.length + \", Probably Hole outside Shape!\" );\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// search for shape-vertex and hole-vertex,\n\t\t\t\t\t// which can be connected without intersections\n\t\t\t\t\tfor ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {\n\t\n\t\t\t\t\t\tshapePt = shape[ shapeIndex ];\n\t\t\t\t\t\tholeIndex\t= - 1;\n\t\n\t\t\t\t\t\t// search for hole which can be reached without intersections\n\t\t\t\t\t\tfor ( var h = 0; h < indepHoles.length; h ++ ) {\n\t\n\t\t\t\t\t\t\tholeIdx = indepHoles[ h ];\n\t\n\t\t\t\t\t\t\t// prevent multiple checks\n\t\t\t\t\t\t\tcutKey = shapePt.x + \":\" + shapePt.y + \":\" + holeIdx;\n\t\t\t\t\t\t\tif ( failedCuts[ cutKey ] !== undefined )\t\t\tcontinue;\n\t\n\t\t\t\t\t\t\thole = holes[ holeIdx ];\n\t\t\t\t\t\t\tfor ( var h2 = 0; h2 < hole.length; h2 ++ ) {\n\t\n\t\t\t\t\t\t\t\tholePt = hole[ h2 ];\n\t\t\t\t\t\t\t\tif ( ! isCutLineInsideAngles( shapeIndex, h2 ) )\t\tcontinue;\n\t\t\t\t\t\t\t\tif ( intersectsShapeEdge( shapePt, holePt ) )\t\tcontinue;\n\t\t\t\t\t\t\t\tif ( intersectsHoleEdge( shapePt, holePt ) )\t\tcontinue;\n\t\n\t\t\t\t\t\t\t\tholeIndex = h2;\n\t\t\t\t\t\t\t\tindepHoles.splice( h, 1 );\n\t\n\t\t\t\t\t\t\t\ttmpShape1 = shape.slice( 0, shapeIndex + 1 );\n\t\t\t\t\t\t\t\ttmpShape2 = shape.slice( shapeIndex );\n\t\t\t\t\t\t\t\ttmpHole1 = hole.slice( holeIndex );\n\t\t\t\t\t\t\t\ttmpHole2 = hole.slice( 0, holeIndex + 1 );\n\t\n\t\t\t\t\t\t\t\tshape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );\n\t\n\t\t\t\t\t\t\t\tminShapeIndex = shapeIndex;\n\t\n\t\t\t\t\t\t\t\t// Debug only, to show the selected cuts\n\t\t\t\t\t\t\t\t// glob_CutLines.push( [ shapePt, holePt ] );\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\n\t\n\t\t\t\t\t\t\tfailedCuts[ cutKey ] = true;\t\t\t// remember failure\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn shape; \t\t\t/* shape with no holes */\n\t\n\t\t\t}\n\t\n\t\n\t\t\tvar i, il, f, face,\n\t\t\t\tkey, index,\n\t\t\t\tallPointsMap = {};\n\t\n\t\t\t// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.\n\t\n\t\t\tvar allpoints = contour.concat();\n\t\n\t\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\t\tArray.prototype.push.apply( allpoints, holes[ h ] );\n\t\n\t\t\t}\n\t\n\t\t\t//console.log( \"allpoints\",allpoints, allpoints.length );\n\t\n\t\t\t// prepare all points map\n\t\n\t\t\tfor ( i = 0, il = allpoints.length; i < il; i ++ ) {\n\t\n\t\t\t\tkey = allpoints[ i ].x + \":\" + allpoints[ i ].y;\n\t\n\t\t\t\tif ( allPointsMap[ key ] !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( \"THREE.Shape: Duplicate point\", key );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tallPointsMap[ key ] = i;\n\t\n\t\t\t}\n\t\n\t\t\t// remove holes by cutting paths to holes and adding them to the shape\n\t\t\tvar shapeWithoutHoles = removeHoles( contour, holes );\n\t\n\t\t\tvar triangles = THREE.ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape\n\t\t\t//console.log( \"triangles\",triangles, triangles.length );\n\t\n\t\t\t// check all face vertices against all points map\n\t\n\t\t\tfor ( i = 0, il = triangles.length; i < il; i ++ ) {\n\t\n\t\t\t\tface = triangles[ i ];\n\t\n\t\t\t\tfor ( f = 0; f < 3; f ++ ) {\n\t\n\t\t\t\t\tkey = face[ f ].x + \":\" + face[ f ].y;\n\t\n\t\t\t\t\tindex = allPointsMap[ key ];\n\t\n\t\t\t\t\tif ( index !== undefined ) {\n\t\n\t\t\t\t\t\tface[ f ] = index;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn triangles.concat();\n\t\n\t\t},\n\t\n\t\tisClockWise: function ( pts ) {\n\t\n\t\t\treturn THREE.ShapeUtils.area( pts ) < 0;\n\t\n\t\t},\n\t\n\t\t// Bezier Curves formulas obtained from\n\t\t// http://en.wikipedia.org/wiki/B%C3%A9zier_curve\n\t\n\t\t// Quad Bezier Functions\n\t\n\t\tb2: ( function () {\n\t\n\t\t\tfunction b2p0( t, p ) {\n\t\n\t\t\t\tvar k = 1 - t;\n\t\t\t\treturn k * k * p;\n\t\n\t\t\t}\n\t\n\t\t\tfunction b2p1( t, p ) {\n\t\n\t\t\t\treturn 2 * ( 1 - t ) * t * p;\n\t\n\t\t\t}\n\t\n\t\t\tfunction b2p2( t, p ) {\n\t\n\t\t\t\treturn t * t * p;\n\t\n\t\t\t}\n\t\n\t\t\treturn function b2( t, p0, p1, p2 ) {\n\t\n\t\t\t\treturn b2p0( t, p0 ) + b2p1( t, p1 ) + b2p2( t, p2 );\n\t\n\t\t\t};\n\t\n\t\t} )(),\n\t\n\t\t// Cubic Bezier Functions\n\t\n\t\tb3: ( function () {\n\t\n\t\t\tfunction b3p0( t, p ) {\n\t\n\t\t\t\tvar k = 1 - t;\n\t\t\t\treturn k * k * k * p;\n\t\n\t\t\t}\n\t\n\t\t\tfunction b3p1( t, p ) {\n\t\n\t\t\t\tvar k = 1 - t;\n\t\t\t\treturn 3 * k * k * t * p;\n\t\n\t\t\t}\n\t\n\t\t\tfunction b3p2( t, p ) {\n\t\n\t\t\t\tvar k = 1 - t;\n\t\t\t\treturn 3 * k * t * t * p;\n\t\n\t\t\t}\n\t\n\t\t\tfunction b3p3( t, p ) {\n\t\n\t\t\t\treturn t * t * t * p;\n\t\n\t\t\t}\n\t\n\t\t\treturn function b3( t, p0, p1, p2, p3 ) {\n\t\n\t\t\t\treturn b3p0( t, p0 ) + b3p1( t, p1 ) + b3p2( t, p2 ) + b3p3( t, p3 );\n\t\n\t\t\t};\n\t\n\t\t} )()\n\t\n\t};\n\t\n\t// File:src/extras/core/Curve.js\n\t\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * Extensible curve object\n\t *\n\t * Some common of Curve methods\n\t * .getPoint(t), getTangent(t)\n\t * .getPointAt(u), getTagentAt(u)\n\t * .getPoints(), .getSpacedPoints()\n\t * .getLength()\n\t * .updateArcLengths()\n\t *\n\t * This following classes subclasses THREE.Curve:\n\t *\n\t * -- 2d classes --\n\t * THREE.LineCurve\n\t * THREE.QuadraticBezierCurve\n\t * THREE.CubicBezierCurve\n\t * THREE.SplineCurve\n\t * THREE.ArcCurve\n\t * THREE.EllipseCurve\n\t *\n\t * -- 3d classes --\n\t * THREE.LineCurve3\n\t * THREE.QuadraticBezierCurve3\n\t * THREE.CubicBezierCurve3\n\t * THREE.SplineCurve3\n\t *\n\t * A series of curves can be represented as a THREE.CurvePath\n\t *\n\t **/\n\t\n\t/**************************************************************\n\t *\tAbstract Curve base class\n\t **************************************************************/\n\t\n\tTHREE.Curve = function () {\n\t\n\t};\n\t\n\tTHREE.Curve.prototype = {\n\t\n\t\tconstructor: THREE.Curve,\n\t\n\t\t// Virtual base class method to overwrite and implement in subclasses\n\t\t//\t- t [0 .. 1]\n\t\n\t\tgetPoint: function ( t ) {\n\t\n\t\t\tconsole.warn( \"THREE.Curve: Warning, getPoint() not implemented!\" );\n\t\t\treturn null;\n\t\n\t\t},\n\t\n\t\t// Get point at relative position in curve according to arc length\n\t\t// - u [0 .. 1]\n\t\n\t\tgetPointAt: function ( u ) {\n\t\n\t\t\tvar t = this.getUtoTmapping( u );\n\t\t\treturn this.getPoint( t );\n\t\n\t\t},\n\t\n\t\t// Get sequence of points using getPoint( t )\n\t\n\t\tgetPoints: function ( divisions ) {\n\t\n\t\t\tif ( ! divisions ) divisions = 5;\n\t\n\t\t\tvar d, pts = [];\n\t\n\t\t\tfor ( d = 0; d <= divisions; d ++ ) {\n\t\n\t\t\t\tpts.push( this.getPoint( d / divisions ) );\n\t\n\t\t\t}\n\t\n\t\t\treturn pts;\n\t\n\t\t},\n\t\n\t\t// Get sequence of points using getPointAt( u )\n\t\n\t\tgetSpacedPoints: function ( divisions ) {\n\t\n\t\t\tif ( ! divisions ) divisions = 5;\n\t\n\t\t\tvar d, pts = [];\n\t\n\t\t\tfor ( d = 0; d <= divisions; d ++ ) {\n\t\n\t\t\t\tpts.push( this.getPointAt( d / divisions ) );\n\t\n\t\t\t}\n\t\n\t\t\treturn pts;\n\t\n\t\t},\n\t\n\t\t// Get total curve arc length\n\t\n\t\tgetLength: function () {\n\t\n\t\t\tvar lengths = this.getLengths();\n\t\t\treturn lengths[ lengths.length - 1 ];\n\t\n\t\t},\n\t\n\t\t// Get list of cumulative segment lengths\n\t\n\t\tgetLengths: function ( divisions ) {\n\t\n\t\t\tif ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;\n\t\n\t\t\tif ( this.cacheArcLengths\n\t\t\t\t&& ( this.cacheArcLengths.length === divisions + 1 )\n\t\t\t\t&& ! this.needsUpdate ) {\n\t\n\t\t\t\t//console.log( \"cached\", this.cacheArcLengths );\n\t\t\t\treturn this.cacheArcLengths;\n\t\n\t\t\t}\n\t\n\t\t\tthis.needsUpdate = false;\n\t\n\t\t\tvar cache = [];\n\t\t\tvar current, last = this.getPoint( 0 );\n\t\t\tvar p, sum = 0;\n\t\n\t\t\tcache.push( 0 );\n\t\n\t\t\tfor ( p = 1; p <= divisions; p ++ ) {\n\t\n\t\t\t\tcurrent = this.getPoint ( p / divisions );\n\t\t\t\tsum += current.distanceTo( last );\n\t\t\t\tcache.push( sum );\n\t\t\t\tlast = current;\n\t\n\t\t\t}\n\t\n\t\t\tthis.cacheArcLengths = cache;\n\t\n\t\t\treturn cache; // { sums: cache, sum:sum }; Sum is in the last element.\n\t\n\t\t},\n\t\n\t\tupdateArcLengths: function() {\n\t\n\t\t\tthis.needsUpdate = true;\n\t\t\tthis.getLengths();\n\t\n\t\t},\n\t\n\t\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\t\n\t\tgetUtoTmapping: function ( u, distance ) {\n\t\n\t\t\tvar arcLengths = this.getLengths();\n\t\n\t\t\tvar i = 0, il = arcLengths.length;\n\t\n\t\t\tvar targetArcLength; // The targeted u distance value to get\n\t\n\t\t\tif ( distance ) {\n\t\n\t\t\t\ttargetArcLength = distance;\n\t\n\t\t\t} else {\n\t\n\t\t\t\ttargetArcLength = u * arcLengths[ il - 1 ];\n\t\n\t\t\t}\n\t\n\t\t\t//var time = Date.now();\n\t\n\t\t\t// binary search for the index with largest value smaller than target u distance\n\t\n\t\t\tvar low = 0, high = il - 1, comparison;\n\t\n\t\t\twhile ( low <= high ) {\n\t\n\t\t\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\t\n\t\t\t\tcomparison = arcLengths[ i ] - targetArcLength;\n\t\n\t\t\t\tif ( comparison < 0 ) {\n\t\n\t\t\t\t\tlow = i + 1;\n\t\n\t\t\t\t} else if ( comparison > 0 ) {\n\t\n\t\t\t\t\thigh = i - 1;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\thigh = i;\n\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t// DONE\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\ti = high;\n\t\n\t\t\t//console.log('b' , i, low, high, Date.now()- time);\n\t\n\t\t\tif ( arcLengths[ i ] === targetArcLength ) {\n\t\n\t\t\t\tvar t = i / ( il - 1 );\n\t\t\t\treturn t;\n\t\n\t\t\t}\n\t\n\t\t\t// we could get finer grain at lengths, or use simple interpolation between two points\n\t\n\t\t\tvar lengthBefore = arcLengths[ i ];\n\t\t\tvar lengthAfter = arcLengths[ i + 1 ];\n\t\n\t\t\tvar segmentLength = lengthAfter - lengthBefore;\n\t\n\t\t\t// determine where we are between the 'before' and 'after' points\n\t\n\t\t\tvar segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\n\t\n\t\t\t// add that fractional amount to t\n\t\n\t\t\tvar t = ( i + segmentFraction ) / ( il - 1 );\n\t\n\t\t\treturn t;\n\t\n\t\t},\n\t\n\t\t// Returns a unit vector tangent at t\n\t\t// In case any sub curve does not implement its tangent derivation,\n\t\t// 2 points a small delta apart will be used to find its gradient\n\t\t// which seems to give a reasonable approximation\n\t\n\t\tgetTangent: function( t ) {\n\t\n\t\t\tvar delta = 0.0001;\n\t\t\tvar t1 = t - delta;\n\t\t\tvar t2 = t + delta;\n\t\n\t\t\t// Capping in case of danger\n\t\n\t\t\tif ( t1 < 0 ) t1 = 0;\n\t\t\tif ( t2 > 1 ) t2 = 1;\n\t\n\t\t\tvar pt1 = this.getPoint( t1 );\n\t\t\tvar pt2 = this.getPoint( t2 );\n\t\n\t\t\tvar vec = pt2.clone().sub( pt1 );\n\t\t\treturn vec.normalize();\n\t\n\t\t},\n\t\n\t\tgetTangentAt: function ( u ) {\n\t\n\t\t\tvar t = this.getUtoTmapping( u );\n\t\t\treturn this.getTangent( t );\n\t\n\t\t}\n\t\n\t};\n\t\n\t// TODO: Transformation for Curves?\n\t\n\t/**************************************************************\n\t *\t3D Curves\n\t **************************************************************/\n\t\n\t// A Factory method for creating new curve subclasses\n\t\n\tTHREE.Curve.create = function ( constructor, getPointFunc ) {\n\t\n\t\tconstructor.prototype = Object.create( THREE.Curve.prototype );\n\t\tconstructor.prototype.constructor = constructor;\n\t\tconstructor.prototype.getPoint = getPointFunc;\n\t\n\t\treturn constructor;\n\t\n\t};\n\t\n\t// File:src/extras/core/CurvePath.js\n\t\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t *\n\t **/\n\t\n\t/**************************************************************\n\t *\tCurved Path - a curve path is simply a array of connected\n\t *  curves, but retains the api of a curve\n\t **************************************************************/\n\t\n\tTHREE.CurvePath = function () {\n\t\n\t\tthis.curves = [];\n\t\n\t\tthis.autoClose = false; // Automatically closes the path\n\t\n\t};\n\t\n\tTHREE.CurvePath.prototype = Object.assign( Object.create( THREE.Curve.prototype ), {\n\t\n\t\tconstructor: THREE.CurvePath,\n\t\n\t\tadd: function ( curve ) {\n\t\n\t\t\tthis.curves.push( curve );\n\t\n\t\t},\n\t\n\t\tclosePath: function () {\n\t\n\t\t\t// TODO Test\n\t\t\t// and verify for vector3 (needs to implement equals)\n\t\t\t// Add a line curve if start and end of lines are not connected\n\t\t\tvar startPoint = this.curves[ 0 ].getPoint( 0 );\n\t\t\tvar endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\n\t\n\t\t\tif ( ! startPoint.equals( endPoint ) ) {\n\t\n\t\t\t\tthis.curves.push( new THREE.LineCurve( endPoint, startPoint ) );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\t// To get accurate point with reference to\n\t\t// entire path distance at time t,\n\t\t// following has to be done:\n\t\n\t\t// 1. Length of each sub path have to be known\n\t\t// 2. Locate and identify type of curve\n\t\t// 3. Get t for the curve\n\t\t// 4. Return curve.getPointAt(t')\n\t\n\t\tgetPoint: function ( t ) {\n\t\n\t\t\tvar d = t * this.getLength();\n\t\t\tvar curveLengths = this.getCurveLengths();\n\t\t\tvar i = 0;\n\t\n\t\t\t// To think about boundaries points.\n\t\n\t\t\twhile ( i < curveLengths.length ) {\n\t\n\t\t\t\tif ( curveLengths[ i ] >= d ) {\n\t\n\t\t\t\t\tvar diff = curveLengths[ i ] - d;\n\t\t\t\t\tvar curve = this.curves[ i ];\n\t\n\t\t\t\t\tvar u = 1 - diff / curve.getLength();\n\t\n\t\t\t\t\treturn curve.getPointAt( u );\n\t\n\t\t\t\t}\n\t\n\t\t\t\ti ++;\n\t\n\t\t\t}\n\t\n\t\t\treturn null;\n\t\n\t\t\t// loop where sum != 0, sum > d , sum+1 <d\n\t\n\t\t},\n\t\n\t\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\n\t\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n\t\t// getPoint() depends on getLength\n\t\n\t\tgetLength: function () {\n\t\n\t\t\tvar lens = this.getCurveLengths();\n\t\t\treturn lens[ lens.length - 1 ];\n\t\n\t\t},\n\t\n\t\t// cacheLengths must be recalculated.\n\t\tupdateArcLengths: function () {\n\t\n\t\t\tthis.needsUpdate = true;\n\t\t\tthis.cacheLengths = null;\n\t\t\tthis.getLengths();\n\t\n\t\t},\n\t\n\t\t// Compute lengths and cache them\n\t\t// We cannot overwrite getLengths() because UtoT mapping uses it.\n\t\n\t\tgetCurveLengths: function () {\n\t\n\t\t\t// We use cache values if curves and cache array are same length\n\t\n\t\t\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\n\t\n\t\t\t\treturn this.cacheLengths;\n\t\n\t\t\t}\n\t\n\t\t\t// Get length of sub-curve\n\t\t\t// Push sums into cached array\n\t\n\t\t\tvar lengths = [], sums = 0;\n\t\n\t\t\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\n\t\n\t\t\t\tsums += this.curves[ i ].getLength();\n\t\t\t\tlengths.push( sums );\n\t\n\t\t\t}\n\t\n\t\t\tthis.cacheLengths = lengths;\n\t\n\t\t\treturn lengths;\n\t\n\t\t},\n\t\n\t\t/**************************************************************\n\t\t *\tCreate Geometries Helpers\n\t\t **************************************************************/\n\t\n\t\t/// Generate geometry from path points (for Line or Points objects)\n\t\n\t\tcreatePointsGeometry: function ( divisions ) {\n\t\n\t\t\tvar pts = this.getPoints( divisions );\n\t\t\treturn this.createGeometry( pts );\n\t\n\t\t},\n\t\n\t\t// Generate geometry from equidistant sampling along the path\n\t\n\t\tcreateSpacedPointsGeometry: function ( divisions ) {\n\t\n\t\t\tvar pts = this.getSpacedPoints( divisions );\n\t\t\treturn this.createGeometry( pts );\n\t\n\t\t},\n\t\n\t\tcreateGeometry: function ( points ) {\n\t\n\t\t\tvar geometry = new THREE.Geometry();\n\t\n\t\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar point = points[ i ];\n\t\t\t\tgeometry.vertices.push( new THREE.Vector3( point.x, point.y, point.z || 0 ) );\n\t\n\t\t\t}\n\t\n\t\t\treturn geometry;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/extras/core/Font.js\n\t\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.Font = function ( data ) {\n\t\n\t\tthis.data = data;\n\t\n\t};\n\t\n\tObject.assign( THREE.Font.prototype, {\n\t\n\t\tgenerateShapes: function ( text, size, divisions ) {\n\t\n\t\t\tfunction createPaths( text ) {\n\t\n\t\t\t\tvar chars = String( text ).split( '' );\n\t\t\t\tvar scale = size / data.resolution;\n\t\t\t\tvar offset = 0;\n\t\n\t\t\t\tvar paths = [];\n\t\n\t\t\t\tfor ( var i = 0; i < chars.length; i ++ ) {\n\t\n\t\t\t\t\tvar ret = createPath( chars[ i ], scale, offset );\n\t\t\t\t\toffset += ret.offset;\n\t\n\t\t\t\t\tpaths.push( ret.path );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn paths;\n\t\n\t\t\t}\n\t\n\t\t\tfunction createPath( c, scale, offset ) {\n\t\n\t\t\t\tvar glyph = data.glyphs[ c ] || data.glyphs[ '?' ];\n\t\n\t\t\t\tif ( ! glyph ) return;\n\t\n\t\t\t\tvar path = new THREE.Path();\n\t\n\t\t\t\tvar pts = [], b2 = THREE.ShapeUtils.b2, b3 = THREE.ShapeUtils.b3;\n\t\t\t\tvar x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;\n\t\n\t\t\t\tif ( glyph.o ) {\n\t\n\t\t\t\t\tvar outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\n\t\n\t\t\t\t\tfor ( var i = 0, l = outline.length; i < l; ) {\n\t\n\t\t\t\t\t\tvar action = outline[ i ++ ];\n\t\n\t\t\t\t\t\tswitch ( action ) {\n\t\n\t\t\t\t\t\t\tcase 'm': // moveTo\n\t\n\t\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\ty = outline[ i ++ ] * scale;\n\t\n\t\t\t\t\t\t\t\tpath.moveTo( x, y );\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'l': // lineTo\n\t\n\t\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\ty = outline[ i ++ ] * scale;\n\t\n\t\t\t\t\t\t\t\tpath.lineTo( x, y );\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'q': // quadraticCurveTo\n\t\n\t\t\t\t\t\t\t\tcpx  = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\tcpy  = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale;\n\t\n\t\t\t\t\t\t\t\tpath.quadraticCurveTo( cpx1, cpy1, cpx, cpy );\n\t\n\t\t\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\n\t\n\t\t\t\t\t\t\t\tif ( laste ) {\n\t\n\t\t\t\t\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\t\t\t\t\tcpy0 = laste.y;\n\t\n\t\t\t\t\t\t\t\t\tfor ( var i2 = 1; i2 <= divisions; i2 ++ ) {\n\t\n\t\t\t\t\t\t\t\t\t\tvar t = i2 / divisions;\n\t\t\t\t\t\t\t\t\t\tb2( t, cpx0, cpx1, cpx );\n\t\t\t\t\t\t\t\t\t\tb2( t, cpy0, cpy1, cpy );\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'b': // bezierCurveTo\n\t\n\t\t\t\t\t\t\t\tcpx  = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\tcpy  = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\t\tcpx2 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\tcpy2 = outline[ i ++ ] * scale;\n\t\n\t\t\t\t\t\t\t\tpath.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );\n\t\n\t\t\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\n\t\n\t\t\t\t\t\t\t\tif ( laste ) {\n\t\n\t\t\t\t\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\t\t\t\t\tcpy0 = laste.y;\n\t\n\t\t\t\t\t\t\t\t\tfor ( var i2 = 1; i2 <= divisions; i2 ++ ) {\n\t\n\t\t\t\t\t\t\t\t\t\tvar t = i2 / divisions;\n\t\t\t\t\t\t\t\t\t\tb3( t, cpx0, cpx1, cpx2, cpx );\n\t\t\t\t\t\t\t\t\t\tb3( t, cpy0, cpy1, cpy2, cpy );\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn { offset: glyph.ha * scale, path: path };\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tif ( size === undefined ) size = 100;\n\t\t\tif ( divisions === undefined ) divisions = 4;\n\t\n\t\t\tvar data = this.data;\n\t\n\t\t\tvar paths = createPaths( text );\n\t\t\tvar shapes = [];\n\t\n\t\t\tfor ( var p = 0, pl = paths.length; p < pl; p ++ ) {\n\t\n\t\t\t\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\n\t\n\t\t\t}\n\t\n\t\t\treturn shapes;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/extras/core/Path.js\n\t\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * Creates free form 2d path using series of points, lines or curves.\n\t *\n\t **/\n\t\n\tTHREE.Path = function ( points ) {\n\t\n\t\tTHREE.CurvePath.call( this );\n\t\n\t\tthis.actions = [];\n\t\n\t\tif ( points ) {\n\t\n\t\t\tthis.fromPoints( points );\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.Path.prototype = Object.assign( Object.create( THREE.CurvePath.prototype ), {\n\t\n\t\tconstructor: THREE.Path,\n\t\n\t\t// TODO Clean up PATH API\n\t\n\t\t// Create path using straight lines to connect all points\n\t\t// - vectors: array of Vector2\n\t\n\t\tfromPoints: function ( vectors ) {\n\t\n\t\t\tthis.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );\n\t\n\t\t\tfor ( var i = 1, l = vectors.length; i < l; i ++ ) {\n\t\n\t\t\t\tthis.lineTo( vectors[ i ].x, vectors[ i ].y );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tmoveTo: function ( x, y ) {\n\t\n\t\t\tthis.actions.push( { action: 'moveTo', args: [ x, y ] } );\n\t\n\t\t},\n\t\n\t\tlineTo: function ( x, y ) {\n\t\n\t\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\t\n\t\t\tvar x0 = lastargs[ lastargs.length - 2 ];\n\t\t\tvar y0 = lastargs[ lastargs.length - 1 ];\n\t\n\t\t\tvar curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );\n\t\t\tthis.curves.push( curve );\n\t\n\t\t\tthis.actions.push( { action: 'lineTo', args: [ x, y ] } );\n\t\n\t\t},\n\t\n\t\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\n\t\n\t\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\t\n\t\t\tvar x0 = lastargs[ lastargs.length - 2 ];\n\t\t\tvar y0 = lastargs[ lastargs.length - 1 ];\n\t\n\t\t\tvar curve = new THREE.QuadraticBezierCurve(\n\t\t\t\tnew THREE.Vector2( x0, y0 ),\n\t\t\t\tnew THREE.Vector2( aCPx, aCPy ),\n\t\t\t\tnew THREE.Vector2( aX, aY )\n\t\t\t);\n\t\n\t\t\tthis.curves.push( curve );\n\t\n\t\t\tthis.actions.push( { action: 'quadraticCurveTo', args: [ aCPx, aCPy, aX, aY ] } );\n\t\n\t\t},\n\t\n\t\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\t\n\t\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\t\n\t\t\tvar x0 = lastargs[ lastargs.length - 2 ];\n\t\t\tvar y0 = lastargs[ lastargs.length - 1 ];\n\t\n\t\t\tvar curve = new THREE.CubicBezierCurve(\n\t\t\t\tnew THREE.Vector2( x0, y0 ),\n\t\t\t\tnew THREE.Vector2( aCP1x, aCP1y ),\n\t\t\t\tnew THREE.Vector2( aCP2x, aCP2y ),\n\t\t\t\tnew THREE.Vector2( aX, aY )\n\t\t\t);\n\t\n\t\t\tthis.curves.push( curve );\n\t\n\t\t\tthis.actions.push( { action: 'bezierCurveTo', args: [ aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ] } );\n\t\n\t\t},\n\t\n\t\tsplineThru: function ( pts /*Array of Vector*/ ) {\n\t\n\t\t\tvar args = Array.prototype.slice.call( arguments );\n\t\n\t\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\t\n\t\t\tvar x0 = lastargs[ lastargs.length - 2 ];\n\t\t\tvar y0 = lastargs[ lastargs.length - 1 ];\n\t\n\t\t\tvar npts = [ new THREE.Vector2( x0, y0 ) ];\n\t\t\tArray.prototype.push.apply( npts, pts );\n\t\n\t\t\tvar curve = new THREE.SplineCurve( npts );\n\t\t\tthis.curves.push( curve );\n\t\n\t\t\tvar lastPoint = pts[ pts.length - 1 ];\n\t\t\targs.push( lastPoint.x );\n\t\t\targs.push( lastPoint.y );\n\t\n\t\t\tthis.actions.push( { action: 'splineThru', args: args } );\n\t\n\t\t},\n\t\n\t\tarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\t\n\t\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\t\t\tvar x0 = lastargs[ lastargs.length - 2 ];\n\t\t\tvar y0 = lastargs[ lastargs.length - 1 ];\n\t\n\t\t\tthis.absarc( aX + x0, aY + y0, aRadius,\n\t\t\t\taStartAngle, aEndAngle, aClockwise );\n\t\n\t\t},\n\t\n\t\tabsarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\t\n\t\t\tthis.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\t\n\t\t},\n\t\n\t\tellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\t\n\t\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\t\t\tvar x0 = lastargs[ lastargs.length - 2 ];\n\t\t\tvar y0 = lastargs[ lastargs.length - 1 ];\n\t\n\t\t\tthis.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\t\n\t\t},\n\t\n\t\tabsellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\t\n\t\t\tvar args = [\n\t\t\t\taX, aY,\n\t\t\t\txRadius, yRadius,\n\t\t\t\taStartAngle, aEndAngle,\n\t\t\t\taClockwise,\n\t\t\t\taRotation || 0 // aRotation is optional.\n\t\t\t];\n\t\n\t\t\tvar curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\t\t\tthis.curves.push( curve );\n\t\n\t\t\tvar lastPoint = curve.getPoint( 1 );\n\t\t\targs.push( lastPoint.x );\n\t\t\targs.push( lastPoint.y );\n\t\n\t\t\tthis.actions.push( { action: 'ellipse', args: args } );\n\t\n\t\t},\n\t\n\t\tgetSpacedPoints: function ( divisions ) {\n\t\n\t\t\tif ( ! divisions ) divisions = 40;\n\t\n\t\t\tvar points = [];\n\t\n\t\t\tfor ( var i = 0; i < divisions; i ++ ) {\n\t\n\t\t\t\tpoints.push( this.getPoint( i / divisions ) );\n\t\n\t\t\t\t//if ( !this.getPoint( i / divisions ) ) throw \"DIE\";\n\t\n\t\t\t}\n\t\n\t\t\tif ( this.autoClose ) {\n\t\n\t\t\t\tpoints.push( points[ 0 ] );\n\t\n\t\t\t}\n\t\n\t\t\treturn points;\n\t\n\t\t},\n\t\n\t\tgetPoints: function ( divisions ) {\n\t\n\t\t\tdivisions = divisions || 12;\n\t\n\t\t\tvar b2 = THREE.ShapeUtils.b2;\n\t\t\tvar b3 = THREE.ShapeUtils.b3;\n\t\n\t\t\tvar points = [];\n\t\n\t\t\tvar cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,\n\t\t\t\tlaste, tx, ty;\n\t\n\t\t\tfor ( var i = 0, l = this.actions.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar item = this.actions[ i ];\n\t\n\t\t\t\tvar action = item.action;\n\t\t\t\tvar args = item.args;\n\t\n\t\t\t\tswitch ( action ) {\n\t\n\t\t\t\tcase 'moveTo':\n\t\n\t\t\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\n\t\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase 'lineTo':\n\t\n\t\t\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\n\t\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase 'quadraticCurveTo':\n\t\n\t\t\t\t\tcpx  = args[ 2 ];\n\t\t\t\t\tcpy  = args[ 3 ];\n\t\n\t\t\t\t\tcpx1 = args[ 0 ];\n\t\t\t\t\tcpy1 = args[ 1 ];\n\t\n\t\t\t\t\tif ( points.length > 0 ) {\n\t\n\t\t\t\t\t\tlaste = points[ points.length - 1 ];\n\t\n\t\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\t\tcpy0 = laste.y;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tlaste = this.actions[ i - 1 ].args;\n\t\n\t\t\t\t\t\tcpx0 = laste[ laste.length - 2 ];\n\t\t\t\t\t\tcpy0 = laste[ laste.length - 1 ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( var j = 1; j <= divisions; j ++ ) {\n\t\n\t\t\t\t\t\tvar t = j / divisions;\n\t\n\t\t\t\t\t\ttx = b2( t, cpx0, cpx1, cpx );\n\t\t\t\t\t\tty = b2( t, cpy0, cpy1, cpy );\n\t\n\t\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase 'bezierCurveTo':\n\t\n\t\t\t\t\tcpx  = args[ 4 ];\n\t\t\t\t\tcpy  = args[ 5 ];\n\t\n\t\t\t\t\tcpx1 = args[ 0 ];\n\t\t\t\t\tcpy1 = args[ 1 ];\n\t\n\t\t\t\t\tcpx2 = args[ 2 ];\n\t\t\t\t\tcpy2 = args[ 3 ];\n\t\n\t\t\t\t\tif ( points.length > 0 ) {\n\t\n\t\t\t\t\t\tlaste = points[ points.length - 1 ];\n\t\n\t\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\t\tcpy0 = laste.y;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tlaste = this.actions[ i - 1 ].args;\n\t\n\t\t\t\t\t\tcpx0 = laste[ laste.length - 2 ];\n\t\t\t\t\t\tcpy0 = laste[ laste.length - 1 ];\n\t\n\t\t\t\t\t}\n\t\n\t\n\t\t\t\t\tfor ( var j = 1; j <= divisions; j ++ ) {\n\t\n\t\t\t\t\t\tvar t = j / divisions;\n\t\n\t\t\t\t\t\ttx = b3( t, cpx0, cpx1, cpx2, cpx );\n\t\t\t\t\t\tty = b3( t, cpy0, cpy1, cpy2, cpy );\n\t\n\t\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase 'splineThru':\n\t\n\t\t\t\t\tlaste = this.actions[ i - 1 ].args;\n\t\n\t\t\t\t\tvar last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );\n\t\t\t\t\tvar spts = [ last ];\n\t\n\t\t\t\t\tvar n = divisions * args[ 0 ].length;\n\t\n\t\t\t\t\tspts = spts.concat( args[ 0 ] );\n\t\n\t\t\t\t\tvar spline = new THREE.SplineCurve( spts );\n\t\n\t\t\t\t\tfor ( var j = 1; j <= n; j ++ ) {\n\t\n\t\t\t\t\t\tpoints.push( spline.getPointAt( j / n ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase 'arc':\n\t\n\t\t\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\n\t\t\t\t\t\taRadius = args[ 2 ],\n\t\t\t\t\t\taStartAngle = args[ 3 ], aEndAngle = args[ 4 ],\n\t\t\t\t\t\taClockwise = !! args[ 5 ];\n\t\n\t\t\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\n\t\t\t\t\tvar angle;\n\t\t\t\t\tvar tdivisions = divisions * 2;\n\t\n\t\t\t\t\tfor ( var j = 1; j <= tdivisions; j ++ ) {\n\t\n\t\t\t\t\t\tvar t = j / tdivisions;\n\t\n\t\t\t\t\t\tif ( ! aClockwise ) {\n\t\n\t\t\t\t\t\t\tt = 1 - t;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tangle = aStartAngle + t * deltaAngle;\n\t\n\t\t\t\t\t\ttx = aX + aRadius * Math.cos( angle );\n\t\t\t\t\t\tty = aY + aRadius * Math.sin( angle );\n\t\n\t\t\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\n\t\n\t\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t//console.log(points);\n\t\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase 'ellipse':\n\t\n\t\t\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\n\t\t\t\t\t\txRadius = args[ 2 ],\n\t\t\t\t\t\tyRadius = args[ 3 ],\n\t\t\t\t\t\taStartAngle = args[ 4 ], aEndAngle = args[ 5 ],\n\t\t\t\t\t\taClockwise = !! args[ 6 ],\n\t\t\t\t\t\taRotation = args[ 7 ];\n\t\n\t\n\t\t\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\n\t\t\t\t\tvar angle;\n\t\t\t\t\tvar tdivisions = divisions * 2;\n\t\n\t\t\t\t\tvar cos, sin;\n\t\t\t\t\tif ( aRotation !== 0 ) {\n\t\n\t\t\t\t\t\tcos = Math.cos( aRotation );\n\t\t\t\t\t\tsin = Math.sin( aRotation );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( var j = 1; j <= tdivisions; j ++ ) {\n\t\n\t\t\t\t\t\tvar t = j / tdivisions;\n\t\n\t\t\t\t\t\tif ( ! aClockwise ) {\n\t\n\t\t\t\t\t\t\tt = 1 - t;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tangle = aStartAngle + t * deltaAngle;\n\t\n\t\t\t\t\t\ttx = aX + xRadius * Math.cos( angle );\n\t\t\t\t\t\tty = aY + yRadius * Math.sin( angle );\n\t\n\t\t\t\t\t\tif ( aRotation !== 0 ) {\n\t\n\t\t\t\t\t\t\tvar x = tx, y = ty;\n\t\n\t\t\t\t\t\t\t// Rotate the point about the center of the ellipse.\n\t\t\t\t\t\t\ttx = ( x - aX ) * cos - ( y - aY ) * sin + aX;\n\t\t\t\t\t\t\tty = ( x - aX ) * sin + ( y - aY ) * cos + aY;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\n\t\n\t\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t//console.log(points);\n\t\n\t\t\t\t\tbreak;\n\t\n\t\t\t\t} // end switch\n\t\n\t\t\t}\n\t\n\t\n\t\n\t\t\t// Normalize to remove the closing point by default.\n\t\t\tvar lastPoint = points[ points.length - 1 ];\n\t\t\tif ( Math.abs( lastPoint.x - points[ 0 ].x ) < Number.EPSILON &&\n\t\t\t\t\t Math.abs( lastPoint.y - points[ 0 ].y ) < Number.EPSILON )\n\t\t\t\tpoints.splice( points.length - 1, 1 );\n\t\n\t\t\tif ( this.autoClose ) {\n\t\n\t\t\t\tpoints.push( points[ 0 ] );\n\t\n\t\t\t}\n\t\n\t\t\treturn points;\n\t\n\t\t},\n\t\n\t\ttoShapes: function ( isCCW, noHoles ) {\n\t\n\t\t\tfunction extractSubpaths( inActions ) {\n\t\n\t\t\t\tvar subPaths = [], lastPath = new THREE.Path();\n\t\n\t\t\t\tfor ( var i = 0, l = inActions.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar item = inActions[ i ];\n\t\n\t\t\t\t\tvar args = item.args;\n\t\t\t\t\tvar action = item.action;\n\t\n\t\t\t\t\tif ( action === 'moveTo' ) {\n\t\n\t\t\t\t\t\tif ( lastPath.actions.length !== 0 ) {\n\t\n\t\t\t\t\t\t\tsubPaths.push( lastPath );\n\t\t\t\t\t\t\tlastPath = new THREE.Path();\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tlastPath[ action ].apply( lastPath, args );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( lastPath.actions.length !== 0 ) {\n\t\n\t\t\t\t\tsubPaths.push( lastPath );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// console.log(subPaths);\n\t\n\t\t\t\treturn\tsubPaths;\n\t\n\t\t\t}\n\t\n\t\t\tfunction toShapesNoHoles( inSubpaths ) {\n\t\n\t\t\t\tvar shapes = [];\n\t\n\t\t\t\tfor ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar tmpPath = inSubpaths[ i ];\n\t\n\t\t\t\t\tvar tmpShape = new THREE.Shape();\n\t\t\t\t\ttmpShape.actions = tmpPath.actions;\n\t\t\t\t\ttmpShape.curves = tmpPath.curves;\n\t\n\t\t\t\t\tshapes.push( tmpShape );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t//console.log(\"shape\", shapes);\n\t\n\t\t\t\treturn shapes;\n\t\n\t\t\t}\n\t\n\t\t\tfunction isPointInsidePolygon( inPt, inPolygon ) {\n\t\n\t\t\t\tvar polyLen = inPolygon.length;\n\t\n\t\t\t\t// inPt on polygon contour => immediate success    or\n\t\t\t\t// toggling of inside/outside at every single! intersection point of an edge\n\t\t\t\t//  with the horizontal line through inPt, left of inPt\n\t\t\t\t//  not counting lowerY endpoints of edges and whole edges on that line\n\t\t\t\tvar inside = false;\n\t\t\t\tfor ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\n\t\n\t\t\t\t\tvar edgeLowPt  = inPolygon[ p ];\n\t\t\t\t\tvar edgeHighPt = inPolygon[ q ];\n\t\n\t\t\t\t\tvar edgeDx = edgeHighPt.x - edgeLowPt.x;\n\t\t\t\t\tvar edgeDy = edgeHighPt.y - edgeLowPt.y;\n\t\n\t\t\t\t\tif ( Math.abs( edgeDy ) > Number.EPSILON ) {\n\t\n\t\t\t\t\t\t// not parallel\n\t\t\t\t\t\tif ( edgeDy < 0 ) {\n\t\n\t\t\t\t\t\t\tedgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;\n\t\t\t\t\t\t\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \t\tcontinue;\n\t\n\t\t\t\t\t\tif ( inPt.y === edgeLowPt.y ) {\n\t\n\t\t\t\t\t\t\tif ( inPt.x === edgeLowPt.x )\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tvar perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\n\t\t\t\t\t\t\tif ( perpEdge === 0 )\t\t\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\t\tif ( perpEdge < 0 ) \t\t\t\tcontinue;\n\t\t\t\t\t\t\tinside = ! inside;\t\t// true intersection left of inPt\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// parallel or collinear\n\t\t\t\t\t\tif ( inPt.y !== edgeLowPt.y ) \t\tcontinue;\t\t\t// parallel\n\t\t\t\t\t\t// edge lies on the same horizontal line as inPt\n\t\t\t\t\t\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\n\t\t\t\t\t\t\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\t\treturn\ttrue;\t// inPt: Point on contour !\n\t\t\t\t\t\t// continue;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn\tinside;\n\t\n\t\t\t}\n\t\n\t\t\tvar isClockWise = THREE.ShapeUtils.isClockWise;\n\t\n\t\t\tvar subPaths = extractSubpaths( this.actions );\n\t\t\tif ( subPaths.length === 0 ) return [];\n\t\n\t\t\tif ( noHoles === true )\treturn\ttoShapesNoHoles( subPaths );\n\t\n\t\n\t\t\tvar solid, tmpPath, tmpShape, shapes = [];\n\t\n\t\t\tif ( subPaths.length === 1 ) {\n\t\n\t\t\t\ttmpPath = subPaths[ 0 ];\n\t\t\t\ttmpShape = new THREE.Shape();\n\t\t\t\ttmpShape.actions = tmpPath.actions;\n\t\t\t\ttmpShape.curves = tmpPath.curves;\n\t\t\t\tshapes.push( tmpShape );\n\t\t\t\treturn shapes;\n\t\n\t\t\t}\n\t\n\t\t\tvar holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\n\t\t\tholesFirst = isCCW ? ! holesFirst : holesFirst;\n\t\n\t\t\t// console.log(\"Holes first\", holesFirst);\n\t\n\t\t\tvar betterShapeHoles = [];\n\t\t\tvar newShapes = [];\n\t\t\tvar newShapeHoles = [];\n\t\t\tvar mainIdx = 0;\n\t\t\tvar tmpPoints;\n\t\n\t\t\tnewShapes[ mainIdx ] = undefined;\n\t\t\tnewShapeHoles[ mainIdx ] = [];\n\t\n\t\t\tfor ( var i = 0, l = subPaths.length; i < l; i ++ ) {\n\t\n\t\t\t\ttmpPath = subPaths[ i ];\n\t\t\t\ttmpPoints = tmpPath.getPoints();\n\t\t\t\tsolid = isClockWise( tmpPoints );\n\t\t\t\tsolid = isCCW ? ! solid : solid;\n\t\n\t\t\t\tif ( solid ) {\n\t\n\t\t\t\t\tif ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )\tmainIdx ++;\n\t\n\t\t\t\t\tnewShapes[ mainIdx ] = { s: new THREE.Shape(), p: tmpPoints };\n\t\t\t\t\tnewShapes[ mainIdx ].s.actions = tmpPath.actions;\n\t\t\t\t\tnewShapes[ mainIdx ].s.curves = tmpPath.curves;\n\t\n\t\t\t\t\tif ( holesFirst )\tmainIdx ++;\n\t\t\t\t\tnewShapeHoles[ mainIdx ] = [];\n\t\n\t\t\t\t\t//console.log('cw', i);\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tnewShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\n\t\n\t\t\t\t\t//console.log('ccw', i);\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// only Holes? -> probably all Shapes with wrong orientation\n\t\t\tif ( ! newShapes[ 0 ] )\treturn\ttoShapesNoHoles( subPaths );\n\t\n\t\n\t\t\tif ( newShapes.length > 1 ) {\n\t\n\t\t\t\tvar ambiguous = false;\n\t\t\t\tvar toChange = [];\n\t\n\t\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\t\n\t\t\t\t\tbetterShapeHoles[ sIdx ] = [];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\t\n\t\t\t\t\tvar sho = newShapeHoles[ sIdx ];\n\t\n\t\t\t\t\tfor ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {\n\t\n\t\t\t\t\t\tvar ho = sho[ hIdx ];\n\t\t\t\t\t\tvar hole_unassigned = true;\n\t\n\t\t\t\t\t\tfor ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\n\t\n\t\t\t\t\t\t\tif ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\n\t\n\t\t\t\t\t\t\t\tif ( sIdx !== s2Idx )\ttoChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );\n\t\t\t\t\t\t\t\tif ( hole_unassigned ) {\n\t\n\t\t\t\t\t\t\t\t\thole_unassigned = false;\n\t\t\t\t\t\t\t\t\tbetterShapeHoles[ s2Idx ].push( ho );\n\t\n\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\tambiguous = true;\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( hole_unassigned ) {\n\t\n\t\t\t\t\t\t\tbetterShapeHoles[ sIdx ].push( ho );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\t\t\t// console.log(\"ambiguous: \", ambiguous);\n\t\t\t\tif ( toChange.length > 0 ) {\n\t\n\t\t\t\t\t// console.log(\"to change: \", toChange);\n\t\t\t\t\tif ( ! ambiguous )\tnewShapeHoles = betterShapeHoles;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tvar tmpHoles;\n\t\n\t\t\tfor ( var i = 0, il = newShapes.length; i < il; i ++ ) {\n\t\n\t\t\t\ttmpShape = newShapes[ i ].s;\n\t\t\t\tshapes.push( tmpShape );\n\t\t\t\ttmpHoles = newShapeHoles[ i ];\n\t\n\t\t\t\tfor ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\ttmpShape.holes.push( tmpHoles[ j ].h );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t//console.log(\"shape\", shapes);\n\t\n\t\t\treturn shapes;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/extras/core/Shape.js\n\t\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * Defines a 2d shape plane using paths.\n\t **/\n\t\n\t// STEP 1 Create a path.\n\t// STEP 2 Turn path into shape.\n\t// STEP 3 ExtrudeGeometry takes in Shape/Shapes\n\t// STEP 3a - Extract points from each shape, turn to vertices\n\t// STEP 3b - Triangulate each shape, add faces.\n\t\n\tTHREE.Shape = function () {\n\t\n\t\tTHREE.Path.apply( this, arguments );\n\t\n\t\tthis.holes = [];\n\t\n\t};\n\t\n\tTHREE.Shape.prototype = Object.assign( Object.create( THREE.Path.prototype ), {\n\t\n\t\tconstructor: THREE.Shape,\n\t\n\t\t// Convenience method to return ExtrudeGeometry\n\t\n\t\textrude: function ( options ) {\n\t\n\t\t\treturn new THREE.ExtrudeGeometry( this, options );\n\t\n\t\t},\n\t\n\t\t// Convenience method to return ShapeGeometry\n\t\n\t\tmakeGeometry: function ( options ) {\n\t\n\t\t\treturn new THREE.ShapeGeometry( this, options );\n\t\n\t\t},\n\t\n\t\tgetPointsHoles: function ( divisions ) {\n\t\n\t\t\tvar holesPts = [];\n\t\n\t\t\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\n\t\n\t\t\t\tholesPts[ i ] = this.holes[ i ].getPoints( divisions );\n\t\n\t\t\t}\n\t\n\t\t\treturn holesPts;\n\t\n\t\t},\n\t\n\t\t// Get points of shape and holes (keypoints based on segments parameter)\n\t\n\t\textractAllPoints: function ( divisions ) {\n\t\n\t\t\treturn {\n\t\n\t\t\t\tshape: this.getPoints( divisions ),\n\t\t\t\tholes: this.getPointsHoles( divisions )\n\t\n\t\t\t};\n\t\n\t\t},\n\t\n\t\textractPoints: function ( divisions ) {\n\t\n\t\t\treturn this.extractAllPoints( divisions );\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/extras/curves/LineCurve.js\n\t\n\t/**************************************************************\n\t *\tLine\n\t **************************************************************/\n\t\n\tTHREE.LineCurve = function ( v1, v2 ) {\n\t\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\n\t};\n\t\n\tTHREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );\n\tTHREE.LineCurve.prototype.constructor = THREE.LineCurve;\n\t\n\tTHREE.LineCurve.prototype.getPoint = function ( t ) {\n\t\n\t\tvar point = this.v2.clone().sub( this.v1 );\n\t\tpoint.multiplyScalar( t ).add( this.v1 );\n\t\n\t\treturn point;\n\t\n\t};\n\t\n\t// Line curve is linear, so we can overwrite default getPointAt\n\t\n\tTHREE.LineCurve.prototype.getPointAt = function ( u ) {\n\t\n\t\treturn this.getPoint( u );\n\t\n\t};\n\t\n\tTHREE.LineCurve.prototype.getTangent = function( t ) {\n\t\n\t\tvar tangent = this.v2.clone().sub( this.v1 );\n\t\n\t\treturn tangent.normalize();\n\t\n\t};\n\t\n\t// File:src/extras/curves/QuadraticBezierCurve.js\n\t\n\t/**************************************************************\n\t *\tQuadratic Bezier curve\n\t **************************************************************/\n\t\n\t\n\tTHREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {\n\t\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\n\t};\n\t\n\tTHREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );\n\tTHREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;\n\t\n\t\n\tTHREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {\n\t\n\t\tvar b2 = THREE.ShapeUtils.b2;\n\t\n\t\treturn new THREE.Vector2(\n\t\t\tb2( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\t\tb2( t, this.v0.y, this.v1.y, this.v2.y )\n\t\t);\n\t\n\t};\n\t\n\t\n\tTHREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {\n\t\n\t\tvar tangentQuadraticBezier = THREE.CurveUtils.tangentQuadraticBezier;\n\t\n\t\treturn new THREE.Vector2(\n\t\t\ttangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\t\ttangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y )\n\t\t).normalize();\n\t\n\t};\n\t\n\t// File:src/extras/curves/CubicBezierCurve.js\n\t\n\t/**************************************************************\n\t *\tCubic Bezier curve\n\t **************************************************************/\n\t\n\tTHREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {\n\t\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\tthis.v3 = v3;\n\t\n\t};\n\t\n\tTHREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );\n\tTHREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;\n\t\n\tTHREE.CubicBezierCurve.prototype.getPoint = function ( t ) {\n\t\n\t\tvar b3 = THREE.ShapeUtils.b3;\n\t\n\t\treturn new THREE.Vector2( \n\t\t\tb3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\t\tb3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\n\t\t);\n\t\n\t};\n\t\n\tTHREE.CubicBezierCurve.prototype.getTangent = function( t ) {\n\t\n\t\tvar tangentCubicBezier = THREE.CurveUtils.tangentCubicBezier;\n\t\n\t\treturn new THREE.Vector2( \n\t\t\ttangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\t\ttangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\n\t\t).normalize();\n\t\n\t};\n\t\n\t// File:src/extras/curves/SplineCurve.js\n\t\n\t/**************************************************************\n\t *\tSpline curve\n\t **************************************************************/\n\t\n\tTHREE.SplineCurve = function ( points /* array of Vector2 */ ) {\n\t\n\t\tthis.points = ( points == undefined ) ? [] : points;\n\t\n\t};\n\t\n\tTHREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );\n\tTHREE.SplineCurve.prototype.constructor = THREE.SplineCurve;\n\t\n\tTHREE.SplineCurve.prototype.getPoint = function ( t ) {\n\t\n\t\tvar points = this.points;\n\t\tvar point = ( points.length - 1 ) * t;\n\t\n\t\tvar intPoint = Math.floor( point );\n\t\tvar weight = point - intPoint;\n\t\n\t\tvar point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\n\t\tvar point1 = points[ intPoint ];\n\t\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n\t\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\t\n\t\tvar interpolate = THREE.CurveUtils.interpolate;\n\t\n\t\treturn new THREE.Vector2(\n\t\t\tinterpolate( point0.x, point1.x, point2.x, point3.x, weight ),\n\t\t\tinterpolate( point0.y, point1.y, point2.y, point3.y, weight )\n\t\t);\n\t\n\t};\n\t\n\t// File:src/extras/curves/EllipseCurve.js\n\t\n\t/**************************************************************\n\t *\tEllipse curve\n\t **************************************************************/\n\t\n\tTHREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\t\n\t\tthis.aX = aX;\n\t\tthis.aY = aY;\n\t\n\t\tthis.xRadius = xRadius;\n\t\tthis.yRadius = yRadius;\n\t\n\t\tthis.aStartAngle = aStartAngle;\n\t\tthis.aEndAngle = aEndAngle;\n\t\n\t\tthis.aClockwise = aClockwise;\n\t\t\n\t\tthis.aRotation = aRotation || 0;\n\t\n\t};\n\t\n\tTHREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );\n\tTHREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;\n\t\n\tTHREE.EllipseCurve.prototype.getPoint = function ( t ) {\n\t\n\t\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\n\t\n\t\tif ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;\n\t\tif ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;\n\t\n\t\tvar angle;\n\t\n\t\tif ( this.aClockwise === true ) {\n\t\n\t\t\tangle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );\n\t\n\t\t} else {\n\t\n\t\t\tangle = this.aStartAngle + t * deltaAngle;\n\t\n\t\t}\n\t\t\n\t\tvar x = this.aX + this.xRadius * Math.cos( angle );\n\t\tvar y = this.aY + this.yRadius * Math.sin( angle );\n\t\n\t\tif ( this.aRotation !== 0 ) {\n\t\n\t\t\tvar cos = Math.cos( this.aRotation );\n\t\t\tvar sin = Math.sin( this.aRotation );\n\t\n\t\t\tvar tx = x, ty = y;\n\t\n\t\t\t// Rotate the point about the center of the ellipse.\n\t\t\tx = ( tx - this.aX ) * cos - ( ty - this.aY ) * sin + this.aX;\n\t\t\ty = ( tx - this.aX ) * sin + ( ty - this.aY ) * cos + this.aY;\n\t\n\t\t}\n\t\n\t\treturn new THREE.Vector2( x, y );\n\t\n\t};\n\t\n\t// File:src/extras/curves/ArcCurve.js\n\t\n\t/**************************************************************\n\t *\tArc curve\n\t **************************************************************/\n\t\n\tTHREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\t\n\t\tTHREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\t\n\t};\n\t\n\tTHREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );\n\tTHREE.ArcCurve.prototype.constructor = THREE.ArcCurve;\n\t\n\t// File:src/extras/curves/LineCurve3.js\n\t\n\t/**************************************************************\n\t *\tLine3D\n\t **************************************************************/\n\t\n\tTHREE.LineCurve3 = THREE.Curve.create(\n\t\n\t\tfunction ( v1, v2 ) {\n\t\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\n\t\t},\n\t\n\t\tfunction ( t ) {\n\t\n\t\t\tvar vector = new THREE.Vector3();\n\t\n\t\t\tvector.subVectors( this.v2, this.v1 ); // diff\n\t\t\tvector.multiplyScalar( t );\n\t\t\tvector.add( this.v1 );\n\t\n\t\t\treturn vector;\n\t\n\t\t}\n\t\n\t);\n\t\n\t// File:src/extras/curves/QuadraticBezierCurve3.js\n\t\n\t/**************************************************************\n\t *\tQuadratic Bezier 3D curve\n\t **************************************************************/\n\t\n\tTHREE.QuadraticBezierCurve3 = THREE.Curve.create(\n\t\n\t\tfunction ( v0, v1, v2 ) {\n\t\n\t\t\tthis.v0 = v0;\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\n\t\t},\n\t\n\t\tfunction ( t ) {\n\t\n\t\t\tvar b2 = THREE.ShapeUtils.b2;\t\t\n\t\n\t\t\treturn new THREE.Vector3(\n\t\t\t\tb2( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\t\t\tb2( t, this.v0.y, this.v1.y, this.v2.y ),\n\t\t\t\tb2( t, this.v0.z, this.v1.z, this.v2.z )\n\t\t\t);\n\t\n\t\t}\n\t\n\t);\n\t\n\t// File:src/extras/curves/CubicBezierCurve3.js\n\t\n\t/**************************************************************\n\t *\tCubic Bezier 3D curve\n\t **************************************************************/\n\t\n\tTHREE.CubicBezierCurve3 = THREE.Curve.create(\n\t\n\t\tfunction ( v0, v1, v2, v3 ) {\n\t\n\t\t\tthis.v0 = v0;\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\t\tthis.v3 = v3;\n\t\n\t\t},\n\t\n\t\tfunction ( t ) {\n\t\n\t\t\tvar b3 = THREE.ShapeUtils.b3;\n\t\n\t\t\treturn new THREE.Vector3(\n\t\t\t\tb3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\t\t\tb3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y ),\n\t\t\t\tb3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z )\n\t\t\t);\n\t\n\t\t}\n\t\n\t);\n\t\n\t// File:src/extras/curves/SplineCurve3.js\n\t\n\t/**************************************************************\n\t *\tSpline 3D curve\n\t **************************************************************/\n\t\n\t\n\tTHREE.SplineCurve3 = THREE.Curve.create(\n\t\n\t\tfunction ( points /* array of Vector3 */ ) {\n\t\n\t\t\tconsole.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );\n\t\t\tthis.points = ( points == undefined ) ? [] : points;\n\t\n\t\t},\n\t\n\t\tfunction ( t ) {\n\t\n\t\t\tvar points = this.points;\n\t\t\tvar point = ( points.length - 1 ) * t;\n\t\n\t\t\tvar intPoint = Math.floor( point );\n\t\t\tvar weight = point - intPoint;\n\t\n\t\t\tvar point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];\n\t\t\tvar point1 = points[ intPoint ];\n\t\t\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n\t\t\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\t\n\t\t\tvar interpolate = THREE.CurveUtils.interpolate;\n\t\n\t\t\treturn new THREE.Vector3(\n\t\t\t\tinterpolate( point0.x, point1.x, point2.x, point3.x, weight ),\n\t\t\t\tinterpolate( point0.y, point1.y, point2.y, point3.y, weight ),\n\t\t\t\tinterpolate( point0.z, point1.z, point2.z, point3.z, weight )\n\t\t\t);\n\t\n\t\t}\n\t\n\t);\n\t\n\t// File:src/extras/curves/CatmullRomCurve3.js\n\t\n\t/**\n\t * @author zz85 https://github.com/zz85\n\t *\n\t * Centripetal CatmullRom Curve - which is useful for avoiding\n\t * cusps and self-intersections in non-uniform catmull rom curves.\n\t * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\n\t *\n\t * curve.type accepts centripetal(default), chordal and catmullrom\n\t * curve.tension is used for catmullrom which defaults to 0.5\n\t */\n\t\n\tTHREE.CatmullRomCurve3 = ( function() {\n\t\n\t\tvar\n\t\t\ttmp = new THREE.Vector3(),\n\t\t\tpx = new CubicPoly(),\n\t\t\tpy = new CubicPoly(),\n\t\t\tpz = new CubicPoly();\n\t\n\t\t/*\n\t\tBased on an optimized c++ solution in\n\t\t - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\n\t\t - http://ideone.com/NoEbVM\n\t\n\t\tThis CubicPoly class could be used for reusing some variables and calculations,\n\t\tbut for three.js curve use, it could be possible inlined and flatten into a single function call\n\t\twhich can be placed in CurveUtils.\n\t\t*/\n\t\n\t\tfunction CubicPoly() {\n\t\n\t\t}\n\t\n\t\t/*\n\t\t * Compute coefficients for a cubic polynomial\n\t\t *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\n\t\t * such that\n\t\t *   p(0) = x0, p(1) = x1\n\t\t *  and\n\t\t *   p'(0) = t0, p'(1) = t1.\n\t\t */\n\t\tCubicPoly.prototype.init = function( x0, x1, t0, t1 ) {\n\t\n\t\t\tthis.c0 = x0;\n\t\t\tthis.c1 = t0;\n\t\t\tthis.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\n\t\t\tthis.c3 = 2 * x0 - 2 * x1 + t0 + t1;\n\t\n\t\t};\n\t\n\t\tCubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {\n\t\n\t\t\t// compute tangents when parameterized in [t1,t2]\n\t\t\tvar t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\n\t\t\tvar t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\n\t\n\t\t\t// rescale tangents for parametrization in [0,1]\n\t\t\tt1 *= dt1;\n\t\t\tt2 *= dt1;\n\t\n\t\t\t// initCubicPoly\n\t\t\tthis.init( x1, x2, t1, t2 );\n\t\n\t\t};\n\t\n\t\t// standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4\n\t\tCubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {\n\t\n\t\t\tthis.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\n\t\n\t\t};\n\t\n\t\tCubicPoly.prototype.calc = function( t ) {\n\t\n\t\t\tvar t2 = t * t;\n\t\t\tvar t3 = t2 * t;\n\t\t\treturn this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;\n\t\n\t\t};\n\t\n\t\t// Subclass Three.js curve\n\t\treturn THREE.Curve.create(\n\t\n\t\t\tfunction ( p /* array of Vector3 */ ) {\n\t\n\t\t\t\tthis.points = p || [];\n\t\t\t\tthis.closed = false;\n\t\n\t\t\t},\n\t\n\t\t\tfunction ( t ) {\n\t\n\t\t\t\tvar points = this.points,\n\t\t\t\t\tpoint, intPoint, weight, l;\n\t\n\t\t\t\tl = points.length;\n\t\n\t\t\t\tif ( l < 2 ) console.log( 'duh, you need at least 2 points' );\n\t\n\t\t\t\tpoint = ( l - ( this.closed ? 0 : 1 ) ) * t;\n\t\t\t\tintPoint = Math.floor( point );\n\t\t\t\tweight = point - intPoint;\n\t\n\t\t\t\tif ( this.closed ) {\n\t\n\t\t\t\t\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;\n\t\n\t\t\t\t} else if ( weight === 0 && intPoint === l - 1 ) {\n\t\n\t\t\t\t\tintPoint = l - 2;\n\t\t\t\t\tweight = 1;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar p0, p1, p2, p3; // 4 points\n\t\n\t\t\t\tif ( this.closed || intPoint > 0 ) {\n\t\n\t\t\t\t\tp0 = points[ ( intPoint - 1 ) % l ];\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// extrapolate first point\n\t\t\t\t\ttmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\n\t\t\t\t\tp0 = tmp;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tp1 = points[ intPoint % l ];\n\t\t\t\tp2 = points[ ( intPoint + 1 ) % l ];\n\t\n\t\t\t\tif ( this.closed || intPoint + 2 < l ) {\n\t\n\t\t\t\t\tp3 = points[ ( intPoint + 2 ) % l ];\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// extrapolate last point\n\t\t\t\t\ttmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\n\t\t\t\t\tp3 = tmp;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {\n\t\n\t\t\t\t\t// init Centripetal / Chordal Catmull-Rom\n\t\t\t\t\tvar pow = this.type === 'chordal' ? 0.5 : 0.25;\n\t\t\t\t\tvar dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\n\t\t\t\t\tvar dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\n\t\t\t\t\tvar dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\n\t\n\t\t\t\t\t// safety check for repeated points\n\t\t\t\t\tif ( dt1 < 1e-4 ) dt1 = 1.0;\n\t\t\t\t\tif ( dt0 < 1e-4 ) dt0 = dt1;\n\t\t\t\t\tif ( dt2 < 1e-4 ) dt2 = dt1;\n\t\n\t\t\t\t\tpx.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\n\t\t\t\t\tpy.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\n\t\t\t\t\tpz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\n\t\n\t\t\t\t} else if ( this.type === 'catmullrom' ) {\n\t\n\t\t\t\t\tvar tension = this.tension !== undefined ? this.tension : 0.5;\n\t\t\t\t\tpx.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );\n\t\t\t\t\tpy.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );\n\t\t\t\t\tpz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar v = new THREE.Vector3(\n\t\t\t\t\tpx.calc( weight ),\n\t\t\t\t\tpy.calc( weight ),\n\t\t\t\t\tpz.calc( weight )\n\t\t\t\t);\n\t\n\t\t\t\treturn v;\n\t\n\t\t\t}\n\t\n\t\t);\n\t\n\t} )();\n\t\n\t// File:src/extras/curves/ClosedSplineCurve3.js\n\t\n\t/**************************************************************\n\t *\tClosed Spline 3D curve\n\t **************************************************************/\n\t\n\t\n\tTHREE.ClosedSplineCurve3 = function ( points ) {\n\t\n\t\tconsole.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3.' );\n\t\n\t\tTHREE.CatmullRomCurve3.call( this, points );\n\t\tthis.type = 'catmullrom';\n\t\tthis.closed = true;\n\t\n\t};\n\t\n\tTHREE.ClosedSplineCurve3.prototype = Object.create( THREE.CatmullRomCurve3.prototype );\n\t\n\t// File:src/extras/geometries/BoxGeometry.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as\n\t */\n\t\n\tTHREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\t\n\t\tTHREE.Geometry.call( this );\n\t\n\t\tthis.type = 'BoxGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tdepth: depth,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tdepthSegments: depthSegments\n\t\t};\n\t\n\t\tthis.fromBufferGeometry( new THREE.BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );\n\t\tthis.mergeVertices();\n\t\n\t};\n\t\n\tTHREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\tTHREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;\n\t\n\tTHREE.CubeGeometry = THREE.BoxGeometry;\n\t\n\t// File:src/extras/geometries/BoxBufferGeometry.js\n\t\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\t\n\tTHREE.BoxBufferGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\t\n\t\tTHREE.BufferGeometry.call( this );\n\t\n\t\tthis.type = 'BoxBufferGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tdepth: depth,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tdepthSegments: depthSegments\n\t\t};\n\t\n\t\tvar scope = this;\n\t\n\t\t// segments\n\t\twidthSegments = Math.floor( widthSegments ) || 1;\n\t\theightSegments = Math.floor( heightSegments ) || 1;\n\t\tdepthSegments = Math.floor( depthSegments ) || 1;\n\t\n\t\t// these are used to calculate buffer length\n\t\tvar vertexCount = calculateVertexCount( widthSegments, heightSegments, depthSegments );\n\t\tvar indexCount = calculateIndexCount( widthSegments, heightSegments, depthSegments );\n\t\n\t\t// buffers\n\t\tvar indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );\n\t\tvar vertices = new Float32Array( vertexCount * 3 );\n\t\tvar normals = new Float32Array( vertexCount * 3 );\n\t\tvar uvs = new Float32Array( vertexCount * 2 );\n\t\n\t\t// offset variables\n\t\tvar vertexBufferOffset = 0;\n\t\tvar uvBufferOffset = 0;\n\t\tvar indexBufferOffset = 0;\n\t\tvar numberOfVertices = 0;\n\t\n\t\t// group variables\n\t\tvar groupStart = 0;\n\t\n\t\t// build each side of the box geometry\n\t\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height,   width,  depthSegments, heightSegments, 0 ); // px\n\t\tbuildPlane( 'z', 'y', 'x',   1, - 1, depth, height, - width,  depthSegments, heightSegments, 1 ); // nx\n\t\tbuildPlane( 'x', 'z', 'y',   1,   1, width, depth,    height, widthSegments, depthSegments,  2 ); // py\n\t\tbuildPlane( 'x', 'z', 'y',   1, - 1, width, depth,  - height, widthSegments, depthSegments,  3 ); // ny\n\t\tbuildPlane( 'x', 'y', 'z',   1, - 1, width, height,   depth,  widthSegments, heightSegments, 4 ); // pz\n\t\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth,  widthSegments, heightSegments, 5 ); // nz\n\t\n\t\t// build geometry\n\t\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ) );\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\n\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n\t\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\n\t\n\t\t// helper functions\n\t\n\t\tfunction calculateVertexCount ( w, h, d ) {\n\t\n\t\t\tvar vertices = 0;\n\t\n\t\t\t// calculate the amount of vertices for each side (plane)\n\t\t\tvertices += (w + 1) * (h + 1) * 2; // xy\n\t\t\tvertices += (w + 1) * (d + 1) * 2; // xz\n\t\t\tvertices += (d + 1) * (h + 1) * 2; // zy\n\t\n\t\t\treturn vertices;\n\t\n\t\t}\n\t\n\t\tfunction calculateIndexCount ( w, h, d ) {\n\t\n\t\t\tvar index = 0;\n\t\n\t\t\t// calculate the amount of squares for each side\n\t\t\tindex += w * h * 2; // xy\n\t\t\tindex += w * d * 2; // xz\n\t\t\tindex += d * h * 2; // zy\n\t\n\t\t\treturn index * 6; // two triangles per square => six vertices per square\n\t\n\t\t}\n\t\n\t\tfunction buildPlane ( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\n\t\n\t\t\tvar segmentWidth\t= width / gridX;\n\t\t\tvar segmentHeight = height / gridY;\n\t\n\t\t\tvar widthHalf = width / 2;\n\t\t\tvar heightHalf = height / 2;\n\t\t\tvar depthHalf = depth / 2;\n\t\n\t\t\tvar gridX1 = gridX + 1;\n\t\t\tvar gridY1 = gridY + 1;\n\t\n\t\t\tvar vertexCounter = 0;\n\t\t\tvar groupCount = 0;\n\t\n\t\t\tvar vector = new THREE.Vector3();\n\t\n\t\t\t// generate vertices, normals and uvs\n\t\n\t\t\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\n\t\n\t\t\t\tvar y = iy * segmentHeight - heightHalf;\n\t\n\t\t\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\n\t\n\t\t\t\t\tvar x = ix * segmentWidth - widthHalf;\n\t\n\t\t\t\t\t// set values to correct vector component\n\t\t\t\t\tvector[ u ] = x * udir;\n\t\t\t\t\tvector[ v ] = y * vdir;\n\t\t\t\t\tvector[ w ] = depthHalf;\n\t\n\t\t\t\t\t// now apply vector to vertex buffer\n\t\t\t\t\tvertices[ vertexBufferOffset ] = vector.x;\n\t\t\t\t\tvertices[ vertexBufferOffset + 1 ] = vector.y;\n\t\t\t\t\tvertices[ vertexBufferOffset + 2 ] = vector.z;\n\t\n\t\t\t\t\t// set values to correct vector component\n\t\t\t\t\tvector[ u ] = 0;\n\t\t\t\t\tvector[ v ] = 0;\n\t\t\t\t\tvector[ w ] = depth > 0 ? 1 : - 1;\n\t\n\t\t\t\t\t// now apply vector to normal buffer\n\t\t\t\t\tnormals[ vertexBufferOffset ] = vector.x;\n\t\t\t\t\tnormals[ vertexBufferOffset + 1 ] = vector.y;\n\t\t\t\t\tnormals[ vertexBufferOffset + 2 ] = vector.z;\n\t\n\t\t\t\t\t// uvs\n\t\t\t\t\tuvs[ uvBufferOffset ] = ix / gridX;\n\t\t\t\t\tuvs[ uvBufferOffset + 1 ] = 1 - ( iy / gridY );\n\t\n\t\t\t\t\t// update offsets and counters\n\t\t\t\t\tvertexBufferOffset += 3;\n\t\t\t\t\tuvBufferOffset += 2;\n\t\t\t\t\tvertexCounter += 1;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// 1. you need three indices to draw a single face\n\t\t\t// 2. a single segment consists of two faces\n\t\t\t// 3. so we need to generate six (2*3) indices per segment\n\t\n\t\t\tfor ( iy = 0; iy < gridY; iy ++ ) {\n\t\n\t\t\t\tfor ( ix = 0; ix < gridX; ix ++ ) {\n\t\n\t\t\t\t\t// indices\n\t\t\t\t\tvar a = numberOfVertices + ix + gridX1 * iy;\n\t\t\t\t\tvar b = numberOfVertices + ix + gridX1 * ( iy + 1 );\n\t\t\t\t\tvar c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\t\tvar d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\n\t\n\t\t\t\t\t// face one\n\t\t\t\t\tindices[ indexBufferOffset ] = a;\n\t\t\t\t\tindices[ indexBufferOffset + 1 ] = b;\n\t\t\t\t\tindices[ indexBufferOffset + 2 ] = d;\n\t\n\t\t\t\t\t// face two\n\t\t\t\t\tindices[ indexBufferOffset + 3 ] = b;\n\t\t\t\t\tindices[ indexBufferOffset + 4 ] = c;\n\t\t\t\t\tindices[ indexBufferOffset + 5 ] = d;\n\t\n\t\t\t\t\t// update offsets and counters\n\t\t\t\t\tindexBufferOffset += 6;\n\t\t\t\t\tgroupCount += 6;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\t\t\tscope.addGroup( groupStart, groupCount, materialIndex );\n\t\n\t\t\t// calculate new start value for groups\n\t\t\tgroupStart += groupCount;\n\t\n\t\t\t// update total number of vertices\n\t\t\tnumberOfVertices += vertexCounter;\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.BoxBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\n\tTHREE.BoxBufferGeometry.prototype.constructor = THREE.BoxBufferGeometry;\n\t\n\t// File:src/extras/geometries/CircleGeometry.js\n\t\n\t/**\n\t * @author hughes\n\t */\n\t\n\tTHREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {\n\t\n\t\tTHREE.Geometry.call( this );\n\t\n\t\tthis.type = 'CircleGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tsegments: segments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\t\n\t\tthis.fromBufferGeometry( new THREE.CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );\n\t\n\t};\n\t\n\tTHREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\tTHREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;\n\t\n\t// File:src/extras/geometries/CircleBufferGeometry.js\n\t\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\t\n\tTHREE.CircleBufferGeometry = function ( radius, segments, thetaStart, thetaLength ) {\n\t\n\t\tTHREE.BufferGeometry.call( this );\n\t\n\t\tthis.type = 'CircleBufferGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tsegments: segments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\t\n\t\tradius = radius || 50;\n\t\tsegments = segments !== undefined ? Math.max( 3, segments ) : 8;\n\t\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\t\n\t\tvar vertices = segments + 2;\n\t\n\t\tvar positions = new Float32Array( vertices * 3 );\n\t\tvar normals = new Float32Array( vertices * 3 );\n\t\tvar uvs = new Float32Array( vertices * 2 );\n\t\n\t\t// center data is already zero, but need to set a few extras\n\t\tnormals[ 2 ] = 1.0;\n\t\tuvs[ 0 ] = 0.5;\n\t\tuvs[ 1 ] = 0.5;\n\t\n\t\tfor ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {\n\t\n\t\t\tvar segment = thetaStart + s / segments * thetaLength;\n\t\n\t\t\tpositions[ i ] = radius * Math.cos( segment );\n\t\t\tpositions[ i + 1 ] = radius * Math.sin( segment );\n\t\n\t\t\tnormals[ i + 2 ] = 1; // normal z\n\t\n\t\t\tuvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;\n\t\t\tuvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;\n\t\n\t\t}\n\t\n\t\tvar indices = [];\n\t\n\t\tfor ( var i = 1; i <= segments; i ++ ) {\n\t\n\t\t\tindices.push( i, i + 1, 0 );\n\t\n\t\t}\n\t\n\t\tthis.setIndex( new THREE.BufferAttribute( new Uint16Array( indices ), 1 ) );\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\n\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n\t\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\n\t\n\t\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\n\t\n\t};\n\t\n\tTHREE.CircleBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\n\tTHREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry;\n\t\n\t// File:src/extras/geometries/CylinderBufferGeometry.js\n\t\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\t\n\tTHREE.CylinderBufferGeometry = function( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\t\n\t\tTHREE.BufferGeometry.call( this );\n\t\n\t\tthis.type = 'CylinderBufferGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tradiusTop: radiusTop,\n\t\t\tradiusBottom: radiusBottom,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\t\n\t\tvar scope = this;\n\t\n\t\tradiusTop = radiusTop !== undefined ? radiusTop : 20;\n\t\tradiusBottom = radiusBottom !== undefined ? radiusBottom : 20;\n\t\theight = height !== undefined ? height : 100;\n\t\n\t\tradialSegments = Math.floor( radialSegments ) || 8;\n\t\theightSegments = Math.floor( heightSegments ) || 1;\n\t\n\t\topenEnded = openEnded !== undefined ? openEnded : false;\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0.0;\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI;\n\t\n\t\t// used to calculate buffer length\n\t\n\t\tvar nbCap = 0;\n\t\n\t\tif ( openEnded === false ) {\n\t\n\t\t\tif ( radiusTop > 0 ) nbCap ++;\n\t\t\tif ( radiusBottom > 0 ) nbCap ++;\n\t\n\t\t}\n\t\n\t\tvar vertexCount = calculateVertexCount();\n\t\tvar indexCount = calculateIndexCount();\n\t\n\t\t// buffers\n\t\n\t\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ), 1 );\n\t\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\t\n\t\t// helper variables\n\t\n\t\tvar index = 0,\n\t\t    indexOffset = 0,\n\t\t    indexArray = [],\n\t\t    halfHeight = height / 2;\n\t\n\t\t// group variables\n\t\tvar groupStart = 0;\n\t\n\t\t// generate geometry\n\t\n\t\tgenerateTorso();\n\t\n\t\tif ( openEnded === false ) {\n\t\n\t\t\tif ( radiusTop > 0 ) generateCap( true );\n\t\t\tif ( radiusBottom > 0 ) generateCap( false );\n\t\n\t\t}\n\t\n\t\t// build geometry\n\t\n\t\tthis.setIndex( indices );\n\t\tthis.addAttribute( 'position', vertices );\n\t\tthis.addAttribute( 'normal', normals );\n\t\tthis.addAttribute( 'uv', uvs );\n\t\n\t\t// helper functions\n\t\n\t\tfunction calculateVertexCount() {\n\t\n\t\t\tvar count = ( radialSegments + 1 ) * ( heightSegments + 1 );\n\t\n\t\t\tif ( openEnded === false ) {\n\t\n\t\t\t\tcount += ( ( radialSegments + 1 ) * nbCap ) + ( radialSegments * nbCap );\n\t\n\t\t\t}\n\t\n\t\t\treturn count;\n\t\n\t\t}\n\t\n\t\tfunction calculateIndexCount() {\n\t\n\t\t\tvar count = radialSegments * heightSegments * 2 * 3;\n\t\n\t\t\tif ( openEnded === false ) {\n\t\n\t\t\t\tcount += radialSegments * nbCap * 3;\n\t\n\t\t\t}\n\t\n\t\t\treturn count;\n\t\n\t\t}\n\t\n\t\tfunction generateTorso() {\n\t\n\t\t\tvar x, y;\n\t\t\tvar normal = new THREE.Vector3();\n\t\t\tvar vertex = new THREE.Vector3();\n\t\n\t\t\tvar groupCount = 0;\n\t\n\t\t\t// this will be used to calculate the normal\n\t\t\tvar tanTheta = ( radiusBottom - radiusTop ) / height;\n\t\n\t\t\t// generate vertices, normals and uvs\n\t\n\t\t\tfor ( y = 0; y <= heightSegments; y ++ ) {\n\t\n\t\t\t\tvar indexRow = [];\n\t\n\t\t\t\tvar v = y / heightSegments;\n\t\n\t\t\t\t// calculate the radius of the current row\n\t\t\t\tvar radius = v * ( radiusBottom - radiusTop ) + radiusTop;\n\t\n\t\t\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\n\t\n\t\t\t\t\tvar u = x / radialSegments;\n\t\n\t\t\t\t\t// vertex\n\t\t\t\t\tvertex.x = radius * Math.sin( u * thetaLength + thetaStart );\n\t\t\t\t\tvertex.y = - v * height + halfHeight;\n\t\t\t\t\tvertex.z = radius * Math.cos( u * thetaLength + thetaStart );\n\t\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t\t// normal\n\t\t\t\t\tnormal.copy( vertex );\n\t\n\t\t\t\t\t// handle special case if radiusTop/radiusBottom is zero\n\t\n\t\t\t\t\tif ( ( radiusTop === 0 && y === 0 ) || ( radiusBottom === 0 && y === heightSegments ) ) {\n\t\n\t\t\t\t\t\tnormal.x = Math.sin( u * thetaLength + thetaStart );\n\t\t\t\t\t\tnormal.z = Math.cos( u * thetaLength + thetaStart );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tnormal.setY( Math.sqrt( normal.x * normal.x + normal.z * normal.z ) * tanTheta ).normalize();\n\t\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\t\n\t\t\t\t\t// uv\n\t\t\t\t\tuvs.setXY( index, u, 1 - v );\n\t\n\t\t\t\t\t// save index of vertex in respective row\n\t\t\t\t\tindexRow.push( index );\n\t\n\t\t\t\t\t// increase index\n\t\t\t\t\tindex ++;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// now save vertices of the row in our index array\n\t\t\t\tindexArray.push( indexRow );\n\t\n\t\t\t}\n\t\n\t\t\t// generate indices\n\t\n\t\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\t\n\t\t\t\tfor ( y = 0; y < heightSegments; y ++ ) {\n\t\n\t\t\t\t\t// we use the index array to access the correct indices\n\t\t\t\t\tvar i1 = indexArray[ y ][ x ];\n\t\t\t\t\tvar i2 = indexArray[ y + 1 ][ x ];\n\t\t\t\t\tvar i3 = indexArray[ y + 1 ][ x + 1 ];\n\t\t\t\t\tvar i4 = indexArray[ y ][ x + 1 ];\n\t\n\t\t\t\t\t// face one\n\t\t\t\t\tindices.setX( indexOffset, i1 ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, i2 ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, i4 ); indexOffset ++;\n\t\n\t\t\t\t\t// face two\n\t\t\t\t\tindices.setX( indexOffset, i2 ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, i3 ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, i4 ); indexOffset ++;\n\t\n\t\t\t\t\t// update counters\n\t\t\t\t\tgroupCount += 6;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\t\t\tscope.addGroup( groupStart, groupCount, 0 );\n\t\n\t\t\t// calculate new start value for groups\n\t\t\tgroupStart += groupCount;\n\t\n\t\t}\n\t\n\t\tfunction generateCap( top ) {\n\t\n\t\t\tvar x, centerIndexStart, centerIndexEnd;\n\t\n\t\t\tvar uv = new THREE.Vector2();\n\t\t\tvar vertex = new THREE.Vector3();\n\t\n\t\t\tvar groupCount = 0;\n\t\n\t\t\tvar radius = ( top === true ) ? radiusTop : radiusBottom;\n\t\t\tvar sign = ( top === true ) ? 1 : - 1;\n\t\n\t\t\t// save the index of the first center vertex\n\t\t\tcenterIndexStart = index;\n\t\n\t\t\t// first we generate the center vertex data of the cap.\n\t\t\t// because the geometry needs one set of uvs per face,\n\t\t\t// we must generate a center vertex per face/segment\n\t\n\t\t\tfor ( x = 1; x <= radialSegments; x ++ ) {\n\t\n\t\t\t\t// vertex\n\t\t\t\tvertices.setXYZ( index, 0, halfHeight * sign, 0 );\n\t\n\t\t\t\t// normal\n\t\t\t\tnormals.setXYZ( index, 0, sign, 0 );\n\t\n\t\t\t\t// uv\n\t\t\t\tuv.x = 0.5;\n\t\t\t\tuv.y = 0.5;\n\t\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\t\n\t\t\t\t// increase index\n\t\t\t\tindex ++;\n\t\n\t\t\t}\n\t\n\t\t\t// save the index of the last center vertex\n\t\t\tcenterIndexEnd = index;\n\t\n\t\t\t// now we generate the surrounding vertices, normals and uvs\n\t\n\t\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\n\t\n\t\t\t\tvar u = x / radialSegments;\n\t\t\t\tvar theta = u * thetaLength + thetaStart;\n\t\n\t\t\t\tvar cosTheta = Math.cos( theta );\n\t\t\t\tvar sinTheta = Math.sin( theta );\n\t\n\t\t\t\t// vertex\n\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\tvertex.y = halfHeight * sign;\n\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t// normal\n\t\t\t\tnormals.setXYZ( index, 0, sign, 0 );\n\t\n\t\t\t\t// uv\n\t\t\t\tuv.x = ( cosTheta * 0.5 ) + 0.5;\n\t\t\t\tuv.y = ( sinTheta * 0.5 * sign ) + 0.5;\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\t\n\t\t\t\t// increase index\n\t\t\t\tindex ++;\n\t\n\t\t\t}\n\t\n\t\t\t// generate indices\n\t\n\t\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\t\n\t\t\t\tvar c = centerIndexStart + x;\n\t\t\t\tvar i = centerIndexEnd + x;\n\t\n\t\t\t\tif ( top === true ) {\n\t\n\t\t\t\t\t// face top\n\t\t\t\t\tindices.setX( indexOffset, i ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, i + 1 ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, c ); indexOffset ++;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// face bottom\n\t\t\t\t\tindices.setX( indexOffset, i + 1 ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, i ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, c ); indexOffset ++;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// update counters\n\t\t\t\tgroupCount += 3;\n\t\n\t\t\t}\n\t\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\t\t\tscope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );\n\t\n\t\t\t// calculate new start value for groups\n\t\t\tgroupStart += groupCount;\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.CylinderBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\n\tTHREE.CylinderBufferGeometry.prototype.constructor = THREE.CylinderBufferGeometry;\n\t\n\t// File:src/extras/geometries/CylinderGeometry.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\t\n\t\tTHREE.Geometry.call( this );\n\t\n\t\tthis.type = 'CylinderGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tradiusTop: radiusTop,\n\t\t\tradiusBottom: radiusBottom,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\t\n\t\tthis.fromBufferGeometry( new THREE.CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );\n\t\tthis.mergeVertices();\n\t\n\t};\n\t\n\tTHREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\tTHREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;\n\t\n\t// File:src/extras/geometries/ConeBufferGeometry.js\n\t\n\t/*\n\t * @author: abelnation / http://github.com/abelnation\n\t */\n\t\n\tTHREE.ConeBufferGeometry = function (\n\t\tradius, height,\n\t\tradialSegments, heightSegments,\n\t\topenEnded, thetaStart, thetaLength ) {\n\t\n\t\tTHREE.CylinderBufferGeometry.call( this,\n\t\t\t0, radius, height,\n\t\t\tradialSegments, heightSegments,\n\t\t\topenEnded, thetaStart, thetaLength );\n\t\n\t\tthis.type = 'ConeBufferGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\t\n\t};\n\t\n\tTHREE.ConeBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\n\tTHREE.ConeBufferGeometry.prototype.constructor = THREE.ConeBufferGeometry;\n\t\n\t// File:src/extras/geometries/ConeGeometry.js\n\t\n\t/**\n\t * @author abelnation / http://github.com/abelnation\n\t */\n\t\n\tTHREE.ConeGeometry = function (\n\t\tradius, height,\n\t\tradialSegments, heightSegments,\n\t\topenEnded, thetaStart, thetaLength ) {\n\t\n\t\tTHREE.CylinderGeometry.call( this,\n\t\t\t0, radius, height,\n\t\t\tradialSegments, heightSegments,\n\t\t\topenEnded, thetaStart, thetaLength );\n\t\n\t\tthis.type = 'ConeGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\t\n\t};\n\t\n\tTHREE.ConeGeometry.prototype = Object.create( THREE.CylinderGeometry.prototype );\n\tTHREE.ConeGeometry.prototype.constructor = THREE.ConeGeometry;\n\t\n\t// File:src/extras/geometries/EdgesGeometry.js\n\t\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\t\n\tTHREE.EdgesGeometry = function ( geometry, thresholdAngle ) {\n\t\n\t\tTHREE.BufferGeometry.call( this );\n\t\n\t\tthresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;\n\t\n\t\tvar thresholdDot = Math.cos( THREE.Math.DEG2RAD * thresholdAngle );\n\t\n\t\tvar edge = [ 0, 0 ], hash = {};\n\t\n\t\tfunction sortFunction( a, b ) {\n\t\n\t\t\treturn a - b;\n\t\n\t\t}\n\t\n\t\tvar keys = [ 'a', 'b', 'c' ];\n\t\n\t\tvar geometry2;\n\t\n\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\t\n\t\t\tgeometry2 = new THREE.Geometry();\n\t\t\tgeometry2.fromBufferGeometry( geometry );\n\t\n\t\t} else {\n\t\n\t\t\tgeometry2 = geometry.clone();\n\t\n\t\t}\n\t\n\t\tgeometry2.mergeVertices();\n\t\tgeometry2.computeFaceNormals();\n\t\n\t\tvar vertices = geometry2.vertices;\n\t\tvar faces = geometry2.faces;\n\t\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\t\n\t\t\tvar face = faces[ i ];\n\t\n\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\t\n\t\t\t\tedge[ 0 ] = face[ keys[ j ] ];\n\t\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\t\tedge.sort( sortFunction );\n\t\n\t\t\t\tvar key = edge.toString();\n\t\n\t\t\t\tif ( hash[ key ] === undefined ) {\n\t\n\t\t\t\t\thash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\thash[ key ].face2 = i;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tvar coords = [];\n\t\n\t\tfor ( var key in hash ) {\n\t\n\t\t\tvar h = hash[ key ];\n\t\n\t\t\tif ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {\n\t\n\t\t\t\tvar vertex = vertices[ h.vert1 ];\n\t\t\t\tcoords.push( vertex.x );\n\t\t\t\tcoords.push( vertex.y );\n\t\t\t\tcoords.push( vertex.z );\n\t\n\t\t\t\tvertex = vertices[ h.vert2 ];\n\t\t\t\tcoords.push( vertex.x );\n\t\t\t\tcoords.push( vertex.y );\n\t\t\t\tcoords.push( vertex.z );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( coords ), 3 ) );\n\t\n\t};\n\t\n\tTHREE.EdgesGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\n\tTHREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry;\n\t\n\t// File:src/extras/geometries/ExtrudeGeometry.js\n\t\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t *\n\t * Creates extruded geometry from a path shape.\n\t *\n\t * parameters = {\n\t *\n\t *  curveSegments: <int>, // number of points on the curves\n\t *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\n\t *  amount: <int>, // Depth to extrude the shape\n\t *\n\t *  bevelEnabled: <bool>, // turn on bevel\n\t *  bevelThickness: <float>, // how deep into the original shape bevel goes\n\t *  bevelSize: <float>, // how far from shape outline is bevel\n\t *  bevelSegments: <int>, // number of bevel layers\n\t *\n\t *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)\n\t *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals\n\t *\n\t *  uvGenerator: <Object> // object that provides UV generator functions\n\t *\n\t * }\n\t **/\n\t\n\tTHREE.ExtrudeGeometry = function ( shapes, options ) {\n\t\n\t\tif ( typeof( shapes ) === \"undefined\" ) {\n\t\n\t\t\tshapes = [];\n\t\t\treturn;\n\t\n\t\t}\n\t\n\t\tTHREE.Geometry.call( this );\n\t\n\t\tthis.type = 'ExtrudeGeometry';\n\t\n\t\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\n\t\n\t\tthis.addShapeList( shapes, options );\n\t\n\t\tthis.computeFaceNormals();\n\t\n\t\t// can't really use automatic vertex normals\n\t\t// as then front and back sides get smoothed too\n\t\t// should do separate smoothing just for sides\n\t\n\t\t//this.computeVertexNormals();\n\t\n\t\t//console.log( \"took\", ( Date.now() - startTime ) );\n\t\n\t};\n\t\n\tTHREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\tTHREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;\n\t\n\tTHREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {\n\t\n\t\tvar sl = shapes.length;\n\t\n\t\tfor ( var s = 0; s < sl; s ++ ) {\n\t\n\t\t\tvar shape = shapes[ s ];\n\t\t\tthis.addShape( shape, options );\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {\n\t\n\t\tvar amount = options.amount !== undefined ? options.amount : 100;\n\t\n\t\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\n\t\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\n\t\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n\t\n\t\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\n\t\n\t\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\t\n\t\tvar steps = options.steps !== undefined ? options.steps : 1;\n\t\n\t\tvar extrudePath = options.extrudePath;\n\t\tvar extrudePts, extrudeByPath = false;\n\t\n\t\t// Use default WorldUVGenerator if no UV generators are specified.\n\t\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;\n\t\n\t\tvar splineTube, binormal, normal, position2;\n\t\tif ( extrudePath ) {\n\t\n\t\t\textrudePts = extrudePath.getSpacedPoints( steps );\n\t\n\t\t\textrudeByPath = true;\n\t\t\tbevelEnabled = false; // bevels not supported for path extrusion\n\t\n\t\t\t// SETUP TNB variables\n\t\n\t\t\t// Reuse TNB from TubeGeomtry for now.\n\t\t\t// TODO1 - have a .isClosed in spline?\n\t\n\t\t\tsplineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames( extrudePath, steps, false );\n\t\n\t\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\t\n\t\t\tbinormal = new THREE.Vector3();\n\t\t\tnormal = new THREE.Vector3();\n\t\t\tposition2 = new THREE.Vector3();\n\t\n\t\t}\n\t\n\t\t// Safeguards if bevels are not enabled\n\t\n\t\tif ( ! bevelEnabled ) {\n\t\n\t\t\tbevelSegments = 0;\n\t\t\tbevelThickness = 0;\n\t\t\tbevelSize = 0;\n\t\n\t\t}\n\t\n\t\t// Variables initialization\n\t\n\t\tvar ahole, h, hl; // looping of holes\n\t\tvar scope = this;\n\t\n\t\tvar shapesOffset = this.vertices.length;\n\t\n\t\tvar shapePoints = shape.extractPoints( curveSegments );\n\t\n\t\tvar vertices = shapePoints.shape;\n\t\tvar holes = shapePoints.holes;\n\t\n\t\tvar reverse = ! THREE.ShapeUtils.isClockWise( vertices );\n\t\n\t\tif ( reverse ) {\n\t\n\t\t\tvertices = vertices.reverse();\n\t\n\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\t\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\t\tahole = holes[ h ];\n\t\n\t\t\t\tif ( THREE.ShapeUtils.isClockWise( ahole ) ) {\n\t\n\t\t\t\t\tholes[ h ] = ahole.reverse();\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!\n\t\n\t\t}\n\t\n\t\n\t\tvar faces = THREE.ShapeUtils.triangulateShape( vertices, holes );\n\t\n\t\t/* Vertices */\n\t\n\t\tvar contour = vertices; // vertices has all points but contour has only points of circumference\n\t\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\tahole = holes[ h ];\n\t\n\t\t\tvertices = vertices.concat( ahole );\n\t\n\t\t}\n\t\n\t\n\t\tfunction scalePt2 ( pt, vec, size ) {\n\t\n\t\t\tif ( ! vec ) console.error( \"THREE.ExtrudeGeometry: vec does not exist\" );\n\t\n\t\t\treturn vec.clone().multiplyScalar( size ).add( pt );\n\t\n\t\t}\n\t\n\t\tvar b, bs, t, z,\n\t\t\tvert, vlen = vertices.length,\n\t\t\tface, flen = faces.length;\n\t\n\t\n\t\t// Find directions for point movement\n\t\n\t\n\t\tfunction getBevelVec( inPt, inPrev, inNext ) {\n\t\n\t\t\t// computes for inPt the corresponding point inPt' on a new contour\n\t\t\t//   shifted by 1 unit (length of normalized vector) to the left\n\t\t\t// if we walk along contour clockwise, this new contour is outside the old one\n\t\t\t//\n\t\t\t// inPt' is the intersection of the two lines parallel to the two\n\t\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\n\t\n\t\t\tvar v_trans_x, v_trans_y, shrink_by = 1;\t\t// resulting translation vector for inPt\n\t\n\t\t\t// good reading for geometry algorithms (here: line-line intersection)\n\t\t\t// http://geomalgorithms.com/a05-_intersect-1.html\n\t\n\t\t\tvar v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;\n\t\t\tvar v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;\n\t\n\t\t\tvar v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\n\t\n\t\t\t// check for collinear edges\n\t\t\tvar collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\t\n\t\t\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\n\t\n\t\t\t\t// not collinear\n\t\n\t\t\t\t// length of vectors for normalizing\n\t\n\t\t\t\tvar v_prev_len = Math.sqrt( v_prev_lensq );\n\t\t\t\tvar v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\n\t\n\t\t\t\t// shift adjacent points by unit vectors to the left\n\t\n\t\t\t\tvar ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\n\t\t\t\tvar ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\n\t\n\t\t\t\tvar ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\n\t\t\t\tvar ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\n\t\n\t\t\t\t// scaling factor for v_prev to intersection point\n\t\n\t\t\t\tvar sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\n\t\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /\n\t\t\t\t\t\t  ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\t\n\t\t\t\t// vector from inPt to intersection point\n\t\n\t\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\n\t\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\n\t\n\t\t\t\t// Don't normalize!, otherwise sharp corners become ugly\n\t\t\t\t//  but prevent crazy spikes\n\t\t\t\tvar v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\n\t\t\t\tif ( v_trans_lensq <= 2 ) {\n\t\n\t\t\t\t\treturn\tnew THREE.Vector2( v_trans_x, v_trans_y );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\n\t\n\t\t\t\t}\n\t\n\t\t\t} else {\n\t\n\t\t\t\t// handle special case of collinear edges\n\t\n\t\t\t\tvar direction_eq = false;\t\t// assumes: opposite\n\t\t\t\tif ( v_prev_x > Number.EPSILON ) {\n\t\n\t\t\t\t\tif ( v_next_x > Number.EPSILON ) {\n\t\n\t\t\t\t\t\tdirection_eq = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tif ( v_prev_x < - Number.EPSILON ) {\n\t\n\t\t\t\t\t\tif ( v_next_x < - Number.EPSILON ) {\n\t\n\t\t\t\t\t\t\tdirection_eq = true;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\n\t\n\t\t\t\t\t\t\tdirection_eq = true;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( direction_eq ) {\n\t\n\t\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\n\t\t\t\t\tv_trans_x = - v_prev_y;\n\t\t\t\t\tv_trans_y =  v_prev_x;\n\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\n\t\t\t\t\tv_trans_x = v_prev_x;\n\t\t\t\t\tv_trans_y = v_prev_y;\n\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn\tnew THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\n\t\n\t\t}\n\t\n\t\n\t\tvar contourMovements = [];\n\t\n\t\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\t\n\t\t\tif ( j === il ) j = 0;\n\t\t\tif ( k === il ) k = 0;\n\t\n\t\t\t//  (j)---(i)---(k)\n\t\t\t// console.log('i,j,k', i, j , k)\n\t\n\t\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\n\t\n\t\t}\n\t\n\t\tvar holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();\n\t\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\tahole = holes[ h ];\n\t\n\t\t\toneHoleMovements = [];\n\t\n\t\t\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\t\n\t\t\t\tif ( j === il ) j = 0;\n\t\t\t\tif ( k === il ) k = 0;\n\t\n\t\t\t\t//  (j)---(i)---(k)\n\t\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\n\t\n\t\t\t}\n\t\n\t\t\tholesMovements.push( oneHoleMovements );\n\t\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\n\t\n\t\t}\n\t\n\t\n\t\t// Loop bevelSegments, 1 for the front, 1 for the back\n\t\n\t\tfor ( b = 0; b < bevelSegments; b ++ ) {\n\t\n\t\t\t//for ( b = bevelSegments; b > 0; b -- ) {\n\t\n\t\t\tt = b / bevelSegments;\n\t\t\tz = bevelThickness * ( 1 - t );\n\t\n\t\t\t//z = bevelThickness * t;\n\t\t\tbs = bevelSize * ( Math.sin ( t * Math.PI / 2 ) ); // curved\n\t\t\t//bs = bevelSize * t; // linear\n\t\n\t\t\t// contract shape\n\t\n\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\t\n\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\n\t\t\t\tv( vert.x, vert.y,  - z );\n\t\n\t\t\t}\n\t\n\t\t\t// expand holes\n\t\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\t\tahole = holes[ h ];\n\t\t\t\toneHoleMovements = holesMovements[ h ];\n\t\n\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\t\n\t\t\t\t\tv( vert.x, vert.y,  - z );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tbs = bevelSize;\n\t\n\t\t// Back facing vertices\n\t\n\t\tfor ( i = 0; i < vlen; i ++ ) {\n\t\n\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\t\n\t\t\tif ( ! extrudeByPath ) {\n\t\n\t\t\t\tv( vert.x, vert.y, 0 );\n\t\n\t\t\t} else {\n\t\n\t\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\t\n\t\t\t\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\n\t\t\t\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\n\t\n\t\t\t\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\n\t\n\t\t\t\tv( position2.x, position2.y, position2.z );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// Add stepped vertices...\n\t\t// Including front facing vertices\n\t\n\t\tvar s;\n\t\n\t\tfor ( s = 1; s <= steps; s ++ ) {\n\t\n\t\t\tfor ( i = 0; i < vlen; i ++ ) {\n\t\n\t\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\t\n\t\t\t\tif ( ! extrudeByPath ) {\n\t\n\t\t\t\t\tv( vert.x, vert.y, amount / steps * s );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\t\n\t\t\t\t\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\n\t\t\t\t\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\n\t\n\t\t\t\t\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\n\t\n\t\t\t\t\tv( position2.x, position2.y, position2.z );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\n\t\t// Add bevel segments planes\n\t\n\t\t//for ( b = 1; b <= bevelSegments; b ++ ) {\n\t\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\n\t\n\t\t\tt = b / bevelSegments;\n\t\t\tz = bevelThickness * ( 1 - t );\n\t\t\t//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );\n\t\t\tbs = bevelSize * Math.sin ( t * Math.PI / 2 );\n\t\n\t\t\t// contract shape\n\t\n\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\t\n\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\t\t\tv( vert.x, vert.y,  amount + z );\n\t\n\t\t\t}\n\t\n\t\t\t// expand holes\n\t\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\t\tahole = holes[ h ];\n\t\t\t\toneHoleMovements = holesMovements[ h ];\n\t\n\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\t\n\t\t\t\t\tif ( ! extrudeByPath ) {\n\t\n\t\t\t\t\t\tv( vert.x, vert.y,  amount + z );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t/* Faces */\n\t\n\t\t// Top and bottom faces\n\t\n\t\tbuildLidFaces();\n\t\n\t\t// Sides faces\n\t\n\t\tbuildSideFaces();\n\t\n\t\n\t\t/////  Internal functions\n\t\n\t\tfunction buildLidFaces() {\n\t\n\t\t\tif ( bevelEnabled ) {\n\t\n\t\t\t\tvar layer = 0; // steps + 1\n\t\t\t\tvar offset = vlen * layer;\n\t\n\t\t\t\t// Bottom faces\n\t\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\t\n\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tlayer = steps + bevelSegments * 2;\n\t\t\t\toffset = vlen * layer;\n\t\n\t\t\t\t// Top faces\n\t\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\t\n\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\n\t\n\t\t\t\t}\n\t\n\t\t\t} else {\n\t\n\t\t\t\t// Bottom faces\n\t\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\t\n\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// Top faces\n\t\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\t\n\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// Create faces for the z-sides of the shape\n\t\n\t\tfunction buildSideFaces() {\n\t\n\t\t\tvar layeroffset = 0;\n\t\t\tsidewalls( contour, layeroffset );\n\t\t\tlayeroffset += contour.length;\n\t\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\t\tahole = holes[ h ];\n\t\t\t\tsidewalls( ahole, layeroffset );\n\t\n\t\t\t\t//, true\n\t\t\t\tlayeroffset += ahole.length;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction sidewalls( contour, layeroffset ) {\n\t\n\t\t\tvar j, k;\n\t\t\ti = contour.length;\n\t\n\t\t\twhile ( -- i >= 0 ) {\n\t\n\t\t\t\tj = i;\n\t\t\t\tk = i - 1;\n\t\t\t\tif ( k < 0 ) k = contour.length - 1;\n\t\n\t\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\n\t\n\t\t\t\tvar s = 0, sl = steps  + bevelSegments * 2;\n\t\n\t\t\t\tfor ( s = 0; s < sl; s ++ ) {\n\t\n\t\t\t\t\tvar slen1 = vlen * s;\n\t\t\t\t\tvar slen2 = vlen * ( s + 1 );\n\t\n\t\t\t\t\tvar a = layeroffset + j + slen1,\n\t\t\t\t\t\tb = layeroffset + k + slen1,\n\t\t\t\t\t\tc = layeroffset + k + slen2,\n\t\t\t\t\t\td = layeroffset + j + slen2;\n\t\n\t\t\t\t\tf4( a, b, c, d, contour, s, sl, j, k );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\n\t\tfunction v( x, y, z ) {\n\t\n\t\t\tscope.vertices.push( new THREE.Vector3( x, y, z ) );\n\t\n\t\t}\n\t\n\t\tfunction f3( a, b, c ) {\n\t\n\t\t\ta += shapesOffset;\n\t\t\tb += shapesOffset;\n\t\t\tc += shapesOffset;\n\t\n\t\t\tscope.faces.push( new THREE.Face3( a, b, c, null, null, 0 ) );\n\t\n\t\t\tvar uvs = uvgen.generateTopUV( scope, a, b, c );\n\t\n\t\t\tscope.faceVertexUvs[ 0 ].push( uvs );\n\t\n\t\t}\n\t\n\t\tfunction f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {\n\t\n\t\t\ta += shapesOffset;\n\t\t\tb += shapesOffset;\n\t\t\tc += shapesOffset;\n\t\t\td += shapesOffset;\n\t\n\t\t\tscope.faces.push( new THREE.Face3( a, b, d, null, null, 1 ) );\n\t\t\tscope.faces.push( new THREE.Face3( b, c, d, null, null, 1 ) );\n\t\n\t\t\tvar uvs = uvgen.generateSideWallUV( scope, a, b, c, d );\n\t\n\t\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );\n\t\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.ExtrudeGeometry.WorldUVGenerator = {\n\t\n\t\tgenerateTopUV: function ( geometry, indexA, indexB, indexC ) {\n\t\n\t\t\tvar vertices = geometry.vertices;\n\t\n\t\t\tvar a = vertices[ indexA ];\n\t\t\tvar b = vertices[ indexB ];\n\t\t\tvar c = vertices[ indexC ];\n\t\n\t\t\treturn [\n\t\t\t\tnew THREE.Vector2( a.x, a.y ),\n\t\t\t\tnew THREE.Vector2( b.x, b.y ),\n\t\t\t\tnew THREE.Vector2( c.x, c.y )\n\t\t\t];\n\t\n\t\t},\n\t\n\t\tgenerateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {\n\t\n\t\t\tvar vertices = geometry.vertices;\n\t\n\t\t\tvar a = vertices[ indexA ];\n\t\t\tvar b = vertices[ indexB ];\n\t\t\tvar c = vertices[ indexC ];\n\t\t\tvar d = vertices[ indexD ];\n\t\n\t\t\tif ( Math.abs( a.y - b.y ) < 0.01 ) {\n\t\n\t\t\t\treturn [\n\t\t\t\t\tnew THREE.Vector2( a.x, 1 - a.z ),\n\t\t\t\t\tnew THREE.Vector2( b.x, 1 - b.z ),\n\t\t\t\t\tnew THREE.Vector2( c.x, 1 - c.z ),\n\t\t\t\t\tnew THREE.Vector2( d.x, 1 - d.z )\n\t\t\t\t];\n\t\n\t\t\t} else {\n\t\n\t\t\t\treturn [\n\t\t\t\t\tnew THREE.Vector2( a.y, 1 - a.z ),\n\t\t\t\t\tnew THREE.Vector2( b.y, 1 - b.z ),\n\t\t\t\t\tnew THREE.Vector2( c.y, 1 - c.z ),\n\t\t\t\t\tnew THREE.Vector2( d.y, 1 - d.z )\n\t\t\t\t];\n\t\n\t\t\t}\n\t\n\t\t}\n\t};\n\t\n\t// File:src/extras/geometries/ShapeGeometry.js\n\t\n\t/**\n\t * @author jonobr1 / http://jonobr1.com\n\t *\n\t * Creates a one-sided polygonal geometry from a path shape. Similar to\n\t * ExtrudeGeometry.\n\t *\n\t * parameters = {\n\t *\n\t *\tcurveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.\n\t *\n\t *\tmaterial: <int> // material index for front and back faces\n\t *\tuvGenerator: <Object> // object that provides UV generator functions\n\t *\n\t * }\n\t **/\n\t\n\tTHREE.ShapeGeometry = function ( shapes, options ) {\n\t\n\t\tTHREE.Geometry.call( this );\n\t\n\t\tthis.type = 'ShapeGeometry';\n\t\n\t\tif ( Array.isArray( shapes ) === false ) shapes = [ shapes ];\n\t\n\t\tthis.addShapeList( shapes, options );\n\t\n\t\tthis.computeFaceNormals();\n\t\n\t};\n\t\n\tTHREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\tTHREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;\n\t\n\t/**\n\t * Add an array of shapes to THREE.ShapeGeometry.\n\t */\n\tTHREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {\n\t\n\t\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\n\t\n\t\t\tthis.addShape( shapes[ i ], options );\n\t\n\t\t}\n\t\n\t\treturn this;\n\t\n\t};\n\t\n\t/**\n\t * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.\n\t */\n\tTHREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {\n\t\n\t\tif ( options === undefined ) options = {};\n\t\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\t\n\t\tvar material = options.material;\n\t\tvar uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;\n\t\n\t\t//\n\t\n\t\tvar i, l, hole;\n\t\n\t\tvar shapesOffset = this.vertices.length;\n\t\tvar shapePoints = shape.extractPoints( curveSegments );\n\t\n\t\tvar vertices = shapePoints.shape;\n\t\tvar holes = shapePoints.holes;\n\t\n\t\tvar reverse = ! THREE.ShapeUtils.isClockWise( vertices );\n\t\n\t\tif ( reverse ) {\n\t\n\t\t\tvertices = vertices.reverse();\n\t\n\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe...\n\t\n\t\t\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\n\t\n\t\t\t\thole = holes[ i ];\n\t\n\t\t\t\tif ( THREE.ShapeUtils.isClockWise( hole ) ) {\n\t\n\t\t\t\t\tholes[ i ] = hole.reverse();\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treverse = false;\n\t\n\t\t}\n\t\n\t\tvar faces = THREE.ShapeUtils.triangulateShape( vertices, holes );\n\t\n\t\t// Vertices\n\t\n\t\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\n\t\n\t\t\thole = holes[ i ];\n\t\t\tvertices = vertices.concat( hole );\n\t\n\t\t}\n\t\n\t\t//\n\t\n\t\tvar vert, vlen = vertices.length;\n\t\tvar face, flen = faces.length;\n\t\n\t\tfor ( i = 0; i < vlen; i ++ ) {\n\t\n\t\t\tvert = vertices[ i ];\n\t\n\t\t\tthis.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );\n\t\n\t\t}\n\t\n\t\tfor ( i = 0; i < flen; i ++ ) {\n\t\n\t\t\tface = faces[ i ];\n\t\n\t\t\tvar a = face[ 0 ] + shapesOffset;\n\t\t\tvar b = face[ 1 ] + shapesOffset;\n\t\t\tvar c = face[ 2 ] + shapesOffset;\n\t\n\t\t\tthis.faces.push( new THREE.Face3( a, b, c, null, null, material ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/extras/geometries/LatheBufferGeometry.js\n\t\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\t\n\t // points - to create a closed torus, one must use a set of points\n\t //    like so: [ a, b, c, d, a ], see first is the same as last.\n\t // segments - the number of circumference segments to create\n\t // phiStart - the starting radian\n\t // phiLength - the radian (0 to 2PI) range of the lathed section\n\t //    2PI is a closed lathe, less than 2PI is a portion.\n\t\n\tTHREE.LatheBufferGeometry = function ( points, segments, phiStart, phiLength ) {\n\t\n\t\tTHREE.BufferGeometry.call( this );\n\t\n\t\tthis.type = 'LatheBufferGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tpoints: points,\n\t\t\tsegments: segments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength\n\t\t};\n\t\n\t\tsegments = Math.floor( segments ) || 12;\n\t\tphiStart = phiStart || 0;\n\t\tphiLength = phiLength || Math.PI * 2;\n\t\n\t\t// clamp phiLength so it's in range of [ 0, 2PI ]\n\t\tphiLength = THREE.Math.clamp( phiLength, 0, Math.PI * 2 );\n\t\n\t\t// these are used to calculate buffer length\n\t\tvar vertexCount = ( segments + 1 ) * points.length;\n\t\tvar indexCount = segments * points.length * 2 * 3;\n\t\n\t\t// buffers\n\t\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\t\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\t\n\t\t// helper variables\n\t\tvar index = 0, indexOffset = 0, base;\n\t\tvar inversePointLength = 1.0 / ( points.length - 1 );\n\t\tvar inverseSegments = 1.0 / segments;\n\t\tvar vertex = new THREE.Vector3();\n\t\tvar uv = new THREE.Vector2();\n\t\tvar i, j;\n\t\n\t\t// generate vertices and uvs\n\t\n\t\tfor ( i = 0; i <= segments; i ++ ) {\n\t\n\t\t\tvar phi = phiStart + i * inverseSegments * phiLength;\n\t\n\t\t\tvar sin = Math.sin( phi );\n\t\t\tvar cos = Math.cos( phi );\n\t\n\t\t\tfor ( j = 0; j <= ( points.length - 1 ); j ++ ) {\n\t\n\t\t\t\t// vertex\n\t\t\t\tvertex.x = points[ j ].x * sin;\n\t\t\t\tvertex.y = points[ j ].y;\n\t\t\t\tvertex.z = points[ j ].x * cos;\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t// uv\n\t\t\t\tuv.x = i / segments;\n\t\t\t\tuv.y = j / ( points.length - 1 );\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\t\n\t\t\t\t// increase index\n\t\t\t\tindex ++;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// generate indices\n\t\n\t\tfor ( i = 0; i < segments; i ++ ) {\n\t\n\t\t\tfor ( j = 0; j < ( points.length - 1 ); j ++ ) {\n\t\n\t\t\t\tbase = j + i * points.length;\n\t\n\t\t\t\t// indices\n\t\t\t\tvar a = base;\n\t\t\t\tvar b = base + points.length;\n\t\t\t\tvar c = base + points.length + 1;\n\t\t\t\tvar d = base + 1;\n\t\n\t\t\t\t// face one\n\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\t\n\t\t\t\t// face two\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// build geometry\n\t\n\t\tthis.setIndex( indices );\n\t\tthis.addAttribute( 'position', vertices );\n\t\tthis.addAttribute( 'uv', uvs );\n\t\n\t\t// generate normals\n\t\n\t\tthis.computeVertexNormals();\n\t\n\t\t// if the geometry is closed, we need to average the normals along the seam.\n\t\t// because the corresponding vertices are identical (but still have different UVs).\n\t\n\t\tif( phiLength === Math.PI * 2 ) {\n\t\n\t\t\tvar normals = this.attributes.normal.array;\n\t\t\tvar n1 = new THREE.Vector3();\n\t\t\tvar n2 = new THREE.Vector3();\n\t\t\tvar n = new THREE.Vector3();\n\t\n\t\t\t// this is the buffer offset for the last line of vertices\n\t\t\tbase = segments * points.length * 3;\n\t\n\t\t\tfor( i = 0, j = 0; i < points.length; i ++, j += 3 ) {\n\t\n\t\t\t\t// select the normal of the vertex in the first line\n\t\t\t\tn1.x = normals[ j + 0 ];\n\t\t\t\tn1.y = normals[ j + 1 ];\n\t\t\t\tn1.z = normals[ j + 2 ];\n\t\n\t\t\t\t// select the normal of the vertex in the last line\n\t\t\t\tn2.x = normals[ base + j + 0 ];\n\t\t\t\tn2.y = normals[ base + j + 1 ];\n\t\t\t\tn2.z = normals[ base + j + 2 ];\n\t\n\t\t\t\t// average normals\n\t\t\t\tn.addVectors( n1, n2 ).normalize();\n\t\n\t\t\t\t// assign the new values to both normals\n\t\t\t\tnormals[ j + 0 ] = normals[ base + j + 0 ] = n.x;\n\t\t\t\tnormals[ j + 1 ] = normals[ base + j + 1 ] = n.y;\n\t\t\t\tnormals[ j + 2 ] = normals[ base + j + 2 ] = n.z;\n\t\n\t\t\t} // next row\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.LatheBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\n\tTHREE.LatheBufferGeometry.prototype.constructor = THREE.LatheBufferGeometry;\n\t\n\t// File:src/extras/geometries/LatheGeometry.js\n\t\n\t/**\n\t * @author astrodud / http://astrodud.isgreat.org/\n\t * @author zz85 / https://github.com/zz85\n\t * @author bhouston / http://clara.io\n\t */\n\t\n\t// points - to create a closed torus, one must use a set of points\n\t//    like so: [ a, b, c, d, a ], see first is the same as last.\n\t// segments - the number of circumference segments to create\n\t// phiStart - the starting radian\n\t// phiLength - the radian (0 to 2PI) range of the lathed section\n\t//    2PI is a closed lathe, less than 2PI is a portion.\n\t\n\tTHREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {\n\t\n\t\tTHREE.Geometry.call( this );\n\t\n\t\tthis.type = 'LatheGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tpoints: points,\n\t\t\tsegments: segments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength\n\t\t};\n\t\n\t\tthis.fromBufferGeometry( new THREE.LatheBufferGeometry( points, segments, phiStart, phiLength ) );\n\t\tthis.mergeVertices();\n\t\n\t};\n\t\n\tTHREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\tTHREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;\n\t\n\t// File:src/extras/geometries/PlaneGeometry.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\n\t */\n\t\n\tTHREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {\n\t\n\t\tTHREE.Geometry.call( this );\n\t\n\t\tthis.type = 'PlaneGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments\n\t\t};\n\t\n\t\tthis.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );\n\t\n\t};\n\t\n\tTHREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\tTHREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;\n\t\n\t// File:src/extras/geometries/PlaneBufferGeometry.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\n\t */\n\t\n\tTHREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {\n\t\n\t\tTHREE.BufferGeometry.call( this );\n\t\n\t\tthis.type = 'PlaneBufferGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments\n\t\t};\n\t\n\t\tvar width_half = width / 2;\n\t\tvar height_half = height / 2;\n\t\n\t\tvar gridX = Math.floor( widthSegments ) || 1;\n\t\tvar gridY = Math.floor( heightSegments ) || 1;\n\t\n\t\tvar gridX1 = gridX + 1;\n\t\tvar gridY1 = gridY + 1;\n\t\n\t\tvar segment_width = width / gridX;\n\t\tvar segment_height = height / gridY;\n\t\n\t\tvar vertices = new Float32Array( gridX1 * gridY1 * 3 );\n\t\tvar normals = new Float32Array( gridX1 * gridY1 * 3 );\n\t\tvar uvs = new Float32Array( gridX1 * gridY1 * 2 );\n\t\n\t\tvar offset = 0;\n\t\tvar offset2 = 0;\n\t\n\t\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\n\t\n\t\t\tvar y = iy * segment_height - height_half;\n\t\n\t\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\n\t\n\t\t\t\tvar x = ix * segment_width - width_half;\n\t\n\t\t\t\tvertices[ offset ] = x;\n\t\t\t\tvertices[ offset + 1 ] = - y;\n\t\n\t\t\t\tnormals[ offset + 2 ] = 1;\n\t\n\t\t\t\tuvs[ offset2 ] = ix / gridX;\n\t\t\t\tuvs[ offset2 + 1 ] = 1 - ( iy / gridY );\n\t\n\t\t\t\toffset += 3;\n\t\t\t\toffset2 += 2;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\toffset = 0;\n\t\n\t\tvar indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );\n\t\n\t\tfor ( var iy = 0; iy < gridY; iy ++ ) {\n\t\n\t\t\tfor ( var ix = 0; ix < gridX; ix ++ ) {\n\t\n\t\t\t\tvar a = ix + gridX1 * iy;\n\t\t\t\tvar b = ix + gridX1 * ( iy + 1 );\n\t\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\tvar d = ( ix + 1 ) + gridX1 * iy;\n\t\n\t\t\t\tindices[ offset ] = a;\n\t\t\t\tindices[ offset + 1 ] = b;\n\t\t\t\tindices[ offset + 2 ] = d;\n\t\n\t\t\t\tindices[ offset + 3 ] = b;\n\t\t\t\tindices[ offset + 4 ] = c;\n\t\t\t\tindices[ offset + 5 ] = d;\n\t\n\t\t\t\toffset += 6;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ) );\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\n\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n\t\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\n\t\n\t};\n\t\n\tTHREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\n\tTHREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;\n\t\n\t// File:src/extras/geometries/RingBufferGeometry.js\n\t\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\t\n\tTHREE.RingBufferGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\t\n\t\tTHREE.BufferGeometry.call( this );\n\t\n\t\tthis.type = 'RingBufferGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tinnerRadius: innerRadius,\n\t\t\touterRadius: outerRadius,\n\t\t\tthetaSegments: thetaSegments,\n\t\t\tphiSegments: phiSegments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\t\n\t\tinnerRadius = innerRadius || 20;\n\t\touterRadius = outerRadius || 50;\n\t\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\t\n\t\tthetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\n\t\tphiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;\n\t\n\t\t// these are used to calculate buffer length\n\t\tvar vertexCount = ( thetaSegments + 1 ) * ( phiSegments + 1 );\n\t\tvar indexCount = thetaSegments * phiSegments * 2 * 3;\n\t\n\t\t// buffers\n\t\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\t\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\t\n\t\t// some helper variables\n\t\tvar index = 0, indexOffset = 0, segment;\n\t\tvar radius = innerRadius;\n\t\tvar radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\n\t\tvar vertex = new THREE.Vector3();\n\t\tvar uv = new THREE.Vector2();\n\t\tvar j, i;\n\t\n\t\t// generate vertices, normals and uvs\n\t\n\t\t// values are generate from the inside of the ring to the outside\n\t\n\t\tfor ( j = 0; j <= phiSegments; j ++ ) {\n\t\n\t\t\tfor ( i = 0; i <= thetaSegments; i ++ ) {\n\t\n\t\t\t\tsegment = thetaStart + i / thetaSegments * thetaLength;\n\t\n\t\t\t\t// vertex\n\t\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\t\tvertex.y = radius * Math.sin( segment );\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t// normal\n\t\t\t\tnormals.setXYZ( index, 0, 0, 1 );\n\t\n\t\t\t\t// uv\n\t\t\t\tuv.x = ( vertex.x / outerRadius + 1 ) / 2;\n\t\t\t\tuv.y = ( vertex.y / outerRadius + 1 ) / 2;\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\t\n\t\t\t\t// increase index\n\t\t\t\tindex++;\n\t\n\t\t\t}\n\t\n\t\t\t// increase the radius for next row of vertices\n\t\t\tradius += radiusStep;\n\t\n\t\t}\n\t\n\t\t// generate indices\n\t\n\t\tfor ( j = 0; j < phiSegments; j ++ ) {\n\t\n\t\t\tvar thetaSegmentLevel = j * ( thetaSegments + 1 );\n\t\n\t\t\tfor ( i = 0; i < thetaSegments; i ++ ) {\n\t\n\t\t\t\tsegment = i + thetaSegmentLevel;\n\t\n\t\t\t\t// indices\n\t\t\t\tvar a = segment;\n\t\t\t\tvar b = segment + thetaSegments + 1;\n\t\t\t\tvar c = segment + thetaSegments + 2;\n\t\t\t\tvar d = segment + 1;\n\t\n\t\t\t\t// face one\n\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\n\t\t\t\t// face two\n\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// build geometry\n\t\n\t\tthis.setIndex( indices );\n\t\tthis.addAttribute( 'position', vertices );\n\t\tthis.addAttribute( 'normal', normals );\n\t\tthis.addAttribute( 'uv', uvs );\n\t\n\t};\n\t\n\tTHREE.RingBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\n\tTHREE.RingBufferGeometry.prototype.constructor = THREE.RingBufferGeometry;\n\t\n\t// File:src/extras/geometries/RingGeometry.js\n\t\n\t/**\n\t * @author Kaleb Murphy\n\t */\n\t\n\tTHREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\t\n\t\tTHREE.Geometry.call( this );\n\t\n\t\tthis.type = 'RingGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tinnerRadius: innerRadius,\n\t\t\touterRadius: outerRadius,\n\t\t\tthetaSegments: thetaSegments,\n\t\t\tphiSegments: phiSegments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\t\n\t\tthis.fromBufferGeometry( new THREE.RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );\n\t\n\t};\n\t\n\tTHREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\tTHREE.RingGeometry.prototype.constructor = THREE.RingGeometry;\n\t\n\t// File:src/extras/geometries/SphereGeometry.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\t\n\t\tTHREE.Geometry.call( this );\n\t\n\t\tthis.type = 'SphereGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\t\n\t\tthis.fromBufferGeometry( new THREE.SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );\n\t\n\t};\n\t\n\tTHREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\tTHREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;\n\t\n\t// File:src/extras/geometries/SphereBufferGeometry.js\n\t\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t * based on THREE.SphereGeometry\n\t */\n\t\n\tTHREE.SphereBufferGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\t\n\t\tTHREE.BufferGeometry.call( this );\n\t\n\t\tthis.type = 'SphereBufferGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\t\n\t\tradius = radius || 50;\n\t\n\t\twidthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\n\t\theightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\n\t\n\t\tphiStart = phiStart !== undefined ? phiStart : 0;\n\t\tphiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\n\t\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\n\t\n\t\tvar thetaEnd = thetaStart + thetaLength;\n\t\n\t\tvar vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );\n\t\n\t\tvar positions = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\t\n\t\tvar index = 0, vertices = [], normal = new THREE.Vector3();\n\t\n\t\tfor ( var y = 0; y <= heightSegments; y ++ ) {\n\t\n\t\t\tvar verticesRow = [];\n\t\n\t\t\tvar v = y / heightSegments;\n\t\n\t\t\tfor ( var x = 0; x <= widthSegments; x ++ ) {\n\t\n\t\t\t\tvar u = x / widthSegments;\n\t\n\t\t\t\tvar px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\t\t\t\tvar py = radius * Math.cos( thetaStart + v * thetaLength );\n\t\t\t\tvar pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\t\n\t\t\t\tnormal.set( px, py, pz ).normalize();\n\t\n\t\t\t\tpositions.setXYZ( index, px, py, pz );\n\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\t\t\t\tuvs.setXY( index, u, 1 - v );\n\t\n\t\t\t\tverticesRow.push( index );\n\t\n\t\t\t\tindex ++;\n\t\n\t\t\t}\n\t\n\t\t\tvertices.push( verticesRow );\n\t\n\t\t}\n\t\n\t\tvar indices = [];\n\t\n\t\tfor ( var y = 0; y < heightSegments; y ++ ) {\n\t\n\t\t\tfor ( var x = 0; x < widthSegments; x ++ ) {\n\t\n\t\t\t\tvar v1 = vertices[ y ][ x + 1 ];\n\t\t\t\tvar v2 = vertices[ y ][ x ];\n\t\t\t\tvar v3 = vertices[ y + 1 ][ x ];\n\t\t\t\tvar v4 = vertices[ y + 1 ][ x + 1 ];\n\t\n\t\t\t\tif ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );\n\t\t\t\tif ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tthis.setIndex( new ( positions.count > 65535 ? THREE.Uint32Attribute : THREE.Uint16Attribute )( indices, 1 ) );\n\t\tthis.addAttribute( 'position', positions );\n\t\tthis.addAttribute( 'normal', normals );\n\t\tthis.addAttribute( 'uv', uvs );\n\t\n\t\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\n\t\n\t};\n\t\n\tTHREE.SphereBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\n\tTHREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry;\n\t\n\t// File:src/extras/geometries/TextGeometry.js\n\t\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * Text = 3D Text\n\t *\n\t * parameters = {\n\t *  font: <THREE.Font>, // font\n\t *\n\t *  size: <float>, // size of the text\n\t *  height: <float>, // thickness to extrude text\n\t *  curveSegments: <int>, // number of points on the curves\n\t *\n\t *  bevelEnabled: <bool>, // turn on bevel\n\t *  bevelThickness: <float>, // how deep into text bevel goes\n\t *  bevelSize: <float> // how far from text outline is bevel\n\t * }\n\t */\n\t\n\tTHREE.TextGeometry = function ( text, parameters ) {\n\t\n\t\tparameters = parameters || {};\n\t\n\t\tvar font = parameters.font;\n\t\n\t\tif ( font instanceof THREE.Font === false ) {\n\t\n\t\t\tconsole.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );\n\t\t\treturn new THREE.Geometry();\n\t\n\t\t}\n\t\n\t\tvar shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );\n\t\n\t\t// translate parameters to ExtrudeGeometry API\n\t\n\t\tparameters.amount = parameters.height !== undefined ? parameters.height : 50;\n\t\n\t\t// defaults\n\t\n\t\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\n\t\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\n\t\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\n\t\n\t\tTHREE.ExtrudeGeometry.call( this, shapes, parameters );\n\t\n\t\tthis.type = 'TextGeometry';\n\t\n\t};\n\t\n\tTHREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );\n\tTHREE.TextGeometry.prototype.constructor = THREE.TextGeometry;\n\t\n\t// File:src/extras/geometries/TorusBufferGeometry.js\n\t\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\t\n\tTHREE.TorusBufferGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {\n\t\n\t\tTHREE.BufferGeometry.call( this );\n\t\n\t\tthis.type = 'TorusBufferGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\tradialSegments: radialSegments,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tarc: arc\n\t\t};\n\t\n\t\tradius = radius || 100;\n\t\ttube = tube || 40;\n\t\tradialSegments = Math.floor( radialSegments ) || 8;\n\t\ttubularSegments = Math.floor( tubularSegments ) || 6;\n\t\tarc = arc || Math.PI * 2;\n\t\n\t\t// used to calculate buffer length\n\t\tvar vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );\n\t\tvar indexCount = radialSegments * tubularSegments * 2 * 3;\n\t\n\t\t// buffers\n\t\tvar indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );\n\t\tvar vertices = new Float32Array( vertexCount * 3 );\n\t\tvar normals = new Float32Array( vertexCount * 3 );\n\t\tvar uvs = new Float32Array( vertexCount * 2 );\n\t\n\t\t// offset variables\n\t\tvar vertexBufferOffset = 0;\n\t\tvar uvBufferOffset = 0;\n\t\tvar indexBufferOffset = 0;\n\t\n\t\t// helper variables\n\t\tvar center = new THREE.Vector3();\n\t\tvar vertex = new THREE.Vector3();\n\t\tvar normal = new THREE.Vector3();\n\t\n\t\tvar j, i;\n\t\n\t\t// generate vertices, normals and uvs\n\t\n\t\tfor ( j = 0; j <= radialSegments; j ++ ) {\n\t\n\t\t\tfor ( i = 0; i <= tubularSegments; i ++ ) {\n\t\n\t\t\t\tvar u = i / tubularSegments * arc;\n\t\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\t\n\t\t\t\t// vertex\n\t\t\t\tvertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\n\t\t\t\tvertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\n\t\t\t\tvertex.z = tube * Math.sin( v );\n\t\n\t\t\t\tvertices[ vertexBufferOffset ] = vertex.x;\n\t\t\t\tvertices[ vertexBufferOffset + 1 ] = vertex.y;\n\t\t\t\tvertices[ vertexBufferOffset + 2 ] = vertex.z;\n\t\n\t\t\t\t// this vector is used to calculate the normal\n\t\t\t\tcenter.x = radius * Math.cos( u );\n\t\t\t\tcenter.y = radius * Math.sin( u );\n\t\n\t\t\t\t// normal\n\t\t\t\tnormal.subVectors( vertex, center ).normalize();\n\t\n\t\t\t\tnormals[ vertexBufferOffset ] = normal.x;\n\t\t\t\tnormals[ vertexBufferOffset + 1 ] = normal.y;\n\t\t\t\tnormals[ vertexBufferOffset + 2 ] = normal.z;\n\t\n\t\t\t\t// uv\n\t\t\t\tuvs[ uvBufferOffset ] = i / tubularSegments;\n\t\t\t\tuvs[ uvBufferOffset + 1 ] = j / radialSegments;\n\t\n\t\t\t\t// update offsets\n\t\t\t\tvertexBufferOffset += 3;\n\t\t\t\tuvBufferOffset += 2;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// generate indices\n\t\n\t\tfor ( j = 1; j <= radialSegments; j ++ ) {\n\t\n\t\t\tfor ( i = 1; i <= tubularSegments; i ++ ) {\n\t\n\t\t\t\t// indices\n\t\t\t\tvar a = ( tubularSegments + 1 ) * j + i - 1;\n\t\t\t\tvar b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\n\t\t\t\tvar c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\n\t\t\t\tvar d = ( tubularSegments + 1 ) * j + i;\n\t\n\t\t\t\t// face one\n\t\t\t\tindices[ indexBufferOffset ] = a;\n\t\t\t\tindices[ indexBufferOffset + 1 ] = b;\n\t\t\t\tindices[ indexBufferOffset + 2 ] = d;\n\t\n\t\t\t\t// face two\n\t\t\t\tindices[ indexBufferOffset + 3 ] = b;\n\t\t\t\tindices[ indexBufferOffset + 4 ] = c;\n\t\t\t\tindices[ indexBufferOffset + 5 ] = d;\n\t\n\t\t\t\t// update offset\n\t\t\t\tindexBufferOffset += 6;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// build geometry\n\t\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ) );\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\n\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n\t\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\n\t\n\t};\n\t\n\tTHREE.TorusBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\n\tTHREE.TorusBufferGeometry.prototype.constructor = THREE.TorusBufferGeometry;\n\t\n\t// File:src/extras/geometries/TorusGeometry.js\n\t\n\t/**\n\t * @author oosmoxiecode\n\t * @author mrdoob / http://mrdoob.com/\n\t * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888\n\t */\n\t\n\tTHREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {\n\t\n\t\tTHREE.Geometry.call( this );\n\t\n\t\tthis.type = 'TorusGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\tradialSegments: radialSegments,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tarc: arc\n\t\t};\n\t\n\t\tthis.fromBufferGeometry( new THREE.TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );\n\t\n\t};\n\t\n\tTHREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\tTHREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;\n\t\n\t// File:src/extras/geometries/TorusKnotBufferGeometry.js\n\t\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t *\n\t * see: http://www.blackpawn.com/texts/pqtorus/\n\t */\n\tTHREE.TorusKnotBufferGeometry = function ( radius, tube, tubularSegments, radialSegments, p, q ) {\n\t\n\t\tTHREE.BufferGeometry.call( this );\n\t\n\t\tthis.type = 'TorusKnotBufferGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradialSegments: radialSegments,\n\t\t\tp: p,\n\t\t\tq: q\n\t\t};\n\t\n\t\tradius = radius || 100;\n\t\ttube = tube || 40;\n\t\ttubularSegments = Math.floor( tubularSegments ) || 64;\n\t\tradialSegments = Math.floor( radialSegments ) || 8;\n\t\tp = p || 2;\n\t\tq = q || 3;\n\t\n\t\t// used to calculate buffer length\n\t\tvar vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );\n\t\tvar indexCount = radialSegments * tubularSegments * 2 * 3;\n\t\n\t\t// buffers\n\t\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\t\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\t\n\t\t// helper variables\n\t\tvar i, j, index = 0, indexOffset = 0;\n\t\n\t\tvar vertex = new THREE.Vector3();\n\t\tvar normal = new THREE.Vector3();\n\t\tvar uv = new THREE.Vector2();\n\t\n\t\tvar P1 = new THREE.Vector3();\n\t\tvar P2 = new THREE.Vector3();\n\t\n\t\tvar B = new THREE.Vector3();\n\t\tvar T = new THREE.Vector3();\n\t\tvar N = new THREE.Vector3();\n\t\n\t\t// generate vertices, normals and uvs\n\t\n\t\tfor ( i = 0; i <= tubularSegments; ++ i ) {\n\t\n\t\t\t// the radian \"u\" is used to calculate the position on the torus curve of the current tubular segement\n\t\n\t\t\tvar u = i / tubularSegments * p * Math.PI * 2;\n\t\n\t\t\t// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\n\t\t\t// these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\n\t\n\t\t\tcalculatePositionOnCurve( u, p, q, radius, P1 );\n\t\t\tcalculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\n\t\n\t\t\t// calculate orthonormal basis\n\t\n\t\t\tT.subVectors( P2, P1 );\n\t\t\tN.addVectors( P2, P1 );\n\t\t\tB.crossVectors( T, N );\n\t\t\tN.crossVectors( B, T );\n\t\n\t\t\t// normalize B, N. T can be ignored, we don't use it\n\t\n\t\t\tB.normalize();\n\t\t\tN.normalize();\n\t\n\t\t\tfor ( j = 0; j <= radialSegments; ++ j ) {\n\t\n\t\t\t\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\n\t\t\t\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\n\t\n\t\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\t\t\t\tvar cx = - tube * Math.cos( v );\n\t\t\t\tvar cy = tube * Math.sin( v );\n\t\n\t\t\t\t// now calculate the final vertex position.\n\t\t\t\t// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\n\t\n\t\t\t\tvertex.x = P1.x + ( cx * N.x + cy * B.x );\n\t\t\t\tvertex.y = P1.y + ( cx * N.y + cy * B.y );\n\t\t\t\tvertex.z = P1.z + ( cx * N.z + cy * B.z );\n\t\n\t\t\t\t// vertex\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\n\t\t\t\tnormal.subVectors( vertex, P1 ).normalize();\n\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\t\n\t\t\t\t// uv\n\t\t\t\tuv.x = i / tubularSegments;\n\t\t\t\tuv.y = j / radialSegments;\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\t\n\t\t\t\t// increase index\n\t\t\t\tindex ++;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// generate indices\n\t\n\t\tfor ( j = 1; j <= tubularSegments; j ++ ) {\n\t\n\t\t\tfor ( i = 1; i <= radialSegments; i ++ ) {\n\t\n\t\t\t\t// indices\n\t\t\t\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\tvar c = ( radialSegments + 1 ) * j + i;\n\t\t\t\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\t\n\t\t\t\t// face one\n\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\t\n\t\t\t\t// face two\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// build geometry\n\t\n\t\tthis.setIndex( indices );\n\t\tthis.addAttribute( 'position', vertices );\n\t\tthis.addAttribute( 'normal', normals );\n\t\tthis.addAttribute( 'uv', uvs );\n\t\n\t\t// this function calculates the current position on the torus curve\n\t\n\t\tfunction calculatePositionOnCurve( u, p, q, radius, position ) {\n\t\n\t\t\tvar cu = Math.cos( u );\n\t\t\tvar su = Math.sin( u );\n\t\t\tvar quOverP = q / p * u;\n\t\t\tvar cs = Math.cos( quOverP );\n\t\n\t\t\tposition.x = radius * ( 2 + cs ) * 0.5 * cu;\n\t\t\tposition.y = radius * ( 2 + cs ) * su * 0.5;\n\t\t\tposition.z = radius * Math.sin( quOverP ) * 0.5;\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.TorusKnotBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\n\tTHREE.TorusKnotBufferGeometry.prototype.constructor = THREE.TorusKnotBufferGeometry;\n\t\n\t// File:src/extras/geometries/TorusKnotGeometry.js\n\t\n\t/**\n\t * @author oosmoxiecode\n\t */\n\t\n\tTHREE.TorusKnotGeometry = function ( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {\n\t\n\t\tTHREE.Geometry.call( this );\n\t\n\t\tthis.type = 'TorusKnotGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradialSegments: radialSegments,\n\t\t\tp: p,\n\t\t\tq: q\n\t\t};\n\t\n\t\tif( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );\n\t\n\t\tthis.fromBufferGeometry( new THREE.TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );\n\t\tthis.mergeVertices();\n\t\n\t};\n\t\n\tTHREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\tTHREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;\n\t\n\t// File:src/extras/geometries/TubeGeometry.js\n\t\n\t/**\n\t * @author WestLangley / https://github.com/WestLangley\n\t * @author zz85 / https://github.com/zz85\n\t * @author miningold / https://github.com/miningold\n\t * @author jonobr1 / https://github.com/jonobr1\n\t *\n\t * Modified from the TorusKnotGeometry by @oosmoxiecode\n\t *\n\t * Creates a tube which extrudes along a 3d spline\n\t *\n\t * Uses parallel transport frames as described in\n\t * http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n\t */\n\t\n\tTHREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed, taper ) {\n\t\n\t\tTHREE.Geometry.call( this );\n\t\n\t\tthis.type = 'TubeGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tpath: path,\n\t\t\tsegments: segments,\n\t\t\tradius: radius,\n\t\t\tradialSegments: radialSegments,\n\t\t\tclosed: closed,\n\t\t\ttaper: taper\n\t\t};\n\t\n\t\tsegments = segments || 64;\n\t\tradius = radius || 1;\n\t\tradialSegments = radialSegments || 8;\n\t\tclosed = closed || false;\n\t\ttaper = taper || THREE.TubeGeometry.NoTaper;\n\t\n\t\tvar grid = [];\n\t\n\t\tvar scope = this,\n\t\n\t\t\ttangent,\n\t\t\tnormal,\n\t\t\tbinormal,\n\t\n\t\t\tnumpoints = segments + 1,\n\t\n\t\t\tu, v, r,\n\t\n\t\t\tcx, cy,\n\t\t\tpos, pos2 = new THREE.Vector3(),\n\t\t\ti, j,\n\t\t\tip, jp,\n\t\t\ta, b, c, d,\n\t\t\tuva, uvb, uvc, uvd;\n\t\n\t\tvar frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),\n\t\t\ttangents = frames.tangents,\n\t\t\tnormals = frames.normals,\n\t\t\tbinormals = frames.binormals;\n\t\n\t\t// proxy internals\n\t\tthis.tangents = tangents;\n\t\tthis.normals = normals;\n\t\tthis.binormals = binormals;\n\t\n\t\tfunction vert( x, y, z ) {\n\t\n\t\t\treturn scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;\n\t\n\t\t}\n\t\n\t\t// construct the grid\n\t\n\t\tfor ( i = 0; i < numpoints; i ++ ) {\n\t\n\t\t\tgrid[ i ] = [];\n\t\n\t\t\tu = i / ( numpoints - 1 );\n\t\n\t\t\tpos = path.getPointAt( u );\n\t\n\t\t\ttangent = tangents[ i ];\n\t\t\tnormal = normals[ i ];\n\t\t\tbinormal = binormals[ i ];\n\t\n\t\t\tr = radius * taper( u );\n\t\n\t\t\tfor ( j = 0; j < radialSegments; j ++ ) {\n\t\n\t\t\t\tv = j / radialSegments * 2 * Math.PI;\n\t\n\t\t\t\tcx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.\n\t\t\t\tcy = r * Math.sin( v );\n\t\n\t\t\t\tpos2.copy( pos );\n\t\t\t\tpos2.x += cx * normal.x + cy * binormal.x;\n\t\t\t\tpos2.y += cx * normal.y + cy * binormal.y;\n\t\t\t\tpos2.z += cx * normal.z + cy * binormal.z;\n\t\n\t\t\t\tgrid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\n\t\t// construct the mesh\n\t\n\t\tfor ( i = 0; i < segments; i ++ ) {\n\t\n\t\t\tfor ( j = 0; j < radialSegments; j ++ ) {\n\t\n\t\t\t\tip = ( closed ) ? ( i + 1 ) % segments : i + 1;\n\t\t\t\tjp = ( j + 1 ) % radialSegments;\n\t\n\t\t\t\ta = grid[ i ][ j ];\t\t// *** NOT NECESSARILY PLANAR ! ***\n\t\t\t\tb = grid[ ip ][ j ];\n\t\t\t\tc = grid[ ip ][ jp ];\n\t\t\t\td = grid[ i ][ jp ];\n\t\n\t\t\t\tuva = new THREE.Vector2( i / segments, j / radialSegments );\n\t\t\t\tuvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );\n\t\t\t\tuvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );\n\t\t\t\tuvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );\n\t\n\t\t\t\tthis.faces.push( new THREE.Face3( a, b, d ) );\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\n\t\n\t\t\t\tthis.faces.push( new THREE.Face3( b, c, d ) );\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tthis.computeFaceNormals();\n\t\tthis.computeVertexNormals();\n\t\n\t};\n\t\n\tTHREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\tTHREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;\n\t\n\tTHREE.TubeGeometry.NoTaper = function ( u ) {\n\t\n\t\treturn 1;\n\t\n\t};\n\t\n\tTHREE.TubeGeometry.SinusoidalTaper = function ( u ) {\n\t\n\t\treturn Math.sin( Math.PI * u );\n\t\n\t};\n\t\n\t// For computing of Frenet frames, exposing the tangents, normals and binormals the spline\n\tTHREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {\n\t\n\t\tvar\tnormal = new THREE.Vector3(),\n\t\n\t\t\ttangents = [],\n\t\t\tnormals = [],\n\t\t\tbinormals = [],\n\t\n\t\t\tvec = new THREE.Vector3(),\n\t\t\tmat = new THREE.Matrix4(),\n\t\n\t\t\tnumpoints = segments + 1,\n\t\t\ttheta,\n\t\t\tsmallest,\n\t\n\t\t\ttx, ty, tz,\n\t\t\ti, u;\n\t\n\t\n\t\t// expose internals\n\t\tthis.tangents = tangents;\n\t\tthis.normals = normals;\n\t\tthis.binormals = binormals;\n\t\n\t\t// compute the tangent vectors for each segment on the path\n\t\n\t\tfor ( i = 0; i < numpoints; i ++ ) {\n\t\n\t\t\tu = i / ( numpoints - 1 );\n\t\n\t\t\ttangents[ i ] = path.getTangentAt( u );\n\t\t\ttangents[ i ].normalize();\n\t\n\t\t}\n\t\n\t\tinitialNormal3();\n\t\n\t\t/*\n\t\tfunction initialNormal1(lastBinormal) {\n\t\t\t// fixed start binormal. Has dangers of 0 vectors\n\t\t\tnormals[ 0 ] = new THREE.Vector3();\n\t\t\tbinormals[ 0 ] = new THREE.Vector3();\n\t\t\tif (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );\n\t\t\tnormals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();\n\t\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\n\t\t}\n\t\n\t\tfunction initialNormal2() {\n\t\n\t\t\t// This uses the Frenet-Serret formula for deriving binormal\n\t\t\tvar t2 = path.getTangentAt( epsilon );\n\t\n\t\t\tnormals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();\n\t\t\tbinormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );\n\t\n\t\t\tnormals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent\n\t\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\n\t\n\t\t}\n\t\t*/\n\t\n\t\tfunction initialNormal3() {\n\t\n\t\t\t// select an initial normal vector perpendicular to the first tangent vector,\n\t\t\t// and in the direction of the smallest tangent xyz component\n\t\n\t\t\tnormals[ 0 ] = new THREE.Vector3();\n\t\t\tbinormals[ 0 ] = new THREE.Vector3();\n\t\t\tsmallest = Number.MAX_VALUE;\n\t\t\ttx = Math.abs( tangents[ 0 ].x );\n\t\t\tty = Math.abs( tangents[ 0 ].y );\n\t\t\ttz = Math.abs( tangents[ 0 ].z );\n\t\n\t\t\tif ( tx <= smallest ) {\n\t\n\t\t\t\tsmallest = tx;\n\t\t\t\tnormal.set( 1, 0, 0 );\n\t\n\t\t\t}\n\t\n\t\t\tif ( ty <= smallest ) {\n\t\n\t\t\t\tsmallest = ty;\n\t\t\t\tnormal.set( 0, 1, 0 );\n\t\n\t\t\t}\n\t\n\t\t\tif ( tz <= smallest ) {\n\t\n\t\t\t\tnormal.set( 0, 0, 1 );\n\t\n\t\t\t}\n\t\n\t\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\n\t\n\t\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\n\t\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\n\t\n\t\t}\n\t\n\t\n\t\t// compute the slowly-varying normal and binormal vectors for each segment on the path\n\t\n\t\tfor ( i = 1; i < numpoints; i ++ ) {\n\t\n\t\t\tnormals[ i ] = normals[ i - 1 ].clone();\n\t\n\t\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\n\t\n\t\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\n\t\n\t\t\tif ( vec.length() > Number.EPSILON ) {\n\t\n\t\t\t\tvec.normalize();\n\t\n\t\t\t\ttheta = Math.acos( THREE.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\n\t\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\n\t\n\t\t\t}\n\t\n\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\t\n\t\t}\n\t\n\t\n\t\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\t\n\t\tif ( closed ) {\n\t\n\t\t\ttheta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), - 1, 1 ) );\n\t\t\ttheta /= ( numpoints - 1 );\n\t\n\t\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {\n\t\n\t\t\t\ttheta = - theta;\n\t\n\t\t\t}\n\t\n\t\t\tfor ( i = 1; i < numpoints; i ++ ) {\n\t\n\t\t\t\t// twist a little...\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\n\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/extras/geometries/PolyhedronGeometry.js\n\t\n\t/**\n\t * @author clockworkgeek / https://github.com/clockworkgeek\n\t * @author timothypratley / https://github.com/timothypratley\n\t * @author WestLangley / http://github.com/WestLangley\n\t*/\n\t\n\tTHREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {\n\t\n\t\tTHREE.Geometry.call( this );\n\t\n\t\tthis.type = 'PolyhedronGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tvertices: vertices,\n\t\t\tindices: indices,\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\t\n\t\tradius = radius || 1;\n\t\tdetail = detail || 0;\n\t\n\t\tvar that = this;\n\t\n\t\tfor ( var i = 0, l = vertices.length; i < l; i += 3 ) {\n\t\n\t\t\tprepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );\n\t\n\t\t}\n\t\n\t\tvar p = this.vertices;\n\t\n\t\tvar faces = [];\n\t\n\t\tfor ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {\n\t\n\t\t\tvar v1 = p[ indices[ i ] ];\n\t\t\tvar v2 = p[ indices[ i + 1 ] ];\n\t\t\tvar v3 = p[ indices[ i + 2 ] ];\n\t\n\t\t\tfaces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );\n\t\n\t\t}\n\t\n\t\tvar centroid = new THREE.Vector3();\n\t\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\t\n\t\t\tsubdivide( faces[ i ], detail );\n\t\n\t\t}\n\t\n\t\n\t\t// Handle case when face straddles the seam\n\t\n\t\tfor ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {\n\t\n\t\t\tvar uvs = this.faceVertexUvs[ 0 ][ i ];\n\t\n\t\t\tvar x0 = uvs[ 0 ].x;\n\t\t\tvar x1 = uvs[ 1 ].x;\n\t\t\tvar x2 = uvs[ 2 ].x;\n\t\n\t\t\tvar max = Math.max( x0, x1, x2 );\n\t\t\tvar min = Math.min( x0, x1, x2 );\n\t\n\t\t\tif ( max > 0.9 && min < 0.1 ) {\n\t\n\t\t\t\t// 0.9 is somewhat arbitrary\n\t\n\t\t\t\tif ( x0 < 0.2 ) uvs[ 0 ].x += 1;\n\t\t\t\tif ( x1 < 0.2 ) uvs[ 1 ].x += 1;\n\t\t\t\tif ( x2 < 0.2 ) uvs[ 2 ].x += 1;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\n\t\t// Apply radius\n\t\n\t\tfor ( var i = 0, l = this.vertices.length; i < l; i ++ ) {\n\t\n\t\t\tthis.vertices[ i ].multiplyScalar( radius );\n\t\n\t\t}\n\t\n\t\n\t\t// Merge vertices\n\t\n\t\tthis.mergeVertices();\n\t\n\t\tthis.computeFaceNormals();\n\t\n\t\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\n\t\n\t\n\t\t// Project vector onto sphere's surface\n\t\n\t\tfunction prepare( vector ) {\n\t\n\t\t\tvar vertex = vector.normalize().clone();\n\t\t\tvertex.index = that.vertices.push( vertex ) - 1;\n\t\n\t\t\t// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.\n\t\n\t\t\tvar u = azimuth( vector ) / 2 / Math.PI + 0.5;\n\t\t\tvar v = inclination( vector ) / Math.PI + 0.5;\n\t\t\tvertex.uv = new THREE.Vector2( u, 1 - v );\n\t\n\t\t\treturn vertex;\n\t\n\t\t}\n\t\n\t\n\t\t// Approximate a curved face with recursively sub-divided triangles.\n\t\n\t\tfunction make( v1, v2, v3 ) {\n\t\n\t\t\tvar face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );\n\t\t\tthat.faces.push( face );\n\t\n\t\t\tcentroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );\n\t\n\t\t\tvar azi = azimuth( centroid );\n\t\n\t\t\tthat.faceVertexUvs[ 0 ].push( [\n\t\t\t\tcorrectUV( v1.uv, v1, azi ),\n\t\t\t\tcorrectUV( v2.uv, v2, azi ),\n\t\t\t\tcorrectUV( v3.uv, v3, azi )\n\t\t\t] );\n\t\n\t\t}\n\t\n\t\n\t\t// Analytically subdivide a face to the required detail level.\n\t\n\t\tfunction subdivide( face, detail ) {\n\t\n\t\t\tvar cols = Math.pow( 2, detail );\n\t\t\tvar a = prepare( that.vertices[ face.a ] );\n\t\t\tvar b = prepare( that.vertices[ face.b ] );\n\t\t\tvar c = prepare( that.vertices[ face.c ] );\n\t\t\tvar v = [];\n\t\n\t\t\t// Construct all of the vertices for this subdivision.\n\t\n\t\t\tfor ( var i = 0 ; i <= cols; i ++ ) {\n\t\n\t\t\t\tv[ i ] = [];\n\t\n\t\t\t\tvar aj = prepare( a.clone().lerp( c, i / cols ) );\n\t\t\t\tvar bj = prepare( b.clone().lerp( c, i / cols ) );\n\t\t\t\tvar rows = cols - i;\n\t\n\t\t\t\tfor ( var j = 0; j <= rows; j ++ ) {\n\t\n\t\t\t\t\tif ( j === 0 && i === cols ) {\n\t\n\t\t\t\t\t\tv[ i ][ j ] = aj;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tv[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// Construct all of the faces.\n\t\n\t\t\tfor ( var i = 0; i < cols ; i ++ ) {\n\t\n\t\t\t\tfor ( var j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\n\t\n\t\t\t\t\tvar k = Math.floor( j / 2 );\n\t\n\t\t\t\t\tif ( j % 2 === 0 ) {\n\t\n\t\t\t\t\t\tmake(\n\t\t\t\t\t\t\tv[ i ][ k + 1 ],\n\t\t\t\t\t\t\tv[ i + 1 ][ k ],\n\t\t\t\t\t\t\tv[ i ][ k ]\n\t\t\t\t\t\t);\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tmake(\n\t\t\t\t\t\t\tv[ i ][ k + 1 ],\n\t\t\t\t\t\t\tv[ i + 1 ][ k + 1 ],\n\t\t\t\t\t\t\tv[ i + 1 ][ k ]\n\t\t\t\t\t\t);\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\n\t\t// Angle around the Y axis, counter-clockwise when looking from above.\n\t\n\t\tfunction azimuth( vector ) {\n\t\n\t\t\treturn Math.atan2( vector.z, - vector.x );\n\t\n\t\t}\n\t\n\t\n\t\t// Angle above the XZ plane.\n\t\n\t\tfunction inclination( vector ) {\n\t\n\t\t\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\n\t\n\t\t}\n\t\n\t\n\t\t// Texture fixing helper. Spheres have some odd behaviours.\n\t\n\t\tfunction correctUV( uv, vector, azimuth ) {\n\t\n\t\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );\n\t\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );\n\t\t\treturn uv.clone();\n\t\n\t\t}\n\t\n\t\n\t};\n\t\n\tTHREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\tTHREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;\n\t\n\t// File:src/extras/geometries/DodecahedronGeometry.js\n\t\n\t/**\n\t * @author Abe Pazos / https://hamoid.com\n\t */\n\t\n\tTHREE.DodecahedronGeometry = function ( radius, detail ) {\n\t\n\t\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\t\tvar r = 1 / t;\n\t\n\t\tvar vertices = [\n\t\n\t\t\t// (±1, ±1, ±1)\n\t\t\t- 1, - 1, - 1,    - 1, - 1,  1,\n\t\t\t- 1,  1, - 1,    - 1,  1,  1,\n\t\t\t 1, - 1, - 1,     1, - 1,  1,\n\t\t\t 1,  1, - 1,     1,  1,  1,\n\t\n\t\t\t// (0, ±1/φ, ±φ)\n\t\t\t 0, - r, - t,     0, - r,  t,\n\t\t\t 0,  r, - t,     0,  r,  t,\n\t\n\t\t\t// (±1/φ, ±φ, 0)\n\t\t\t- r, - t,  0,    - r,  t,  0,\n\t\t\t r, - t,  0,     r,  t,  0,\n\t\n\t\t\t// (±φ, 0, ±1/φ)\n\t\t\t- t,  0, - r,     t,  0, - r,\n\t\t\t- t,  0,  r,     t,  0,  r\n\t\t];\n\t\n\t\tvar indices = [\n\t\t\t 3, 11,  7,      3,  7, 15,      3, 15, 13,\n\t\t\t 7, 19, 17,      7, 17,  6,      7,  6, 15,\n\t\t\t17,  4,  8,     17,  8, 10,     17, 10,  6,\n\t\t\t 8,  0, 16,      8, 16,  2,      8,  2, 10,\n\t\t\t 0, 12,  1,      0,  1, 18,      0, 18, 16,\n\t\t\t 6, 10,  2,      6,  2, 13,      6, 13, 15,\n\t\t\t 2, 16, 18,      2, 18,  3,      2,  3, 13,\n\t\t\t18,  1,  9,     18,  9, 11,     18, 11,  3,\n\t\t\t 4, 14, 12,      4, 12,  0,      4,  0,  8,\n\t\t\t11,  9,  5,     11,  5, 19,     11, 19,  7,\n\t\t\t19,  5, 14,     19, 14,  4,     19,  4, 17,\n\t\t\t 1, 12, 14,      1, 14,  5,      1,  5,  9\n\t\t];\n\t\n\t\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\n\t\n\t\tthis.type = 'DodecahedronGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\t\n\t};\n\t\n\tTHREE.DodecahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\n\tTHREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;\n\t\n\t// File:src/extras/geometries/IcosahedronGeometry.js\n\t\n\t/**\n\t * @author timothypratley / https://github.com/timothypratley\n\t */\n\t\n\tTHREE.IcosahedronGeometry = function ( radius, detail ) {\n\t\n\t\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\t\n\t\tvar vertices = [\n\t\t\t- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,\n\t\t\t 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,\n\t\t\t t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1\n\t\t];\n\t\n\t\tvar indices = [\n\t\t\t 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,\n\t\t\t 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,\n\t\t\t 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,\n\t\t\t 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1\n\t\t];\n\t\n\t\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\n\t\n\t\tthis.type = 'IcosahedronGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\t\n\t};\n\t\n\tTHREE.IcosahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\n\tTHREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;\n\t\n\t// File:src/extras/geometries/OctahedronGeometry.js\n\t\n\t/**\n\t * @author timothypratley / https://github.com/timothypratley\n\t */\n\t\n\tTHREE.OctahedronGeometry = function ( radius, detail ) {\n\t\n\t\tvar vertices = [\n\t\t\t1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1\n\t\t];\n\t\n\t\tvar indices = [\n\t\t\t0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2\n\t\t];\n\t\n\t\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\n\t\n\t\tthis.type = 'OctahedronGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\t\n\t};\n\t\n\tTHREE.OctahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\n\tTHREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;\n\t\n\t// File:src/extras/geometries/TetrahedronGeometry.js\n\t\n\t/**\n\t * @author timothypratley / https://github.com/timothypratley\n\t */\n\t\n\tTHREE.TetrahedronGeometry = function ( radius, detail ) {\n\t\n\t\tvar vertices = [\n\t\t\t 1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1\n\t\t];\n\t\n\t\tvar indices = [\n\t\t\t 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1\n\t\t];\n\t\n\t\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\n\t\n\t\tthis.type = 'TetrahedronGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\t\n\t};\n\t\n\tTHREE.TetrahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\n\tTHREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;\n\t\n\t// File:src/extras/geometries/ParametricGeometry.js\n\t\n\t/**\n\t * @author zz85 / https://github.com/zz85\n\t * Parametric Surfaces Geometry\n\t * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\n\t *\n\t * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );\n\t *\n\t */\n\t\n\tTHREE.ParametricGeometry = function ( func, slices, stacks ) {\n\t\n\t\tTHREE.Geometry.call( this );\n\t\n\t\tthis.type = 'ParametricGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tfunc: func,\n\t\t\tslices: slices,\n\t\t\tstacks: stacks\n\t\t};\n\t\n\t\tvar verts = this.vertices;\n\t\tvar faces = this.faces;\n\t\tvar uvs = this.faceVertexUvs[ 0 ];\n\t\n\t\tvar i, j, p;\n\t\tvar u, v;\n\t\n\t\tvar sliceCount = slices + 1;\n\t\n\t\tfor ( i = 0; i <= stacks; i ++ ) {\n\t\n\t\t\tv = i / stacks;\n\t\n\t\t\tfor ( j = 0; j <= slices; j ++ ) {\n\t\n\t\t\t\tu = j / slices;\n\t\n\t\t\t\tp = func( u, v );\n\t\t\t\tverts.push( p );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tvar a, b, c, d;\n\t\tvar uva, uvb, uvc, uvd;\n\t\n\t\tfor ( i = 0; i < stacks; i ++ ) {\n\t\n\t\t\tfor ( j = 0; j < slices; j ++ ) {\n\t\n\t\t\t\ta = i * sliceCount + j;\n\t\t\t\tb = i * sliceCount + j + 1;\n\t\t\t\tc = ( i + 1 ) * sliceCount + j + 1;\n\t\t\t\td = ( i + 1 ) * sliceCount + j;\n\t\n\t\t\t\tuva = new THREE.Vector2( j / slices, i / stacks );\n\t\t\t\tuvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );\n\t\t\t\tuvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );\n\t\t\t\tuvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );\n\t\n\t\t\t\tfaces.push( new THREE.Face3( a, b, d ) );\n\t\t\t\tuvs.push( [ uva, uvb, uvd ] );\n\t\n\t\t\t\tfaces.push( new THREE.Face3( b, c, d ) );\n\t\t\t\tuvs.push( [ uvb.clone(), uvc, uvd.clone() ] );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// console.log(this);\n\t\n\t\t// magic bullet\n\t\t// var diff = this.mergeVertices();\n\t\t// console.log('removed ', diff, ' vertices by merging');\n\t\n\t\tthis.computeFaceNormals();\n\t\tthis.computeVertexNormals();\n\t\n\t};\n\t\n\tTHREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\tTHREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;\n\t\n\t// File:src/extras/geometries/WireframeGeometry.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.WireframeGeometry = function ( geometry ) {\n\t\n\t\tTHREE.BufferGeometry.call( this );\n\t\n\t\tvar edge = [ 0, 0 ], hash = {};\n\t\n\t\tfunction sortFunction( a, b ) {\n\t\n\t\t\treturn a - b;\n\t\n\t\t}\n\t\n\t\tvar keys = [ 'a', 'b', 'c' ];\n\t\n\t\tif ( geometry instanceof THREE.Geometry ) {\n\t\n\t\t\tvar vertices = geometry.vertices;\n\t\t\tvar faces = geometry.faces;\n\t\t\tvar numEdges = 0;\n\t\n\t\t\t// allocate maximal size\n\t\t\tvar edges = new Uint32Array( 6 * faces.length );\n\t\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar face = faces[ i ];\n\t\n\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\t\n\t\t\t\t\tedge[ 0 ] = face[ keys[ j ] ];\n\t\t\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\t\t\tedge.sort( sortFunction );\n\t\n\t\t\t\t\tvar key = edge.toString();\n\t\n\t\t\t\t\tif ( hash[ key ] === undefined ) {\n\t\n\t\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\n\t\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\n\t\t\t\t\t\thash[ key ] = true;\n\t\t\t\t\t\tnumEdges ++;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\t\n\t\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\n\t\n\t\t\t\tfor ( var j = 0; j < 2; j ++ ) {\n\t\n\t\t\t\t\tvar vertex = vertices[ edges [ 2 * i + j ] ];\n\t\n\t\t\t\t\tvar index = 6 * i + 3 * j;\n\t\t\t\t\tcoords[ index + 0 ] = vertex.x;\n\t\t\t\t\tcoords[ index + 1 ] = vertex.y;\n\t\t\t\t\tcoords[ index + 2 ] = vertex.z;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\n\t\n\t\t} else if ( geometry instanceof THREE.BufferGeometry ) {\n\t\n\t\t\tif ( geometry.index !== null ) {\n\t\n\t\t\t\t// Indexed BufferGeometry\n\t\n\t\t\t\tvar indices = geometry.index.array;\n\t\t\t\tvar vertices = geometry.attributes.position;\n\t\t\t\tvar groups = geometry.groups;\n\t\t\t\tvar numEdges = 0;\n\t\n\t\t\t\tif ( groups.length === 0 ) {\n\t\n\t\t\t\t\tgeometry.addGroup( 0, indices.length );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// allocate maximal size\n\t\t\t\tvar edges = new Uint32Array( 2 * indices.length );\n\t\n\t\t\t\tfor ( var o = 0, ol = groups.length; o < ol; ++ o ) {\n\t\n\t\t\t\t\tvar group = groups[ o ];\n\t\n\t\t\t\t\tvar start = group.start;\n\t\t\t\t\tvar count = group.count;\n\t\n\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\n\t\n\t\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\t\n\t\t\t\t\t\t\tedge[ 0 ] = indices[ i + j ];\n\t\t\t\t\t\t\tedge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];\n\t\t\t\t\t\t\tedge.sort( sortFunction );\n\t\n\t\t\t\t\t\t\tvar key = edge.toString();\n\t\n\t\t\t\t\t\t\tif ( hash[ key ] === undefined ) {\n\t\n\t\t\t\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\n\t\t\t\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\n\t\t\t\t\t\t\t\thash[ key ] = true;\n\t\t\t\t\t\t\t\tnumEdges ++;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\t\n\t\t\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\n\t\n\t\t\t\t\tfor ( var j = 0; j < 2; j ++ ) {\n\t\n\t\t\t\t\t\tvar index = 6 * i + 3 * j;\n\t\t\t\t\t\tvar index2 = edges[ 2 * i + j ];\n\t\n\t\t\t\t\t\tcoords[ index + 0 ] = vertices.getX( index2 );\n\t\t\t\t\t\tcoords[ index + 1 ] = vertices.getY( index2 );\n\t\t\t\t\t\tcoords[ index + 2 ] = vertices.getZ( index2 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\n\t\n\t\t\t} else {\n\t\n\t\t\t\t// non-indexed BufferGeometry\n\t\n\t\t\t\tvar vertices = geometry.attributes.position.array;\n\t\t\t\tvar numEdges = vertices.length / 3;\n\t\t\t\tvar numTris = numEdges / 3;\n\t\n\t\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\t\n\t\t\t\tfor ( var i = 0, l = numTris; i < l; i ++ ) {\n\t\n\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\t\n\t\t\t\t\t\tvar index = 18 * i + 6 * j;\n\t\n\t\t\t\t\t\tvar index1 = 9 * i + 3 * j;\n\t\t\t\t\t\tcoords[ index + 0 ] = vertices[ index1 ];\n\t\t\t\t\t\tcoords[ index + 1 ] = vertices[ index1 + 1 ];\n\t\t\t\t\t\tcoords[ index + 2 ] = vertices[ index1 + 2 ];\n\t\n\t\t\t\t\t\tvar index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );\n\t\t\t\t\t\tcoords[ index + 3 ] = vertices[ index2 ];\n\t\t\t\t\t\tcoords[ index + 4 ] = vertices[ index2 + 1 ];\n\t\t\t\t\t\tcoords[ index + 5 ] = vertices[ index2 + 2 ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.WireframeGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\n\tTHREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry;\n\t\n\t// File:src/extras/helpers/AxisHelper.js\n\t\n\t/**\n\t * @author sroucheray / http://sroucheray.org/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.AxisHelper = function ( size ) {\n\t\n\t\tsize = size || 1;\n\t\n\t\tvar vertices = new Float32Array( [\n\t\t\t0, 0, 0,  size, 0, 0,\n\t\t\t0, 0, 0,  0, size, 0,\n\t\t\t0, 0, 0,  0, 0, size\n\t\t] );\n\t\n\t\tvar colors = new Float32Array( [\n\t\t\t1, 0, 0,  1, 0.6, 0,\n\t\t\t0, 1, 0,  0.6, 1, 0,\n\t\t\t0, 0, 1,  0, 0.6, 1\n\t\t] );\n\t\n\t\tvar geometry = new THREE.BufferGeometry();\n\t\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\n\t\tgeometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );\n\t\n\t\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\n\t\n\t\tTHREE.LineSegments.call( this, geometry, material );\n\t\n\t};\n\t\n\tTHREE.AxisHelper.prototype = Object.create( THREE.LineSegments.prototype );\n\tTHREE.AxisHelper.prototype.constructor = THREE.AxisHelper;\n\t\n\t// File:src/extras/helpers/ArrowHelper.js\n\t\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author zz85 / http://github.com/zz85\n\t * @author bhouston / http://clara.io\n\t *\n\t * Creates an arrow for visualizing directions\n\t *\n\t * Parameters:\n\t *  dir - Vector3\n\t *  origin - Vector3\n\t *  length - Number\n\t *  color - color in hex value\n\t *  headLength - Number\n\t *  headWidth - Number\n\t */\n\t\n\tTHREE.ArrowHelper = ( function () {\n\t\n\t\tvar lineGeometry = new THREE.BufferGeometry();\n\t\tlineGeometry.addAttribute( 'position', new THREE.Float32Attribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );\n\t\n\t\tvar coneGeometry = new THREE.CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );\n\t\tconeGeometry.translate( 0, - 0.5, 0 );\n\t\n\t\treturn function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {\n\t\n\t\t\t// dir is assumed to be normalized\n\t\n\t\t\tTHREE.Object3D.call( this );\n\t\n\t\t\tif ( color === undefined ) color = 0xffff00;\n\t\t\tif ( length === undefined ) length = 1;\n\t\t\tif ( headLength === undefined ) headLength = 0.2 * length;\n\t\t\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\t\n\t\t\tthis.position.copy( origin );\n\t\n\t\t\tthis.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );\n\t\t\tthis.line.matrixAutoUpdate = false;\n\t\t\tthis.add( this.line );\n\t\n\t\t\tthis.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );\n\t\t\tthis.cone.matrixAutoUpdate = false;\n\t\t\tthis.add( this.cone );\n\t\n\t\t\tthis.setDirection( dir );\n\t\t\tthis.setLength( length, headLength, headWidth );\n\t\n\t\t};\n\t\n\t}() );\n\t\n\tTHREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );\n\tTHREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;\n\t\n\tTHREE.ArrowHelper.prototype.setDirection = ( function () {\n\t\n\t\tvar axis = new THREE.Vector3();\n\t\tvar radians;\n\t\n\t\treturn function setDirection( dir ) {\n\t\n\t\t\t// dir is assumed to be normalized\n\t\n\t\t\tif ( dir.y > 0.99999 ) {\n\t\n\t\t\t\tthis.quaternion.set( 0, 0, 0, 1 );\n\t\n\t\t\t} else if ( dir.y < - 0.99999 ) {\n\t\n\t\t\t\tthis.quaternion.set( 1, 0, 0, 0 );\n\t\n\t\t\t} else {\n\t\n\t\t\t\taxis.set( dir.z, 0, - dir.x ).normalize();\n\t\n\t\t\t\tradians = Math.acos( dir.y );\n\t\n\t\t\t\tthis.quaternion.setFromAxisAngle( axis, radians );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t}() );\n\t\n\tTHREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {\n\t\n\t\tif ( headLength === undefined ) headLength = 0.2 * length;\n\t\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\t\n\t\tthis.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );\n\t\tthis.line.updateMatrix();\n\t\n\t\tthis.cone.scale.set( headWidth, headLength, headWidth );\n\t\tthis.cone.position.y = length;\n\t\tthis.cone.updateMatrix();\n\t\n\t};\n\t\n\tTHREE.ArrowHelper.prototype.setColor = function ( color ) {\n\t\n\t\tthis.line.material.color.copy( color );\n\t\tthis.cone.material.color.copy( color );\n\t\n\t};\n\t\n\t// File:src/extras/helpers/BoxHelper.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.BoxHelper = function ( object, color ) {\n\t\t\n\t\tif ( color === undefined ) color = 0xffff00;\n\t\n\t\tvar indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\n\t\tvar positions = new Float32Array( 8 * 3 );\n\t\n\t\tvar geometry = new THREE.BufferGeometry();\n\t\tgeometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );\n\t\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\n\t\n\t\tTHREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ) );\n\t\n\t\tif ( object !== undefined ) {\n\t\n\t\t\tthis.update( object );\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.BoxHelper.prototype = Object.create( THREE.LineSegments.prototype );\n\tTHREE.BoxHelper.prototype.constructor = THREE.BoxHelper;\n\t\n\tTHREE.BoxHelper.prototype.update = ( function () {\n\t\n\t\tvar box = new THREE.Box3();\n\t\n\t\treturn function update( object ) {\n\t\n\t\t\tif ( object instanceof THREE.Box3 ) {\n\t\n\t\t\t\tbox.copy( object );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tbox.setFromObject( object );\n\t\n\t\t\t}\n\t\n\t\t\tif ( box.isEmpty() ) return;\n\t\n\t\t\tvar min = box.min;\n\t\t\tvar max = box.max;\n\t\n\t\t\t/*\n\t\t\t  5____4\n\t\t\t1/___0/|\n\t\t\t| 6__|_7\n\t\t\t2/___3/\n\t\n\t\t\t0: max.x, max.y, max.z\n\t\t\t1: min.x, max.y, max.z\n\t\t\t2: min.x, min.y, max.z\n\t\t\t3: max.x, min.y, max.z\n\t\t\t4: max.x, max.y, min.z\n\t\t\t5: min.x, max.y, min.z\n\t\t\t6: min.x, min.y, min.z\n\t\t\t7: max.x, min.y, min.z\n\t\t\t*/\n\t\n\t\t\tvar position = this.geometry.attributes.position;\n\t\t\tvar array = position.array;\n\t\n\t\t\tarray[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;\n\t\t\tarray[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;\n\t\t\tarray[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;\n\t\t\tarray[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;\n\t\t\tarray[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;\n\t\t\tarray[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;\n\t\t\tarray[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;\n\t\t\tarray[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;\n\t\n\t\t\tposition.needsUpdate = true;\n\t\n\t\t\tthis.geometry.computeBoundingSphere();\n\t\n\t\t};\n\t\n\t} )();\n\t\n\t// File:src/extras/helpers/BoundingBoxHelper.js\n\t\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\t\n\t// a helper to show the world-axis-aligned bounding box for an object\n\t\n\tTHREE.BoundingBoxHelper = function ( object, hex ) {\n\t\n\t\tvar color = ( hex !== undefined ) ? hex : 0x888888;\n\t\n\t\tthis.object = object;\n\t\n\t\tthis.box = new THREE.Box3();\n\t\n\t\tTHREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );\n\t\n\t};\n\t\n\tTHREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );\n\tTHREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;\n\t\n\tTHREE.BoundingBoxHelper.prototype.update = function () {\n\t\n\t\tthis.box.setFromObject( this.object );\n\t\n\t\tthis.box.size( this.scale );\n\t\n\t\tthis.box.center( this.position );\n\t\n\t};\n\t\n\t// File:src/extras/helpers/CameraHelper.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t *\t- shows frustum, line of sight and up of the camera\n\t *\t- suitable for fast updates\n\t * \t- based on frustum visualization in lightgl.js shadowmap example\n\t *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\n\t */\n\t\n\tTHREE.CameraHelper = function ( camera ) {\n\t\n\t\tvar geometry = new THREE.Geometry();\n\t\tvar material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );\n\t\n\t\tvar pointMap = {};\n\t\n\t\t// colors\n\t\n\t\tvar hexFrustum = 0xffaa00;\n\t\tvar hexCone = 0xff0000;\n\t\tvar hexUp = 0x00aaff;\n\t\tvar hexTarget = 0xffffff;\n\t\tvar hexCross = 0x333333;\n\t\n\t\t// near\n\t\n\t\taddLine( \"n1\", \"n2\", hexFrustum );\n\t\taddLine( \"n2\", \"n4\", hexFrustum );\n\t\taddLine( \"n4\", \"n3\", hexFrustum );\n\t\taddLine( \"n3\", \"n1\", hexFrustum );\n\t\n\t\t// far\n\t\n\t\taddLine( \"f1\", \"f2\", hexFrustum );\n\t\taddLine( \"f2\", \"f4\", hexFrustum );\n\t\taddLine( \"f4\", \"f3\", hexFrustum );\n\t\taddLine( \"f3\", \"f1\", hexFrustum );\n\t\n\t\t// sides\n\t\n\t\taddLine( \"n1\", \"f1\", hexFrustum );\n\t\taddLine( \"n2\", \"f2\", hexFrustum );\n\t\taddLine( \"n3\", \"f3\", hexFrustum );\n\t\taddLine( \"n4\", \"f4\", hexFrustum );\n\t\n\t\t// cone\n\t\n\t\taddLine( \"p\", \"n1\", hexCone );\n\t\taddLine( \"p\", \"n2\", hexCone );\n\t\taddLine( \"p\", \"n3\", hexCone );\n\t\taddLine( \"p\", \"n4\", hexCone );\n\t\n\t\t// up\n\t\n\t\taddLine( \"u1\", \"u2\", hexUp );\n\t\taddLine( \"u2\", \"u3\", hexUp );\n\t\taddLine( \"u3\", \"u1\", hexUp );\n\t\n\t\t// target\n\t\n\t\taddLine( \"c\", \"t\", hexTarget );\n\t\taddLine( \"p\", \"c\", hexCross );\n\t\n\t\t// cross\n\t\n\t\taddLine( \"cn1\", \"cn2\", hexCross );\n\t\taddLine( \"cn3\", \"cn4\", hexCross );\n\t\n\t\taddLine( \"cf1\", \"cf2\", hexCross );\n\t\taddLine( \"cf3\", \"cf4\", hexCross );\n\t\n\t\tfunction addLine( a, b, hex ) {\n\t\n\t\t\taddPoint( a, hex );\n\t\t\taddPoint( b, hex );\n\t\n\t\t}\n\t\n\t\tfunction addPoint( id, hex ) {\n\t\n\t\t\tgeometry.vertices.push( new THREE.Vector3() );\n\t\t\tgeometry.colors.push( new THREE.Color( hex ) );\n\t\n\t\t\tif ( pointMap[ id ] === undefined ) {\n\t\n\t\t\t\tpointMap[ id ] = [];\n\t\n\t\t\t}\n\t\n\t\t\tpointMap[ id ].push( geometry.vertices.length - 1 );\n\t\n\t\t}\n\t\n\t\tTHREE.LineSegments.call( this, geometry, material );\n\t\n\t\tthis.camera = camera;\n\t\tif( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();\n\t\n\t\tthis.matrix = camera.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\t\n\t\tthis.pointMap = pointMap;\n\t\n\t\tthis.update();\n\t\n\t};\n\t\n\tTHREE.CameraHelper.prototype = Object.create( THREE.LineSegments.prototype );\n\tTHREE.CameraHelper.prototype.constructor = THREE.CameraHelper;\n\t\n\tTHREE.CameraHelper.prototype.update = function () {\n\t\n\t\tvar geometry, pointMap;\n\t\n\t\tvar vector = new THREE.Vector3();\n\t\tvar camera = new THREE.Camera();\n\t\n\t\tfunction setPoint( point, x, y, z ) {\n\t\n\t\t\tvector.set( x, y, z ).unproject( camera );\n\t\n\t\t\tvar points = pointMap[ point ];\n\t\n\t\t\tif ( points !== undefined ) {\n\t\n\t\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tgeometry.vertices[ points[ i ] ].copy( vector );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\treturn function update() {\n\t\n\t\t\tgeometry = this.geometry;\n\t\t\tpointMap = this.pointMap;\n\t\n\t\t\tvar w = 1, h = 1;\n\t\n\t\t\t// we need just camera projection matrix\n\t\t\t// world matrix must be identity\n\t\n\t\t\tcamera.projectionMatrix.copy( this.camera.projectionMatrix );\n\t\n\t\t\t// center / target\n\t\n\t\t\tsetPoint( \"c\", 0, 0, - 1 );\n\t\t\tsetPoint( \"t\", 0, 0,  1 );\n\t\n\t\t\t// near\n\t\n\t\t\tsetPoint( \"n1\", - w, - h, - 1 );\n\t\t\tsetPoint( \"n2\",   w, - h, - 1 );\n\t\t\tsetPoint( \"n3\", - w,   h, - 1 );\n\t\t\tsetPoint( \"n4\",   w,   h, - 1 );\n\t\n\t\t\t// far\n\t\n\t\t\tsetPoint( \"f1\", - w, - h, 1 );\n\t\t\tsetPoint( \"f2\",   w, - h, 1 );\n\t\t\tsetPoint( \"f3\", - w,   h, 1 );\n\t\t\tsetPoint( \"f4\",   w,   h, 1 );\n\t\n\t\t\t// up\n\t\n\t\t\tsetPoint( \"u1\",   w * 0.7, h * 1.1, - 1 );\n\t\t\tsetPoint( \"u2\", - w * 0.7, h * 1.1, - 1 );\n\t\t\tsetPoint( \"u3\",         0, h * 2,   - 1 );\n\t\n\t\t\t// cross\n\t\n\t\t\tsetPoint( \"cf1\", - w,   0, 1 );\n\t\t\tsetPoint( \"cf2\",   w,   0, 1 );\n\t\t\tsetPoint( \"cf3\",   0, - h, 1 );\n\t\t\tsetPoint( \"cf4\",   0,   h, 1 );\n\t\n\t\t\tsetPoint( \"cn1\", - w,   0, - 1 );\n\t\t\tsetPoint( \"cn2\",   w,   0, - 1 );\n\t\t\tsetPoint( \"cn3\",   0, - h, - 1 );\n\t\t\tsetPoint( \"cn4\",   0,   h, - 1 );\n\t\n\t\t\tgeometry.verticesNeedUpdate = true;\n\t\n\t\t};\n\t\n\t}();\n\t\n\t// File:src/extras/helpers/DirectionalLightHelper.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\t\n\tTHREE.DirectionalLightHelper = function ( light, size ) {\n\t\n\t\tTHREE.Object3D.call( this );\n\t\n\t\tthis.light = light;\n\t\tthis.light.updateMatrixWorld();\n\t\n\t\tthis.matrix = light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\t\n\t\tif ( size === undefined ) size = 1;\n\t\n\t\tvar geometry = new THREE.BufferGeometry();\n\t\tgeometry.addAttribute( 'position', new THREE.Float32Attribute( [\n\t\t\t- size,   size, 0,\n\t\t\t  size,   size, 0,\n\t\t\t  size, - size, 0,\n\t\t\t- size, - size, 0,\n\t\t\t- size,   size, 0\n\t\t], 3 ) );\n\t\n\t\tvar material = new THREE.LineBasicMaterial( { fog: false } );\n\t\n\t\tthis.add( new THREE.Line( geometry, material ) );\n\t\n\t\tgeometry = new THREE.BufferGeometry();\n\t\tgeometry.addAttribute( 'position', new THREE.Float32Attribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );\n\t\n\t\tthis.add( new THREE.Line( geometry, material ));\n\t\n\t\tthis.update();\n\t\n\t};\n\t\n\tTHREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );\n\tTHREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;\n\t\n\tTHREE.DirectionalLightHelper.prototype.dispose = function () {\n\t\n\t\tvar lightPlane = this.children[ 0 ];\n\t\tvar targetLine = this.children[ 1 ];\n\t\n\t\tlightPlane.geometry.dispose();\n\t\tlightPlane.material.dispose();\n\t\ttargetLine.geometry.dispose();\n\t\ttargetLine.material.dispose();\n\t\n\t};\n\t\n\tTHREE.DirectionalLightHelper.prototype.update = function () {\n\t\n\t\tvar v1 = new THREE.Vector3();\n\t\tvar v2 = new THREE.Vector3();\n\t\tvar v3 = new THREE.Vector3();\n\t\n\t\treturn function update() {\n\t\n\t\t\tv1.setFromMatrixPosition( this.light.matrixWorld );\n\t\t\tv2.setFromMatrixPosition( this.light.target.matrixWorld );\n\t\t\tv3.subVectors( v2, v1 );\n\t\n\t\t\tvar lightPlane = this.children[ 0 ];\n\t\t\tvar targetLine = this.children[ 1 ];\n\t\n\t\t\tlightPlane.lookAt( v3 );\n\t\t\tlightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\t\n\t\t\ttargetLine.lookAt( v3 );\n\t\t\ttargetLine.scale.z = v3.length();\n\t\n\t\t};\n\t\n\t}();\n\t\n\t// File:src/extras/helpers/EdgesHelper.js\n\t\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @param object THREE.Mesh whose geometry will be used\n\t * @param hex line color\n\t * @param thresholdAngle the minimum angle (in degrees),\n\t * between the face normals of adjacent faces,\n\t * that is required to render an edge. A value of 10 means\n\t * an edge is only rendered if the angle is at least 10 degrees.\n\t */\n\t\n\tTHREE.EdgesHelper = function ( object, hex, thresholdAngle ) {\n\t\n\t\tvar color = ( hex !== undefined ) ? hex : 0xffffff;\n\t\n\t\tTHREE.LineSegments.call( this, new THREE.EdgesGeometry( object.geometry, thresholdAngle ), new THREE.LineBasicMaterial( { color: color } ) );\n\t\n\t\tthis.matrix = object.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\t\n\t};\n\t\n\tTHREE.EdgesHelper.prototype = Object.create( THREE.LineSegments.prototype );\n\tTHREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;\n\t\n\t// File:src/extras/helpers/FaceNormalsHelper.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t*/\n\t\n\tTHREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {\n\t\n\t\t// FaceNormalsHelper only supports THREE.Geometry\n\t\n\t\tthis.object = object;\n\t\n\t\tthis.size = ( size !== undefined ) ? size : 1;\n\t\n\t\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\n\t\n\t\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\t\n\t\t//\n\t\n\t\tvar nNormals = 0;\n\t\n\t\tvar objGeometry = this.object.geometry;\n\t\n\t\tif ( objGeometry instanceof THREE.Geometry ) {\n\t\n\t\t\tnNormals = objGeometry.faces.length;\n\t\n\t\t} else {\n\t\n\t\t\tconsole.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );\n\t\n\t\t}\n\t\n\t\t//\n\t\n\t\tvar geometry = new THREE.BufferGeometry();\n\t\n\t\tvar positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );\n\t\n\t\tgeometry.addAttribute( 'position', positions );\n\t\n\t\tTHREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );\n\t\n\t\t//\n\t\n\t\tthis.matrixAutoUpdate = false;\n\t\tthis.update();\n\t\n\t};\n\t\n\tTHREE.FaceNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );\n\tTHREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;\n\t\n\tTHREE.FaceNormalsHelper.prototype.update = ( function () {\n\t\n\t\tvar v1 = new THREE.Vector3();\n\t\tvar v2 = new THREE.Vector3();\n\t\tvar normalMatrix = new THREE.Matrix3();\n\t\n\t\treturn function update() {\n\t\n\t\t\tthis.object.updateMatrixWorld( true );\n\t\n\t\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\n\t\n\t\t\tvar matrixWorld = this.object.matrixWorld;\n\t\n\t\t\tvar position = this.geometry.attributes.position;\n\t\n\t\t\t//\n\t\n\t\t\tvar objGeometry = this.object.geometry;\n\t\n\t\t\tvar vertices = objGeometry.vertices;\n\t\n\t\t\tvar faces = objGeometry.faces;\n\t\n\t\t\tvar idx = 0;\n\t\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar face = faces[ i ];\n\t\n\t\t\t\tvar normal = face.normal;\n\t\n\t\t\t\tv1.copy( vertices[ face.a ] )\n\t\t\t\t\t.add( vertices[ face.b ] )\n\t\t\t\t\t.add( vertices[ face.c ] )\n\t\t\t\t\t.divideScalar( 3 )\n\t\t\t\t\t.applyMatrix4( matrixWorld );\n\t\n\t\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\t\n\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\t\n\t\t\t\tidx = idx + 1;\n\t\n\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\t\n\t\t\t\tidx = idx + 1;\n\t\n\t\t\t}\n\t\n\t\t\tposition.needsUpdate = true;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t}() );\n\t\n\t// File:src/extras/helpers/GridHelper.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.GridHelper = function ( size, step, color1, color2 ) {\n\t\n\t\tcolor1 = new THREE.Color( color1 !== undefined ? color1 : 0x444444 );\n\t\tcolor2 = new THREE.Color( color2 !== undefined ? color2 : 0x888888 );\n\t\n\t\tvar vertices = [];\n\t\tvar colors = [];\n\t\n\t\tfor ( var i = - size, j = 0; i <= size; i += step ) {\n\t\n\t\t\tvertices.push( - size, 0, i, size, 0, i );\n\t\t\tvertices.push( i, 0, - size, i, 0, size );\n\t\n\t\t\tvar color = i === 0 ? color1 : color2;\n\t\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\n\t\t}\n\t\n\t\tvar geometry = new THREE.BufferGeometry();\n\t\tgeometry.addAttribute( 'position', new THREE.Float32Attribute( vertices, 3 ) );\n\t\tgeometry.addAttribute( 'color', new THREE.Float32Attribute( colors, 3 ) );\n\t\n\t\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\n\t\n\t\tTHREE.LineSegments.call( this, geometry, material );\n\t\n\t};\n\t\n\tTHREE.GridHelper.prototype = Object.create( THREE.LineSegments.prototype );\n\tTHREE.GridHelper.prototype.constructor = THREE.GridHelper;\n\t\n\tTHREE.GridHelper.prototype.setColors = function () {\n\t\n\t\tconsole.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );\n\t\n\t};\n\t\n\t// File:src/extras/helpers/HemisphereLightHelper.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.HemisphereLightHelper = function ( light, sphereSize ) {\n\t\n\t\tTHREE.Object3D.call( this );\n\t\n\t\tthis.light = light;\n\t\tthis.light.updateMatrixWorld();\n\t\n\t\tthis.matrix = light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\t\n\t\tthis.colors = [ new THREE.Color(), new THREE.Color() ];\n\t\n\t\tvar geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );\n\t\tgeometry.rotateX( - Math.PI / 2 );\n\t\n\t\tfor ( var i = 0, il = 8; i < il; i ++ ) {\n\t\n\t\t\tgeometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];\n\t\n\t\t}\n\t\n\t\tvar material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );\n\t\n\t\tthis.lightSphere = new THREE.Mesh( geometry, material );\n\t\tthis.add( this.lightSphere );\n\t\n\t\tthis.update();\n\t\n\t};\n\t\n\tTHREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );\n\tTHREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;\n\t\n\tTHREE.HemisphereLightHelper.prototype.dispose = function () {\n\t\n\t\tthis.lightSphere.geometry.dispose();\n\t\tthis.lightSphere.material.dispose();\n\t\n\t};\n\t\n\tTHREE.HemisphereLightHelper.prototype.update = function () {\n\t\n\t\tvar vector = new THREE.Vector3();\n\t\n\t\treturn function update() {\n\t\n\t\t\tthis.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );\n\t\t\tthis.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );\n\t\n\t\t\tthis.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );\n\t\t\tthis.lightSphere.geometry.colorsNeedUpdate = true;\n\t\n\t\t};\n\t\n\t}();\n\t\n\t// File:src/extras/helpers/PointLightHelper.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.PointLightHelper = function ( light, sphereSize ) {\n\t\n\t\tthis.light = light;\n\t\tthis.light.updateMatrixWorld();\n\t\n\t\tvar geometry = new THREE.SphereBufferGeometry( sphereSize, 4, 2 );\n\t\tvar material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );\n\t\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\t\n\t\tTHREE.Mesh.call( this, geometry, material );\n\t\n\t\tthis.matrix = this.light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\t\n\t\t/*\n\t\tvar distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\n\t\tvar distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\n\t\n\t\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\n\t\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\n\t\n\t\tvar d = light.distance;\n\t\n\t\tif ( d === 0.0 ) {\n\t\n\t\t\tthis.lightDistance.visible = false;\n\t\n\t\t} else {\n\t\n\t\t\tthis.lightDistance.scale.set( d, d, d );\n\t\n\t\t}\n\t\n\t\tthis.add( this.lightDistance );\n\t\t*/\n\t\n\t};\n\t\n\tTHREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );\n\tTHREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;\n\t\n\tTHREE.PointLightHelper.prototype.dispose = function () {\n\t\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\t\n\t};\n\t\n\tTHREE.PointLightHelper.prototype.update = function () {\n\t\n\t\tthis.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\t\n\t\t/*\n\t\tvar d = this.light.distance;\n\t\n\t\tif ( d === 0.0 ) {\n\t\n\t\t\tthis.lightDistance.visible = false;\n\t\n\t\t} else {\n\t\n\t\t\tthis.lightDistance.visible = true;\n\t\t\tthis.lightDistance.scale.set( d, d, d );\n\t\n\t\t}\n\t\t*/\n\t\n\t};\n\t\n\t// File:src/extras/helpers/SkeletonHelper.js\n\t\n\t/**\n\t * @author Sean Griffin / http://twitter.com/sgrif\n\t * @author Michael Guerrero / http://realitymeltdown.com\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author ikerr / http://verold.com\n\t */\n\t\n\tTHREE.SkeletonHelper = function ( object ) {\n\t\n\t\tthis.bones = this.getBoneList( object );\n\t\n\t\tvar geometry = new THREE.Geometry();\n\t\n\t\tfor ( var i = 0; i < this.bones.length; i ++ ) {\n\t\n\t\t\tvar bone = this.bones[ i ];\n\t\n\t\t\tif ( bone.parent instanceof THREE.Bone ) {\n\t\n\t\t\t\tgeometry.vertices.push( new THREE.Vector3() );\n\t\t\t\tgeometry.vertices.push( new THREE.Vector3() );\n\t\t\t\tgeometry.colors.push( new THREE.Color( 0, 0, 1 ) );\n\t\t\t\tgeometry.colors.push( new THREE.Color( 0, 1, 0 ) );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tgeometry.dynamic = true;\n\t\n\t\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );\n\t\n\t\tTHREE.LineSegments.call( this, geometry, material );\n\t\n\t\tthis.root = object;\n\t\n\t\tthis.matrix = object.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\t\n\t\tthis.update();\n\t\n\t};\n\t\n\t\n\tTHREE.SkeletonHelper.prototype = Object.create( THREE.LineSegments.prototype );\n\tTHREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;\n\t\n\tTHREE.SkeletonHelper.prototype.getBoneList = function( object ) {\n\t\n\t\tvar boneList = [];\n\t\n\t\tif ( object instanceof THREE.Bone ) {\n\t\n\t\t\tboneList.push( object );\n\t\n\t\t}\n\t\n\t\tfor ( var i = 0; i < object.children.length; i ++ ) {\n\t\n\t\t\tboneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );\n\t\n\t\t}\n\t\n\t\treturn boneList;\n\t\n\t};\n\t\n\tTHREE.SkeletonHelper.prototype.update = function () {\n\t\n\t\tvar geometry = this.geometry;\n\t\n\t\tvar matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );\n\t\n\t\tvar boneMatrix = new THREE.Matrix4();\n\t\n\t\tvar j = 0;\n\t\n\t\tfor ( var i = 0; i < this.bones.length; i ++ ) {\n\t\n\t\t\tvar bone = this.bones[ i ];\n\t\n\t\t\tif ( bone.parent instanceof THREE.Bone ) {\n\t\n\t\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );\n\t\t\t\tgeometry.vertices[ j ].setFromMatrixPosition( boneMatrix );\n\t\n\t\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );\n\t\t\t\tgeometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );\n\t\n\t\t\t\tj += 2;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tgeometry.verticesNeedUpdate = true;\n\t\n\t\tgeometry.computeBoundingSphere();\n\t\n\t};\n\t\n\t// File:src/extras/helpers/SpotLightHelper.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t*/\n\t\n\tTHREE.SpotLightHelper = function ( light ) {\n\t\n\t\tTHREE.Object3D.call( this );\n\t\n\t\tthis.light = light;\n\t\tthis.light.updateMatrixWorld();\n\t\n\t\tthis.matrix = light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\t\n\t\tvar geometry = new THREE.BufferGeometry();\n\t\n\t\tvar positions = [\n\t\t\t0, 0, 0,   0,   0,   1,\n\t\t\t0, 0, 0,   1,   0,   1,\n\t\t\t0, 0, 0, - 1,   0,   1,\n\t\t\t0, 0, 0,   0,   1,   1,\n\t\t\t0, 0, 0,   0, - 1,   1\n\t\t];\n\t\n\t\tfor ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {\n\t\n\t\t\tvar p1 = ( i / l ) * Math.PI * 2;\n\t\t\tvar p2 = ( j / l ) * Math.PI * 2;\n\t\n\t\t\tpositions.push(\n\t\t\t\tMath.cos( p1 ), Math.sin( p1 ), 1,\n\t\t\t\tMath.cos( p2 ), Math.sin( p2 ), 1\n\t\t\t);\n\t\n\t\t}\n\t\n\t\tgeometry.addAttribute( 'position', new THREE.Float32Attribute( positions, 3 ) );\n\t\n\t\tvar material = new THREE.LineBasicMaterial( { fog: false } );\n\t\n\t\tthis.cone = new THREE.LineSegments( geometry, material );\n\t\tthis.add( this.cone );\n\t\n\t\tthis.update();\n\t\n\t};\n\t\n\tTHREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );\n\tTHREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;\n\t\n\tTHREE.SpotLightHelper.prototype.dispose = function () {\n\t\n\t\tthis.cone.geometry.dispose();\n\t\tthis.cone.material.dispose();\n\t\n\t};\n\t\n\tTHREE.SpotLightHelper.prototype.update = function () {\n\t\n\t\tvar vector = new THREE.Vector3();\n\t\tvar vector2 = new THREE.Vector3();\n\t\n\t\treturn function update() {\n\t\n\t\t\tvar coneLength = this.light.distance ? this.light.distance : 1000;\n\t\t\tvar coneWidth = coneLength * Math.tan( this.light.angle );\n\t\n\t\t\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\n\t\n\t\t\tvector.setFromMatrixPosition( this.light.matrixWorld );\n\t\t\tvector2.setFromMatrixPosition( this.light.target.matrixWorld );\n\t\n\t\t\tthis.cone.lookAt( vector2.sub( vector ) );\n\t\n\t\t\tthis.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\t\n\t\t};\n\t\n\t}();\n\t\n\t// File:src/extras/helpers/VertexNormalsHelper.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t*/\n\t\n\tTHREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {\n\t\n\t\tthis.object = object;\n\t\n\t\tthis.size = ( size !== undefined ) ? size : 1;\n\t\n\t\tvar color = ( hex !== undefined ) ? hex : 0xff0000;\n\t\n\t\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\t\n\t\t//\n\t\n\t\tvar nNormals = 0;\n\t\n\t\tvar objGeometry = this.object.geometry;\n\t\n\t\tif ( objGeometry instanceof THREE.Geometry ) {\n\t\n\t\t\tnNormals = objGeometry.faces.length * 3;\n\t\n\t\t} else if ( objGeometry instanceof THREE.BufferGeometry ) {\n\t\n\t\t\tnNormals = objGeometry.attributes.normal.count;\n\t\n\t\t}\n\t\n\t\t//\n\t\n\t\tvar geometry = new THREE.BufferGeometry();\n\t\n\t\tvar positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );\n\t\n\t\tgeometry.addAttribute( 'position', positions );\n\t\n\t\tTHREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );\n\t\n\t\t//\n\t\n\t\tthis.matrixAutoUpdate = false;\n\t\n\t\tthis.update();\n\t\n\t};\n\t\n\tTHREE.VertexNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );\n\tTHREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;\n\t\n\tTHREE.VertexNormalsHelper.prototype.update = ( function () {\n\t\n\t\tvar v1 = new THREE.Vector3();\n\t\tvar v2 = new THREE.Vector3();\n\t\tvar normalMatrix = new THREE.Matrix3();\n\t\n\t\treturn function update() {\n\t\n\t\t\tvar keys = [ 'a', 'b', 'c' ];\n\t\n\t\t\tthis.object.updateMatrixWorld( true );\n\t\n\t\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\n\t\n\t\t\tvar matrixWorld = this.object.matrixWorld;\n\t\n\t\t\tvar position = this.geometry.attributes.position;\n\t\n\t\t\t//\n\t\n\t\t\tvar objGeometry = this.object.geometry;\n\t\n\t\t\tif ( objGeometry instanceof THREE.Geometry ) {\n\t\n\t\t\t\tvar vertices = objGeometry.vertices;\n\t\n\t\t\t\tvar faces = objGeometry.faces;\n\t\n\t\t\t\tvar idx = 0;\n\t\n\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar face = faces[ i ];\n\t\n\t\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\tvar vertex = vertices[ face[ keys[ j ] ] ];\n\t\n\t\t\t\t\t\tvar normal = face.vertexNormals[ j ];\n\t\n\t\t\t\t\t\tv1.copy( vertex ).applyMatrix4( matrixWorld );\n\t\n\t\t\t\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\t\n\t\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\t\n\t\t\t\t\t\tidx = idx + 1;\n\t\n\t\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\t\n\t\t\t\t\t\tidx = idx + 1;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t} else if ( objGeometry instanceof THREE.BufferGeometry ) {\n\t\n\t\t\t\tvar objPos = objGeometry.attributes.position;\n\t\n\t\t\t\tvar objNorm = objGeometry.attributes.normal;\n\t\n\t\t\t\tvar idx = 0;\n\t\n\t\t\t\t// for simplicity, ignore index and drawcalls, and render every normal\n\t\n\t\t\t\tfor ( var j = 0, jl = objPos.count; j < jl; j ++ ) {\n\t\n\t\t\t\t\tv1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );\n\t\n\t\t\t\t\tv2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );\n\t\n\t\t\t\t\tv2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\t\n\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\t\n\t\t\t\t\tidx = idx + 1;\n\t\n\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\t\n\t\t\t\t\tidx = idx + 1;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tposition.needsUpdate = true;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t}() );\n\t\n\t// File:src/extras/helpers/WireframeHelper.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.WireframeHelper = function ( object, hex ) {\n\t\n\t\tvar color = ( hex !== undefined ) ? hex : 0xffffff;\n\t\n\t\tTHREE.LineSegments.call( this, new THREE.WireframeGeometry( object.geometry ), new THREE.LineBasicMaterial( { color: color } ) );\n\t\n\t\tthis.matrix = object.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\t\n\t};\n\t\n\tTHREE.WireframeHelper.prototype = Object.create( THREE.LineSegments.prototype );\n\tTHREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;\n\t\n\t// File:src/extras/objects/ImmediateRenderObject.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.ImmediateRenderObject = function ( material ) {\n\t\n\t\tTHREE.Object3D.call( this );\n\t\n\t\tthis.material = material;\n\t\tthis.render = function ( renderCallback ) {};\n\t\n\t};\n\t\n\tTHREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );\n\tTHREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;\n\t\n\t// File:src/extras/objects/MorphBlendMesh.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.MorphBlendMesh = function( geometry, material ) {\n\t\n\t\tTHREE.Mesh.call( this, geometry, material );\n\t\n\t\tthis.animationsMap = {};\n\t\tthis.animationsList = [];\n\t\n\t\t// prepare default animation\n\t\t// (all frames played together in 1 second)\n\t\n\t\tvar numFrames = this.geometry.morphTargets.length;\n\t\n\t\tvar name = \"__default\";\n\t\n\t\tvar startFrame = 0;\n\t\tvar endFrame = numFrames - 1;\n\t\n\t\tvar fps = numFrames / 1;\n\t\n\t\tthis.createAnimation( name, startFrame, endFrame, fps );\n\t\tthis.setAnimationWeight( name, 1 );\n\t\n\t};\n\t\n\tTHREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );\n\tTHREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;\n\t\n\tTHREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {\n\t\n\t\tvar animation = {\n\t\n\t\t\tstart: start,\n\t\t\tend: end,\n\t\n\t\t\tlength: end - start + 1,\n\t\n\t\t\tfps: fps,\n\t\t\tduration: ( end - start ) / fps,\n\t\n\t\t\tlastFrame: 0,\n\t\t\tcurrentFrame: 0,\n\t\n\t\t\tactive: false,\n\t\n\t\t\ttime: 0,\n\t\t\tdirection: 1,\n\t\t\tweight: 1,\n\t\n\t\t\tdirectionBackwards: false,\n\t\t\tmirroredLoop: false\n\t\n\t\t};\n\t\n\t\tthis.animationsMap[ name ] = animation;\n\t\tthis.animationsList.push( animation );\n\t\n\t};\n\t\n\tTHREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {\n\t\n\t\tvar pattern = /([a-z]+)_?(\\d+)/i;\n\t\n\t\tvar firstAnimation, frameRanges = {};\n\t\n\t\tvar geometry = this.geometry;\n\t\n\t\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\n\t\n\t\t\tvar morph = geometry.morphTargets[ i ];\n\t\t\tvar chunks = morph.name.match( pattern );\n\t\n\t\t\tif ( chunks && chunks.length > 1 ) {\n\t\n\t\t\t\tvar name = chunks[ 1 ];\n\t\n\t\t\t\tif ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };\n\t\n\t\t\t\tvar range = frameRanges[ name ];\n\t\n\t\t\t\tif ( i < range.start ) range.start = i;\n\t\t\t\tif ( i > range.end ) range.end = i;\n\t\n\t\t\t\tif ( ! firstAnimation ) firstAnimation = name;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfor ( var name in frameRanges ) {\n\t\n\t\t\tvar range = frameRanges[ name ];\n\t\t\tthis.createAnimation( name, range.start, range.end, fps );\n\t\n\t\t}\n\t\n\t\tthis.firstAnimation = firstAnimation;\n\t\n\t};\n\t\n\tTHREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {\n\t\n\t\tvar animation = this.animationsMap[ name ];\n\t\n\t\tif ( animation ) {\n\t\n\t\t\tanimation.direction = 1;\n\t\t\tanimation.directionBackwards = false;\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {\n\t\n\t\tvar animation = this.animationsMap[ name ];\n\t\n\t\tif ( animation ) {\n\t\n\t\t\tanimation.direction = - 1;\n\t\t\tanimation.directionBackwards = true;\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {\n\t\n\t\tvar animation = this.animationsMap[ name ];\n\t\n\t\tif ( animation ) {\n\t\n\t\t\tanimation.fps = fps;\n\t\t\tanimation.duration = ( animation.end - animation.start ) / animation.fps;\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {\n\t\n\t\tvar animation = this.animationsMap[ name ];\n\t\n\t\tif ( animation ) {\n\t\n\t\t\tanimation.duration = duration;\n\t\t\tanimation.fps = ( animation.end - animation.start ) / animation.duration;\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {\n\t\n\t\tvar animation = this.animationsMap[ name ];\n\t\n\t\tif ( animation ) {\n\t\n\t\t\tanimation.weight = weight;\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {\n\t\n\t\tvar animation = this.animationsMap[ name ];\n\t\n\t\tif ( animation ) {\n\t\n\t\t\tanimation.time = time;\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {\n\t\n\t\tvar time = 0;\n\t\n\t\tvar animation = this.animationsMap[ name ];\n\t\n\t\tif ( animation ) {\n\t\n\t\t\ttime = animation.time;\n\t\n\t\t}\n\t\n\t\treturn time;\n\t\n\t};\n\t\n\tTHREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {\n\t\n\t\tvar duration = - 1;\n\t\n\t\tvar animation = this.animationsMap[ name ];\n\t\n\t\tif ( animation ) {\n\t\n\t\t\tduration = animation.duration;\n\t\n\t\t}\n\t\n\t\treturn duration;\n\t\n\t};\n\t\n\tTHREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {\n\t\n\t\tvar animation = this.animationsMap[ name ];\n\t\n\t\tif ( animation ) {\n\t\n\t\t\tanimation.time = 0;\n\t\t\tanimation.active = true;\n\t\n\t\t} else {\n\t\n\t\t\tconsole.warn( \"THREE.MorphBlendMesh: animation[\" + name + \"] undefined in .playAnimation()\" );\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {\n\t\n\t\tvar animation = this.animationsMap[ name ];\n\t\n\t\tif ( animation ) {\n\t\n\t\t\tanimation.active = false;\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.MorphBlendMesh.prototype.update = function ( delta ) {\n\t\n\t\tfor ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {\n\t\n\t\t\tvar animation = this.animationsList[ i ];\n\t\n\t\t\tif ( ! animation.active ) continue;\n\t\n\t\t\tvar frameTime = animation.duration / animation.length;\n\t\n\t\t\tanimation.time += animation.direction * delta;\n\t\n\t\t\tif ( animation.mirroredLoop ) {\n\t\n\t\t\t\tif ( animation.time > animation.duration || animation.time < 0 ) {\n\t\n\t\t\t\t\tanimation.direction *= - 1;\n\t\n\t\t\t\t\tif ( animation.time > animation.duration ) {\n\t\n\t\t\t\t\t\tanimation.time = animation.duration;\n\t\t\t\t\t\tanimation.directionBackwards = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( animation.time < 0 ) {\n\t\n\t\t\t\t\t\tanimation.time = 0;\n\t\t\t\t\t\tanimation.directionBackwards = false;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t} else {\n\t\n\t\t\t\tanimation.time = animation.time % animation.duration;\n\t\n\t\t\t\tif ( animation.time < 0 ) animation.time += animation.duration;\n\t\n\t\t\t}\n\t\n\t\t\tvar keyframe = animation.start + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );\n\t\t\tvar weight = animation.weight;\n\t\n\t\t\tif ( keyframe !== animation.currentFrame ) {\n\t\n\t\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = 0;\n\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;\n\t\n\t\t\t\tthis.morphTargetInfluences[ keyframe ] = 0;\n\t\n\t\t\t\tanimation.lastFrame = animation.currentFrame;\n\t\t\t\tanimation.currentFrame = keyframe;\n\t\n\t\t\t}\n\t\n\t\t\tvar mix = ( animation.time % frameTime ) / frameTime;\n\t\n\t\t\tif ( animation.directionBackwards ) mix = 1 - mix;\n\t\n\t\t\tif ( animation.currentFrame !== animation.lastFrame ) {\n\t\n\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = mix * weight;\n\t\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = weight;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t};\n\t\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t/*!\n\t * vue-resource v0.9.0\n\t * https://github.com/vuejs/vue-resource\n\t * Released under the MIT License.\n\t */\n\t\n\t'use strict';\n\t\n\t/**\n\t * Promises/A+ polyfill v1.1.4 (https://github.com/bramstein/promis)\n\t */\n\t\n\tvar RESOLVED = 0;\n\tvar REJECTED = 1;\n\tvar PENDING = 2;\n\t\n\tfunction Promise$2(executor) {\n\t\n\t    this.state = PENDING;\n\t    this.value = undefined;\n\t    this.deferred = [];\n\t\n\t    var promise = this;\n\t\n\t    try {\n\t        executor(function (x) {\n\t            promise.resolve(x);\n\t        }, function (r) {\n\t            promise.reject(r);\n\t        });\n\t    } catch (e) {\n\t        promise.reject(e);\n\t    }\n\t}\n\t\n\tPromise$2.reject = function (r) {\n\t    return new Promise$2(function (resolve, reject) {\n\t        reject(r);\n\t    });\n\t};\n\t\n\tPromise$2.resolve = function (x) {\n\t    return new Promise$2(function (resolve, reject) {\n\t        resolve(x);\n\t    });\n\t};\n\t\n\tPromise$2.all = function all(iterable) {\n\t    return new Promise$2(function (resolve, reject) {\n\t        var count = 0,\n\t            result = [];\n\t\n\t        if (iterable.length === 0) {\n\t            resolve(result);\n\t        }\n\t\n\t        function resolver(i) {\n\t            return function (x) {\n\t                result[i] = x;\n\t                count += 1;\n\t\n\t                if (count === iterable.length) {\n\t                    resolve(result);\n\t                }\n\t            };\n\t        }\n\t\n\t        for (var i = 0; i < iterable.length; i += 1) {\n\t            Promise$2.resolve(iterable[i]).then(resolver(i), reject);\n\t        }\n\t    });\n\t};\n\t\n\tPromise$2.race = function race(iterable) {\n\t    return new Promise$2(function (resolve, reject) {\n\t        for (var i = 0; i < iterable.length; i += 1) {\n\t            Promise$2.resolve(iterable[i]).then(resolve, reject);\n\t        }\n\t    });\n\t};\n\t\n\tvar p$1 = Promise$2.prototype;\n\t\n\tp$1.resolve = function resolve(x) {\n\t    var promise = this;\n\t\n\t    if (promise.state === PENDING) {\n\t        if (x === promise) {\n\t            throw new TypeError('Promise settled with itself.');\n\t        }\n\t\n\t        var called = false;\n\t\n\t        try {\n\t            var then = x && x['then'];\n\t\n\t            if (x !== null && typeof x === 'object' && typeof then === 'function') {\n\t                then.call(x, function (x) {\n\t                    if (!called) {\n\t                        promise.resolve(x);\n\t                    }\n\t                    called = true;\n\t                }, function (r) {\n\t                    if (!called) {\n\t                        promise.reject(r);\n\t                    }\n\t                    called = true;\n\t                });\n\t                return;\n\t            }\n\t        } catch (e) {\n\t            if (!called) {\n\t                promise.reject(e);\n\t            }\n\t            return;\n\t        }\n\t\n\t        promise.state = RESOLVED;\n\t        promise.value = x;\n\t        promise.notify();\n\t    }\n\t};\n\t\n\tp$1.reject = function reject(reason) {\n\t    var promise = this;\n\t\n\t    if (promise.state === PENDING) {\n\t        if (reason === promise) {\n\t            throw new TypeError('Promise settled with itself.');\n\t        }\n\t\n\t        promise.state = REJECTED;\n\t        promise.value = reason;\n\t        promise.notify();\n\t    }\n\t};\n\t\n\tp$1.notify = function notify() {\n\t    var promise = this;\n\t\n\t    nextTick(function () {\n\t        if (promise.state !== PENDING) {\n\t            while (promise.deferred.length) {\n\t                var deferred = promise.deferred.shift(),\n\t                    onResolved = deferred[0],\n\t                    onRejected = deferred[1],\n\t                    resolve = deferred[2],\n\t                    reject = deferred[3];\n\t\n\t                try {\n\t                    if (promise.state === RESOLVED) {\n\t                        if (typeof onResolved === 'function') {\n\t                            resolve(onResolved.call(undefined, promise.value));\n\t                        } else {\n\t                            resolve(promise.value);\n\t                        }\n\t                    } else if (promise.state === REJECTED) {\n\t                        if (typeof onRejected === 'function') {\n\t                            resolve(onRejected.call(undefined, promise.value));\n\t                        } else {\n\t                            reject(promise.value);\n\t                        }\n\t                    }\n\t                } catch (e) {\n\t                    reject(e);\n\t                }\n\t            }\n\t        }\n\t    });\n\t};\n\t\n\tp$1.then = function then(onResolved, onRejected) {\n\t    var promise = this;\n\t\n\t    return new Promise$2(function (resolve, reject) {\n\t        promise.deferred.push([onResolved, onRejected, resolve, reject]);\n\t        promise.notify();\n\t    });\n\t};\n\t\n\tp$1.catch = function (onRejected) {\n\t    return this.then(undefined, onRejected);\n\t};\n\t\n\tvar PromiseObj = window.Promise || Promise$2;\n\t\n\tfunction Promise$1(executor, context) {\n\t\n\t    if (executor instanceof PromiseObj) {\n\t        this.promise = executor;\n\t    } else {\n\t        this.promise = new PromiseObj(executor.bind(context));\n\t    }\n\t\n\t    this.context = context;\n\t}\n\t\n\tPromise$1.all = function (iterable, context) {\n\t    return new Promise$1(PromiseObj.all(iterable), context);\n\t};\n\t\n\tPromise$1.resolve = function (value, context) {\n\t    return new Promise$1(PromiseObj.resolve(value), context);\n\t};\n\t\n\tPromise$1.reject = function (reason, context) {\n\t    return new Promise$1(PromiseObj.reject(reason), context);\n\t};\n\t\n\tPromise$1.race = function (iterable, context) {\n\t    return new Promise$1(PromiseObj.race(iterable), context);\n\t};\n\t\n\tvar p = Promise$1.prototype;\n\t\n\tp.bind = function (context) {\n\t    this.context = context;\n\t    return this;\n\t};\n\t\n\tp.then = function (fulfilled, rejected) {\n\t\n\t    if (fulfilled && fulfilled.bind && this.context) {\n\t        fulfilled = fulfilled.bind(this.context);\n\t    }\n\t\n\t    if (rejected && rejected.bind && this.context) {\n\t        rejected = rejected.bind(this.context);\n\t    }\n\t\n\t    return new Promise$1(this.promise.then(fulfilled, rejected), this.context);\n\t};\n\t\n\tp.catch = function (rejected) {\n\t\n\t    if (rejected && rejected.bind && this.context) {\n\t        rejected = rejected.bind(this.context);\n\t    }\n\t\n\t    return new Promise$1(this.promise.catch(rejected), this.context);\n\t};\n\t\n\tp.finally = function (callback) {\n\t\n\t    return this.then(function (value) {\n\t        callback.call(this);\n\t        return value;\n\t    }, function (reason) {\n\t        callback.call(this);\n\t        return PromiseObj.reject(reason);\n\t    });\n\t};\n\t\n\tvar debug = false;\n\tvar util = {};\n\tvar array = [];\n\tfunction Util (Vue) {\n\t    util = Vue.util;\n\t    debug = Vue.config.debug || !Vue.config.silent;\n\t}\n\t\n\tfunction warn(msg) {\n\t    if (typeof console !== 'undefined' && debug) {\n\t        console.warn('[VueResource warn]: ' + msg);\n\t    }\n\t}\n\t\n\tfunction error(msg) {\n\t    if (typeof console !== 'undefined') {\n\t        console.error(msg);\n\t    }\n\t}\n\t\n\tfunction nextTick(cb, ctx) {\n\t    return util.nextTick(cb, ctx);\n\t}\n\t\n\tfunction trim(str) {\n\t    return str.replace(/^\\s*|\\s*$/g, '');\n\t}\n\t\n\tvar isArray = Array.isArray;\n\t\n\tfunction isString(val) {\n\t    return typeof val === 'string';\n\t}\n\t\n\tfunction isBoolean(val) {\n\t    return val === true || val === false;\n\t}\n\t\n\tfunction isFunction(val) {\n\t    return typeof val === 'function';\n\t}\n\t\n\tfunction isObject(obj) {\n\t    return obj !== null && typeof obj === 'object';\n\t}\n\t\n\tfunction isPlainObject(obj) {\n\t    return isObject(obj) && Object.getPrototypeOf(obj) == Object.prototype;\n\t}\n\t\n\tfunction isFormData(obj) {\n\t    return typeof FormData !== 'undefined' && obj instanceof FormData;\n\t}\n\t\n\tfunction when(value, fulfilled, rejected) {\n\t\n\t    var promise = Promise$1.resolve(value);\n\t\n\t    if (arguments.length < 2) {\n\t        return promise;\n\t    }\n\t\n\t    return promise.then(fulfilled, rejected);\n\t}\n\t\n\tfunction options(fn, obj, opts) {\n\t\n\t    opts = opts || {};\n\t\n\t    if (isFunction(opts)) {\n\t        opts = opts.call(obj);\n\t    }\n\t\n\t    return merge(fn.bind({ $vm: obj, $options: opts }), fn, { $options: opts });\n\t}\n\t\n\tfunction each(obj, iterator) {\n\t\n\t    var i, key;\n\t\n\t    if (typeof obj.length == 'number') {\n\t        for (i = 0; i < obj.length; i++) {\n\t            iterator.call(obj[i], obj[i], i);\n\t        }\n\t    } else if (isObject(obj)) {\n\t        for (key in obj) {\n\t            if (obj.hasOwnProperty(key)) {\n\t                iterator.call(obj[key], obj[key], key);\n\t            }\n\t        }\n\t    }\n\t\n\t    return obj;\n\t}\n\t\n\tvar assign = Object.assign || _assign;\n\t\n\tfunction merge(target) {\n\t\n\t    var args = array.slice.call(arguments, 1);\n\t\n\t    args.forEach(function (source) {\n\t        _merge(target, source, true);\n\t    });\n\t\n\t    return target;\n\t}\n\t\n\tfunction defaults(target) {\n\t\n\t    var args = array.slice.call(arguments, 1);\n\t\n\t    args.forEach(function (source) {\n\t\n\t        for (var key in source) {\n\t            if (target[key] === undefined) {\n\t                target[key] = source[key];\n\t            }\n\t        }\n\t    });\n\t\n\t    return target;\n\t}\n\t\n\tfunction _assign(target) {\n\t\n\t    var args = array.slice.call(arguments, 1);\n\t\n\t    args.forEach(function (source) {\n\t        _merge(target, source);\n\t    });\n\t\n\t    return target;\n\t}\n\t\n\tfunction _merge(target, source, deep) {\n\t    for (var key in source) {\n\t        if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {\n\t            if (isPlainObject(source[key]) && !isPlainObject(target[key])) {\n\t                target[key] = {};\n\t            }\n\t            if (isArray(source[key]) && !isArray(target[key])) {\n\t                target[key] = [];\n\t            }\n\t            _merge(target[key], source[key], deep);\n\t        } else if (source[key] !== undefined) {\n\t            target[key] = source[key];\n\t        }\n\t    }\n\t}\n\t\n\tfunction root (options, next) {\n\t\n\t    var url = next(options);\n\t\n\t    if (isString(options.root) && !url.match(/^(https?:)?\\//)) {\n\t        url = options.root + '/' + url;\n\t    }\n\t\n\t    return url;\n\t}\n\t\n\tfunction query (options, next) {\n\t\n\t    var urlParams = Object.keys(Url.options.params),\n\t        query = {},\n\t        url = next(options);\n\t\n\t    each(options.params, function (value, key) {\n\t        if (urlParams.indexOf(key) === -1) {\n\t            query[key] = value;\n\t        }\n\t    });\n\t\n\t    query = Url.params(query);\n\t\n\t    if (query) {\n\t        url += (url.indexOf('?') == -1 ? '?' : '&') + query;\n\t    }\n\t\n\t    return url;\n\t}\n\t\n\t/**\n\t * URL Template v2.0.6 (https://github.com/bramstein/url-template)\n\t */\n\t\n\tfunction expand(url, params, variables) {\n\t\n\t    var tmpl = parse(url),\n\t        expanded = tmpl.expand(params);\n\t\n\t    if (variables) {\n\t        variables.push.apply(variables, tmpl.vars);\n\t    }\n\t\n\t    return expanded;\n\t}\n\t\n\tfunction parse(template) {\n\t\n\t    var operators = ['+', '#', '.', '/', ';', '?', '&'],\n\t        variables = [];\n\t\n\t    return {\n\t        vars: variables,\n\t        expand: function (context) {\n\t            return template.replace(/\\{([^\\{\\}]+)\\}|([^\\{\\}]+)/g, function (_, expression, literal) {\n\t                if (expression) {\n\t\n\t                    var operator = null,\n\t                        values = [];\n\t\n\t                    if (operators.indexOf(expression.charAt(0)) !== -1) {\n\t                        operator = expression.charAt(0);\n\t                        expression = expression.substr(1);\n\t                    }\n\t\n\t                    expression.split(/,/g).forEach(function (variable) {\n\t                        var tmp = /([^:\\*]*)(?::(\\d+)|(\\*))?/.exec(variable);\n\t                        values.push.apply(values, getValues(context, operator, tmp[1], tmp[2] || tmp[3]));\n\t                        variables.push(tmp[1]);\n\t                    });\n\t\n\t                    if (operator && operator !== '+') {\n\t\n\t                        var separator = ',';\n\t\n\t                        if (operator === '?') {\n\t                            separator = '&';\n\t                        } else if (operator !== '#') {\n\t                            separator = operator;\n\t                        }\n\t\n\t                        return (values.length !== 0 ? operator : '') + values.join(separator);\n\t                    } else {\n\t                        return values.join(',');\n\t                    }\n\t                } else {\n\t                    return encodeReserved(literal);\n\t                }\n\t            });\n\t        }\n\t    };\n\t}\n\t\n\tfunction getValues(context, operator, key, modifier) {\n\t\n\t    var value = context[key],\n\t        result = [];\n\t\n\t    if (isDefined(value) && value !== '') {\n\t        if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n\t            value = value.toString();\n\t\n\t            if (modifier && modifier !== '*') {\n\t                value = value.substring(0, parseInt(modifier, 10));\n\t            }\n\t\n\t            result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));\n\t        } else {\n\t            if (modifier === '*') {\n\t                if (Array.isArray(value)) {\n\t                    value.filter(isDefined).forEach(function (value) {\n\t                        result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));\n\t                    });\n\t                } else {\n\t                    Object.keys(value).forEach(function (k) {\n\t                        if (isDefined(value[k])) {\n\t                            result.push(encodeValue(operator, value[k], k));\n\t                        }\n\t                    });\n\t                }\n\t            } else {\n\t                var tmp = [];\n\t\n\t                if (Array.isArray(value)) {\n\t                    value.filter(isDefined).forEach(function (value) {\n\t                        tmp.push(encodeValue(operator, value));\n\t                    });\n\t                } else {\n\t                    Object.keys(value).forEach(function (k) {\n\t                        if (isDefined(value[k])) {\n\t                            tmp.push(encodeURIComponent(k));\n\t                            tmp.push(encodeValue(operator, value[k].toString()));\n\t                        }\n\t                    });\n\t                }\n\t\n\t                if (isKeyOperator(operator)) {\n\t                    result.push(encodeURIComponent(key) + '=' + tmp.join(','));\n\t                } else if (tmp.length !== 0) {\n\t                    result.push(tmp.join(','));\n\t                }\n\t            }\n\t        }\n\t    } else {\n\t        if (operator === ';') {\n\t            result.push(encodeURIComponent(key));\n\t        } else if (value === '' && (operator === '&' || operator === '?')) {\n\t            result.push(encodeURIComponent(key) + '=');\n\t        } else if (value === '') {\n\t            result.push('');\n\t        }\n\t    }\n\t\n\t    return result;\n\t}\n\t\n\tfunction isDefined(value) {\n\t    return value !== undefined && value !== null;\n\t}\n\t\n\tfunction isKeyOperator(operator) {\n\t    return operator === ';' || operator === '&' || operator === '?';\n\t}\n\t\n\tfunction encodeValue(operator, value, key) {\n\t\n\t    value = operator === '+' || operator === '#' ? encodeReserved(value) : encodeURIComponent(value);\n\t\n\t    if (key) {\n\t        return encodeURIComponent(key) + '=' + value;\n\t    } else {\n\t        return value;\n\t    }\n\t}\n\t\n\tfunction encodeReserved(str) {\n\t    return str.split(/(%[0-9A-Fa-f]{2})/g).map(function (part) {\n\t        if (!/%[0-9A-Fa-f]/.test(part)) {\n\t            part = encodeURI(part);\n\t        }\n\t        return part;\n\t    }).join('');\n\t}\n\t\n\tfunction template (options) {\n\t\n\t    var variables = [],\n\t        url = expand(options.url, options.params, variables);\n\t\n\t    variables.forEach(function (key) {\n\t        delete options.params[key];\n\t    });\n\t\n\t    return url;\n\t}\n\t\n\t/**\n\t * Service for URL templating.\n\t */\n\t\n\tvar ie = document.documentMode;\n\tvar el = document.createElement('a');\n\t\n\tfunction Url(url, params) {\n\t\n\t    var self = this || {},\n\t        options = url,\n\t        transform;\n\t\n\t    if (isString(url)) {\n\t        options = { url: url, params: params };\n\t    }\n\t\n\t    options = merge({}, Url.options, self.$options, options);\n\t\n\t    Url.transforms.forEach(function (handler) {\n\t        transform = factory(handler, transform, self.$vm);\n\t    });\n\t\n\t    return transform(options);\n\t}\n\t\n\t/**\n\t * Url options.\n\t */\n\t\n\tUrl.options = {\n\t    url: '',\n\t    root: null,\n\t    params: {}\n\t};\n\t\n\t/**\n\t * Url transforms.\n\t */\n\t\n\tUrl.transforms = [template, query, root];\n\t\n\t/**\n\t * Encodes a Url parameter string.\n\t *\n\t * @param {Object} obj\n\t */\n\t\n\tUrl.params = function (obj) {\n\t\n\t    var params = [],\n\t        escape = encodeURIComponent;\n\t\n\t    params.add = function (key, value) {\n\t\n\t        if (isFunction(value)) {\n\t            value = value();\n\t        }\n\t\n\t        if (value === null) {\n\t            value = '';\n\t        }\n\t\n\t        this.push(escape(key) + '=' + escape(value));\n\t    };\n\t\n\t    serialize(params, obj);\n\t\n\t    return params.join('&').replace(/%20/g, '+');\n\t};\n\t\n\t/**\n\t * Parse a URL and return its components.\n\t *\n\t * @param {String} url\n\t */\n\t\n\tUrl.parse = function (url) {\n\t\n\t    if (ie) {\n\t        el.href = url;\n\t        url = el.href;\n\t    }\n\t\n\t    el.href = url;\n\t\n\t    return {\n\t        href: el.href,\n\t        protocol: el.protocol ? el.protocol.replace(/:$/, '') : '',\n\t        port: el.port,\n\t        host: el.host,\n\t        hostname: el.hostname,\n\t        pathname: el.pathname.charAt(0) === '/' ? el.pathname : '/' + el.pathname,\n\t        search: el.search ? el.search.replace(/^\\?/, '') : '',\n\t        hash: el.hash ? el.hash.replace(/^#/, '') : ''\n\t    };\n\t};\n\t\n\tfunction factory(handler, next, vm) {\n\t    return function (options) {\n\t        return handler.call(vm, options, next);\n\t    };\n\t}\n\t\n\tfunction serialize(params, obj, scope) {\n\t\n\t    var array = isArray(obj),\n\t        plain = isPlainObject(obj),\n\t        hash;\n\t\n\t    each(obj, function (value, key) {\n\t\n\t        hash = isObject(value) || isArray(value);\n\t\n\t        if (scope) {\n\t            key = scope + '[' + (plain || hash ? key : '') + ']';\n\t        }\n\t\n\t        if (!scope && array) {\n\t            params.add(value.name, value.value);\n\t        } else if (hash) {\n\t            serialize(params, value, key);\n\t        } else {\n\t            params.add(key, value);\n\t        }\n\t    });\n\t}\n\t\n\tfunction xdrClient (request) {\n\t    return new Promise$1(function (resolve) {\n\t\n\t        var xdr = new XDomainRequest(),\n\t            handler = function (event) {\n\t\n\t            var response = request.respondWith(xdr.responseText, {\n\t                status: xhr.status,\n\t                statusText: xdr.statusText\n\t            });\n\t\n\t            resolve(response);\n\t        };\n\t\n\t        request.abort = function () {\n\t            return xdr.abort();\n\t        };\n\t\n\t        xdr.open(request.method, request.getUrl(), true);\n\t        xdr.timeout = 0;\n\t        xdr.onload = handler;\n\t        xdr.onerror = handler;\n\t        xdr.ontimeout = function () {};\n\t        xdr.onprogress = function () {};\n\t        xdr.send(request.getBody());\n\t    });\n\t}\n\t\n\tvar ORIGIN_URL = Url.parse(location.href);\n\tvar SUPPORTS_CORS = 'withCredentials' in new XMLHttpRequest();\n\t\n\tfunction cors (request, next) {\n\t\n\t    if (!isBoolean(request.crossOrigin) && crossOrigin(request)) {\n\t        request.crossOrigin = true;\n\t    }\n\t\n\t    if (request.crossOrigin) {\n\t\n\t        if (!SUPPORTS_CORS) {\n\t            request.client = xdrClient;\n\t        }\n\t\n\t        delete request.emulateHTTP;\n\t    }\n\t\n\t    next();\n\t}\n\t\n\tfunction crossOrigin(request) {\n\t\n\t    var requestUrl = Url.parse(Url(request));\n\t\n\t    return requestUrl.protocol !== ORIGIN_URL.protocol || requestUrl.host !== ORIGIN_URL.host;\n\t}\n\t\n\tfunction body (request, next) {\n\t\n\t    if (request.emulateJSON && isPlainObject(request.body)) {\n\t        request.body = Url.params(request.body);\n\t        request.headers['Content-Type'] = 'application/x-www-form-urlencoded';\n\t    }\n\t\n\t    if (isFormData(request.body)) {\n\t        delete request.headers['Content-Type'];\n\t    }\n\t\n\t    if (isPlainObject(request.body)) {\n\t        request.body = JSON.stringify(request.body);\n\t    }\n\t\n\t    next(function (response) {\n\t\n\t        var contentType = response.headers['Content-Type'];\n\t\n\t        if (isString(contentType) && contentType.indexOf('application/json') === 0) {\n\t\n\t            try {\n\t                response.data = response.json();\n\t            } catch (e) {\n\t                response.data = null;\n\t            }\n\t        } else {\n\t            response.data = response.text();\n\t        }\n\t    });\n\t}\n\t\n\tfunction jsonpClient (request) {\n\t    return new Promise$1(function (resolve) {\n\t\n\t        var name = request.jsonp || 'callback',\n\t            callback = '_jsonp' + Math.random().toString(36).substr(2),\n\t            body = null,\n\t            handler,\n\t            script;\n\t\n\t        handler = function (event) {\n\t\n\t            var status = 0;\n\t\n\t            if (event.type === 'load' && body !== null) {\n\t                status = 200;\n\t            } else if (event.type === 'error') {\n\t                status = 404;\n\t            }\n\t\n\t            resolve(request.respondWith(body, { status: status }));\n\t\n\t            delete window[callback];\n\t            document.body.removeChild(script);\n\t        };\n\t\n\t        request.params[name] = callback;\n\t\n\t        window[callback] = function (result) {\n\t            body = JSON.stringify(result);\n\t        };\n\t\n\t        script = document.createElement('script');\n\t        script.src = request.getUrl();\n\t        script.type = 'text/javascript';\n\t        script.async = true;\n\t        script.onload = handler;\n\t        script.onerror = handler;\n\t\n\t        document.body.appendChild(script);\n\t    });\n\t}\n\t\n\tfunction jsonp (request, next) {\n\t\n\t    if (request.method == 'JSONP') {\n\t        request.client = jsonpClient;\n\t    }\n\t\n\t    next(function (response) {\n\t\n\t        if (request.method == 'JSONP') {\n\t            response.data = response.json();\n\t        }\n\t    });\n\t}\n\t\n\tfunction before (request, next) {\n\t\n\t    if (isFunction(request.before)) {\n\t        request.before.call(this, request);\n\t    }\n\t\n\t    next();\n\t}\n\t\n\t/**\n\t * HTTP method override Interceptor.\n\t */\n\t\n\tfunction method (request, next) {\n\t\n\t    if (request.emulateHTTP && /^(PUT|PATCH|DELETE)$/i.test(request.method)) {\n\t        request.headers['X-HTTP-Method-Override'] = request.method;\n\t        request.method = 'POST';\n\t    }\n\t\n\t    next();\n\t}\n\t\n\tfunction header (request, next) {\n\t\n\t    request.method = request.method.toUpperCase();\n\t    request.headers = assign({}, Http.headers.common, !request.crossOrigin ? Http.headers.custom : {}, Http.headers[request.method.toLowerCase()], request.headers);\n\t\n\t    next();\n\t}\n\t\n\t/**\n\t * Timeout Interceptor.\n\t */\n\t\n\tfunction timeout (request, next) {\n\t\n\t    var timeout;\n\t\n\t    if (request.timeout) {\n\t        timeout = setTimeout(function () {\n\t            request.cancel();\n\t        }, request.timeout);\n\t    }\n\t\n\t    next(function (response) {\n\t\n\t        clearTimeout(timeout);\n\t    });\n\t}\n\t\n\tfunction xhrClient (request) {\n\t    return new Promise$1(function (resolve) {\n\t\n\t        var xhr = new XMLHttpRequest(),\n\t            handler = function (event) {\n\t\n\t            var response = request.respondWith('response' in xhr ? xhr.response : xhr.responseText, {\n\t                status: xhr.status === 1223 ? 204 : xhr.status, // IE9 status bug\n\t                statusText: xhr.status === 1223 ? 'No Content' : trim(xhr.statusText),\n\t                headers: parseHeaders(xhr.getAllResponseHeaders())\n\t            });\n\t\n\t            resolve(response);\n\t        };\n\t\n\t        request.abort = function () {\n\t            return xhr.abort();\n\t        };\n\t\n\t        xhr.open(request.method, request.getUrl(), true);\n\t        xhr.timeout = 0;\n\t        xhr.onload = handler;\n\t        xhr.onerror = handler;\n\t\n\t        if (request.progress) {\n\t            if (request.method === 'GET') {\n\t                xhr.addEventListener('progress', request.progress);\n\t            } else if (/^(POST|PUT)$/i.test(request.method)) {\n\t                xhr.upload.addEventListener('progress', request.progress);\n\t            }\n\t        }\n\t\n\t        if (request.credentials === true) {\n\t            xhr.withCredentials = true;\n\t        }\n\t\n\t        each(request.headers || {}, function (value, header) {\n\t            xhr.setRequestHeader(header, value);\n\t        });\n\t\n\t        xhr.send(request.getBody());\n\t    });\n\t}\n\t\n\tfunction parseHeaders(str) {\n\t\n\t    var headers = {},\n\t        value,\n\t        name,\n\t        i;\n\t\n\t    each(trim(str).split('\\n'), function (row) {\n\t\n\t        i = row.indexOf(':');\n\t        name = trim(row.slice(0, i));\n\t        value = trim(row.slice(i + 1));\n\t\n\t        if (headers[name]) {\n\t\n\t            if (isArray(headers[name])) {\n\t                headers[name].push(value);\n\t            } else {\n\t                headers[name] = [headers[name], value];\n\t            }\n\t        } else {\n\t\n\t            headers[name] = value;\n\t        }\n\t    });\n\t\n\t    return headers;\n\t}\n\t\n\tfunction Client (context) {\n\t\n\t    var reqHandlers = [sendRequest],\n\t        resHandlers = [],\n\t        handler;\n\t\n\t    if (!isObject(context)) {\n\t        context = null;\n\t    }\n\t\n\t    function Client(request) {\n\t        return new Promise$1(function (resolve) {\n\t\n\t            function exec() {\n\t\n\t                handler = reqHandlers.pop();\n\t\n\t                if (isFunction(handler)) {\n\t                    handler.call(context, request, next);\n\t                } else {\n\t                    warn('Invalid interceptor of type ' + typeof handler + ', must be a function');\n\t                    next();\n\t                }\n\t            }\n\t\n\t            function next(response) {\n\t                when(response, function (response) {\n\t\n\t                    if (isFunction(response)) {\n\t\n\t                        resHandlers.unshift(response);\n\t                    } else if (isObject(response)) {\n\t\n\t                        resHandlers.forEach(function (handler) {\n\t                            handler.call(context, response);\n\t                        });\n\t\n\t                        resolve(response);\n\t\n\t                        return;\n\t                    }\n\t\n\t                    exec();\n\t                });\n\t            }\n\t\n\t            exec();\n\t        }, context);\n\t    }\n\t\n\t    Client.use = function (handler) {\n\t        reqHandlers.push(handler);\n\t    };\n\t\n\t    return Client;\n\t}\n\t\n\tfunction sendRequest(request, resolve) {\n\t\n\t    var client = request.client || xhrClient;\n\t\n\t    resolve(client(request));\n\t}\n\t\n\tvar classCallCheck = function (instance, Constructor) {\n\t  if (!(instance instanceof Constructor)) {\n\t    throw new TypeError(\"Cannot call a class as a function\");\n\t  }\n\t};\n\t\n\t/**\n\t * HTTP Response.\n\t */\n\t\n\tvar Response = function () {\n\t    function Response(body, _ref) {\n\t        var url = _ref.url;\n\t        var headers = _ref.headers;\n\t        var status = _ref.status;\n\t        var statusText = _ref.statusText;\n\t        classCallCheck(this, Response);\n\t\n\t\n\t        this.url = url;\n\t        this.body = body;\n\t        this.headers = headers || {};\n\t        this.status = status || 0;\n\t        this.statusText = statusText || '';\n\t        this.ok = status >= 200 && status < 300;\n\t    }\n\t\n\t    Response.prototype.text = function text() {\n\t        return this.body;\n\t    };\n\t\n\t    Response.prototype.blob = function blob() {\n\t        return new Blob([this.body]);\n\t    };\n\t\n\t    Response.prototype.json = function json() {\n\t        return JSON.parse(this.body);\n\t    };\n\t\n\t    return Response;\n\t}();\n\t\n\tvar Request = function () {\n\t    function Request(options) {\n\t        classCallCheck(this, Request);\n\t\n\t\n\t        this.method = 'GET';\n\t        this.body = null;\n\t        this.params = {};\n\t        this.headers = {};\n\t\n\t        assign(this, options);\n\t    }\n\t\n\t    Request.prototype.getUrl = function getUrl() {\n\t        return Url(this);\n\t    };\n\t\n\t    Request.prototype.getBody = function getBody() {\n\t        return this.body;\n\t    };\n\t\n\t    Request.prototype.respondWith = function respondWith(body, options) {\n\t        return new Response(body, assign(options || {}, { url: this.getUrl() }));\n\t    };\n\t\n\t    return Request;\n\t}();\n\t\n\t/**\n\t * Service for sending network requests.\n\t */\n\t\n\tvar CUSTOM_HEADERS = { 'X-Requested-With': 'XMLHttpRequest' };\n\tvar COMMON_HEADERS = { 'Accept': 'application/json, text/plain, */*' };\n\tvar JSON_CONTENT_TYPE = { 'Content-Type': 'application/json;charset=utf-8' };\n\t\n\tfunction Http(options) {\n\t\n\t    var self = this || {},\n\t        client = Client(self.$vm);\n\t\n\t    defaults(options || {}, self.$options, Http.options);\n\t\n\t    Http.interceptors.forEach(function (handler) {\n\t        client.use(handler);\n\t    });\n\t\n\t    return client(new Request(options)).then(function (response) {\n\t\n\t        return response.ok ? response : Promise$1.reject(response);\n\t    }, function (response) {\n\t\n\t        if (response instanceof Error) {\n\t            error(response);\n\t        }\n\t\n\t        return Promise$1.reject(response);\n\t    });\n\t}\n\t\n\tHttp.options = {};\n\t\n\tHttp.headers = {\n\t    put: JSON_CONTENT_TYPE,\n\t    post: JSON_CONTENT_TYPE,\n\t    patch: JSON_CONTENT_TYPE,\n\t    delete: JSON_CONTENT_TYPE,\n\t    custom: CUSTOM_HEADERS,\n\t    common: COMMON_HEADERS\n\t};\n\t\n\tHttp.interceptors = [before, timeout, method, body, jsonp, header, cors];\n\t\n\t['get', 'delete', 'head', 'jsonp'].forEach(function (method) {\n\t\n\t    Http[method] = function (url, options) {\n\t        return this(assign(options || {}, { url: url, method: method }));\n\t    };\n\t});\n\t\n\t['post', 'put', 'patch'].forEach(function (method) {\n\t\n\t    Http[method] = function (url, body, options) {\n\t        return this(assign(options || {}, { url: url, method: method, body: body }));\n\t    };\n\t});\n\t\n\tfunction Resource(url, params, actions, options) {\n\t\n\t    var self = this || {},\n\t        resource = {};\n\t\n\t    actions = assign({}, Resource.actions, actions);\n\t\n\t    each(actions, function (action, name) {\n\t\n\t        action = merge({ url: url, params: params || {} }, options, action);\n\t\n\t        resource[name] = function () {\n\t            return (self.$http || Http)(opts(action, arguments));\n\t        };\n\t    });\n\t\n\t    return resource;\n\t}\n\t\n\tfunction opts(action, args) {\n\t\n\t    var options = assign({}, action),\n\t        params = {},\n\t        body;\n\t\n\t    switch (args.length) {\n\t\n\t        case 2:\n\t\n\t            params = args[0];\n\t            body = args[1];\n\t\n\t            break;\n\t\n\t        case 1:\n\t\n\t            if (/^(POST|PUT|PATCH)$/i.test(options.method)) {\n\t                body = args[0];\n\t            } else {\n\t                params = args[0];\n\t            }\n\t\n\t            break;\n\t\n\t        case 0:\n\t\n\t            break;\n\t\n\t        default:\n\t\n\t            throw 'Expected up to 4 arguments [params, body], got ' + args.length + ' arguments';\n\t    }\n\t\n\t    options.body = body;\n\t    options.params = assign({}, options.params, params);\n\t\n\t    return options;\n\t}\n\t\n\tResource.actions = {\n\t\n\t    get: { method: 'GET' },\n\t    save: { method: 'POST' },\n\t    query: { method: 'GET' },\n\t    update: { method: 'PUT' },\n\t    remove: { method: 'DELETE' },\n\t    delete: { method: 'DELETE' }\n\t\n\t};\n\t\n\tfunction plugin(Vue) {\n\t\n\t    if (plugin.installed) {\n\t        return;\n\t    }\n\t\n\t    Util(Vue);\n\t\n\t    Vue.url = Url;\n\t    Vue.http = Http;\n\t    Vue.resource = Resource;\n\t    Vue.Promise = Promise$1;\n\t\n\t    Object.defineProperties(Vue.prototype, {\n\t\n\t        $url: {\n\t            get: function () {\n\t                return options(Vue.url, this, this.$options.url);\n\t            }\n\t        },\n\t\n\t        $http: {\n\t            get: function () {\n\t                return options(Vue.http, this, this.$options.http);\n\t            }\n\t        },\n\t\n\t        $resource: {\n\t            get: function () {\n\t                return Vue.resource.bind(this);\n\t            }\n\t        },\n\t\n\t        $promise: {\n\t            get: function () {\n\t                var _this = this;\n\t\n\t                return function (executor) {\n\t                    return new Vue.Promise(executor, _this);\n\t                };\n\t            }\n\t        }\n\t\n\t    });\n\t}\n\t\n\tif (typeof window !== 'undefined' && window.Vue) {\n\t    window.Vue.use(plugin);\n\t}\n\t\n\tmodule.exports = plugin;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/*!\n\t * Vue.js v1.0.25\n\t * (c) 2016 Evan You\n\t * Released under the MIT License.\n\t */\n\t'use strict';\n\t\n\tfunction set(obj, key, val) {\n\t  if (hasOwn(obj, key)) {\n\t    obj[key] = val;\n\t    return;\n\t  }\n\t  if (obj._isVue) {\n\t    set(obj._data, key, val);\n\t    return;\n\t  }\n\t  var ob = obj.__ob__;\n\t  if (!ob) {\n\t    obj[key] = val;\n\t    return;\n\t  }\n\t  ob.convert(key, val);\n\t  ob.dep.notify();\n\t  if (ob.vms) {\n\t    var i = ob.vms.length;\n\t    while (i--) {\n\t      var vm = ob.vms[i];\n\t      vm._proxy(key);\n\t      vm._digest();\n\t    }\n\t  }\n\t  return val;\n\t}\n\t\n\t/**\n\t * Delete a property and trigger change if necessary.\n\t *\n\t * @param {Object} obj\n\t * @param {String} key\n\t */\n\t\n\tfunction del(obj, key) {\n\t  if (!hasOwn(obj, key)) {\n\t    return;\n\t  }\n\t  delete obj[key];\n\t  var ob = obj.__ob__;\n\t  if (!ob) {\n\t    if (obj._isVue) {\n\t      delete obj._data[key];\n\t      obj._digest();\n\t    }\n\t    return;\n\t  }\n\t  ob.dep.notify();\n\t  if (ob.vms) {\n\t    var i = ob.vms.length;\n\t    while (i--) {\n\t      var vm = ob.vms[i];\n\t      vm._unproxy(key);\n\t      vm._digest();\n\t    }\n\t  }\n\t}\n\t\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\t/**\n\t * Check whether the object has the property.\n\t *\n\t * @param {Object} obj\n\t * @param {String} key\n\t * @return {Boolean}\n\t */\n\t\n\tfunction hasOwn(obj, key) {\n\t  return hasOwnProperty.call(obj, key);\n\t}\n\t\n\t/**\n\t * Check if an expression is a literal value.\n\t *\n\t * @param {String} exp\n\t * @return {Boolean}\n\t */\n\t\n\tvar literalValueRE = /^\\s?(true|false|-?[\\d\\.]+|'[^']*'|\"[^\"]*\")\\s?$/;\n\t\n\tfunction isLiteral(exp) {\n\t  return literalValueRE.test(exp);\n\t}\n\t\n\t/**\n\t * Check if a string starts with $ or _\n\t *\n\t * @param {String} str\n\t * @return {Boolean}\n\t */\n\t\n\tfunction isReserved(str) {\n\t  var c = (str + '').charCodeAt(0);\n\t  return c === 0x24 || c === 0x5F;\n\t}\n\t\n\t/**\n\t * Guard text output, make sure undefined outputs\n\t * empty string\n\t *\n\t * @param {*} value\n\t * @return {String}\n\t */\n\t\n\tfunction _toString(value) {\n\t  return value == null ? '' : value.toString();\n\t}\n\t\n\t/**\n\t * Check and convert possible numeric strings to numbers\n\t * before setting back to data\n\t *\n\t * @param {*} value\n\t * @return {*|Number}\n\t */\n\t\n\tfunction toNumber(value) {\n\t  if (typeof value !== 'string') {\n\t    return value;\n\t  } else {\n\t    var parsed = Number(value);\n\t    return isNaN(parsed) ? value : parsed;\n\t  }\n\t}\n\t\n\t/**\n\t * Convert string boolean literals into real booleans.\n\t *\n\t * @param {*} value\n\t * @return {*|Boolean}\n\t */\n\t\n\tfunction toBoolean(value) {\n\t  return value === 'true' ? true : value === 'false' ? false : value;\n\t}\n\t\n\t/**\n\t * Strip quotes from a string\n\t *\n\t * @param {String} str\n\t * @return {String | false}\n\t */\n\t\n\tfunction stripQuotes(str) {\n\t  var a = str.charCodeAt(0);\n\t  var b = str.charCodeAt(str.length - 1);\n\t  return a === b && (a === 0x22 || a === 0x27) ? str.slice(1, -1) : str;\n\t}\n\t\n\t/**\n\t * Camelize a hyphen-delmited string.\n\t *\n\t * @param {String} str\n\t * @return {String}\n\t */\n\t\n\tvar camelizeRE = /-(\\w)/g;\n\t\n\tfunction camelize(str) {\n\t  return str.replace(camelizeRE, toUpper);\n\t}\n\t\n\tfunction toUpper(_, c) {\n\t  return c ? c.toUpperCase() : '';\n\t}\n\t\n\t/**\n\t * Hyphenate a camelCase string.\n\t *\n\t * @param {String} str\n\t * @return {String}\n\t */\n\t\n\tvar hyphenateRE = /([a-z\\d])([A-Z])/g;\n\t\n\tfunction hyphenate(str) {\n\t  return str.replace(hyphenateRE, '$1-$2').toLowerCase();\n\t}\n\t\n\t/**\n\t * Converts hyphen/underscore/slash delimitered names into\n\t * camelized classNames.\n\t *\n\t * e.g. my-component => MyComponent\n\t *      some_else    => SomeElse\n\t *      some/comp    => SomeComp\n\t *\n\t * @param {String} str\n\t * @return {String}\n\t */\n\t\n\tvar classifyRE = /(?:^|[-_\\/])(\\w)/g;\n\t\n\tfunction classify(str) {\n\t  return str.replace(classifyRE, toUpper);\n\t}\n\t\n\t/**\n\t * Simple bind, faster than native\n\t *\n\t * @param {Function} fn\n\t * @param {Object} ctx\n\t * @return {Function}\n\t */\n\t\n\tfunction bind(fn, ctx) {\n\t  return function (a) {\n\t    var l = arguments.length;\n\t    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);\n\t  };\n\t}\n\t\n\t/**\n\t * Convert an Array-like object to a real Array.\n\t *\n\t * @param {Array-like} list\n\t * @param {Number} [start] - start index\n\t * @return {Array}\n\t */\n\t\n\tfunction toArray(list, start) {\n\t  start = start || 0;\n\t  var i = list.length - start;\n\t  var ret = new Array(i);\n\t  while (i--) {\n\t    ret[i] = list[i + start];\n\t  }\n\t  return ret;\n\t}\n\t\n\t/**\n\t * Mix properties into target object.\n\t *\n\t * @param {Object} to\n\t * @param {Object} from\n\t */\n\t\n\tfunction extend(to, from) {\n\t  var keys = Object.keys(from);\n\t  var i = keys.length;\n\t  while (i--) {\n\t    to[keys[i]] = from[keys[i]];\n\t  }\n\t  return to;\n\t}\n\t\n\t/**\n\t * Quick object check - this is primarily used to tell\n\t * Objects from primitive values when we know the value\n\t * is a JSON-compliant type.\n\t *\n\t * @param {*} obj\n\t * @return {Boolean}\n\t */\n\t\n\tfunction isObject(obj) {\n\t  return obj !== null && typeof obj === 'object';\n\t}\n\t\n\t/**\n\t * Strict object type check. Only returns true\n\t * for plain JavaScript objects.\n\t *\n\t * @param {*} obj\n\t * @return {Boolean}\n\t */\n\t\n\tvar toString = Object.prototype.toString;\n\tvar OBJECT_STRING = '[object Object]';\n\t\n\tfunction isPlainObject(obj) {\n\t  return toString.call(obj) === OBJECT_STRING;\n\t}\n\t\n\t/**\n\t * Array type check.\n\t *\n\t * @param {*} obj\n\t * @return {Boolean}\n\t */\n\t\n\tvar isArray = Array.isArray;\n\t\n\t/**\n\t * Define a property.\n\t *\n\t * @param {Object} obj\n\t * @param {String} key\n\t * @param {*} val\n\t * @param {Boolean} [enumerable]\n\t */\n\t\n\tfunction def(obj, key, val, enumerable) {\n\t  Object.defineProperty(obj, key, {\n\t    value: val,\n\t    enumerable: !!enumerable,\n\t    writable: true,\n\t    configurable: true\n\t  });\n\t}\n\t\n\t/**\n\t * Debounce a function so it only gets called after the\n\t * input stops arriving after the given wait period.\n\t *\n\t * @param {Function} func\n\t * @param {Number} wait\n\t * @return {Function} - the debounced function\n\t */\n\t\n\tfunction _debounce(func, wait) {\n\t  var timeout, args, context, timestamp, result;\n\t  var later = function later() {\n\t    var last = Date.now() - timestamp;\n\t    if (last < wait && last >= 0) {\n\t      timeout = setTimeout(later, wait - last);\n\t    } else {\n\t      timeout = null;\n\t      result = func.apply(context, args);\n\t      if (!timeout) context = args = null;\n\t    }\n\t  };\n\t  return function () {\n\t    context = this;\n\t    args = arguments;\n\t    timestamp = Date.now();\n\t    if (!timeout) {\n\t      timeout = setTimeout(later, wait);\n\t    }\n\t    return result;\n\t  };\n\t}\n\t\n\t/**\n\t * Manual indexOf because it's slightly faster than\n\t * native.\n\t *\n\t * @param {Array} arr\n\t * @param {*} obj\n\t */\n\t\n\tfunction indexOf(arr, obj) {\n\t  var i = arr.length;\n\t  while (i--) {\n\t    if (arr[i] === obj) return i;\n\t  }\n\t  return -1;\n\t}\n\t\n\t/**\n\t * Make a cancellable version of an async callback.\n\t *\n\t * @param {Function} fn\n\t * @return {Function}\n\t */\n\t\n\tfunction cancellable(fn) {\n\t  var cb = function cb() {\n\t    if (!cb.cancelled) {\n\t      return fn.apply(this, arguments);\n\t    }\n\t  };\n\t  cb.cancel = function () {\n\t    cb.cancelled = true;\n\t  };\n\t  return cb;\n\t}\n\t\n\t/**\n\t * Check if two values are loosely equal - that is,\n\t * if they are plain objects, do they have the same shape?\n\t *\n\t * @param {*} a\n\t * @param {*} b\n\t * @return {Boolean}\n\t */\n\t\n\tfunction looseEqual(a, b) {\n\t  /* eslint-disable eqeqeq */\n\t  return a == b || (isObject(a) && isObject(b) ? JSON.stringify(a) === JSON.stringify(b) : false);\n\t  /* eslint-enable eqeqeq */\n\t}\n\t\n\tvar hasProto = ('__proto__' in {});\n\t\n\t// Browser environment sniffing\n\tvar inBrowser = typeof window !== 'undefined' && Object.prototype.toString.call(window) !== '[object Object]';\n\t\n\t// detect devtools\n\tvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\t\n\t// UA sniffing for working around browser-specific quirks\n\tvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\n\tvar isIE = UA && UA.indexOf('trident') > 0;\n\tvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\n\tvar isAndroid = UA && UA.indexOf('android') > 0;\n\tvar isIos = UA && /(iphone|ipad|ipod|ios)/i.test(UA);\n\tvar iosVersionMatch = isIos && UA.match(/os ([\\d_]+)/);\n\tvar iosVersion = iosVersionMatch && iosVersionMatch[1].split('_');\n\t\n\t// detecting iOS UIWebView by indexedDB\n\tvar hasMutationObserverBug = iosVersion && Number(iosVersion[0]) >= 9 && Number(iosVersion[1]) >= 3 && !window.indexedDB;\n\t\n\tvar transitionProp = undefined;\n\tvar transitionEndEvent = undefined;\n\tvar animationProp = undefined;\n\tvar animationEndEvent = undefined;\n\t\n\t// Transition property/event sniffing\n\tif (inBrowser && !isIE9) {\n\t  var isWebkitTrans = window.ontransitionend === undefined && window.onwebkittransitionend !== undefined;\n\t  var isWebkitAnim = window.onanimationend === undefined && window.onwebkitanimationend !== undefined;\n\t  transitionProp = isWebkitTrans ? 'WebkitTransition' : 'transition';\n\t  transitionEndEvent = isWebkitTrans ? 'webkitTransitionEnd' : 'transitionend';\n\t  animationProp = isWebkitAnim ? 'WebkitAnimation' : 'animation';\n\t  animationEndEvent = isWebkitAnim ? 'webkitAnimationEnd' : 'animationend';\n\t}\n\t\n\t/**\n\t * Defer a task to execute it asynchronously. Ideally this\n\t * should be executed as a microtask, so we leverage\n\t * MutationObserver if it's available, and fallback to\n\t * setTimeout(0).\n\t *\n\t * @param {Function} cb\n\t * @param {Object} ctx\n\t */\n\t\n\tvar nextTick = (function () {\n\t  var callbacks = [];\n\t  var pending = false;\n\t  var timerFunc;\n\t  function nextTickHandler() {\n\t    pending = false;\n\t    var copies = callbacks.slice(0);\n\t    callbacks = [];\n\t    for (var i = 0; i < copies.length; i++) {\n\t      copies[i]();\n\t    }\n\t  }\n\t\n\t  /* istanbul ignore if */\n\t  if (typeof MutationObserver !== 'undefined' && !hasMutationObserverBug) {\n\t    var counter = 1;\n\t    var observer = new MutationObserver(nextTickHandler);\n\t    var textNode = document.createTextNode(counter);\n\t    observer.observe(textNode, {\n\t      characterData: true\n\t    });\n\t    timerFunc = function () {\n\t      counter = (counter + 1) % 2;\n\t      textNode.data = counter;\n\t    };\n\t  } else {\n\t    // webpack attempts to inject a shim for setImmediate\n\t    // if it is used as a global, so we have to work around that to\n\t    // avoid bundling unnecessary code.\n\t    var context = inBrowser ? window : typeof global !== 'undefined' ? global : {};\n\t    timerFunc = context.setImmediate || setTimeout;\n\t  }\n\t  return function (cb, ctx) {\n\t    var func = ctx ? function () {\n\t      cb.call(ctx);\n\t    } : cb;\n\t    callbacks.push(func);\n\t    if (pending) return;\n\t    pending = true;\n\t    timerFunc(nextTickHandler, 0);\n\t  };\n\t})();\n\t\n\tvar _Set = undefined;\n\t/* istanbul ignore if */\n\tif (typeof Set !== 'undefined' && Set.toString().match(/native code/)) {\n\t  // use native Set when available.\n\t  _Set = Set;\n\t} else {\n\t  // a non-standard Set polyfill that only works with primitive keys.\n\t  _Set = function () {\n\t    this.set = Object.create(null);\n\t  };\n\t  _Set.prototype.has = function (key) {\n\t    return this.set[key] !== undefined;\n\t  };\n\t  _Set.prototype.add = function (key) {\n\t    this.set[key] = 1;\n\t  };\n\t  _Set.prototype.clear = function () {\n\t    this.set = Object.create(null);\n\t  };\n\t}\n\t\n\tfunction Cache(limit) {\n\t  this.size = 0;\n\t  this.limit = limit;\n\t  this.head = this.tail = undefined;\n\t  this._keymap = Object.create(null);\n\t}\n\t\n\tvar p = Cache.prototype;\n\t\n\t/**\n\t * Put <value> into the cache associated with <key>.\n\t * Returns the entry which was removed to make room for\n\t * the new entry. Otherwise undefined is returned.\n\t * (i.e. if there was enough room already).\n\t *\n\t * @param {String} key\n\t * @param {*} value\n\t * @return {Entry|undefined}\n\t */\n\t\n\tp.put = function (key, value) {\n\t  var removed;\n\t\n\t  var entry = this.get(key, true);\n\t  if (!entry) {\n\t    if (this.size === this.limit) {\n\t      removed = this.shift();\n\t    }\n\t    entry = {\n\t      key: key\n\t    };\n\t    this._keymap[key] = entry;\n\t    if (this.tail) {\n\t      this.tail.newer = entry;\n\t      entry.older = this.tail;\n\t    } else {\n\t      this.head = entry;\n\t    }\n\t    this.tail = entry;\n\t    this.size++;\n\t  }\n\t  entry.value = value;\n\t\n\t  return removed;\n\t};\n\t\n\t/**\n\t * Purge the least recently used (oldest) entry from the\n\t * cache. Returns the removed entry or undefined if the\n\t * cache was empty.\n\t */\n\t\n\tp.shift = function () {\n\t  var entry = this.head;\n\t  if (entry) {\n\t    this.head = this.head.newer;\n\t    this.head.older = undefined;\n\t    entry.newer = entry.older = undefined;\n\t    this._keymap[entry.key] = undefined;\n\t    this.size--;\n\t  }\n\t  return entry;\n\t};\n\t\n\t/**\n\t * Get and register recent use of <key>. Returns the value\n\t * associated with <key> or undefined if not in cache.\n\t *\n\t * @param {String} key\n\t * @param {Boolean} returnEntry\n\t * @return {Entry|*}\n\t */\n\t\n\tp.get = function (key, returnEntry) {\n\t  var entry = this._keymap[key];\n\t  if (entry === undefined) return;\n\t  if (entry === this.tail) {\n\t    return returnEntry ? entry : entry.value;\n\t  }\n\t  // HEAD--------------TAIL\n\t  //   <.older   .newer>\n\t  //  <--- add direction --\n\t  //   A  B  C  <D>  E\n\t  if (entry.newer) {\n\t    if (entry === this.head) {\n\t      this.head = entry.newer;\n\t    }\n\t    entry.newer.older = entry.older; // C <-- E.\n\t  }\n\t  if (entry.older) {\n\t    entry.older.newer = entry.newer; // C. --> E\n\t  }\n\t  entry.newer = undefined; // D --x\n\t  entry.older = this.tail; // D. --> E\n\t  if (this.tail) {\n\t    this.tail.newer = entry; // E. <-- D\n\t  }\n\t  this.tail = entry;\n\t  return returnEntry ? entry : entry.value;\n\t};\n\t\n\tvar cache$1 = new Cache(1000);\n\tvar filterTokenRE = /[^\\s'\"]+|'[^']*'|\"[^\"]*\"/g;\n\tvar reservedArgRE = /^in$|^-?\\d+/;\n\t\n\t/**\n\t * Parser state\n\t */\n\t\n\tvar str;\n\tvar dir;\n\tvar c;\n\tvar prev;\n\tvar i;\n\tvar l;\n\tvar lastFilterIndex;\n\tvar inSingle;\n\tvar inDouble;\n\tvar curly;\n\tvar square;\n\tvar paren;\n\t/**\n\t * Push a filter to the current directive object\n\t */\n\t\n\tfunction pushFilter() {\n\t  var exp = str.slice(lastFilterIndex, i).trim();\n\t  var filter;\n\t  if (exp) {\n\t    filter = {};\n\t    var tokens = exp.match(filterTokenRE);\n\t    filter.name = tokens[0];\n\t    if (tokens.length > 1) {\n\t      filter.args = tokens.slice(1).map(processFilterArg);\n\t    }\n\t  }\n\t  if (filter) {\n\t    (dir.filters = dir.filters || []).push(filter);\n\t  }\n\t  lastFilterIndex = i + 1;\n\t}\n\t\n\t/**\n\t * Check if an argument is dynamic and strip quotes.\n\t *\n\t * @param {String} arg\n\t * @return {Object}\n\t */\n\t\n\tfunction processFilterArg(arg) {\n\t  if (reservedArgRE.test(arg)) {\n\t    return {\n\t      value: toNumber(arg),\n\t      dynamic: false\n\t    };\n\t  } else {\n\t    var stripped = stripQuotes(arg);\n\t    var dynamic = stripped === arg;\n\t    return {\n\t      value: dynamic ? arg : stripped,\n\t      dynamic: dynamic\n\t    };\n\t  }\n\t}\n\t\n\t/**\n\t * Parse a directive value and extract the expression\n\t * and its filters into a descriptor.\n\t *\n\t * Example:\n\t *\n\t * \"a + 1 | uppercase\" will yield:\n\t * {\n\t *   expression: 'a + 1',\n\t *   filters: [\n\t *     { name: 'uppercase', args: null }\n\t *   ]\n\t * }\n\t *\n\t * @param {String} s\n\t * @return {Object}\n\t */\n\t\n\tfunction parseDirective(s) {\n\t  var hit = cache$1.get(s);\n\t  if (hit) {\n\t    return hit;\n\t  }\n\t\n\t  // reset parser state\n\t  str = s;\n\t  inSingle = inDouble = false;\n\t  curly = square = paren = 0;\n\t  lastFilterIndex = 0;\n\t  dir = {};\n\t\n\t  for (i = 0, l = str.length; i < l; i++) {\n\t    prev = c;\n\t    c = str.charCodeAt(i);\n\t    if (inSingle) {\n\t      // check single quote\n\t      if (c === 0x27 && prev !== 0x5C) inSingle = !inSingle;\n\t    } else if (inDouble) {\n\t      // check double quote\n\t      if (c === 0x22 && prev !== 0x5C) inDouble = !inDouble;\n\t    } else if (c === 0x7C && // pipe\n\t    str.charCodeAt(i + 1) !== 0x7C && str.charCodeAt(i - 1) !== 0x7C) {\n\t      if (dir.expression == null) {\n\t        // first filter, end of expression\n\t        lastFilterIndex = i + 1;\n\t        dir.expression = str.slice(0, i).trim();\n\t      } else {\n\t        // already has filter\n\t        pushFilter();\n\t      }\n\t    } else {\n\t      switch (c) {\n\t        case 0x22:\n\t          inDouble = true;break; // \"\n\t        case 0x27:\n\t          inSingle = true;break; // '\n\t        case 0x28:\n\t          paren++;break; // (\n\t        case 0x29:\n\t          paren--;break; // )\n\t        case 0x5B:\n\t          square++;break; // [\n\t        case 0x5D:\n\t          square--;break; // ]\n\t        case 0x7B:\n\t          curly++;break; // {\n\t        case 0x7D:\n\t          curly--;break; // }\n\t      }\n\t    }\n\t  }\n\t\n\t  if (dir.expression == null) {\n\t    dir.expression = str.slice(0, i).trim();\n\t  } else if (lastFilterIndex !== 0) {\n\t    pushFilter();\n\t  }\n\t\n\t  cache$1.put(s, dir);\n\t  return dir;\n\t}\n\t\n\tvar directive = Object.freeze({\n\t  parseDirective: parseDirective\n\t});\n\t\n\tvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\tvar cache = undefined;\n\tvar tagRE = undefined;\n\tvar htmlRE = undefined;\n\t/**\n\t * Escape a string so it can be used in a RegExp\n\t * constructor.\n\t *\n\t * @param {String} str\n\t */\n\t\n\tfunction escapeRegex(str) {\n\t  return str.replace(regexEscapeRE, '\\\\$&');\n\t}\n\t\n\tfunction compileRegex() {\n\t  var open = escapeRegex(config.delimiters[0]);\n\t  var close = escapeRegex(config.delimiters[1]);\n\t  var unsafeOpen = escapeRegex(config.unsafeDelimiters[0]);\n\t  var unsafeClose = escapeRegex(config.unsafeDelimiters[1]);\n\t  tagRE = new RegExp(unsafeOpen + '((?:.|\\\\n)+?)' + unsafeClose + '|' + open + '((?:.|\\\\n)+?)' + close, 'g');\n\t  htmlRE = new RegExp('^' + unsafeOpen + '((?:.|\\\\n)+?)' + unsafeClose + '$');\n\t  // reset cache\n\t  cache = new Cache(1000);\n\t}\n\t\n\t/**\n\t * Parse a template text string into an array of tokens.\n\t *\n\t * @param {String} text\n\t * @return {Array<Object> | null}\n\t *               - {String} type\n\t *               - {String} value\n\t *               - {Boolean} [html]\n\t *               - {Boolean} [oneTime]\n\t */\n\t\n\tfunction parseText(text) {\n\t  if (!cache) {\n\t    compileRegex();\n\t  }\n\t  var hit = cache.get(text);\n\t  if (hit) {\n\t    return hit;\n\t  }\n\t  if (!tagRE.test(text)) {\n\t    return null;\n\t  }\n\t  var tokens = [];\n\t  var lastIndex = tagRE.lastIndex = 0;\n\t  var match, index, html, value, first, oneTime;\n\t  /* eslint-disable no-cond-assign */\n\t  while (match = tagRE.exec(text)) {\n\t    /* eslint-enable no-cond-assign */\n\t    index = match.index;\n\t    // push text token\n\t    if (index > lastIndex) {\n\t      tokens.push({\n\t        value: text.slice(lastIndex, index)\n\t      });\n\t    }\n\t    // tag token\n\t    html = htmlRE.test(match[0]);\n\t    value = html ? match[1] : match[2];\n\t    first = value.charCodeAt(0);\n\t    oneTime = first === 42; // *\n\t    value = oneTime ? value.slice(1) : value;\n\t    tokens.push({\n\t      tag: true,\n\t      value: value.trim(),\n\t      html: html,\n\t      oneTime: oneTime\n\t    });\n\t    lastIndex = index + match[0].length;\n\t  }\n\t  if (lastIndex < text.length) {\n\t    tokens.push({\n\t      value: text.slice(lastIndex)\n\t    });\n\t  }\n\t  cache.put(text, tokens);\n\t  return tokens;\n\t}\n\t\n\t/**\n\t * Format a list of tokens into an expression.\n\t * e.g. tokens parsed from 'a {{b}} c' can be serialized\n\t * into one single expression as '\"a \" + b + \" c\"'.\n\t *\n\t * @param {Array} tokens\n\t * @param {Vue} [vm]\n\t * @return {String}\n\t */\n\t\n\tfunction tokensToExp(tokens, vm) {\n\t  if (tokens.length > 1) {\n\t    return tokens.map(function (token) {\n\t      return formatToken(token, vm);\n\t    }).join('+');\n\t  } else {\n\t    return formatToken(tokens[0], vm, true);\n\t  }\n\t}\n\t\n\t/**\n\t * Format a single token.\n\t *\n\t * @param {Object} token\n\t * @param {Vue} [vm]\n\t * @param {Boolean} [single]\n\t * @return {String}\n\t */\n\t\n\tfunction formatToken(token, vm, single) {\n\t  return token.tag ? token.oneTime && vm ? '\"' + vm.$eval(token.value) + '\"' : inlineFilters(token.value, single) : '\"' + token.value + '\"';\n\t}\n\t\n\t/**\n\t * For an attribute with multiple interpolation tags,\n\t * e.g. attr=\"some-{{thing | filter}}\", in order to combine\n\t * the whole thing into a single watchable expression, we\n\t * have to inline those filters. This function does exactly\n\t * that. This is a bit hacky but it avoids heavy changes\n\t * to directive parser and watcher mechanism.\n\t *\n\t * @param {String} exp\n\t * @param {Boolean} single\n\t * @return {String}\n\t */\n\t\n\tvar filterRE = /[^|]\\|[^|]/;\n\tfunction inlineFilters(exp, single) {\n\t  if (!filterRE.test(exp)) {\n\t    return single ? exp : '(' + exp + ')';\n\t  } else {\n\t    var dir = parseDirective(exp);\n\t    if (!dir.filters) {\n\t      return '(' + exp + ')';\n\t    } else {\n\t      return 'this._applyFilters(' + dir.expression + // value\n\t      ',null,' + // oldValue (null for read)\n\t      JSON.stringify(dir.filters) + // filter descriptors\n\t      ',false)'; // write?\n\t    }\n\t  }\n\t}\n\t\n\tvar text = Object.freeze({\n\t  compileRegex: compileRegex,\n\t  parseText: parseText,\n\t  tokensToExp: tokensToExp\n\t});\n\t\n\tvar delimiters = ['{{', '}}'];\n\tvar unsafeDelimiters = ['{{{', '}}}'];\n\t\n\tvar config = Object.defineProperties({\n\t\n\t  /**\n\t   * Whether to print debug messages.\n\t   * Also enables stack trace for warnings.\n\t   *\n\t   * @type {Boolean}\n\t   */\n\t\n\t  debug: false,\n\t\n\t  /**\n\t   * Whether to suppress warnings.\n\t   *\n\t   * @type {Boolean}\n\t   */\n\t\n\t  silent: false,\n\t\n\t  /**\n\t   * Whether to use async rendering.\n\t   */\n\t\n\t  async: true,\n\t\n\t  /**\n\t   * Whether to warn against errors caught when evaluating\n\t   * expressions.\n\t   */\n\t\n\t  warnExpressionErrors: true,\n\t\n\t  /**\n\t   * Whether to allow devtools inspection.\n\t   * Disabled by default in production builds.\n\t   */\n\t\n\t  devtools: (\"production\") !== 'production',\n\t\n\t  /**\n\t   * Internal flag to indicate the delimiters have been\n\t   * changed.\n\t   *\n\t   * @type {Boolean}\n\t   */\n\t\n\t  _delimitersChanged: true,\n\t\n\t  /**\n\t   * List of asset types that a component can own.\n\t   *\n\t   * @type {Array}\n\t   */\n\t\n\t  _assetTypes: ['component', 'directive', 'elementDirective', 'filter', 'transition', 'partial'],\n\t\n\t  /**\n\t   * prop binding modes\n\t   */\n\t\n\t  _propBindingModes: {\n\t    ONE_WAY: 0,\n\t    TWO_WAY: 1,\n\t    ONE_TIME: 2\n\t  },\n\t\n\t  /**\n\t   * Max circular updates allowed in a batcher flush cycle.\n\t   */\n\t\n\t  _maxUpdateCount: 100\n\t\n\t}, {\n\t  delimiters: { /**\n\t                 * Interpolation delimiters. Changing these would trigger\n\t                 * the text parser to re-compile the regular expressions.\n\t                 *\n\t                 * @type {Array<String>}\n\t                 */\n\t\n\t    get: function get() {\n\t      return delimiters;\n\t    },\n\t    set: function set(val) {\n\t      delimiters = val;\n\t      compileRegex();\n\t    },\n\t    configurable: true,\n\t    enumerable: true\n\t  },\n\t  unsafeDelimiters: {\n\t    get: function get() {\n\t      return unsafeDelimiters;\n\t    },\n\t    set: function set(val) {\n\t      unsafeDelimiters = val;\n\t      compileRegex();\n\t    },\n\t    configurable: true,\n\t    enumerable: true\n\t  }\n\t});\n\t\n\tvar warn = undefined;\n\tvar formatComponentName = undefined;\n\t\n\tif (false) {\n\t  (function () {\n\t    var hasConsole = typeof console !== 'undefined';\n\t\n\t    warn = function (msg, vm) {\n\t      if (hasConsole && !config.silent) {\n\t        console.error('[Vue warn]: ' + msg + (vm ? formatComponentName(vm) : ''));\n\t      }\n\t    };\n\t\n\t    formatComponentName = function (vm) {\n\t      var name = vm._isVue ? vm.$options.name : vm.name;\n\t      return name ? ' (found in component: <' + hyphenate(name) + '>)' : '';\n\t    };\n\t  })();\n\t}\n\t\n\t/**\n\t * Append with transition.\n\t *\n\t * @param {Element} el\n\t * @param {Element} target\n\t * @param {Vue} vm\n\t * @param {Function} [cb]\n\t */\n\t\n\tfunction appendWithTransition(el, target, vm, cb) {\n\t  applyTransition(el, 1, function () {\n\t    target.appendChild(el);\n\t  }, vm, cb);\n\t}\n\t\n\t/**\n\t * InsertBefore with transition.\n\t *\n\t * @param {Element} el\n\t * @param {Element} target\n\t * @param {Vue} vm\n\t * @param {Function} [cb]\n\t */\n\t\n\tfunction beforeWithTransition(el, target, vm, cb) {\n\t  applyTransition(el, 1, function () {\n\t    before(el, target);\n\t  }, vm, cb);\n\t}\n\t\n\t/**\n\t * Remove with transition.\n\t *\n\t * @param {Element} el\n\t * @param {Vue} vm\n\t * @param {Function} [cb]\n\t */\n\t\n\tfunction removeWithTransition(el, vm, cb) {\n\t  applyTransition(el, -1, function () {\n\t    remove(el);\n\t  }, vm, cb);\n\t}\n\t\n\t/**\n\t * Apply transitions with an operation callback.\n\t *\n\t * @param {Element} el\n\t * @param {Number} direction\n\t *                  1: enter\n\t *                 -1: leave\n\t * @param {Function} op - the actual DOM operation\n\t * @param {Vue} vm\n\t * @param {Function} [cb]\n\t */\n\t\n\tfunction applyTransition(el, direction, op, vm, cb) {\n\t  var transition = el.__v_trans;\n\t  if (!transition ||\n\t  // skip if there are no js hooks and CSS transition is\n\t  // not supported\n\t  !transition.hooks && !transitionEndEvent ||\n\t  // skip transitions for initial compile\n\t  !vm._isCompiled ||\n\t  // if the vm is being manipulated by a parent directive\n\t  // during the parent's compilation phase, skip the\n\t  // animation.\n\t  vm.$parent && !vm.$parent._isCompiled) {\n\t    op();\n\t    if (cb) cb();\n\t    return;\n\t  }\n\t  var action = direction > 0 ? 'enter' : 'leave';\n\t  transition[action](op, cb);\n\t}\n\t\n\tvar transition = Object.freeze({\n\t  appendWithTransition: appendWithTransition,\n\t  beforeWithTransition: beforeWithTransition,\n\t  removeWithTransition: removeWithTransition,\n\t  applyTransition: applyTransition\n\t});\n\t\n\t/**\n\t * Query an element selector if it's not an element already.\n\t *\n\t * @param {String|Element} el\n\t * @return {Element}\n\t */\n\t\n\tfunction query(el) {\n\t  if (typeof el === 'string') {\n\t    var selector = el;\n\t    el = document.querySelector(el);\n\t    if (!el) {\n\t      (\"production\") !== 'production' && warn('Cannot find element: ' + selector);\n\t    }\n\t  }\n\t  return el;\n\t}\n\t\n\t/**\n\t * Check if a node is in the document.\n\t * Note: document.documentElement.contains should work here\n\t * but always returns false for comment nodes in phantomjs,\n\t * making unit tests difficult. This is fixed by doing the\n\t * contains() check on the node's parentNode instead of\n\t * the node itself.\n\t *\n\t * @param {Node} node\n\t * @return {Boolean}\n\t */\n\t\n\tfunction inDoc(node) {\n\t  if (!node) return false;\n\t  var doc = node.ownerDocument.documentElement;\n\t  var parent = node.parentNode;\n\t  return doc === node || doc === parent || !!(parent && parent.nodeType === 1 && doc.contains(parent));\n\t}\n\t\n\t/**\n\t * Get and remove an attribute from a node.\n\t *\n\t * @param {Node} node\n\t * @param {String} _attr\n\t */\n\t\n\tfunction getAttr(node, _attr) {\n\t  var val = node.getAttribute(_attr);\n\t  if (val !== null) {\n\t    node.removeAttribute(_attr);\n\t  }\n\t  return val;\n\t}\n\t\n\t/**\n\t * Get an attribute with colon or v-bind: prefix.\n\t *\n\t * @param {Node} node\n\t * @param {String} name\n\t * @return {String|null}\n\t */\n\t\n\tfunction getBindAttr(node, name) {\n\t  var val = getAttr(node, ':' + name);\n\t  if (val === null) {\n\t    val = getAttr(node, 'v-bind:' + name);\n\t  }\n\t  return val;\n\t}\n\t\n\t/**\n\t * Check the presence of a bind attribute.\n\t *\n\t * @param {Node} node\n\t * @param {String} name\n\t * @return {Boolean}\n\t */\n\t\n\tfunction hasBindAttr(node, name) {\n\t  return node.hasAttribute(name) || node.hasAttribute(':' + name) || node.hasAttribute('v-bind:' + name);\n\t}\n\t\n\t/**\n\t * Insert el before target\n\t *\n\t * @param {Element} el\n\t * @param {Element} target\n\t */\n\t\n\tfunction before(el, target) {\n\t  target.parentNode.insertBefore(el, target);\n\t}\n\t\n\t/**\n\t * Insert el after target\n\t *\n\t * @param {Element} el\n\t * @param {Element} target\n\t */\n\t\n\tfunction after(el, target) {\n\t  if (target.nextSibling) {\n\t    before(el, target.nextSibling);\n\t  } else {\n\t    target.parentNode.appendChild(el);\n\t  }\n\t}\n\t\n\t/**\n\t * Remove el from DOM\n\t *\n\t * @param {Element} el\n\t */\n\t\n\tfunction remove(el) {\n\t  el.parentNode.removeChild(el);\n\t}\n\t\n\t/**\n\t * Prepend el to target\n\t *\n\t * @param {Element} el\n\t * @param {Element} target\n\t */\n\t\n\tfunction prepend(el, target) {\n\t  if (target.firstChild) {\n\t    before(el, target.firstChild);\n\t  } else {\n\t    target.appendChild(el);\n\t  }\n\t}\n\t\n\t/**\n\t * Replace target with el\n\t *\n\t * @param {Element} target\n\t * @param {Element} el\n\t */\n\t\n\tfunction replace(target, el) {\n\t  var parent = target.parentNode;\n\t  if (parent) {\n\t    parent.replaceChild(el, target);\n\t  }\n\t}\n\t\n\t/**\n\t * Add event listener shorthand.\n\t *\n\t * @param {Element} el\n\t * @param {String} event\n\t * @param {Function} cb\n\t * @param {Boolean} [useCapture]\n\t */\n\t\n\tfunction on(el, event, cb, useCapture) {\n\t  el.addEventListener(event, cb, useCapture);\n\t}\n\t\n\t/**\n\t * Remove event listener shorthand.\n\t *\n\t * @param {Element} el\n\t * @param {String} event\n\t * @param {Function} cb\n\t */\n\t\n\tfunction off(el, event, cb) {\n\t  el.removeEventListener(event, cb);\n\t}\n\t\n\t/**\n\t * For IE9 compat: when both class and :class are present\n\t * getAttribute('class') returns wrong value...\n\t *\n\t * @param {Element} el\n\t * @return {String}\n\t */\n\t\n\tfunction getClass(el) {\n\t  var classname = el.className;\n\t  if (typeof classname === 'object') {\n\t    classname = classname.baseVal || '';\n\t  }\n\t  return classname;\n\t}\n\t\n\t/**\n\t * In IE9, setAttribute('class') will result in empty class\n\t * if the element also has the :class attribute; However in\n\t * PhantomJS, setting `className` does not work on SVG elements...\n\t * So we have to do a conditional check here.\n\t *\n\t * @param {Element} el\n\t * @param {String} cls\n\t */\n\t\n\tfunction setClass(el, cls) {\n\t  /* istanbul ignore if */\n\t  if (isIE9 && !/svg$/.test(el.namespaceURI)) {\n\t    el.className = cls;\n\t  } else {\n\t    el.setAttribute('class', cls);\n\t  }\n\t}\n\t\n\t/**\n\t * Add class with compatibility for IE & SVG\n\t *\n\t * @param {Element} el\n\t * @param {String} cls\n\t */\n\t\n\tfunction addClass(el, cls) {\n\t  if (el.classList) {\n\t    el.classList.add(cls);\n\t  } else {\n\t    var cur = ' ' + getClass(el) + ' ';\n\t    if (cur.indexOf(' ' + cls + ' ') < 0) {\n\t      setClass(el, (cur + cls).trim());\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Remove class with compatibility for IE & SVG\n\t *\n\t * @param {Element} el\n\t * @param {String} cls\n\t */\n\t\n\tfunction removeClass(el, cls) {\n\t  if (el.classList) {\n\t    el.classList.remove(cls);\n\t  } else {\n\t    var cur = ' ' + getClass(el) + ' ';\n\t    var tar = ' ' + cls + ' ';\n\t    while (cur.indexOf(tar) >= 0) {\n\t      cur = cur.replace(tar, ' ');\n\t    }\n\t    setClass(el, cur.trim());\n\t  }\n\t  if (!el.className) {\n\t    el.removeAttribute('class');\n\t  }\n\t}\n\t\n\t/**\n\t * Extract raw content inside an element into a temporary\n\t * container div\n\t *\n\t * @param {Element} el\n\t * @param {Boolean} asFragment\n\t * @return {Element|DocumentFragment}\n\t */\n\t\n\tfunction extractContent(el, asFragment) {\n\t  var child;\n\t  var rawContent;\n\t  /* istanbul ignore if */\n\t  if (isTemplate(el) && isFragment(el.content)) {\n\t    el = el.content;\n\t  }\n\t  if (el.hasChildNodes()) {\n\t    trimNode(el);\n\t    rawContent = asFragment ? document.createDocumentFragment() : document.createElement('div');\n\t    /* eslint-disable no-cond-assign */\n\t    while (child = el.firstChild) {\n\t      /* eslint-enable no-cond-assign */\n\t      rawContent.appendChild(child);\n\t    }\n\t  }\n\t  return rawContent;\n\t}\n\t\n\t/**\n\t * Trim possible empty head/tail text and comment\n\t * nodes inside a parent.\n\t *\n\t * @param {Node} node\n\t */\n\t\n\tfunction trimNode(node) {\n\t  var child;\n\t  /* eslint-disable no-sequences */\n\t  while ((child = node.firstChild, isTrimmable(child))) {\n\t    node.removeChild(child);\n\t  }\n\t  while ((child = node.lastChild, isTrimmable(child))) {\n\t    node.removeChild(child);\n\t  }\n\t  /* eslint-enable no-sequences */\n\t}\n\t\n\tfunction isTrimmable(node) {\n\t  return node && (node.nodeType === 3 && !node.data.trim() || node.nodeType === 8);\n\t}\n\t\n\t/**\n\t * Check if an element is a template tag.\n\t * Note if the template appears inside an SVG its tagName\n\t * will be in lowercase.\n\t *\n\t * @param {Element} el\n\t */\n\t\n\tfunction isTemplate(el) {\n\t  return el.tagName && el.tagName.toLowerCase() === 'template';\n\t}\n\t\n\t/**\n\t * Create an \"anchor\" for performing dom insertion/removals.\n\t * This is used in a number of scenarios:\n\t * - fragment instance\n\t * - v-html\n\t * - v-if\n\t * - v-for\n\t * - component\n\t *\n\t * @param {String} content\n\t * @param {Boolean} persist - IE trashes empty textNodes on\n\t *                            cloneNode(true), so in certain\n\t *                            cases the anchor needs to be\n\t *                            non-empty to be persisted in\n\t *                            templates.\n\t * @return {Comment|Text}\n\t */\n\t\n\tfunction createAnchor(content, persist) {\n\t  var anchor = config.debug ? document.createComment(content) : document.createTextNode(persist ? ' ' : '');\n\t  anchor.__v_anchor = true;\n\t  return anchor;\n\t}\n\t\n\t/**\n\t * Find a component ref attribute that starts with $.\n\t *\n\t * @param {Element} node\n\t * @return {String|undefined}\n\t */\n\t\n\tvar refRE = /^v-ref:/;\n\t\n\tfunction findRef(node) {\n\t  if (node.hasAttributes()) {\n\t    var attrs = node.attributes;\n\t    for (var i = 0, l = attrs.length; i < l; i++) {\n\t      var name = attrs[i].name;\n\t      if (refRE.test(name)) {\n\t        return camelize(name.replace(refRE, ''));\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Map a function to a range of nodes .\n\t *\n\t * @param {Node} node\n\t * @param {Node} end\n\t * @param {Function} op\n\t */\n\t\n\tfunction mapNodeRange(node, end, op) {\n\t  var next;\n\t  while (node !== end) {\n\t    next = node.nextSibling;\n\t    op(node);\n\t    node = next;\n\t  }\n\t  op(end);\n\t}\n\t\n\t/**\n\t * Remove a range of nodes with transition, store\n\t * the nodes in a fragment with correct ordering,\n\t * and call callback when done.\n\t *\n\t * @param {Node} start\n\t * @param {Node} end\n\t * @param {Vue} vm\n\t * @param {DocumentFragment} frag\n\t * @param {Function} cb\n\t */\n\t\n\tfunction removeNodeRange(start, end, vm, frag, cb) {\n\t  var done = false;\n\t  var removed = 0;\n\t  var nodes = [];\n\t  mapNodeRange(start, end, function (node) {\n\t    if (node === end) done = true;\n\t    nodes.push(node);\n\t    removeWithTransition(node, vm, onRemoved);\n\t  });\n\t  function onRemoved() {\n\t    removed++;\n\t    if (done && removed >= nodes.length) {\n\t      for (var i = 0; i < nodes.length; i++) {\n\t        frag.appendChild(nodes[i]);\n\t      }\n\t      cb && cb();\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Check if a node is a DocumentFragment.\n\t *\n\t * @param {Node} node\n\t * @return {Boolean}\n\t */\n\t\n\tfunction isFragment(node) {\n\t  return node && node.nodeType === 11;\n\t}\n\t\n\t/**\n\t * Get outerHTML of elements, taking care\n\t * of SVG elements in IE as well.\n\t *\n\t * @param {Element} el\n\t * @return {String}\n\t */\n\t\n\tfunction getOuterHTML(el) {\n\t  if (el.outerHTML) {\n\t    return el.outerHTML;\n\t  } else {\n\t    var container = document.createElement('div');\n\t    container.appendChild(el.cloneNode(true));\n\t    return container.innerHTML;\n\t  }\n\t}\n\t\n\tvar commonTagRE = /^(div|p|span|img|a|b|i|br|ul|ol|li|h1|h2|h3|h4|h5|h6|code|pre|table|th|td|tr|form|label|input|select|option|nav|article|section|header|footer)$/i;\n\tvar reservedTagRE = /^(slot|partial|component)$/i;\n\t\n\tvar isUnknownElement = undefined;\n\tif (false) {\n\t  isUnknownElement = function (el, tag) {\n\t    if (tag.indexOf('-') > -1) {\n\t      // http://stackoverflow.com/a/28210364/1070244\n\t      return el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;\n\t    } else {\n\t      return (/HTMLUnknownElement/.test(el.toString()) &&\n\t        // Chrome returns unknown for several HTML5 elements.\n\t        // https://code.google.com/p/chromium/issues/detail?id=540526\n\t        // Firefox returns unknown for some \"Interactive elements.\"\n\t        !/^(data|time|rtc|rb|details|dialog|summary)$/.test(tag)\n\t      );\n\t    }\n\t  };\n\t}\n\t\n\t/**\n\t * Check if an element is a component, if yes return its\n\t * component id.\n\t *\n\t * @param {Element} el\n\t * @param {Object} options\n\t * @return {Object|undefined}\n\t */\n\t\n\tfunction checkComponentAttr(el, options) {\n\t  var tag = el.tagName.toLowerCase();\n\t  var hasAttrs = el.hasAttributes();\n\t  if (!commonTagRE.test(tag) && !reservedTagRE.test(tag)) {\n\t    if (resolveAsset(options, 'components', tag)) {\n\t      return { id: tag };\n\t    } else {\n\t      var is = hasAttrs && getIsBinding(el, options);\n\t      if (is) {\n\t        return is;\n\t      } else if (false) {\n\t        var expectedTag = options._componentNameMap && options._componentNameMap[tag];\n\t        if (expectedTag) {\n\t          warn('Unknown custom element: <' + tag + '> - ' + 'did you mean <' + expectedTag + '>? ' + 'HTML is case-insensitive, remember to use kebab-case in templates.');\n\t        } else if (isUnknownElement(el, tag)) {\n\t          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the \"name\" option.');\n\t        }\n\t      }\n\t    }\n\t  } else if (hasAttrs) {\n\t    return getIsBinding(el, options);\n\t  }\n\t}\n\t\n\t/**\n\t * Get \"is\" binding from an element.\n\t *\n\t * @param {Element} el\n\t * @param {Object} options\n\t * @return {Object|undefined}\n\t */\n\t\n\tfunction getIsBinding(el, options) {\n\t  // dynamic syntax\n\t  var exp = el.getAttribute('is');\n\t  if (exp != null) {\n\t    if (resolveAsset(options, 'components', exp)) {\n\t      el.removeAttribute('is');\n\t      return { id: exp };\n\t    }\n\t  } else {\n\t    exp = getBindAttr(el, 'is');\n\t    if (exp != null) {\n\t      return { id: exp, dynamic: true };\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Option overwriting strategies are functions that handle\n\t * how to merge a parent option value and a child option\n\t * value into the final value.\n\t *\n\t * All strategy functions follow the same signature:\n\t *\n\t * @param {*} parentVal\n\t * @param {*} childVal\n\t * @param {Vue} [vm]\n\t */\n\t\n\tvar strats = config.optionMergeStrategies = Object.create(null);\n\t\n\t/**\n\t * Helper that recursively merges two data objects together.\n\t */\n\t\n\tfunction mergeData(to, from) {\n\t  var key, toVal, fromVal;\n\t  for (key in from) {\n\t    toVal = to[key];\n\t    fromVal = from[key];\n\t    if (!hasOwn(to, key)) {\n\t      set(to, key, fromVal);\n\t    } else if (isObject(toVal) && isObject(fromVal)) {\n\t      mergeData(toVal, fromVal);\n\t    }\n\t  }\n\t  return to;\n\t}\n\t\n\t/**\n\t * Data\n\t */\n\t\n\tstrats.data = function (parentVal, childVal, vm) {\n\t  if (!vm) {\n\t    // in a Vue.extend merge, both should be functions\n\t    if (!childVal) {\n\t      return parentVal;\n\t    }\n\t    if (typeof childVal !== 'function') {\n\t      (\"production\") !== 'production' && warn('The \"data\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);\n\t      return parentVal;\n\t    }\n\t    if (!parentVal) {\n\t      return childVal;\n\t    }\n\t    // when parentVal & childVal are both present,\n\t    // we need to return a function that returns the\n\t    // merged result of both functions... no need to\n\t    // check if parentVal is a function here because\n\t    // it has to be a function to pass previous merges.\n\t    return function mergedDataFn() {\n\t      return mergeData(childVal.call(this), parentVal.call(this));\n\t    };\n\t  } else if (parentVal || childVal) {\n\t    return function mergedInstanceDataFn() {\n\t      // instance merge\n\t      var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;\n\t      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;\n\t      if (instanceData) {\n\t        return mergeData(instanceData, defaultData);\n\t      } else {\n\t        return defaultData;\n\t      }\n\t    };\n\t  }\n\t};\n\t\n\t/**\n\t * El\n\t */\n\t\n\tstrats.el = function (parentVal, childVal, vm) {\n\t  if (!vm && childVal && typeof childVal !== 'function') {\n\t    (\"production\") !== 'production' && warn('The \"el\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);\n\t    return;\n\t  }\n\t  var ret = childVal || parentVal;\n\t  // invoke the element factory if this is instance merge\n\t  return vm && typeof ret === 'function' ? ret.call(vm) : ret;\n\t};\n\t\n\t/**\n\t * Hooks and param attributes are merged as arrays.\n\t */\n\t\n\tstrats.init = strats.created = strats.ready = strats.attached = strats.detached = strats.beforeCompile = strats.compiled = strats.beforeDestroy = strats.destroyed = strats.activate = function (parentVal, childVal) {\n\t  return childVal ? parentVal ? parentVal.concat(childVal) : isArray(childVal) ? childVal : [childVal] : parentVal;\n\t};\n\t\n\t/**\n\t * Assets\n\t *\n\t * When a vm is present (instance creation), we need to do\n\t * a three-way merge between constructor options, instance\n\t * options and parent options.\n\t */\n\t\n\tfunction mergeAssets(parentVal, childVal) {\n\t  var res = Object.create(parentVal || null);\n\t  return childVal ? extend(res, guardArrayAssets(childVal)) : res;\n\t}\n\t\n\tconfig._assetTypes.forEach(function (type) {\n\t  strats[type + 's'] = mergeAssets;\n\t});\n\t\n\t/**\n\t * Events & Watchers.\n\t *\n\t * Events & watchers hashes should not overwrite one\n\t * another, so we merge them as arrays.\n\t */\n\t\n\tstrats.watch = strats.events = function (parentVal, childVal) {\n\t  if (!childVal) return parentVal;\n\t  if (!parentVal) return childVal;\n\t  var ret = {};\n\t  extend(ret, parentVal);\n\t  for (var key in childVal) {\n\t    var parent = ret[key];\n\t    var child = childVal[key];\n\t    if (parent && !isArray(parent)) {\n\t      parent = [parent];\n\t    }\n\t    ret[key] = parent ? parent.concat(child) : [child];\n\t  }\n\t  return ret;\n\t};\n\t\n\t/**\n\t * Other object hashes.\n\t */\n\t\n\tstrats.props = strats.methods = strats.computed = function (parentVal, childVal) {\n\t  if (!childVal) return parentVal;\n\t  if (!parentVal) return childVal;\n\t  var ret = Object.create(null);\n\t  extend(ret, parentVal);\n\t  extend(ret, childVal);\n\t  return ret;\n\t};\n\t\n\t/**\n\t * Default strategy.\n\t */\n\t\n\tvar defaultStrat = function defaultStrat(parentVal, childVal) {\n\t  return childVal === undefined ? parentVal : childVal;\n\t};\n\t\n\t/**\n\t * Make sure component options get converted to actual\n\t * constructors.\n\t *\n\t * @param {Object} options\n\t */\n\t\n\tfunction guardComponents(options) {\n\t  if (options.components) {\n\t    var components = options.components = guardArrayAssets(options.components);\n\t    var ids = Object.keys(components);\n\t    var def;\n\t    if (false) {\n\t      var map = options._componentNameMap = {};\n\t    }\n\t    for (var i = 0, l = ids.length; i < l; i++) {\n\t      var key = ids[i];\n\t      if (commonTagRE.test(key) || reservedTagRE.test(key)) {\n\t        (\"production\") !== 'production' && warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);\n\t        continue;\n\t      }\n\t      // record a all lowercase <-> kebab-case mapping for\n\t      // possible custom element case error warning\n\t      if (false) {\n\t        map[key.replace(/-/g, '').toLowerCase()] = hyphenate(key);\n\t      }\n\t      def = components[key];\n\t      if (isPlainObject(def)) {\n\t        components[key] = Vue.extend(def);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Ensure all props option syntax are normalized into the\n\t * Object-based format.\n\t *\n\t * @param {Object} options\n\t */\n\t\n\tfunction guardProps(options) {\n\t  var props = options.props;\n\t  var i, val;\n\t  if (isArray(props)) {\n\t    options.props = {};\n\t    i = props.length;\n\t    while (i--) {\n\t      val = props[i];\n\t      if (typeof val === 'string') {\n\t        options.props[val] = null;\n\t      } else if (val.name) {\n\t        options.props[val.name] = val;\n\t      }\n\t    }\n\t  } else if (isPlainObject(props)) {\n\t    var keys = Object.keys(props);\n\t    i = keys.length;\n\t    while (i--) {\n\t      val = props[keys[i]];\n\t      if (typeof val === 'function') {\n\t        props[keys[i]] = { type: val };\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Guard an Array-format assets option and converted it\n\t * into the key-value Object format.\n\t *\n\t * @param {Object|Array} assets\n\t * @return {Object}\n\t */\n\t\n\tfunction guardArrayAssets(assets) {\n\t  if (isArray(assets)) {\n\t    var res = {};\n\t    var i = assets.length;\n\t    var asset;\n\t    while (i--) {\n\t      asset = assets[i];\n\t      var id = typeof asset === 'function' ? asset.options && asset.options.name || asset.id : asset.name || asset.id;\n\t      if (!id) {\n\t        (\"production\") !== 'production' && warn('Array-syntax assets must provide a \"name\" or \"id\" field.');\n\t      } else {\n\t        res[id] = asset;\n\t      }\n\t    }\n\t    return res;\n\t  }\n\t  return assets;\n\t}\n\t\n\t/**\n\t * Merge two option objects into a new one.\n\t * Core utility used in both instantiation and inheritance.\n\t *\n\t * @param {Object} parent\n\t * @param {Object} child\n\t * @param {Vue} [vm] - if vm is present, indicates this is\n\t *                     an instantiation merge.\n\t */\n\t\n\tfunction mergeOptions(parent, child, vm) {\n\t  guardComponents(child);\n\t  guardProps(child);\n\t  if (false) {\n\t    if (child.propsData && !vm) {\n\t      warn('propsData can only be used as an instantiation option.');\n\t    }\n\t  }\n\t  var options = {};\n\t  var key;\n\t  if (child['extends']) {\n\t    parent = typeof child['extends'] === 'function' ? mergeOptions(parent, child['extends'].options, vm) : mergeOptions(parent, child['extends'], vm);\n\t  }\n\t  if (child.mixins) {\n\t    for (var i = 0, l = child.mixins.length; i < l; i++) {\n\t      var mixin = child.mixins[i];\n\t      var mixinOptions = mixin.prototype instanceof Vue ? mixin.options : mixin;\n\t      parent = mergeOptions(parent, mixinOptions, vm);\n\t    }\n\t  }\n\t  for (key in parent) {\n\t    mergeField(key);\n\t  }\n\t  for (key in child) {\n\t    if (!hasOwn(parent, key)) {\n\t      mergeField(key);\n\t    }\n\t  }\n\t  function mergeField(key) {\n\t    var strat = strats[key] || defaultStrat;\n\t    options[key] = strat(parent[key], child[key], vm, key);\n\t  }\n\t  return options;\n\t}\n\t\n\t/**\n\t * Resolve an asset.\n\t * This function is used because child instances need access\n\t * to assets defined in its ancestor chain.\n\t *\n\t * @param {Object} options\n\t * @param {String} type\n\t * @param {String} id\n\t * @param {Boolean} warnMissing\n\t * @return {Object|Function}\n\t */\n\t\n\tfunction resolveAsset(options, type, id, warnMissing) {\n\t  /* istanbul ignore if */\n\t  if (typeof id !== 'string') {\n\t    return;\n\t  }\n\t  var assets = options[type];\n\t  var camelizedId;\n\t  var res = assets[id] ||\n\t  // camelCase ID\n\t  assets[camelizedId = camelize(id)] ||\n\t  // Pascal Case ID\n\t  assets[camelizedId.charAt(0).toUpperCase() + camelizedId.slice(1)];\n\t  if (false) {\n\t    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);\n\t  }\n\t  return res;\n\t}\n\t\n\tvar uid$1 = 0;\n\t\n\t/**\n\t * A dep is an observable that can have multiple\n\t * directives subscribing to it.\n\t *\n\t * @constructor\n\t */\n\tfunction Dep() {\n\t  this.id = uid$1++;\n\t  this.subs = [];\n\t}\n\t\n\t// the current target watcher being evaluated.\n\t// this is globally unique because there could be only one\n\t// watcher being evaluated at any time.\n\tDep.target = null;\n\t\n\t/**\n\t * Add a directive subscriber.\n\t *\n\t * @param {Directive} sub\n\t */\n\t\n\tDep.prototype.addSub = function (sub) {\n\t  this.subs.push(sub);\n\t};\n\t\n\t/**\n\t * Remove a directive subscriber.\n\t *\n\t * @param {Directive} sub\n\t */\n\t\n\tDep.prototype.removeSub = function (sub) {\n\t  this.subs.$remove(sub);\n\t};\n\t\n\t/**\n\t * Add self as a dependency to the target watcher.\n\t */\n\t\n\tDep.prototype.depend = function () {\n\t  Dep.target.addDep(this);\n\t};\n\t\n\t/**\n\t * Notify all subscribers of a new value.\n\t */\n\t\n\tDep.prototype.notify = function () {\n\t  // stablize the subscriber list first\n\t  var subs = toArray(this.subs);\n\t  for (var i = 0, l = subs.length; i < l; i++) {\n\t    subs[i].update();\n\t  }\n\t};\n\t\n\tvar arrayProto = Array.prototype;\n\tvar arrayMethods = Object.create(arrayProto)\n\t\n\t/**\n\t * Intercept mutating methods and emit events\n\t */\n\t\n\t;['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {\n\t  // cache original method\n\t  var original = arrayProto[method];\n\t  def(arrayMethods, method, function mutator() {\n\t    // avoid leaking arguments:\n\t    // http://jsperf.com/closure-with-arguments\n\t    var i = arguments.length;\n\t    var args = new Array(i);\n\t    while (i--) {\n\t      args[i] = arguments[i];\n\t    }\n\t    var result = original.apply(this, args);\n\t    var ob = this.__ob__;\n\t    var inserted;\n\t    switch (method) {\n\t      case 'push':\n\t        inserted = args;\n\t        break;\n\t      case 'unshift':\n\t        inserted = args;\n\t        break;\n\t      case 'splice':\n\t        inserted = args.slice(2);\n\t        break;\n\t    }\n\t    if (inserted) ob.observeArray(inserted);\n\t    // notify change\n\t    ob.dep.notify();\n\t    return result;\n\t  });\n\t});\n\t\n\t/**\n\t * Swap the element at the given index with a new value\n\t * and emits corresponding event.\n\t *\n\t * @param {Number} index\n\t * @param {*} val\n\t * @return {*} - replaced element\n\t */\n\t\n\tdef(arrayProto, '$set', function $set(index, val) {\n\t  if (index >= this.length) {\n\t    this.length = Number(index) + 1;\n\t  }\n\t  return this.splice(index, 1, val)[0];\n\t});\n\t\n\t/**\n\t * Convenience method to remove the element at given index or target element reference.\n\t *\n\t * @param {*} item\n\t */\n\t\n\tdef(arrayProto, '$remove', function $remove(item) {\n\t  /* istanbul ignore if */\n\t  if (!this.length) return;\n\t  var index = indexOf(this, item);\n\t  if (index > -1) {\n\t    return this.splice(index, 1);\n\t  }\n\t});\n\t\n\tvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\t\n\t/**\n\t * By default, when a reactive property is set, the new value is\n\t * also converted to become reactive. However in certain cases, e.g.\n\t * v-for scope alias and props, we don't want to force conversion\n\t * because the value may be a nested value under a frozen data structure.\n\t *\n\t * So whenever we want to set a reactive property without forcing\n\t * conversion on the new value, we wrap that call inside this function.\n\t */\n\t\n\tvar shouldConvert = true;\n\t\n\tfunction withoutConversion(fn) {\n\t  shouldConvert = false;\n\t  fn();\n\t  shouldConvert = true;\n\t}\n\t\n\t/**\n\t * Observer class that are attached to each observed\n\t * object. Once attached, the observer converts target\n\t * object's property keys into getter/setters that\n\t * collect dependencies and dispatches updates.\n\t *\n\t * @param {Array|Object} value\n\t * @constructor\n\t */\n\t\n\tfunction Observer(value) {\n\t  this.value = value;\n\t  this.dep = new Dep();\n\t  def(value, '__ob__', this);\n\t  if (isArray(value)) {\n\t    var augment = hasProto ? protoAugment : copyAugment;\n\t    augment(value, arrayMethods, arrayKeys);\n\t    this.observeArray(value);\n\t  } else {\n\t    this.walk(value);\n\t  }\n\t}\n\t\n\t// Instance methods\n\t\n\t/**\n\t * Walk through each property and convert them into\n\t * getter/setters. This method should only be called when\n\t * value type is Object.\n\t *\n\t * @param {Object} obj\n\t */\n\t\n\tObserver.prototype.walk = function (obj) {\n\t  var keys = Object.keys(obj);\n\t  for (var i = 0, l = keys.length; i < l; i++) {\n\t    this.convert(keys[i], obj[keys[i]]);\n\t  }\n\t};\n\t\n\t/**\n\t * Observe a list of Array items.\n\t *\n\t * @param {Array} items\n\t */\n\t\n\tObserver.prototype.observeArray = function (items) {\n\t  for (var i = 0, l = items.length; i < l; i++) {\n\t    observe(items[i]);\n\t  }\n\t};\n\t\n\t/**\n\t * Convert a property into getter/setter so we can emit\n\t * the events when the property is accessed/changed.\n\t *\n\t * @param {String} key\n\t * @param {*} val\n\t */\n\t\n\tObserver.prototype.convert = function (key, val) {\n\t  defineReactive(this.value, key, val);\n\t};\n\t\n\t/**\n\t * Add an owner vm, so that when $set/$delete mutations\n\t * happen we can notify owner vms to proxy the keys and\n\t * digest the watchers. This is only called when the object\n\t * is observed as an instance's root $data.\n\t *\n\t * @param {Vue} vm\n\t */\n\t\n\tObserver.prototype.addVm = function (vm) {\n\t  (this.vms || (this.vms = [])).push(vm);\n\t};\n\t\n\t/**\n\t * Remove an owner vm. This is called when the object is\n\t * swapped out as an instance's $data object.\n\t *\n\t * @param {Vue} vm\n\t */\n\t\n\tObserver.prototype.removeVm = function (vm) {\n\t  this.vms.$remove(vm);\n\t};\n\t\n\t// helpers\n\t\n\t/**\n\t * Augment an target Object or Array by intercepting\n\t * the prototype chain using __proto__\n\t *\n\t * @param {Object|Array} target\n\t * @param {Object} src\n\t */\n\t\n\tfunction protoAugment(target, src) {\n\t  /* eslint-disable no-proto */\n\t  target.__proto__ = src;\n\t  /* eslint-enable no-proto */\n\t}\n\t\n\t/**\n\t * Augment an target Object or Array by defining\n\t * hidden properties.\n\t *\n\t * @param {Object|Array} target\n\t * @param {Object} proto\n\t */\n\t\n\tfunction copyAugment(target, src, keys) {\n\t  for (var i = 0, l = keys.length; i < l; i++) {\n\t    var key = keys[i];\n\t    def(target, key, src[key]);\n\t  }\n\t}\n\t\n\t/**\n\t * Attempt to create an observer instance for a value,\n\t * returns the new observer if successfully observed,\n\t * or the existing observer if the value already has one.\n\t *\n\t * @param {*} value\n\t * @param {Vue} [vm]\n\t * @return {Observer|undefined}\n\t * @static\n\t */\n\t\n\tfunction observe(value, vm) {\n\t  if (!value || typeof value !== 'object') {\n\t    return;\n\t  }\n\t  var ob;\n\t  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n\t    ob = value.__ob__;\n\t  } else if (shouldConvert && (isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {\n\t    ob = new Observer(value);\n\t  }\n\t  if (ob && vm) {\n\t    ob.addVm(vm);\n\t  }\n\t  return ob;\n\t}\n\t\n\t/**\n\t * Define a reactive property on an Object.\n\t *\n\t * @param {Object} obj\n\t * @param {String} key\n\t * @param {*} val\n\t */\n\t\n\tfunction defineReactive(obj, key, val) {\n\t  var dep = new Dep();\n\t\n\t  var property = Object.getOwnPropertyDescriptor(obj, key);\n\t  if (property && property.configurable === false) {\n\t    return;\n\t  }\n\t\n\t  // cater for pre-defined getter/setters\n\t  var getter = property && property.get;\n\t  var setter = property && property.set;\n\t\n\t  var childOb = observe(val);\n\t  Object.defineProperty(obj, key, {\n\t    enumerable: true,\n\t    configurable: true,\n\t    get: function reactiveGetter() {\n\t      var value = getter ? getter.call(obj) : val;\n\t      if (Dep.target) {\n\t        dep.depend();\n\t        if (childOb) {\n\t          childOb.dep.depend();\n\t        }\n\t        if (isArray(value)) {\n\t          for (var e, i = 0, l = value.length; i < l; i++) {\n\t            e = value[i];\n\t            e && e.__ob__ && e.__ob__.dep.depend();\n\t          }\n\t        }\n\t      }\n\t      return value;\n\t    },\n\t    set: function reactiveSetter(newVal) {\n\t      var value = getter ? getter.call(obj) : val;\n\t      if (newVal === value) {\n\t        return;\n\t      }\n\t      if (setter) {\n\t        setter.call(obj, newVal);\n\t      } else {\n\t        val = newVal;\n\t      }\n\t      childOb = observe(newVal);\n\t      dep.notify();\n\t    }\n\t  });\n\t}\n\t\n\t\n\t\n\tvar util = Object.freeze({\n\t\tdefineReactive: defineReactive,\n\t\tset: set,\n\t\tdel: del,\n\t\thasOwn: hasOwn,\n\t\tisLiteral: isLiteral,\n\t\tisReserved: isReserved,\n\t\t_toString: _toString,\n\t\ttoNumber: toNumber,\n\t\ttoBoolean: toBoolean,\n\t\tstripQuotes: stripQuotes,\n\t\tcamelize: camelize,\n\t\thyphenate: hyphenate,\n\t\tclassify: classify,\n\t\tbind: bind,\n\t\ttoArray: toArray,\n\t\textend: extend,\n\t\tisObject: isObject,\n\t\tisPlainObject: isPlainObject,\n\t\tdef: def,\n\t\tdebounce: _debounce,\n\t\tindexOf: indexOf,\n\t\tcancellable: cancellable,\n\t\tlooseEqual: looseEqual,\n\t\tisArray: isArray,\n\t\thasProto: hasProto,\n\t\tinBrowser: inBrowser,\n\t\tdevtools: devtools,\n\t\tisIE: isIE,\n\t\tisIE9: isIE9,\n\t\tisAndroid: isAndroid,\n\t\tisIos: isIos,\n\t\tiosVersionMatch: iosVersionMatch,\n\t\tiosVersion: iosVersion,\n\t\thasMutationObserverBug: hasMutationObserverBug,\n\t\tget transitionProp () { return transitionProp; },\n\t\tget transitionEndEvent () { return transitionEndEvent; },\n\t\tget animationProp () { return animationProp; },\n\t\tget animationEndEvent () { return animationEndEvent; },\n\t\tnextTick: nextTick,\n\t\tget _Set () { return _Set; },\n\t\tquery: query,\n\t\tinDoc: inDoc,\n\t\tgetAttr: getAttr,\n\t\tgetBindAttr: getBindAttr,\n\t\thasBindAttr: hasBindAttr,\n\t\tbefore: before,\n\t\tafter: after,\n\t\tremove: remove,\n\t\tprepend: prepend,\n\t\treplace: replace,\n\t\ton: on,\n\t\toff: off,\n\t\tsetClass: setClass,\n\t\taddClass: addClass,\n\t\tremoveClass: removeClass,\n\t\textractContent: extractContent,\n\t\ttrimNode: trimNode,\n\t\tisTemplate: isTemplate,\n\t\tcreateAnchor: createAnchor,\n\t\tfindRef: findRef,\n\t\tmapNodeRange: mapNodeRange,\n\t\tremoveNodeRange: removeNodeRange,\n\t\tisFragment: isFragment,\n\t\tgetOuterHTML: getOuterHTML,\n\t\tmergeOptions: mergeOptions,\n\t\tresolveAsset: resolveAsset,\n\t\tcheckComponentAttr: checkComponentAttr,\n\t\tcommonTagRE: commonTagRE,\n\t\treservedTagRE: reservedTagRE,\n\t\tget warn () { return warn; }\n\t});\n\t\n\tvar uid = 0;\n\t\n\tfunction initMixin (Vue) {\n\t  /**\n\t   * The main init sequence. This is called for every\n\t   * instance, including ones that are created from extended\n\t   * constructors.\n\t   *\n\t   * @param {Object} options - this options object should be\n\t   *                           the result of merging class\n\t   *                           options and the options passed\n\t   *                           in to the constructor.\n\t   */\n\t\n\t  Vue.prototype._init = function (options) {\n\t    options = options || {};\n\t\n\t    this.$el = null;\n\t    this.$parent = options.parent;\n\t    this.$root = this.$parent ? this.$parent.$root : this;\n\t    this.$children = [];\n\t    this.$refs = {}; // child vm references\n\t    this.$els = {}; // element references\n\t    this._watchers = []; // all watchers as an array\n\t    this._directives = []; // all directives\n\t\n\t    // a uid\n\t    this._uid = uid++;\n\t\n\t    // a flag to avoid this being observed\n\t    this._isVue = true;\n\t\n\t    // events bookkeeping\n\t    this._events = {}; // registered callbacks\n\t    this._eventsCount = {}; // for $broadcast optimization\n\t\n\t    // fragment instance properties\n\t    this._isFragment = false;\n\t    this._fragment = // @type {DocumentFragment}\n\t    this._fragmentStart = // @type {Text|Comment}\n\t    this._fragmentEnd = null; // @type {Text|Comment}\n\t\n\t    // lifecycle state\n\t    this._isCompiled = this._isDestroyed = this._isReady = this._isAttached = this._isBeingDestroyed = this._vForRemoving = false;\n\t    this._unlinkFn = null;\n\t\n\t    // context:\n\t    // if this is a transcluded component, context\n\t    // will be the common parent vm of this instance\n\t    // and its host.\n\t    this._context = options._context || this.$parent;\n\t\n\t    // scope:\n\t    // if this is inside an inline v-for, the scope\n\t    // will be the intermediate scope created for this\n\t    // repeat fragment. this is used for linking props\n\t    // and container directives.\n\t    this._scope = options._scope;\n\t\n\t    // fragment:\n\t    // if this instance is compiled inside a Fragment, it\n\t    // needs to reigster itself as a child of that fragment\n\t    // for attach/detach to work properly.\n\t    this._frag = options._frag;\n\t    if (this._frag) {\n\t      this._frag.children.push(this);\n\t    }\n\t\n\t    // push self into parent / transclusion host\n\t    if (this.$parent) {\n\t      this.$parent.$children.push(this);\n\t    }\n\t\n\t    // merge options.\n\t    options = this.$options = mergeOptions(this.constructor.options, options, this);\n\t\n\t    // set ref\n\t    this._updateRef();\n\t\n\t    // initialize data as empty object.\n\t    // it will be filled up in _initData().\n\t    this._data = {};\n\t\n\t    // call init hook\n\t    this._callHook('init');\n\t\n\t    // initialize data observation and scope inheritance.\n\t    this._initState();\n\t\n\t    // setup event system and option events.\n\t    this._initEvents();\n\t\n\t    // call created hook\n\t    this._callHook('created');\n\t\n\t    // if `el` option is passed, start compilation.\n\t    if (options.el) {\n\t      this.$mount(options.el);\n\t    }\n\t  };\n\t}\n\t\n\tvar pathCache = new Cache(1000);\n\t\n\t// actions\n\tvar APPEND = 0;\n\tvar PUSH = 1;\n\tvar INC_SUB_PATH_DEPTH = 2;\n\tvar PUSH_SUB_PATH = 3;\n\t\n\t// states\n\tvar BEFORE_PATH = 0;\n\tvar IN_PATH = 1;\n\tvar BEFORE_IDENT = 2;\n\tvar IN_IDENT = 3;\n\tvar IN_SUB_PATH = 4;\n\tvar IN_SINGLE_QUOTE = 5;\n\tvar IN_DOUBLE_QUOTE = 6;\n\tvar AFTER_PATH = 7;\n\tvar ERROR = 8;\n\t\n\tvar pathStateMachine = [];\n\t\n\tpathStateMachine[BEFORE_PATH] = {\n\t  'ws': [BEFORE_PATH],\n\t  'ident': [IN_IDENT, APPEND],\n\t  '[': [IN_SUB_PATH],\n\t  'eof': [AFTER_PATH]\n\t};\n\t\n\tpathStateMachine[IN_PATH] = {\n\t  'ws': [IN_PATH],\n\t  '.': [BEFORE_IDENT],\n\t  '[': [IN_SUB_PATH],\n\t  'eof': [AFTER_PATH]\n\t};\n\t\n\tpathStateMachine[BEFORE_IDENT] = {\n\t  'ws': [BEFORE_IDENT],\n\t  'ident': [IN_IDENT, APPEND]\n\t};\n\t\n\tpathStateMachine[IN_IDENT] = {\n\t  'ident': [IN_IDENT, APPEND],\n\t  '0': [IN_IDENT, APPEND],\n\t  'number': [IN_IDENT, APPEND],\n\t  'ws': [IN_PATH, PUSH],\n\t  '.': [BEFORE_IDENT, PUSH],\n\t  '[': [IN_SUB_PATH, PUSH],\n\t  'eof': [AFTER_PATH, PUSH]\n\t};\n\t\n\tpathStateMachine[IN_SUB_PATH] = {\n\t  \"'\": [IN_SINGLE_QUOTE, APPEND],\n\t  '\"': [IN_DOUBLE_QUOTE, APPEND],\n\t  '[': [IN_SUB_PATH, INC_SUB_PATH_DEPTH],\n\t  ']': [IN_PATH, PUSH_SUB_PATH],\n\t  'eof': ERROR,\n\t  'else': [IN_SUB_PATH, APPEND]\n\t};\n\t\n\tpathStateMachine[IN_SINGLE_QUOTE] = {\n\t  \"'\": [IN_SUB_PATH, APPEND],\n\t  'eof': ERROR,\n\t  'else': [IN_SINGLE_QUOTE, APPEND]\n\t};\n\t\n\tpathStateMachine[IN_DOUBLE_QUOTE] = {\n\t  '\"': [IN_SUB_PATH, APPEND],\n\t  'eof': ERROR,\n\t  'else': [IN_DOUBLE_QUOTE, APPEND]\n\t};\n\t\n\t/**\n\t * Determine the type of a character in a keypath.\n\t *\n\t * @param {Char} ch\n\t * @return {String} type\n\t */\n\t\n\tfunction getPathCharType(ch) {\n\t  if (ch === undefined) {\n\t    return 'eof';\n\t  }\n\t\n\t  var code = ch.charCodeAt(0);\n\t\n\t  switch (code) {\n\t    case 0x5B: // [\n\t    case 0x5D: // ]\n\t    case 0x2E: // .\n\t    case 0x22: // \"\n\t    case 0x27: // '\n\t    case 0x30:\n\t      // 0\n\t      return ch;\n\t\n\t    case 0x5F: // _\n\t    case 0x24:\n\t      // $\n\t      return 'ident';\n\t\n\t    case 0x20: // Space\n\t    case 0x09: // Tab\n\t    case 0x0A: // Newline\n\t    case 0x0D: // Return\n\t    case 0xA0: // No-break space\n\t    case 0xFEFF: // Byte Order Mark\n\t    case 0x2028: // Line Separator\n\t    case 0x2029:\n\t      // Paragraph Separator\n\t      return 'ws';\n\t  }\n\t\n\t  // a-z, A-Z\n\t  if (code >= 0x61 && code <= 0x7A || code >= 0x41 && code <= 0x5A) {\n\t    return 'ident';\n\t  }\n\t\n\t  // 1-9\n\t  if (code >= 0x31 && code <= 0x39) {\n\t    return 'number';\n\t  }\n\t\n\t  return 'else';\n\t}\n\t\n\t/**\n\t * Format a subPath, return its plain form if it is\n\t * a literal string or number. Otherwise prepend the\n\t * dynamic indicator (*).\n\t *\n\t * @param {String} path\n\t * @return {String}\n\t */\n\t\n\tfunction formatSubPath(path) {\n\t  var trimmed = path.trim();\n\t  // invalid leading 0\n\t  if (path.charAt(0) === '0' && isNaN(path)) {\n\t    return false;\n\t  }\n\t  return isLiteral(trimmed) ? stripQuotes(trimmed) : '*' + trimmed;\n\t}\n\t\n\t/**\n\t * Parse a string path into an array of segments\n\t *\n\t * @param {String} path\n\t * @return {Array|undefined}\n\t */\n\t\n\tfunction parse(path) {\n\t  var keys = [];\n\t  var index = -1;\n\t  var mode = BEFORE_PATH;\n\t  var subPathDepth = 0;\n\t  var c, newChar, key, type, transition, action, typeMap;\n\t\n\t  var actions = [];\n\t\n\t  actions[PUSH] = function () {\n\t    if (key !== undefined) {\n\t      keys.push(key);\n\t      key = undefined;\n\t    }\n\t  };\n\t\n\t  actions[APPEND] = function () {\n\t    if (key === undefined) {\n\t      key = newChar;\n\t    } else {\n\t      key += newChar;\n\t    }\n\t  };\n\t\n\t  actions[INC_SUB_PATH_DEPTH] = function () {\n\t    actions[APPEND]();\n\t    subPathDepth++;\n\t  };\n\t\n\t  actions[PUSH_SUB_PATH] = function () {\n\t    if (subPathDepth > 0) {\n\t      subPathDepth--;\n\t      mode = IN_SUB_PATH;\n\t      actions[APPEND]();\n\t    } else {\n\t      subPathDepth = 0;\n\t      key = formatSubPath(key);\n\t      if (key === false) {\n\t        return false;\n\t      } else {\n\t        actions[PUSH]();\n\t      }\n\t    }\n\t  };\n\t\n\t  function maybeUnescapeQuote() {\n\t    var nextChar = path[index + 1];\n\t    if (mode === IN_SINGLE_QUOTE && nextChar === \"'\" || mode === IN_DOUBLE_QUOTE && nextChar === '\"') {\n\t      index++;\n\t      newChar = '\\\\' + nextChar;\n\t      actions[APPEND]();\n\t      return true;\n\t    }\n\t  }\n\t\n\t  while (mode != null) {\n\t    index++;\n\t    c = path[index];\n\t\n\t    if (c === '\\\\' && maybeUnescapeQuote()) {\n\t      continue;\n\t    }\n\t\n\t    type = getPathCharType(c);\n\t    typeMap = pathStateMachine[mode];\n\t    transition = typeMap[type] || typeMap['else'] || ERROR;\n\t\n\t    if (transition === ERROR) {\n\t      return; // parse error\n\t    }\n\t\n\t    mode = transition[0];\n\t    action = actions[transition[1]];\n\t    if (action) {\n\t      newChar = transition[2];\n\t      newChar = newChar === undefined ? c : newChar;\n\t      if (action() === false) {\n\t        return;\n\t      }\n\t    }\n\t\n\t    if (mode === AFTER_PATH) {\n\t      keys.raw = path;\n\t      return keys;\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * External parse that check for a cache hit first\n\t *\n\t * @param {String} path\n\t * @return {Array|undefined}\n\t */\n\t\n\tfunction parsePath(path) {\n\t  var hit = pathCache.get(path);\n\t  if (!hit) {\n\t    hit = parse(path);\n\t    if (hit) {\n\t      pathCache.put(path, hit);\n\t    }\n\t  }\n\t  return hit;\n\t}\n\t\n\t/**\n\t * Get from an object from a path string\n\t *\n\t * @param {Object} obj\n\t * @param {String} path\n\t */\n\t\n\tfunction getPath(obj, path) {\n\t  return parseExpression(path).get(obj);\n\t}\n\t\n\t/**\n\t * Warn against setting non-existent root path on a vm.\n\t */\n\t\n\tvar warnNonExistent;\n\tif (false) {\n\t  warnNonExistent = function (path, vm) {\n\t    warn('You are setting a non-existent path \"' + path.raw + '\" ' + 'on a vm instance. Consider pre-initializing the property ' + 'with the \"data\" option for more reliable reactivity ' + 'and better performance.', vm);\n\t  };\n\t}\n\t\n\t/**\n\t * Set on an object from a path\n\t *\n\t * @param {Object} obj\n\t * @param {String | Array} path\n\t * @param {*} val\n\t */\n\t\n\tfunction setPath(obj, path, val) {\n\t  var original = obj;\n\t  if (typeof path === 'string') {\n\t    path = parse(path);\n\t  }\n\t  if (!path || !isObject(obj)) {\n\t    return false;\n\t  }\n\t  var last, key;\n\t  for (var i = 0, l = path.length; i < l; i++) {\n\t    last = obj;\n\t    key = path[i];\n\t    if (key.charAt(0) === '*') {\n\t      key = parseExpression(key.slice(1)).get.call(original, original);\n\t    }\n\t    if (i < l - 1) {\n\t      obj = obj[key];\n\t      if (!isObject(obj)) {\n\t        obj = {};\n\t        if (false) {\n\t          warnNonExistent(path, last);\n\t        }\n\t        set(last, key, obj);\n\t      }\n\t    } else {\n\t      if (isArray(obj)) {\n\t        obj.$set(key, val);\n\t      } else if (key in obj) {\n\t        obj[key] = val;\n\t      } else {\n\t        if (false) {\n\t          warnNonExistent(path, obj);\n\t        }\n\t        set(obj, key, val);\n\t      }\n\t    }\n\t  }\n\t  return true;\n\t}\n\t\n\tvar path = Object.freeze({\n\t  parsePath: parsePath,\n\t  getPath: getPath,\n\t  setPath: setPath\n\t});\n\t\n\tvar expressionCache = new Cache(1000);\n\t\n\tvar allowedKeywords = 'Math,Date,this,true,false,null,undefined,Infinity,NaN,' + 'isNaN,isFinite,decodeURI,decodeURIComponent,encodeURI,' + 'encodeURIComponent,parseInt,parseFloat';\n\tvar allowedKeywordsRE = new RegExp('^(' + allowedKeywords.replace(/,/g, '\\\\b|') + '\\\\b)');\n\t\n\t// keywords that don't make sense inside expressions\n\tvar improperKeywords = 'break,case,class,catch,const,continue,debugger,default,' + 'delete,do,else,export,extends,finally,for,function,if,' + 'import,in,instanceof,let,return,super,switch,throw,try,' + 'var,while,with,yield,enum,await,implements,package,' + 'protected,static,interface,private,public';\n\tvar improperKeywordsRE = new RegExp('^(' + improperKeywords.replace(/,/g, '\\\\b|') + '\\\\b)');\n\t\n\tvar wsRE = /\\s/g;\n\tvar newlineRE = /\\n/g;\n\tvar saveRE = /[\\{,]\\s*[\\w\\$_]+\\s*:|('(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`)|new |typeof |void /g;\n\tvar restoreRE = /\"(\\d+)\"/g;\n\tvar pathTestRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?'\\]|\\[\".*?\"\\]|\\[\\d+\\]|\\[[A-Za-z_$][\\w$]*\\])*$/;\n\tvar identRE = /[^\\w$\\.](?:[A-Za-z_$][\\w$]*)/g;\n\tvar literalValueRE$1 = /^(?:true|false|null|undefined|Infinity|NaN)$/;\n\t\n\tfunction noop() {}\n\t\n\t/**\n\t * Save / Rewrite / Restore\n\t *\n\t * When rewriting paths found in an expression, it is\n\t * possible for the same letter sequences to be found in\n\t * strings and Object literal property keys. Therefore we\n\t * remove and store these parts in a temporary array, and\n\t * restore them after the path rewrite.\n\t */\n\t\n\tvar saved = [];\n\t\n\t/**\n\t * Save replacer\n\t *\n\t * The save regex can match two possible cases:\n\t * 1. An opening object literal\n\t * 2. A string\n\t * If matched as a plain string, we need to escape its\n\t * newlines, since the string needs to be preserved when\n\t * generating the function body.\n\t *\n\t * @param {String} str\n\t * @param {String} isString - str if matched as a string\n\t * @return {String} - placeholder with index\n\t */\n\t\n\tfunction save(str, isString) {\n\t  var i = saved.length;\n\t  saved[i] = isString ? str.replace(newlineRE, '\\\\n') : str;\n\t  return '\"' + i + '\"';\n\t}\n\t\n\t/**\n\t * Path rewrite replacer\n\t *\n\t * @param {String} raw\n\t * @return {String}\n\t */\n\t\n\tfunction rewrite(raw) {\n\t  var c = raw.charAt(0);\n\t  var path = raw.slice(1);\n\t  if (allowedKeywordsRE.test(path)) {\n\t    return raw;\n\t  } else {\n\t    path = path.indexOf('\"') > -1 ? path.replace(restoreRE, restore) : path;\n\t    return c + 'scope.' + path;\n\t  }\n\t}\n\t\n\t/**\n\t * Restore replacer\n\t *\n\t * @param {String} str\n\t * @param {String} i - matched save index\n\t * @return {String}\n\t */\n\t\n\tfunction restore(str, i) {\n\t  return saved[i];\n\t}\n\t\n\t/**\n\t * Rewrite an expression, prefixing all path accessors with\n\t * `scope.` and generate getter/setter functions.\n\t *\n\t * @param {String} exp\n\t * @return {Function}\n\t */\n\t\n\tfunction compileGetter(exp) {\n\t  if (improperKeywordsRE.test(exp)) {\n\t    (\"production\") !== 'production' && warn('Avoid using reserved keywords in expression: ' + exp);\n\t  }\n\t  // reset state\n\t  saved.length = 0;\n\t  // save strings and object literal keys\n\t  var body = exp.replace(saveRE, save).replace(wsRE, '');\n\t  // rewrite all paths\n\t  // pad 1 space here because the regex matches 1 extra char\n\t  body = (' ' + body).replace(identRE, rewrite).replace(restoreRE, restore);\n\t  return makeGetterFn(body);\n\t}\n\t\n\t/**\n\t * Build a getter function. Requires eval.\n\t *\n\t * We isolate the try/catch so it doesn't affect the\n\t * optimization of the parse function when it is not called.\n\t *\n\t * @param {String} body\n\t * @return {Function|undefined}\n\t */\n\t\n\tfunction makeGetterFn(body) {\n\t  try {\n\t    /* eslint-disable no-new-func */\n\t    return new Function('scope', 'return ' + body + ';');\n\t    /* eslint-enable no-new-func */\n\t  } catch (e) {\n\t    if (false) {\n\t      /* istanbul ignore if */\n\t      if (e.toString().match(/unsafe-eval|CSP/)) {\n\t        warn('It seems you are using the default build of Vue.js in an environment ' + 'with Content Security Policy that prohibits unsafe-eval. ' + 'Use the CSP-compliant build instead: ' + 'http://vuejs.org/guide/installation.html#CSP-compliant-build');\n\t      } else {\n\t        warn('Invalid expression. ' + 'Generated function body: ' + body);\n\t      }\n\t    }\n\t    return noop;\n\t  }\n\t}\n\t\n\t/**\n\t * Compile a setter function for the expression.\n\t *\n\t * @param {String} exp\n\t * @return {Function|undefined}\n\t */\n\t\n\tfunction compileSetter(exp) {\n\t  var path = parsePath(exp);\n\t  if (path) {\n\t    return function (scope, val) {\n\t      setPath(scope, path, val);\n\t    };\n\t  } else {\n\t    (\"production\") !== 'production' && warn('Invalid setter expression: ' + exp);\n\t  }\n\t}\n\t\n\t/**\n\t * Parse an expression into re-written getter/setters.\n\t *\n\t * @param {String} exp\n\t * @param {Boolean} needSet\n\t * @return {Function}\n\t */\n\t\n\tfunction parseExpression(exp, needSet) {\n\t  exp = exp.trim();\n\t  // try cache\n\t  var hit = expressionCache.get(exp);\n\t  if (hit) {\n\t    if (needSet && !hit.set) {\n\t      hit.set = compileSetter(hit.exp);\n\t    }\n\t    return hit;\n\t  }\n\t  var res = { exp: exp };\n\t  res.get = isSimplePath(exp) && exp.indexOf('[') < 0\n\t  // optimized super simple getter\n\t  ? makeGetterFn('scope.' + exp)\n\t  // dynamic getter\n\t  : compileGetter(exp);\n\t  if (needSet) {\n\t    res.set = compileSetter(exp);\n\t  }\n\t  expressionCache.put(exp, res);\n\t  return res;\n\t}\n\t\n\t/**\n\t * Check if an expression is a simple path.\n\t *\n\t * @param {String} exp\n\t * @return {Boolean}\n\t */\n\t\n\tfunction isSimplePath(exp) {\n\t  return pathTestRE.test(exp) &&\n\t  // don't treat literal values as paths\n\t  !literalValueRE$1.test(exp) &&\n\t  // Math constants e.g. Math.PI, Math.E etc.\n\t  exp.slice(0, 5) !== 'Math.';\n\t}\n\t\n\tvar expression = Object.freeze({\n\t  parseExpression: parseExpression,\n\t  isSimplePath: isSimplePath\n\t});\n\t\n\t// we have two separate queues: one for directive updates\n\t// and one for user watcher registered via $watch().\n\t// we want to guarantee directive updates to be called\n\t// before user watchers so that when user watchers are\n\t// triggered, the DOM would have already been in updated\n\t// state.\n\t\n\tvar queue = [];\n\tvar userQueue = [];\n\tvar has = {};\n\tvar circular = {};\n\tvar waiting = false;\n\t\n\t/**\n\t * Reset the batcher's state.\n\t */\n\t\n\tfunction resetBatcherState() {\n\t  queue.length = 0;\n\t  userQueue.length = 0;\n\t  has = {};\n\t  circular = {};\n\t  waiting = false;\n\t}\n\t\n\t/**\n\t * Flush both queues and run the watchers.\n\t */\n\t\n\tfunction flushBatcherQueue() {\n\t  var _again = true;\n\t\n\t  _function: while (_again) {\n\t    _again = false;\n\t\n\t    runBatcherQueue(queue);\n\t    runBatcherQueue(userQueue);\n\t    // user watchers triggered more watchers,\n\t    // keep flushing until it depletes\n\t    if (queue.length) {\n\t      _again = true;\n\t      continue _function;\n\t    }\n\t    // dev tool hook\n\t    /* istanbul ignore if */\n\t    if (devtools && config.devtools) {\n\t      devtools.emit('flush');\n\t    }\n\t    resetBatcherState();\n\t  }\n\t}\n\t\n\t/**\n\t * Run the watchers in a single queue.\n\t *\n\t * @param {Array} queue\n\t */\n\t\n\tfunction runBatcherQueue(queue) {\n\t  // do not cache length because more watchers might be pushed\n\t  // as we run existing watchers\n\t  for (var i = 0; i < queue.length; i++) {\n\t    var watcher = queue[i];\n\t    var id = watcher.id;\n\t    has[id] = null;\n\t    watcher.run();\n\t    // in dev build, check and stop circular updates.\n\t    if (false) {\n\t      circular[id] = (circular[id] || 0) + 1;\n\t      if (circular[id] > config._maxUpdateCount) {\n\t        warn('You may have an infinite update loop for watcher ' + 'with expression \"' + watcher.expression + '\"', watcher.vm);\n\t        break;\n\t      }\n\t    }\n\t  }\n\t  queue.length = 0;\n\t}\n\t\n\t/**\n\t * Push a watcher into the watcher queue.\n\t * Jobs with duplicate IDs will be skipped unless it's\n\t * pushed when the queue is being flushed.\n\t *\n\t * @param {Watcher} watcher\n\t *   properties:\n\t *   - {Number} id\n\t *   - {Function} run\n\t */\n\t\n\tfunction pushWatcher(watcher) {\n\t  var id = watcher.id;\n\t  if (has[id] == null) {\n\t    // push watcher into appropriate queue\n\t    var q = watcher.user ? userQueue : queue;\n\t    has[id] = q.length;\n\t    q.push(watcher);\n\t    // queue the flush\n\t    if (!waiting) {\n\t      waiting = true;\n\t      nextTick(flushBatcherQueue);\n\t    }\n\t  }\n\t}\n\t\n\tvar uid$2 = 0;\n\t\n\t/**\n\t * A watcher parses an expression, collects dependencies,\n\t * and fires callback when the expression value changes.\n\t * This is used for both the $watch() api and directives.\n\t *\n\t * @param {Vue} vm\n\t * @param {String|Function} expOrFn\n\t * @param {Function} cb\n\t * @param {Object} options\n\t *                 - {Array} filters\n\t *                 - {Boolean} twoWay\n\t *                 - {Boolean} deep\n\t *                 - {Boolean} user\n\t *                 - {Boolean} sync\n\t *                 - {Boolean} lazy\n\t *                 - {Function} [preProcess]\n\t *                 - {Function} [postProcess]\n\t * @constructor\n\t */\n\tfunction Watcher(vm, expOrFn, cb, options) {\n\t  // mix in options\n\t  if (options) {\n\t    extend(this, options);\n\t  }\n\t  var isFn = typeof expOrFn === 'function';\n\t  this.vm = vm;\n\t  vm._watchers.push(this);\n\t  this.expression = expOrFn;\n\t  this.cb = cb;\n\t  this.id = ++uid$2; // uid for batching\n\t  this.active = true;\n\t  this.dirty = this.lazy; // for lazy watchers\n\t  this.deps = [];\n\t  this.newDeps = [];\n\t  this.depIds = new _Set();\n\t  this.newDepIds = new _Set();\n\t  this.prevError = null; // for async error stacks\n\t  // parse expression for getter/setter\n\t  if (isFn) {\n\t    this.getter = expOrFn;\n\t    this.setter = undefined;\n\t  } else {\n\t    var res = parseExpression(expOrFn, this.twoWay);\n\t    this.getter = res.get;\n\t    this.setter = res.set;\n\t  }\n\t  this.value = this.lazy ? undefined : this.get();\n\t  // state for avoiding false triggers for deep and Array\n\t  // watchers during vm._digest()\n\t  this.queued = this.shallow = false;\n\t}\n\t\n\t/**\n\t * Evaluate the getter, and re-collect dependencies.\n\t */\n\t\n\tWatcher.prototype.get = function () {\n\t  this.beforeGet();\n\t  var scope = this.scope || this.vm;\n\t  var value;\n\t  try {\n\t    value = this.getter.call(scope, scope);\n\t  } catch (e) {\n\t    if (false) {\n\t      warn('Error when evaluating expression ' + '\"' + this.expression + '\": ' + e.toString(), this.vm);\n\t    }\n\t  }\n\t  // \"touch\" every property so they are all tracked as\n\t  // dependencies for deep watching\n\t  if (this.deep) {\n\t    traverse(value);\n\t  }\n\t  if (this.preProcess) {\n\t    value = this.preProcess(value);\n\t  }\n\t  if (this.filters) {\n\t    value = scope._applyFilters(value, null, this.filters, false);\n\t  }\n\t  if (this.postProcess) {\n\t    value = this.postProcess(value);\n\t  }\n\t  this.afterGet();\n\t  return value;\n\t};\n\t\n\t/**\n\t * Set the corresponding value with the setter.\n\t *\n\t * @param {*} value\n\t */\n\t\n\tWatcher.prototype.set = function (value) {\n\t  var scope = this.scope || this.vm;\n\t  if (this.filters) {\n\t    value = scope._applyFilters(value, this.value, this.filters, true);\n\t  }\n\t  try {\n\t    this.setter.call(scope, scope, value);\n\t  } catch (e) {\n\t    if (false) {\n\t      warn('Error when evaluating setter ' + '\"' + this.expression + '\": ' + e.toString(), this.vm);\n\t    }\n\t  }\n\t  // two-way sync for v-for alias\n\t  var forContext = scope.$forContext;\n\t  if (forContext && forContext.alias === this.expression) {\n\t    if (forContext.filters) {\n\t      (\"production\") !== 'production' && warn('It seems you are using two-way binding on ' + 'a v-for alias (' + this.expression + '), and the ' + 'v-for has filters. This will not work properly. ' + 'Either remove the filters or use an array of ' + 'objects and bind to object properties instead.', this.vm);\n\t      return;\n\t    }\n\t    forContext._withLock(function () {\n\t      if (scope.$key) {\n\t        // original is an object\n\t        forContext.rawValue[scope.$key] = value;\n\t      } else {\n\t        forContext.rawValue.$set(scope.$index, value);\n\t      }\n\t    });\n\t  }\n\t};\n\t\n\t/**\n\t * Prepare for dependency collection.\n\t */\n\t\n\tWatcher.prototype.beforeGet = function () {\n\t  Dep.target = this;\n\t};\n\t\n\t/**\n\t * Add a dependency to this directive.\n\t *\n\t * @param {Dep} dep\n\t */\n\t\n\tWatcher.prototype.addDep = function (dep) {\n\t  var id = dep.id;\n\t  if (!this.newDepIds.has(id)) {\n\t    this.newDepIds.add(id);\n\t    this.newDeps.push(dep);\n\t    if (!this.depIds.has(id)) {\n\t      dep.addSub(this);\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Clean up for dependency collection.\n\t */\n\t\n\tWatcher.prototype.afterGet = function () {\n\t  Dep.target = null;\n\t  var i = this.deps.length;\n\t  while (i--) {\n\t    var dep = this.deps[i];\n\t    if (!this.newDepIds.has(dep.id)) {\n\t      dep.removeSub(this);\n\t    }\n\t  }\n\t  var tmp = this.depIds;\n\t  this.depIds = this.newDepIds;\n\t  this.newDepIds = tmp;\n\t  this.newDepIds.clear();\n\t  tmp = this.deps;\n\t  this.deps = this.newDeps;\n\t  this.newDeps = tmp;\n\t  this.newDeps.length = 0;\n\t};\n\t\n\t/**\n\t * Subscriber interface.\n\t * Will be called when a dependency changes.\n\t *\n\t * @param {Boolean} shallow\n\t */\n\t\n\tWatcher.prototype.update = function (shallow) {\n\t  if (this.lazy) {\n\t    this.dirty = true;\n\t  } else if (this.sync || !config.async) {\n\t    this.run();\n\t  } else {\n\t    // if queued, only overwrite shallow with non-shallow,\n\t    // but not the other way around.\n\t    this.shallow = this.queued ? shallow ? this.shallow : false : !!shallow;\n\t    this.queued = true;\n\t    // record before-push error stack in debug mode\n\t    /* istanbul ignore if */\n\t    if (false) {\n\t      this.prevError = new Error('[vue] async stack trace');\n\t    }\n\t    pushWatcher(this);\n\t  }\n\t};\n\t\n\t/**\n\t * Batcher job interface.\n\t * Will be called by the batcher.\n\t */\n\t\n\tWatcher.prototype.run = function () {\n\t  if (this.active) {\n\t    var value = this.get();\n\t    if (value !== this.value ||\n\t    // Deep watchers and watchers on Object/Arrays should fire even\n\t    // when the value is the same, because the value may\n\t    // have mutated; but only do so if this is a\n\t    // non-shallow update (caused by a vm digest).\n\t    (isObject(value) || this.deep) && !this.shallow) {\n\t      // set new value\n\t      var oldValue = this.value;\n\t      this.value = value;\n\t      // in debug + async mode, when a watcher callbacks\n\t      // throws, we also throw the saved before-push error\n\t      // so the full cross-tick stack trace is available.\n\t      var prevError = this.prevError;\n\t      /* istanbul ignore if */\n\t      if (false) {\n\t        this.prevError = null;\n\t        try {\n\t          this.cb.call(this.vm, value, oldValue);\n\t        } catch (e) {\n\t          nextTick(function () {\n\t            throw prevError;\n\t          }, 0);\n\t          throw e;\n\t        }\n\t      } else {\n\t        this.cb.call(this.vm, value, oldValue);\n\t      }\n\t    }\n\t    this.queued = this.shallow = false;\n\t  }\n\t};\n\t\n\t/**\n\t * Evaluate the value of the watcher.\n\t * This only gets called for lazy watchers.\n\t */\n\t\n\tWatcher.prototype.evaluate = function () {\n\t  // avoid overwriting another watcher that is being\n\t  // collected.\n\t  var current = Dep.target;\n\t  this.value = this.get();\n\t  this.dirty = false;\n\t  Dep.target = current;\n\t};\n\t\n\t/**\n\t * Depend on all deps collected by this watcher.\n\t */\n\t\n\tWatcher.prototype.depend = function () {\n\t  var i = this.deps.length;\n\t  while (i--) {\n\t    this.deps[i].depend();\n\t  }\n\t};\n\t\n\t/**\n\t * Remove self from all dependencies' subcriber list.\n\t */\n\t\n\tWatcher.prototype.teardown = function () {\n\t  if (this.active) {\n\t    // remove self from vm's watcher list\n\t    // this is a somewhat expensive operation so we skip it\n\t    // if the vm is being destroyed or is performing a v-for\n\t    // re-render (the watcher list is then filtered by v-for).\n\t    if (!this.vm._isBeingDestroyed && !this.vm._vForRemoving) {\n\t      this.vm._watchers.$remove(this);\n\t    }\n\t    var i = this.deps.length;\n\t    while (i--) {\n\t      this.deps[i].removeSub(this);\n\t    }\n\t    this.active = false;\n\t    this.vm = this.cb = this.value = null;\n\t  }\n\t};\n\t\n\t/**\n\t * Recrusively traverse an object to evoke all converted\n\t * getters, so that every nested property inside the object\n\t * is collected as a \"deep\" dependency.\n\t *\n\t * @param {*} val\n\t */\n\t\n\tvar seenObjects = new _Set();\n\tfunction traverse(val, seen) {\n\t  var i = undefined,\n\t      keys = undefined;\n\t  if (!seen) {\n\t    seen = seenObjects;\n\t    seen.clear();\n\t  }\n\t  var isA = isArray(val);\n\t  var isO = isObject(val);\n\t  if (isA || isO) {\n\t    if (val.__ob__) {\n\t      var depId = val.__ob__.dep.id;\n\t      if (seen.has(depId)) {\n\t        return;\n\t      } else {\n\t        seen.add(depId);\n\t      }\n\t    }\n\t    if (isA) {\n\t      i = val.length;\n\t      while (i--) traverse(val[i], seen);\n\t    } else if (isO) {\n\t      keys = Object.keys(val);\n\t      i = keys.length;\n\t      while (i--) traverse(val[keys[i]], seen);\n\t    }\n\t  }\n\t}\n\t\n\tvar text$1 = {\n\t\n\t  bind: function bind() {\n\t    this.attr = this.el.nodeType === 3 ? 'data' : 'textContent';\n\t  },\n\t\n\t  update: function update(value) {\n\t    this.el[this.attr] = _toString(value);\n\t  }\n\t};\n\t\n\tvar templateCache = new Cache(1000);\n\tvar idSelectorCache = new Cache(1000);\n\t\n\tvar map = {\n\t  efault: [0, '', ''],\n\t  legend: [1, '<fieldset>', '</fieldset>'],\n\t  tr: [2, '<table><tbody>', '</tbody></table>'],\n\t  col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>']\n\t};\n\t\n\tmap.td = map.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];\n\t\n\tmap.option = map.optgroup = [1, '<select multiple=\"multiple\">', '</select>'];\n\t\n\tmap.thead = map.tbody = map.colgroup = map.caption = map.tfoot = [1, '<table>', '</table>'];\n\t\n\tmap.g = map.defs = map.symbol = map.use = map.image = map.text = map.circle = map.ellipse = map.line = map.path = map.polygon = map.polyline = map.rect = [1, '<svg ' + 'xmlns=\"http://www.w3.org/2000/svg\" ' + 'xmlns:xlink=\"http://www.w3.org/1999/xlink\" ' + 'xmlns:ev=\"http://www.w3.org/2001/xml-events\"' + 'version=\"1.1\">', '</svg>'];\n\t\n\t/**\n\t * Check if a node is a supported template node with a\n\t * DocumentFragment content.\n\t *\n\t * @param {Node} node\n\t * @return {Boolean}\n\t */\n\t\n\tfunction isRealTemplate(node) {\n\t  return isTemplate(node) && isFragment(node.content);\n\t}\n\t\n\tvar tagRE$1 = /<([\\w:-]+)/;\n\tvar entityRE = /&#?\\w+?;/;\n\tvar commentRE = /<!--/;\n\t\n\t/**\n\t * Convert a string template to a DocumentFragment.\n\t * Determines correct wrapping by tag types. Wrapping\n\t * strategy found in jQuery & component/domify.\n\t *\n\t * @param {String} templateString\n\t * @param {Boolean} raw\n\t * @return {DocumentFragment}\n\t */\n\t\n\tfunction stringToFragment(templateString, raw) {\n\t  // try a cache hit first\n\t  var cacheKey = raw ? templateString : templateString.trim();\n\t  var hit = templateCache.get(cacheKey);\n\t  if (hit) {\n\t    return hit;\n\t  }\n\t\n\t  var frag = document.createDocumentFragment();\n\t  var tagMatch = templateString.match(tagRE$1);\n\t  var entityMatch = entityRE.test(templateString);\n\t  var commentMatch = commentRE.test(templateString);\n\t\n\t  if (!tagMatch && !entityMatch && !commentMatch) {\n\t    // text only, return a single text node.\n\t    frag.appendChild(document.createTextNode(templateString));\n\t  } else {\n\t    var tag = tagMatch && tagMatch[1];\n\t    var wrap = map[tag] || map.efault;\n\t    var depth = wrap[0];\n\t    var prefix = wrap[1];\n\t    var suffix = wrap[2];\n\t    var node = document.createElement('div');\n\t\n\t    node.innerHTML = prefix + templateString + suffix;\n\t    while (depth--) {\n\t      node = node.lastChild;\n\t    }\n\t\n\t    var child;\n\t    /* eslint-disable no-cond-assign */\n\t    while (child = node.firstChild) {\n\t      /* eslint-enable no-cond-assign */\n\t      frag.appendChild(child);\n\t    }\n\t  }\n\t  if (!raw) {\n\t    trimNode(frag);\n\t  }\n\t  templateCache.put(cacheKey, frag);\n\t  return frag;\n\t}\n\t\n\t/**\n\t * Convert a template node to a DocumentFragment.\n\t *\n\t * @param {Node} node\n\t * @return {DocumentFragment}\n\t */\n\t\n\tfunction nodeToFragment(node) {\n\t  // if its a template tag and the browser supports it,\n\t  // its content is already a document fragment. However, iOS Safari has\n\t  // bug when using directly cloned template content with touch\n\t  // events and can cause crashes when the nodes are removed from DOM, so we\n\t  // have to treat template elements as string templates. (#2805)\n\t  /* istanbul ignore if */\n\t  if (isRealTemplate(node)) {\n\t    return stringToFragment(node.innerHTML);\n\t  }\n\t  // script template\n\t  if (node.tagName === 'SCRIPT') {\n\t    return stringToFragment(node.textContent);\n\t  }\n\t  // normal node, clone it to avoid mutating the original\n\t  var clonedNode = cloneNode(node);\n\t  var frag = document.createDocumentFragment();\n\t  var child;\n\t  /* eslint-disable no-cond-assign */\n\t  while (child = clonedNode.firstChild) {\n\t    /* eslint-enable no-cond-assign */\n\t    frag.appendChild(child);\n\t  }\n\t  trimNode(frag);\n\t  return frag;\n\t}\n\t\n\t// Test for the presence of the Safari template cloning bug\n\t// https://bugs.webkit.org/showug.cgi?id=137755\n\tvar hasBrokenTemplate = (function () {\n\t  /* istanbul ignore else */\n\t  if (inBrowser) {\n\t    var a = document.createElement('div');\n\t    a.innerHTML = '<template>1</template>';\n\t    return !a.cloneNode(true).firstChild.innerHTML;\n\t  } else {\n\t    return false;\n\t  }\n\t})();\n\t\n\t// Test for IE10/11 textarea placeholder clone bug\n\tvar hasTextareaCloneBug = (function () {\n\t  /* istanbul ignore else */\n\t  if (inBrowser) {\n\t    var t = document.createElement('textarea');\n\t    t.placeholder = 't';\n\t    return t.cloneNode(true).value === 't';\n\t  } else {\n\t    return false;\n\t  }\n\t})();\n\t\n\t/**\n\t * 1. Deal with Safari cloning nested <template> bug by\n\t *    manually cloning all template instances.\n\t * 2. Deal with IE10/11 textarea placeholder bug by setting\n\t *    the correct value after cloning.\n\t *\n\t * @param {Element|DocumentFragment} node\n\t * @return {Element|DocumentFragment}\n\t */\n\t\n\tfunction cloneNode(node) {\n\t  /* istanbul ignore if */\n\t  if (!node.querySelectorAll) {\n\t    return node.cloneNode();\n\t  }\n\t  var res = node.cloneNode(true);\n\t  var i, original, cloned;\n\t  /* istanbul ignore if */\n\t  if (hasBrokenTemplate) {\n\t    var tempClone = res;\n\t    if (isRealTemplate(node)) {\n\t      node = node.content;\n\t      tempClone = res.content;\n\t    }\n\t    original = node.querySelectorAll('template');\n\t    if (original.length) {\n\t      cloned = tempClone.querySelectorAll('template');\n\t      i = cloned.length;\n\t      while (i--) {\n\t        cloned[i].parentNode.replaceChild(cloneNode(original[i]), cloned[i]);\n\t      }\n\t    }\n\t  }\n\t  /* istanbul ignore if */\n\t  if (hasTextareaCloneBug) {\n\t    if (node.tagName === 'TEXTAREA') {\n\t      res.value = node.value;\n\t    } else {\n\t      original = node.querySelectorAll('textarea');\n\t      if (original.length) {\n\t        cloned = res.querySelectorAll('textarea');\n\t        i = cloned.length;\n\t        while (i--) {\n\t          cloned[i].value = original[i].value;\n\t        }\n\t      }\n\t    }\n\t  }\n\t  return res;\n\t}\n\t\n\t/**\n\t * Process the template option and normalizes it into a\n\t * a DocumentFragment that can be used as a partial or a\n\t * instance template.\n\t *\n\t * @param {*} template\n\t *        Possible values include:\n\t *        - DocumentFragment object\n\t *        - Node object of type Template\n\t *        - id selector: '#some-template-id'\n\t *        - template string: '<div><span>{{msg}}</span></div>'\n\t * @param {Boolean} shouldClone\n\t * @param {Boolean} raw\n\t *        inline HTML interpolation. Do not check for id\n\t *        selector and keep whitespace in the string.\n\t * @return {DocumentFragment|undefined}\n\t */\n\t\n\tfunction parseTemplate(template, shouldClone, raw) {\n\t  var node, frag;\n\t\n\t  // if the template is already a document fragment,\n\t  // do nothing\n\t  if (isFragment(template)) {\n\t    trimNode(template);\n\t    return shouldClone ? cloneNode(template) : template;\n\t  }\n\t\n\t  if (typeof template === 'string') {\n\t    // id selector\n\t    if (!raw && template.charAt(0) === '#') {\n\t      // id selector can be cached too\n\t      frag = idSelectorCache.get(template);\n\t      if (!frag) {\n\t        node = document.getElementById(template.slice(1));\n\t        if (node) {\n\t          frag = nodeToFragment(node);\n\t          // save selector to cache\n\t          idSelectorCache.put(template, frag);\n\t        }\n\t      }\n\t    } else {\n\t      // normal string template\n\t      frag = stringToFragment(template, raw);\n\t    }\n\t  } else if (template.nodeType) {\n\t    // a direct node\n\t    frag = nodeToFragment(template);\n\t  }\n\t\n\t  return frag && shouldClone ? cloneNode(frag) : frag;\n\t}\n\t\n\tvar template = Object.freeze({\n\t  cloneNode: cloneNode,\n\t  parseTemplate: parseTemplate\n\t});\n\t\n\tvar html = {\n\t\n\t  bind: function bind() {\n\t    // a comment node means this is a binding for\n\t    // {{{ inline unescaped html }}}\n\t    if (this.el.nodeType === 8) {\n\t      // hold nodes\n\t      this.nodes = [];\n\t      // replace the placeholder with proper anchor\n\t      this.anchor = createAnchor('v-html');\n\t      replace(this.el, this.anchor);\n\t    }\n\t  },\n\t\n\t  update: function update(value) {\n\t    value = _toString(value);\n\t    if (this.nodes) {\n\t      this.swap(value);\n\t    } else {\n\t      this.el.innerHTML = value;\n\t    }\n\t  },\n\t\n\t  swap: function swap(value) {\n\t    // remove old nodes\n\t    var i = this.nodes.length;\n\t    while (i--) {\n\t      remove(this.nodes[i]);\n\t    }\n\t    // convert new value to a fragment\n\t    // do not attempt to retrieve from id selector\n\t    var frag = parseTemplate(value, true, true);\n\t    // save a reference to these nodes so we can remove later\n\t    this.nodes = toArray(frag.childNodes);\n\t    before(frag, this.anchor);\n\t  }\n\t};\n\t\n\t/**\n\t * Abstraction for a partially-compiled fragment.\n\t * Can optionally compile content with a child scope.\n\t *\n\t * @param {Function} linker\n\t * @param {Vue} vm\n\t * @param {DocumentFragment} frag\n\t * @param {Vue} [host]\n\t * @param {Object} [scope]\n\t * @param {Fragment} [parentFrag]\n\t */\n\tfunction Fragment(linker, vm, frag, host, scope, parentFrag) {\n\t  this.children = [];\n\t  this.childFrags = [];\n\t  this.vm = vm;\n\t  this.scope = scope;\n\t  this.inserted = false;\n\t  this.parentFrag = parentFrag;\n\t  if (parentFrag) {\n\t    parentFrag.childFrags.push(this);\n\t  }\n\t  this.unlink = linker(vm, frag, host, scope, this);\n\t  var single = this.single = frag.childNodes.length === 1 &&\n\t  // do not go single mode if the only node is an anchor\n\t  !frag.childNodes[0].__v_anchor;\n\t  if (single) {\n\t    this.node = frag.childNodes[0];\n\t    this.before = singleBefore;\n\t    this.remove = singleRemove;\n\t  } else {\n\t    this.node = createAnchor('fragment-start');\n\t    this.end = createAnchor('fragment-end');\n\t    this.frag = frag;\n\t    prepend(this.node, frag);\n\t    frag.appendChild(this.end);\n\t    this.before = multiBefore;\n\t    this.remove = multiRemove;\n\t  }\n\t  this.node.__v_frag = this;\n\t}\n\t\n\t/**\n\t * Call attach/detach for all components contained within\n\t * this fragment. Also do so recursively for all child\n\t * fragments.\n\t *\n\t * @param {Function} hook\n\t */\n\t\n\tFragment.prototype.callHook = function (hook) {\n\t  var i, l;\n\t  for (i = 0, l = this.childFrags.length; i < l; i++) {\n\t    this.childFrags[i].callHook(hook);\n\t  }\n\t  for (i = 0, l = this.children.length; i < l; i++) {\n\t    hook(this.children[i]);\n\t  }\n\t};\n\t\n\t/**\n\t * Insert fragment before target, single node version\n\t *\n\t * @param {Node} target\n\t * @param {Boolean} withTransition\n\t */\n\t\n\tfunction singleBefore(target, withTransition) {\n\t  this.inserted = true;\n\t  var method = withTransition !== false ? beforeWithTransition : before;\n\t  method(this.node, target, this.vm);\n\t  if (inDoc(this.node)) {\n\t    this.callHook(attach);\n\t  }\n\t}\n\t\n\t/**\n\t * Remove fragment, single node version\n\t */\n\t\n\tfunction singleRemove() {\n\t  this.inserted = false;\n\t  var shouldCallRemove = inDoc(this.node);\n\t  var self = this;\n\t  this.beforeRemove();\n\t  removeWithTransition(this.node, this.vm, function () {\n\t    if (shouldCallRemove) {\n\t      self.callHook(detach);\n\t    }\n\t    self.destroy();\n\t  });\n\t}\n\t\n\t/**\n\t * Insert fragment before target, multi-nodes version\n\t *\n\t * @param {Node} target\n\t * @param {Boolean} withTransition\n\t */\n\t\n\tfunction multiBefore(target, withTransition) {\n\t  this.inserted = true;\n\t  var vm = this.vm;\n\t  var method = withTransition !== false ? beforeWithTransition : before;\n\t  mapNodeRange(this.node, this.end, function (node) {\n\t    method(node, target, vm);\n\t  });\n\t  if (inDoc(this.node)) {\n\t    this.callHook(attach);\n\t  }\n\t}\n\t\n\t/**\n\t * Remove fragment, multi-nodes version\n\t */\n\t\n\tfunction multiRemove() {\n\t  this.inserted = false;\n\t  var self = this;\n\t  var shouldCallRemove = inDoc(this.node);\n\t  this.beforeRemove();\n\t  removeNodeRange(this.node, this.end, this.vm, this.frag, function () {\n\t    if (shouldCallRemove) {\n\t      self.callHook(detach);\n\t    }\n\t    self.destroy();\n\t  });\n\t}\n\t\n\t/**\n\t * Prepare the fragment for removal.\n\t */\n\t\n\tFragment.prototype.beforeRemove = function () {\n\t  var i, l;\n\t  for (i = 0, l = this.childFrags.length; i < l; i++) {\n\t    // call the same method recursively on child\n\t    // fragments, depth-first\n\t    this.childFrags[i].beforeRemove(false);\n\t  }\n\t  for (i = 0, l = this.children.length; i < l; i++) {\n\t    // Call destroy for all contained instances,\n\t    // with remove:false and defer:true.\n\t    // Defer is necessary because we need to\n\t    // keep the children to call detach hooks\n\t    // on them.\n\t    this.children[i].$destroy(false, true);\n\t  }\n\t  var dirs = this.unlink.dirs;\n\t  for (i = 0, l = dirs.length; i < l; i++) {\n\t    // disable the watchers on all the directives\n\t    // so that the rendered content stays the same\n\t    // during removal.\n\t    dirs[i]._watcher && dirs[i]._watcher.teardown();\n\t  }\n\t};\n\t\n\t/**\n\t * Destroy the fragment.\n\t */\n\t\n\tFragment.prototype.destroy = function () {\n\t  if (this.parentFrag) {\n\t    this.parentFrag.childFrags.$remove(this);\n\t  }\n\t  this.node.__v_frag = null;\n\t  this.unlink();\n\t};\n\t\n\t/**\n\t * Call attach hook for a Vue instance.\n\t *\n\t * @param {Vue} child\n\t */\n\t\n\tfunction attach(child) {\n\t  if (!child._isAttached && inDoc(child.$el)) {\n\t    child._callHook('attached');\n\t  }\n\t}\n\t\n\t/**\n\t * Call detach hook for a Vue instance.\n\t *\n\t * @param {Vue} child\n\t */\n\t\n\tfunction detach(child) {\n\t  if (child._isAttached && !inDoc(child.$el)) {\n\t    child._callHook('detached');\n\t  }\n\t}\n\t\n\tvar linkerCache = new Cache(5000);\n\t\n\t/**\n\t * A factory that can be used to create instances of a\n\t * fragment. Caches the compiled linker if possible.\n\t *\n\t * @param {Vue} vm\n\t * @param {Element|String} el\n\t */\n\tfunction FragmentFactory(vm, el) {\n\t  this.vm = vm;\n\t  var template;\n\t  var isString = typeof el === 'string';\n\t  if (isString || isTemplate(el) && !el.hasAttribute('v-if')) {\n\t    template = parseTemplate(el, true);\n\t  } else {\n\t    template = document.createDocumentFragment();\n\t    template.appendChild(el);\n\t  }\n\t  this.template = template;\n\t  // linker can be cached, but only for components\n\t  var linker;\n\t  var cid = vm.constructor.cid;\n\t  if (cid > 0) {\n\t    var cacheId = cid + (isString ? el : getOuterHTML(el));\n\t    linker = linkerCache.get(cacheId);\n\t    if (!linker) {\n\t      linker = compile(template, vm.$options, true);\n\t      linkerCache.put(cacheId, linker);\n\t    }\n\t  } else {\n\t    linker = compile(template, vm.$options, true);\n\t  }\n\t  this.linker = linker;\n\t}\n\t\n\t/**\n\t * Create a fragment instance with given host and scope.\n\t *\n\t * @param {Vue} host\n\t * @param {Object} scope\n\t * @param {Fragment} parentFrag\n\t */\n\t\n\tFragmentFactory.prototype.create = function (host, scope, parentFrag) {\n\t  var frag = cloneNode(this.template);\n\t  return new Fragment(this.linker, this.vm, frag, host, scope, parentFrag);\n\t};\n\t\n\tvar ON = 700;\n\tvar MODEL = 800;\n\tvar BIND = 850;\n\tvar TRANSITION = 1100;\n\tvar EL = 1500;\n\tvar COMPONENT = 1500;\n\tvar PARTIAL = 1750;\n\tvar IF = 2100;\n\tvar FOR = 2200;\n\tvar SLOT = 2300;\n\t\n\tvar uid$3 = 0;\n\t\n\tvar vFor = {\n\t\n\t  priority: FOR,\n\t  terminal: true,\n\t\n\t  params: ['track-by', 'stagger', 'enter-stagger', 'leave-stagger'],\n\t\n\t  bind: function bind() {\n\t    // support \"item in/of items\" syntax\n\t    var inMatch = this.expression.match(/(.*) (?:in|of) (.*)/);\n\t    if (inMatch) {\n\t      var itMatch = inMatch[1].match(/\\((.*),(.*)\\)/);\n\t      if (itMatch) {\n\t        this.iterator = itMatch[1].trim();\n\t        this.alias = itMatch[2].trim();\n\t      } else {\n\t        this.alias = inMatch[1].trim();\n\t      }\n\t      this.expression = inMatch[2];\n\t    }\n\t\n\t    if (!this.alias) {\n\t      (\"production\") !== 'production' && warn('Invalid v-for expression \"' + this.descriptor.raw + '\": ' + 'alias is required.', this.vm);\n\t      return;\n\t    }\n\t\n\t    // uid as a cache identifier\n\t    this.id = '__v-for__' + ++uid$3;\n\t\n\t    // check if this is an option list,\n\t    // so that we know if we need to update the <select>'s\n\t    // v-model when the option list has changed.\n\t    // because v-model has a lower priority than v-for,\n\t    // the v-model is not bound here yet, so we have to\n\t    // retrive it in the actual updateModel() function.\n\t    var tag = this.el.tagName;\n\t    this.isOption = (tag === 'OPTION' || tag === 'OPTGROUP') && this.el.parentNode.tagName === 'SELECT';\n\t\n\t    // setup anchor nodes\n\t    this.start = createAnchor('v-for-start');\n\t    this.end = createAnchor('v-for-end');\n\t    replace(this.el, this.end);\n\t    before(this.start, this.end);\n\t\n\t    // cache\n\t    this.cache = Object.create(null);\n\t\n\t    // fragment factory\n\t    this.factory = new FragmentFactory(this.vm, this.el);\n\t  },\n\t\n\t  update: function update(data) {\n\t    this.diff(data);\n\t    this.updateRef();\n\t    this.updateModel();\n\t  },\n\t\n\t  /**\n\t   * Diff, based on new data and old data, determine the\n\t   * minimum amount of DOM manipulations needed to make the\n\t   * DOM reflect the new data Array.\n\t   *\n\t   * The algorithm diffs the new data Array by storing a\n\t   * hidden reference to an owner vm instance on previously\n\t   * seen data. This allows us to achieve O(n) which is\n\t   * better than a levenshtein distance based algorithm,\n\t   * which is O(m * n).\n\t   *\n\t   * @param {Array} data\n\t   */\n\t\n\t  diff: function diff(data) {\n\t    // check if the Array was converted from an Object\n\t    var item = data[0];\n\t    var convertedFromObject = this.fromObject = isObject(item) && hasOwn(item, '$key') && hasOwn(item, '$value');\n\t\n\t    var trackByKey = this.params.trackBy;\n\t    var oldFrags = this.frags;\n\t    var frags = this.frags = new Array(data.length);\n\t    var alias = this.alias;\n\t    var iterator = this.iterator;\n\t    var start = this.start;\n\t    var end = this.end;\n\t    var inDocument = inDoc(start);\n\t    var init = !oldFrags;\n\t    var i, l, frag, key, value, primitive;\n\t\n\t    // First pass, go through the new Array and fill up\n\t    // the new frags array. If a piece of data has a cached\n\t    // instance for it, we reuse it. Otherwise build a new\n\t    // instance.\n\t    for (i = 0, l = data.length; i < l; i++) {\n\t      item = data[i];\n\t      key = convertedFromObject ? item.$key : null;\n\t      value = convertedFromObject ? item.$value : item;\n\t      primitive = !isObject(value);\n\t      frag = !init && this.getCachedFrag(value, i, key);\n\t      if (frag) {\n\t        // reusable fragment\n\t        frag.reused = true;\n\t        // update $index\n\t        frag.scope.$index = i;\n\t        // update $key\n\t        if (key) {\n\t          frag.scope.$key = key;\n\t        }\n\t        // update iterator\n\t        if (iterator) {\n\t          frag.scope[iterator] = key !== null ? key : i;\n\t        }\n\t        // update data for track-by, object repeat &\n\t        // primitive values.\n\t        if (trackByKey || convertedFromObject || primitive) {\n\t          withoutConversion(function () {\n\t            frag.scope[alias] = value;\n\t          });\n\t        }\n\t      } else {\n\t        // new isntance\n\t        frag = this.create(value, alias, i, key);\n\t        frag.fresh = !init;\n\t      }\n\t      frags[i] = frag;\n\t      if (init) {\n\t        frag.before(end);\n\t      }\n\t    }\n\t\n\t    // we're done for the initial render.\n\t    if (init) {\n\t      return;\n\t    }\n\t\n\t    // Second pass, go through the old fragments and\n\t    // destroy those who are not reused (and remove them\n\t    // from cache)\n\t    var removalIndex = 0;\n\t    var totalRemoved = oldFrags.length - frags.length;\n\t    // when removing a large number of fragments, watcher removal\n\t    // turns out to be a perf bottleneck, so we batch the watcher\n\t    // removals into a single filter call!\n\t    this.vm._vForRemoving = true;\n\t    for (i = 0, l = oldFrags.length; i < l; i++) {\n\t      frag = oldFrags[i];\n\t      if (!frag.reused) {\n\t        this.deleteCachedFrag(frag);\n\t        this.remove(frag, removalIndex++, totalRemoved, inDocument);\n\t      }\n\t    }\n\t    this.vm._vForRemoving = false;\n\t    if (removalIndex) {\n\t      this.vm._watchers = this.vm._watchers.filter(function (w) {\n\t        return w.active;\n\t      });\n\t    }\n\t\n\t    // Final pass, move/insert new fragments into the\n\t    // right place.\n\t    var targetPrev, prevEl, currentPrev;\n\t    var insertionIndex = 0;\n\t    for (i = 0, l = frags.length; i < l; i++) {\n\t      frag = frags[i];\n\t      // this is the frag that we should be after\n\t      targetPrev = frags[i - 1];\n\t      prevEl = targetPrev ? targetPrev.staggerCb ? targetPrev.staggerAnchor : targetPrev.end || targetPrev.node : start;\n\t      if (frag.reused && !frag.staggerCb) {\n\t        currentPrev = findPrevFrag(frag, start, this.id);\n\t        if (currentPrev !== targetPrev && (!currentPrev ||\n\t        // optimization for moving a single item.\n\t        // thanks to suggestions by @livoras in #1807\n\t        findPrevFrag(currentPrev, start, this.id) !== targetPrev)) {\n\t          this.move(frag, prevEl);\n\t        }\n\t      } else {\n\t        // new instance, or still in stagger.\n\t        // insert with updated stagger index.\n\t        this.insert(frag, insertionIndex++, prevEl, inDocument);\n\t      }\n\t      frag.reused = frag.fresh = false;\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Create a new fragment instance.\n\t   *\n\t   * @param {*} value\n\t   * @param {String} alias\n\t   * @param {Number} index\n\t   * @param {String} [key]\n\t   * @return {Fragment}\n\t   */\n\t\n\t  create: function create(value, alias, index, key) {\n\t    var host = this._host;\n\t    // create iteration scope\n\t    var parentScope = this._scope || this.vm;\n\t    var scope = Object.create(parentScope);\n\t    // ref holder for the scope\n\t    scope.$refs = Object.create(parentScope.$refs);\n\t    scope.$els = Object.create(parentScope.$els);\n\t    // make sure point $parent to parent scope\n\t    scope.$parent = parentScope;\n\t    // for two-way binding on alias\n\t    scope.$forContext = this;\n\t    // define scope properties\n\t    // important: define the scope alias without forced conversion\n\t    // so that frozen data structures remain non-reactive.\n\t    withoutConversion(function () {\n\t      defineReactive(scope, alias, value);\n\t    });\n\t    defineReactive(scope, '$index', index);\n\t    if (key) {\n\t      defineReactive(scope, '$key', key);\n\t    } else if (scope.$key) {\n\t      // avoid accidental fallback\n\t      def(scope, '$key', null);\n\t    }\n\t    if (this.iterator) {\n\t      defineReactive(scope, this.iterator, key !== null ? key : index);\n\t    }\n\t    var frag = this.factory.create(host, scope, this._frag);\n\t    frag.forId = this.id;\n\t    this.cacheFrag(value, frag, index, key);\n\t    return frag;\n\t  },\n\t\n\t  /**\n\t   * Update the v-ref on owner vm.\n\t   */\n\t\n\t  updateRef: function updateRef() {\n\t    var ref = this.descriptor.ref;\n\t    if (!ref) return;\n\t    var hash = (this._scope || this.vm).$refs;\n\t    var refs;\n\t    if (!this.fromObject) {\n\t      refs = this.frags.map(findVmFromFrag);\n\t    } else {\n\t      refs = {};\n\t      this.frags.forEach(function (frag) {\n\t        refs[frag.scope.$key] = findVmFromFrag(frag);\n\t      });\n\t    }\n\t    hash[ref] = refs;\n\t  },\n\t\n\t  /**\n\t   * For option lists, update the containing v-model on\n\t   * parent <select>.\n\t   */\n\t\n\t  updateModel: function updateModel() {\n\t    if (this.isOption) {\n\t      var parent = this.start.parentNode;\n\t      var model = parent && parent.__v_model;\n\t      if (model) {\n\t        model.forceUpdate();\n\t      }\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Insert a fragment. Handles staggering.\n\t   *\n\t   * @param {Fragment} frag\n\t   * @param {Number} index\n\t   * @param {Node} prevEl\n\t   * @param {Boolean} inDocument\n\t   */\n\t\n\t  insert: function insert(frag, index, prevEl, inDocument) {\n\t    if (frag.staggerCb) {\n\t      frag.staggerCb.cancel();\n\t      frag.staggerCb = null;\n\t    }\n\t    var staggerAmount = this.getStagger(frag, index, null, 'enter');\n\t    if (inDocument && staggerAmount) {\n\t      // create an anchor and insert it synchronously,\n\t      // so that we can resolve the correct order without\n\t      // worrying about some elements not inserted yet\n\t      var anchor = frag.staggerAnchor;\n\t      if (!anchor) {\n\t        anchor = frag.staggerAnchor = createAnchor('stagger-anchor');\n\t        anchor.__v_frag = frag;\n\t      }\n\t      after(anchor, prevEl);\n\t      var op = frag.staggerCb = cancellable(function () {\n\t        frag.staggerCb = null;\n\t        frag.before(anchor);\n\t        remove(anchor);\n\t      });\n\t      setTimeout(op, staggerAmount);\n\t    } else {\n\t      var target = prevEl.nextSibling;\n\t      /* istanbul ignore if */\n\t      if (!target) {\n\t        // reset end anchor position in case the position was messed up\n\t        // by an external drag-n-drop library.\n\t        after(this.end, prevEl);\n\t        target = this.end;\n\t      }\n\t      frag.before(target);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Remove a fragment. Handles staggering.\n\t   *\n\t   * @param {Fragment} frag\n\t   * @param {Number} index\n\t   * @param {Number} total\n\t   * @param {Boolean} inDocument\n\t   */\n\t\n\t  remove: function remove(frag, index, total, inDocument) {\n\t    if (frag.staggerCb) {\n\t      frag.staggerCb.cancel();\n\t      frag.staggerCb = null;\n\t      // it's not possible for the same frag to be removed\n\t      // twice, so if we have a pending stagger callback,\n\t      // it means this frag is queued for enter but removed\n\t      // before its transition started. Since it is already\n\t      // destroyed, we can just leave it in detached state.\n\t      return;\n\t    }\n\t    var staggerAmount = this.getStagger(frag, index, total, 'leave');\n\t    if (inDocument && staggerAmount) {\n\t      var op = frag.staggerCb = cancellable(function () {\n\t        frag.staggerCb = null;\n\t        frag.remove();\n\t      });\n\t      setTimeout(op, staggerAmount);\n\t    } else {\n\t      frag.remove();\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Move a fragment to a new position.\n\t   * Force no transition.\n\t   *\n\t   * @param {Fragment} frag\n\t   * @param {Node} prevEl\n\t   */\n\t\n\t  move: function move(frag, prevEl) {\n\t    // fix a common issue with Sortable:\n\t    // if prevEl doesn't have nextSibling, this means it's\n\t    // been dragged after the end anchor. Just re-position\n\t    // the end anchor to the end of the container.\n\t    /* istanbul ignore if */\n\t    if (!prevEl.nextSibling) {\n\t      this.end.parentNode.appendChild(this.end);\n\t    }\n\t    frag.before(prevEl.nextSibling, false);\n\t  },\n\t\n\t  /**\n\t   * Cache a fragment using track-by or the object key.\n\t   *\n\t   * @param {*} value\n\t   * @param {Fragment} frag\n\t   * @param {Number} index\n\t   * @param {String} [key]\n\t   */\n\t\n\t  cacheFrag: function cacheFrag(value, frag, index, key) {\n\t    var trackByKey = this.params.trackBy;\n\t    var cache = this.cache;\n\t    var primitive = !isObject(value);\n\t    var id;\n\t    if (key || trackByKey || primitive) {\n\t      id = getTrackByKey(index, key, value, trackByKey);\n\t      if (!cache[id]) {\n\t        cache[id] = frag;\n\t      } else if (trackByKey !== '$index') {\n\t        (\"production\") !== 'production' && this.warnDuplicate(value);\n\t      }\n\t    } else {\n\t      id = this.id;\n\t      if (hasOwn(value, id)) {\n\t        if (value[id] === null) {\n\t          value[id] = frag;\n\t        } else {\n\t          (\"production\") !== 'production' && this.warnDuplicate(value);\n\t        }\n\t      } else if (Object.isExtensible(value)) {\n\t        def(value, id, frag);\n\t      } else if (false) {\n\t        warn('Frozen v-for objects cannot be automatically tracked, make sure to ' + 'provide a track-by key.');\n\t      }\n\t    }\n\t    frag.raw = value;\n\t  },\n\t\n\t  /**\n\t   * Get a cached fragment from the value/index/key\n\t   *\n\t   * @param {*} value\n\t   * @param {Number} index\n\t   * @param {String} key\n\t   * @return {Fragment}\n\t   */\n\t\n\t  getCachedFrag: function getCachedFrag(value, index, key) {\n\t    var trackByKey = this.params.trackBy;\n\t    var primitive = !isObject(value);\n\t    var frag;\n\t    if (key || trackByKey || primitive) {\n\t      var id = getTrackByKey(index, key, value, trackByKey);\n\t      frag = this.cache[id];\n\t    } else {\n\t      frag = value[this.id];\n\t    }\n\t    if (frag && (frag.reused || frag.fresh)) {\n\t      (\"production\") !== 'production' && this.warnDuplicate(value);\n\t    }\n\t    return frag;\n\t  },\n\t\n\t  /**\n\t   * Delete a fragment from cache.\n\t   *\n\t   * @param {Fragment} frag\n\t   */\n\t\n\t  deleteCachedFrag: function deleteCachedFrag(frag) {\n\t    var value = frag.raw;\n\t    var trackByKey = this.params.trackBy;\n\t    var scope = frag.scope;\n\t    var index = scope.$index;\n\t    // fix #948: avoid accidentally fall through to\n\t    // a parent repeater which happens to have $key.\n\t    var key = hasOwn(scope, '$key') && scope.$key;\n\t    var primitive = !isObject(value);\n\t    if (trackByKey || key || primitive) {\n\t      var id = getTrackByKey(index, key, value, trackByKey);\n\t      this.cache[id] = null;\n\t    } else {\n\t      value[this.id] = null;\n\t      frag.raw = null;\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Get the stagger amount for an insertion/removal.\n\t   *\n\t   * @param {Fragment} frag\n\t   * @param {Number} index\n\t   * @param {Number} total\n\t   * @param {String} type\n\t   */\n\t\n\t  getStagger: function getStagger(frag, index, total, type) {\n\t    type = type + 'Stagger';\n\t    var trans = frag.node.__v_trans;\n\t    var hooks = trans && trans.hooks;\n\t    var hook = hooks && (hooks[type] || hooks.stagger);\n\t    return hook ? hook.call(frag, index, total) : index * parseInt(this.params[type] || this.params.stagger, 10);\n\t  },\n\t\n\t  /**\n\t   * Pre-process the value before piping it through the\n\t   * filters. This is passed to and called by the watcher.\n\t   */\n\t\n\t  _preProcess: function _preProcess(value) {\n\t    // regardless of type, store the un-filtered raw value.\n\t    this.rawValue = value;\n\t    return value;\n\t  },\n\t\n\t  /**\n\t   * Post-process the value after it has been piped through\n\t   * the filters. This is passed to and called by the watcher.\n\t   *\n\t   * It is necessary for this to be called during the\n\t   * watcher's dependency collection phase because we want\n\t   * the v-for to update when the source Object is mutated.\n\t   */\n\t\n\t  _postProcess: function _postProcess(value) {\n\t    if (isArray(value)) {\n\t      return value;\n\t    } else if (isPlainObject(value)) {\n\t      // convert plain object to array.\n\t      var keys = Object.keys(value);\n\t      var i = keys.length;\n\t      var res = new Array(i);\n\t      var key;\n\t      while (i--) {\n\t        key = keys[i];\n\t        res[i] = {\n\t          $key: key,\n\t          $value: value[key]\n\t        };\n\t      }\n\t      return res;\n\t    } else {\n\t      if (typeof value === 'number' && !isNaN(value)) {\n\t        value = range(value);\n\t      }\n\t      return value || [];\n\t    }\n\t  },\n\t\n\t  unbind: function unbind() {\n\t    if (this.descriptor.ref) {\n\t      (this._scope || this.vm).$refs[this.descriptor.ref] = null;\n\t    }\n\t    if (this.frags) {\n\t      var i = this.frags.length;\n\t      var frag;\n\t      while (i--) {\n\t        frag = this.frags[i];\n\t        this.deleteCachedFrag(frag);\n\t        frag.destroy();\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Helper to find the previous element that is a fragment\n\t * anchor. This is necessary because a destroyed frag's\n\t * element could still be lingering in the DOM before its\n\t * leaving transition finishes, but its inserted flag\n\t * should have been set to false so we can skip them.\n\t *\n\t * If this is a block repeat, we want to make sure we only\n\t * return frag that is bound to this v-for. (see #929)\n\t *\n\t * @param {Fragment} frag\n\t * @param {Comment|Text} anchor\n\t * @param {String} id\n\t * @return {Fragment}\n\t */\n\t\n\tfunction findPrevFrag(frag, anchor, id) {\n\t  var el = frag.node.previousSibling;\n\t  /* istanbul ignore if */\n\t  if (!el) return;\n\t  frag = el.__v_frag;\n\t  while ((!frag || frag.forId !== id || !frag.inserted) && el !== anchor) {\n\t    el = el.previousSibling;\n\t    /* istanbul ignore if */\n\t    if (!el) return;\n\t    frag = el.__v_frag;\n\t  }\n\t  return frag;\n\t}\n\t\n\t/**\n\t * Find a vm from a fragment.\n\t *\n\t * @param {Fragment} frag\n\t * @return {Vue|undefined}\n\t */\n\t\n\tfunction findVmFromFrag(frag) {\n\t  var node = frag.node;\n\t  // handle multi-node frag\n\t  if (frag.end) {\n\t    while (!node.__vue__ && node !== frag.end && node.nextSibling) {\n\t      node = node.nextSibling;\n\t    }\n\t  }\n\t  return node.__vue__;\n\t}\n\t\n\t/**\n\t * Create a range array from given number.\n\t *\n\t * @param {Number} n\n\t * @return {Array}\n\t */\n\t\n\tfunction range(n) {\n\t  var i = -1;\n\t  var ret = new Array(Math.floor(n));\n\t  while (++i < n) {\n\t    ret[i] = i;\n\t  }\n\t  return ret;\n\t}\n\t\n\t/**\n\t * Get the track by key for an item.\n\t *\n\t * @param {Number} index\n\t * @param {String} key\n\t * @param {*} value\n\t * @param {String} [trackByKey]\n\t */\n\t\n\tfunction getTrackByKey(index, key, value, trackByKey) {\n\t  return trackByKey ? trackByKey === '$index' ? index : trackByKey.charAt(0).match(/\\w/) ? getPath(value, trackByKey) : value[trackByKey] : key || value;\n\t}\n\t\n\tif (false) {\n\t  vFor.warnDuplicate = function (value) {\n\t    warn('Duplicate value found in v-for=\"' + this.descriptor.raw + '\": ' + JSON.stringify(value) + '. Use track-by=\"$index\" if ' + 'you are expecting duplicate values.', this.vm);\n\t  };\n\t}\n\t\n\tvar vIf = {\n\t\n\t  priority: IF,\n\t  terminal: true,\n\t\n\t  bind: function bind() {\n\t    var el = this.el;\n\t    if (!el.__vue__) {\n\t      // check else block\n\t      var next = el.nextElementSibling;\n\t      if (next && getAttr(next, 'v-else') !== null) {\n\t        remove(next);\n\t        this.elseEl = next;\n\t      }\n\t      // check main block\n\t      this.anchor = createAnchor('v-if');\n\t      replace(el, this.anchor);\n\t    } else {\n\t      (\"production\") !== 'production' && warn('v-if=\"' + this.expression + '\" cannot be ' + 'used on an instance root element.', this.vm);\n\t      this.invalid = true;\n\t    }\n\t  },\n\t\n\t  update: function update(value) {\n\t    if (this.invalid) return;\n\t    if (value) {\n\t      if (!this.frag) {\n\t        this.insert();\n\t      }\n\t    } else {\n\t      this.remove();\n\t    }\n\t  },\n\t\n\t  insert: function insert() {\n\t    if (this.elseFrag) {\n\t      this.elseFrag.remove();\n\t      this.elseFrag = null;\n\t    }\n\t    // lazy init factory\n\t    if (!this.factory) {\n\t      this.factory = new FragmentFactory(this.vm, this.el);\n\t    }\n\t    this.frag = this.factory.create(this._host, this._scope, this._frag);\n\t    this.frag.before(this.anchor);\n\t  },\n\t\n\t  remove: function remove() {\n\t    if (this.frag) {\n\t      this.frag.remove();\n\t      this.frag = null;\n\t    }\n\t    if (this.elseEl && !this.elseFrag) {\n\t      if (!this.elseFactory) {\n\t        this.elseFactory = new FragmentFactory(this.elseEl._context || this.vm, this.elseEl);\n\t      }\n\t      this.elseFrag = this.elseFactory.create(this._host, this._scope, this._frag);\n\t      this.elseFrag.before(this.anchor);\n\t    }\n\t  },\n\t\n\t  unbind: function unbind() {\n\t    if (this.frag) {\n\t      this.frag.destroy();\n\t    }\n\t    if (this.elseFrag) {\n\t      this.elseFrag.destroy();\n\t    }\n\t  }\n\t};\n\t\n\tvar show = {\n\t\n\t  bind: function bind() {\n\t    // check else block\n\t    var next = this.el.nextElementSibling;\n\t    if (next && getAttr(next, 'v-else') !== null) {\n\t      this.elseEl = next;\n\t    }\n\t  },\n\t\n\t  update: function update(value) {\n\t    this.apply(this.el, value);\n\t    if (this.elseEl) {\n\t      this.apply(this.elseEl, !value);\n\t    }\n\t  },\n\t\n\t  apply: function apply(el, value) {\n\t    if (inDoc(el)) {\n\t      applyTransition(el, value ? 1 : -1, toggle, this.vm);\n\t    } else {\n\t      toggle();\n\t    }\n\t    function toggle() {\n\t      el.style.display = value ? '' : 'none';\n\t    }\n\t  }\n\t};\n\t\n\tvar text$2 = {\n\t\n\t  bind: function bind() {\n\t    var self = this;\n\t    var el = this.el;\n\t    var isRange = el.type === 'range';\n\t    var lazy = this.params.lazy;\n\t    var number = this.params.number;\n\t    var debounce = this.params.debounce;\n\t\n\t    // handle composition events.\n\t    //   http://blog.evanyou.me/2014/01/03/composition-event/\n\t    // skip this for Android because it handles composition\n\t    // events quite differently. Android doesn't trigger\n\t    // composition events for language input methods e.g.\n\t    // Chinese, but instead triggers them for spelling\n\t    // suggestions... (see Discussion/#162)\n\t    var composing = false;\n\t    if (!isAndroid && !isRange) {\n\t      this.on('compositionstart', function () {\n\t        composing = true;\n\t      });\n\t      this.on('compositionend', function () {\n\t        composing = false;\n\t        // in IE11 the \"compositionend\" event fires AFTER\n\t        // the \"input\" event, so the input handler is blocked\n\t        // at the end... have to call it here.\n\t        //\n\t        // #1327: in lazy mode this is unecessary.\n\t        if (!lazy) {\n\t          self.listener();\n\t        }\n\t      });\n\t    }\n\t\n\t    // prevent messing with the input when user is typing,\n\t    // and force update on blur.\n\t    this.focused = false;\n\t    if (!isRange && !lazy) {\n\t      this.on('focus', function () {\n\t        self.focused = true;\n\t      });\n\t      this.on('blur', function () {\n\t        self.focused = false;\n\t        // do not sync value after fragment removal (#2017)\n\t        if (!self._frag || self._frag.inserted) {\n\t          self.rawListener();\n\t        }\n\t      });\n\t    }\n\t\n\t    // Now attach the main listener\n\t    this.listener = this.rawListener = function () {\n\t      if (composing || !self._bound) {\n\t        return;\n\t      }\n\t      var val = number || isRange ? toNumber(el.value) : el.value;\n\t      self.set(val);\n\t      // force update on next tick to avoid lock & same value\n\t      // also only update when user is not typing\n\t      nextTick(function () {\n\t        if (self._bound && !self.focused) {\n\t          self.update(self._watcher.value);\n\t        }\n\t      });\n\t    };\n\t\n\t    // apply debounce\n\t    if (debounce) {\n\t      this.listener = _debounce(this.listener, debounce);\n\t    }\n\t\n\t    // Support jQuery events, since jQuery.trigger() doesn't\n\t    // trigger native events in some cases and some plugins\n\t    // rely on $.trigger()\n\t    //\n\t    // We want to make sure if a listener is attached using\n\t    // jQuery, it is also removed with jQuery, that's why\n\t    // we do the check for each directive instance and\n\t    // store that check result on itself. This also allows\n\t    // easier test coverage control by unsetting the global\n\t    // jQuery variable in tests.\n\t    this.hasjQuery = typeof jQuery === 'function';\n\t    if (this.hasjQuery) {\n\t      var method = jQuery.fn.on ? 'on' : 'bind';\n\t      jQuery(el)[method]('change', this.rawListener);\n\t      if (!lazy) {\n\t        jQuery(el)[method]('input', this.listener);\n\t      }\n\t    } else {\n\t      this.on('change', this.rawListener);\n\t      if (!lazy) {\n\t        this.on('input', this.listener);\n\t      }\n\t    }\n\t\n\t    // IE9 doesn't fire input event on backspace/del/cut\n\t    if (!lazy && isIE9) {\n\t      this.on('cut', function () {\n\t        nextTick(self.listener);\n\t      });\n\t      this.on('keyup', function (e) {\n\t        if (e.keyCode === 46 || e.keyCode === 8) {\n\t          self.listener();\n\t        }\n\t      });\n\t    }\n\t\n\t    // set initial value if present\n\t    if (el.hasAttribute('value') || el.tagName === 'TEXTAREA' && el.value.trim()) {\n\t      this.afterBind = this.listener;\n\t    }\n\t  },\n\t\n\t  update: function update(value) {\n\t    // #3029 only update when the value changes. This prevent\n\t    // browsers from overwriting values like selectionStart\n\t    value = _toString(value);\n\t    if (value !== this.el.value) this.el.value = value;\n\t  },\n\t\n\t  unbind: function unbind() {\n\t    var el = this.el;\n\t    if (this.hasjQuery) {\n\t      var method = jQuery.fn.off ? 'off' : 'unbind';\n\t      jQuery(el)[method]('change', this.listener);\n\t      jQuery(el)[method]('input', this.listener);\n\t    }\n\t  }\n\t};\n\t\n\tvar radio = {\n\t\n\t  bind: function bind() {\n\t    var self = this;\n\t    var el = this.el;\n\t\n\t    this.getValue = function () {\n\t      // value overwrite via v-bind:value\n\t      if (el.hasOwnProperty('_value')) {\n\t        return el._value;\n\t      }\n\t      var val = el.value;\n\t      if (self.params.number) {\n\t        val = toNumber(val);\n\t      }\n\t      return val;\n\t    };\n\t\n\t    this.listener = function () {\n\t      self.set(self.getValue());\n\t    };\n\t    this.on('change', this.listener);\n\t\n\t    if (el.hasAttribute('checked')) {\n\t      this.afterBind = this.listener;\n\t    }\n\t  },\n\t\n\t  update: function update(value) {\n\t    this.el.checked = looseEqual(value, this.getValue());\n\t  }\n\t};\n\t\n\tvar select = {\n\t\n\t  bind: function bind() {\n\t    var _this = this;\n\t\n\t    var self = this;\n\t    var el = this.el;\n\t\n\t    // method to force update DOM using latest value.\n\t    this.forceUpdate = function () {\n\t      if (self._watcher) {\n\t        self.update(self._watcher.get());\n\t      }\n\t    };\n\t\n\t    // check if this is a multiple select\n\t    var multiple = this.multiple = el.hasAttribute('multiple');\n\t\n\t    // attach listener\n\t    this.listener = function () {\n\t      var value = getValue(el, multiple);\n\t      value = self.params.number ? isArray(value) ? value.map(toNumber) : toNumber(value) : value;\n\t      self.set(value);\n\t    };\n\t    this.on('change', this.listener);\n\t\n\t    // if has initial value, set afterBind\n\t    var initValue = getValue(el, multiple, true);\n\t    if (multiple && initValue.length || !multiple && initValue !== null) {\n\t      this.afterBind = this.listener;\n\t    }\n\t\n\t    // All major browsers except Firefox resets\n\t    // selectedIndex with value -1 to 0 when the element\n\t    // is appended to a new parent, therefore we have to\n\t    // force a DOM update whenever that happens...\n\t    this.vm.$on('hook:attached', function () {\n\t      nextTick(_this.forceUpdate);\n\t    });\n\t  },\n\t\n\t  update: function update(value) {\n\t    var el = this.el;\n\t    if (!inDoc(el)) {\n\t      return nextTick(this.forceUpdate);\n\t    }\n\t    el.selectedIndex = -1;\n\t    var multi = this.multiple && isArray(value);\n\t    var options = el.options;\n\t    var i = options.length;\n\t    var op, val;\n\t    while (i--) {\n\t      op = options[i];\n\t      val = op.hasOwnProperty('_value') ? op._value : op.value;\n\t      /* eslint-disable eqeqeq */\n\t      op.selected = multi ? indexOf$1(value, val) > -1 : looseEqual(value, val);\n\t      /* eslint-enable eqeqeq */\n\t    }\n\t  },\n\t\n\t  unbind: function unbind() {\n\t    /* istanbul ignore next */\n\t    this.vm.$off('hook:attached', this.forceUpdate);\n\t  }\n\t};\n\t\n\t/**\n\t * Get select value\n\t *\n\t * @param {SelectElement} el\n\t * @param {Boolean} multi\n\t * @param {Boolean} init\n\t * @return {Array|*}\n\t */\n\t\n\tfunction getValue(el, multi, init) {\n\t  var res = multi ? [] : null;\n\t  var op, val, selected;\n\t  for (var i = 0, l = el.options.length; i < l; i++) {\n\t    op = el.options[i];\n\t    selected = init ? op.hasAttribute('selected') : op.selected;\n\t    if (selected) {\n\t      val = op.hasOwnProperty('_value') ? op._value : op.value;\n\t      if (multi) {\n\t        res.push(val);\n\t      } else {\n\t        return val;\n\t      }\n\t    }\n\t  }\n\t  return res;\n\t}\n\t\n\t/**\n\t * Native Array.indexOf uses strict equal, but in this\n\t * case we need to match string/numbers with custom equal.\n\t *\n\t * @param {Array} arr\n\t * @param {*} val\n\t */\n\t\n\tfunction indexOf$1(arr, val) {\n\t  var i = arr.length;\n\t  while (i--) {\n\t    if (looseEqual(arr[i], val)) {\n\t      return i;\n\t    }\n\t  }\n\t  return -1;\n\t}\n\t\n\tvar checkbox = {\n\t\n\t  bind: function bind() {\n\t    var self = this;\n\t    var el = this.el;\n\t\n\t    this.getValue = function () {\n\t      return el.hasOwnProperty('_value') ? el._value : self.params.number ? toNumber(el.value) : el.value;\n\t    };\n\t\n\t    function getBooleanValue() {\n\t      var val = el.checked;\n\t      if (val && el.hasOwnProperty('_trueValue')) {\n\t        return el._trueValue;\n\t      }\n\t      if (!val && el.hasOwnProperty('_falseValue')) {\n\t        return el._falseValue;\n\t      }\n\t      return val;\n\t    }\n\t\n\t    this.listener = function () {\n\t      var model = self._watcher.value;\n\t      if (isArray(model)) {\n\t        var val = self.getValue();\n\t        if (el.checked) {\n\t          if (indexOf(model, val) < 0) {\n\t            model.push(val);\n\t          }\n\t        } else {\n\t          model.$remove(val);\n\t        }\n\t      } else {\n\t        self.set(getBooleanValue());\n\t      }\n\t    };\n\t\n\t    this.on('change', this.listener);\n\t    if (el.hasAttribute('checked')) {\n\t      this.afterBind = this.listener;\n\t    }\n\t  },\n\t\n\t  update: function update(value) {\n\t    var el = this.el;\n\t    if (isArray(value)) {\n\t      el.checked = indexOf(value, this.getValue()) > -1;\n\t    } else {\n\t      if (el.hasOwnProperty('_trueValue')) {\n\t        el.checked = looseEqual(value, el._trueValue);\n\t      } else {\n\t        el.checked = !!value;\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\tvar handlers = {\n\t  text: text$2,\n\t  radio: radio,\n\t  select: select,\n\t  checkbox: checkbox\n\t};\n\t\n\tvar model = {\n\t\n\t  priority: MODEL,\n\t  twoWay: true,\n\t  handlers: handlers,\n\t  params: ['lazy', 'number', 'debounce'],\n\t\n\t  /**\n\t   * Possible elements:\n\t   *   <select>\n\t   *   <textarea>\n\t   *   <input type=\"*\">\n\t   *     - text\n\t   *     - checkbox\n\t   *     - radio\n\t   *     - number\n\t   */\n\t\n\t  bind: function bind() {\n\t    // friendly warning...\n\t    this.checkFilters();\n\t    if (this.hasRead && !this.hasWrite) {\n\t      (\"production\") !== 'production' && warn('It seems you are using a read-only filter with ' + 'v-model=\"' + this.descriptor.raw + '\". ' + 'You might want to use a two-way filter to ensure correct behavior.', this.vm);\n\t    }\n\t    var el = this.el;\n\t    var tag = el.tagName;\n\t    var handler;\n\t    if (tag === 'INPUT') {\n\t      handler = handlers[el.type] || handlers.text;\n\t    } else if (tag === 'SELECT') {\n\t      handler = handlers.select;\n\t    } else if (tag === 'TEXTAREA') {\n\t      handler = handlers.text;\n\t    } else {\n\t      (\"production\") !== 'production' && warn('v-model does not support element type: ' + tag, this.vm);\n\t      return;\n\t    }\n\t    el.__v_model = this;\n\t    handler.bind.call(this);\n\t    this.update = handler.update;\n\t    this._unbind = handler.unbind;\n\t  },\n\t\n\t  /**\n\t   * Check read/write filter stats.\n\t   */\n\t\n\t  checkFilters: function checkFilters() {\n\t    var filters = this.filters;\n\t    if (!filters) return;\n\t    var i = filters.length;\n\t    while (i--) {\n\t      var filter = resolveAsset(this.vm.$options, 'filters', filters[i].name);\n\t      if (typeof filter === 'function' || filter.read) {\n\t        this.hasRead = true;\n\t      }\n\t      if (filter.write) {\n\t        this.hasWrite = true;\n\t      }\n\t    }\n\t  },\n\t\n\t  unbind: function unbind() {\n\t    this.el.__v_model = null;\n\t    this._unbind && this._unbind();\n\t  }\n\t};\n\t\n\t// keyCode aliases\n\tvar keyCodes = {\n\t  esc: 27,\n\t  tab: 9,\n\t  enter: 13,\n\t  space: 32,\n\t  'delete': [8, 46],\n\t  up: 38,\n\t  left: 37,\n\t  right: 39,\n\t  down: 40\n\t};\n\t\n\tfunction keyFilter(handler, keys) {\n\t  var codes = keys.map(function (key) {\n\t    var charCode = key.charCodeAt(0);\n\t    if (charCode > 47 && charCode < 58) {\n\t      return parseInt(key, 10);\n\t    }\n\t    if (key.length === 1) {\n\t      charCode = key.toUpperCase().charCodeAt(0);\n\t      if (charCode > 64 && charCode < 91) {\n\t        return charCode;\n\t      }\n\t    }\n\t    return keyCodes[key];\n\t  });\n\t  codes = [].concat.apply([], codes);\n\t  return function keyHandler(e) {\n\t    if (codes.indexOf(e.keyCode) > -1) {\n\t      return handler.call(this, e);\n\t    }\n\t  };\n\t}\n\t\n\tfunction stopFilter(handler) {\n\t  return function stopHandler(e) {\n\t    e.stopPropagation();\n\t    return handler.call(this, e);\n\t  };\n\t}\n\t\n\tfunction preventFilter(handler) {\n\t  return function preventHandler(e) {\n\t    e.preventDefault();\n\t    return handler.call(this, e);\n\t  };\n\t}\n\t\n\tfunction selfFilter(handler) {\n\t  return function selfHandler(e) {\n\t    if (e.target === e.currentTarget) {\n\t      return handler.call(this, e);\n\t    }\n\t  };\n\t}\n\t\n\tvar on$1 = {\n\t\n\t  priority: ON,\n\t  acceptStatement: true,\n\t  keyCodes: keyCodes,\n\t\n\t  bind: function bind() {\n\t    // deal with iframes\n\t    if (this.el.tagName === 'IFRAME' && this.arg !== 'load') {\n\t      var self = this;\n\t      this.iframeBind = function () {\n\t        on(self.el.contentWindow, self.arg, self.handler, self.modifiers.capture);\n\t      };\n\t      this.on('load', this.iframeBind);\n\t    }\n\t  },\n\t\n\t  update: function update(handler) {\n\t    // stub a noop for v-on with no value,\n\t    // e.g. @mousedown.prevent\n\t    if (!this.descriptor.raw) {\n\t      handler = function () {};\n\t    }\n\t\n\t    if (typeof handler !== 'function') {\n\t      (\"production\") !== 'production' && warn('v-on:' + this.arg + '=\"' + this.expression + '\" expects a function value, ' + 'got ' + handler, this.vm);\n\t      return;\n\t    }\n\t\n\t    // apply modifiers\n\t    if (this.modifiers.stop) {\n\t      handler = stopFilter(handler);\n\t    }\n\t    if (this.modifiers.prevent) {\n\t      handler = preventFilter(handler);\n\t    }\n\t    if (this.modifiers.self) {\n\t      handler = selfFilter(handler);\n\t    }\n\t    // key filter\n\t    var keys = Object.keys(this.modifiers).filter(function (key) {\n\t      return key !== 'stop' && key !== 'prevent' && key !== 'self' && key !== 'capture';\n\t    });\n\t    if (keys.length) {\n\t      handler = keyFilter(handler, keys);\n\t    }\n\t\n\t    this.reset();\n\t    this.handler = handler;\n\t\n\t    if (this.iframeBind) {\n\t      this.iframeBind();\n\t    } else {\n\t      on(this.el, this.arg, this.handler, this.modifiers.capture);\n\t    }\n\t  },\n\t\n\t  reset: function reset() {\n\t    var el = this.iframeBind ? this.el.contentWindow : this.el;\n\t    if (this.handler) {\n\t      off(el, this.arg, this.handler);\n\t    }\n\t  },\n\t\n\t  unbind: function unbind() {\n\t    this.reset();\n\t  }\n\t};\n\t\n\tvar prefixes = ['-webkit-', '-moz-', '-ms-'];\n\tvar camelPrefixes = ['Webkit', 'Moz', 'ms'];\n\tvar importantRE = /!important;?$/;\n\tvar propCache = Object.create(null);\n\t\n\tvar testEl = null;\n\t\n\tvar style = {\n\t\n\t  deep: true,\n\t\n\t  update: function update(value) {\n\t    if (typeof value === 'string') {\n\t      this.el.style.cssText = value;\n\t    } else if (isArray(value)) {\n\t      this.handleObject(value.reduce(extend, {}));\n\t    } else {\n\t      this.handleObject(value || {});\n\t    }\n\t  },\n\t\n\t  handleObject: function handleObject(value) {\n\t    // cache object styles so that only changed props\n\t    // are actually updated.\n\t    var cache = this.cache || (this.cache = {});\n\t    var name, val;\n\t    for (name in cache) {\n\t      if (!(name in value)) {\n\t        this.handleSingle(name, null);\n\t        delete cache[name];\n\t      }\n\t    }\n\t    for (name in value) {\n\t      val = value[name];\n\t      if (val !== cache[name]) {\n\t        cache[name] = val;\n\t        this.handleSingle(name, val);\n\t      }\n\t    }\n\t  },\n\t\n\t  handleSingle: function handleSingle(prop, value) {\n\t    prop = normalize(prop);\n\t    if (!prop) return; // unsupported prop\n\t    // cast possible numbers/booleans into strings\n\t    if (value != null) value += '';\n\t    if (value) {\n\t      var isImportant = importantRE.test(value) ? 'important' : '';\n\t      if (isImportant) {\n\t        /* istanbul ignore if */\n\t        if (false) {\n\t          warn('It\\'s probably a bad idea to use !important with inline rules. ' + 'This feature will be deprecated in a future version of Vue.');\n\t        }\n\t        value = value.replace(importantRE, '').trim();\n\t        this.el.style.setProperty(prop.kebab, value, isImportant);\n\t      } else {\n\t        this.el.style[prop.camel] = value;\n\t      }\n\t    } else {\n\t      this.el.style[prop.camel] = '';\n\t    }\n\t  }\n\t\n\t};\n\t\n\t/**\n\t * Normalize a CSS property name.\n\t * - cache result\n\t * - auto prefix\n\t * - camelCase -> dash-case\n\t *\n\t * @param {String} prop\n\t * @return {String}\n\t */\n\t\n\tfunction normalize(prop) {\n\t  if (propCache[prop]) {\n\t    return propCache[prop];\n\t  }\n\t  var res = prefix(prop);\n\t  propCache[prop] = propCache[res] = res;\n\t  return res;\n\t}\n\t\n\t/**\n\t * Auto detect the appropriate prefix for a CSS property.\n\t * https://gist.github.com/paulirish/523692\n\t *\n\t * @param {String} prop\n\t * @return {String}\n\t */\n\t\n\tfunction prefix(prop) {\n\t  prop = hyphenate(prop);\n\t  var camel = camelize(prop);\n\t  var upper = camel.charAt(0).toUpperCase() + camel.slice(1);\n\t  if (!testEl) {\n\t    testEl = document.createElement('div');\n\t  }\n\t  var i = prefixes.length;\n\t  var prefixed;\n\t  if (camel !== 'filter' && camel in testEl.style) {\n\t    return {\n\t      kebab: prop,\n\t      camel: camel\n\t    };\n\t  }\n\t  while (i--) {\n\t    prefixed = camelPrefixes[i] + upper;\n\t    if (prefixed in testEl.style) {\n\t      return {\n\t        kebab: prefixes[i] + prop,\n\t        camel: prefixed\n\t      };\n\t    }\n\t  }\n\t}\n\t\n\t// xlink\n\tvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\tvar xlinkRE = /^xlink:/;\n\t\n\t// check for attributes that prohibit interpolations\n\tvar disallowedInterpAttrRE = /^v-|^:|^@|^(?:is|transition|transition-mode|debounce|track-by|stagger|enter-stagger|leave-stagger)$/;\n\t// these attributes should also set their corresponding properties\n\t// because they only affect the initial state of the element\n\tvar attrWithPropsRE = /^(?:value|checked|selected|muted)$/;\n\t// these attributes expect enumrated values of \"true\" or \"false\"\n\t// but are not boolean attributes\n\tvar enumeratedAttrRE = /^(?:draggable|contenteditable|spellcheck)$/;\n\t\n\t// these attributes should set a hidden property for\n\t// binding v-model to object values\n\tvar modelProps = {\n\t  value: '_value',\n\t  'true-value': '_trueValue',\n\t  'false-value': '_falseValue'\n\t};\n\t\n\tvar bind$1 = {\n\t\n\t  priority: BIND,\n\t\n\t  bind: function bind() {\n\t    var attr = this.arg;\n\t    var tag = this.el.tagName;\n\t    // should be deep watch on object mode\n\t    if (!attr) {\n\t      this.deep = true;\n\t    }\n\t    // handle interpolation bindings\n\t    var descriptor = this.descriptor;\n\t    var tokens = descriptor.interp;\n\t    if (tokens) {\n\t      // handle interpolations with one-time tokens\n\t      if (descriptor.hasOneTime) {\n\t        this.expression = tokensToExp(tokens, this._scope || this.vm);\n\t      }\n\t\n\t      // only allow binding on native attributes\n\t      if (disallowedInterpAttrRE.test(attr) || attr === 'name' && (tag === 'PARTIAL' || tag === 'SLOT')) {\n\t        (\"production\") !== 'production' && warn(attr + '=\"' + descriptor.raw + '\": ' + 'attribute interpolation is not allowed in Vue.js ' + 'directives and special attributes.', this.vm);\n\t        this.el.removeAttribute(attr);\n\t        this.invalid = true;\n\t      }\n\t\n\t      /* istanbul ignore if */\n\t      if (false) {\n\t        var raw = attr + '=\"' + descriptor.raw + '\": ';\n\t        // warn src\n\t        if (attr === 'src') {\n\t          warn(raw + 'interpolation in \"src\" attribute will cause ' + 'a 404 request. Use v-bind:src instead.', this.vm);\n\t        }\n\t\n\t        // warn style\n\t        if (attr === 'style') {\n\t          warn(raw + 'interpolation in \"style\" attribute will cause ' + 'the attribute to be discarded in Internet Explorer. ' + 'Use v-bind:style instead.', this.vm);\n\t        }\n\t      }\n\t    }\n\t  },\n\t\n\t  update: function update(value) {\n\t    if (this.invalid) {\n\t      return;\n\t    }\n\t    var attr = this.arg;\n\t    if (this.arg) {\n\t      this.handleSingle(attr, value);\n\t    } else {\n\t      this.handleObject(value || {});\n\t    }\n\t  },\n\t\n\t  // share object handler with v-bind:class\n\t  handleObject: style.handleObject,\n\t\n\t  handleSingle: function handleSingle(attr, value) {\n\t    var el = this.el;\n\t    var interp = this.descriptor.interp;\n\t    if (this.modifiers.camel) {\n\t      attr = camelize(attr);\n\t    }\n\t    if (!interp && attrWithPropsRE.test(attr) && attr in el) {\n\t      var attrValue = attr === 'value' ? value == null // IE9 will set input.value to \"null\" for null...\n\t      ? '' : value : value;\n\t\n\t      if (el[attr] !== attrValue) {\n\t        el[attr] = attrValue;\n\t      }\n\t    }\n\t    // set model props\n\t    var modelProp = modelProps[attr];\n\t    if (!interp && modelProp) {\n\t      el[modelProp] = value;\n\t      // update v-model if present\n\t      var model = el.__v_model;\n\t      if (model) {\n\t        model.listener();\n\t      }\n\t    }\n\t    // do not set value attribute for textarea\n\t    if (attr === 'value' && el.tagName === 'TEXTAREA') {\n\t      el.removeAttribute(attr);\n\t      return;\n\t    }\n\t    // update attribute\n\t    if (enumeratedAttrRE.test(attr)) {\n\t      el.setAttribute(attr, value ? 'true' : 'false');\n\t    } else if (value != null && value !== false) {\n\t      if (attr === 'class') {\n\t        // handle edge case #1960:\n\t        // class interpolation should not overwrite Vue transition class\n\t        if (el.__v_trans) {\n\t          value += ' ' + el.__v_trans.id + '-transition';\n\t        }\n\t        setClass(el, value);\n\t      } else if (xlinkRE.test(attr)) {\n\t        el.setAttributeNS(xlinkNS, attr, value === true ? '' : value);\n\t      } else {\n\t        el.setAttribute(attr, value === true ? '' : value);\n\t      }\n\t    } else {\n\t      el.removeAttribute(attr);\n\t    }\n\t  }\n\t};\n\t\n\tvar el = {\n\t\n\t  priority: EL,\n\t\n\t  bind: function bind() {\n\t    /* istanbul ignore if */\n\t    if (!this.arg) {\n\t      return;\n\t    }\n\t    var id = this.id = camelize(this.arg);\n\t    var refs = (this._scope || this.vm).$els;\n\t    if (hasOwn(refs, id)) {\n\t      refs[id] = this.el;\n\t    } else {\n\t      defineReactive(refs, id, this.el);\n\t    }\n\t  },\n\t\n\t  unbind: function unbind() {\n\t    var refs = (this._scope || this.vm).$els;\n\t    if (refs[this.id] === this.el) {\n\t      refs[this.id] = null;\n\t    }\n\t  }\n\t};\n\t\n\tvar ref = {\n\t  bind: function bind() {\n\t    (\"production\") !== 'production' && warn('v-ref:' + this.arg + ' must be used on a child ' + 'component. Found on <' + this.el.tagName.toLowerCase() + '>.', this.vm);\n\t  }\n\t};\n\t\n\tvar cloak = {\n\t  bind: function bind() {\n\t    var el = this.el;\n\t    this.vm.$once('pre-hook:compiled', function () {\n\t      el.removeAttribute('v-cloak');\n\t    });\n\t  }\n\t};\n\t\n\t// must export plain object\n\tvar directives = {\n\t  text: text$1,\n\t  html: html,\n\t  'for': vFor,\n\t  'if': vIf,\n\t  show: show,\n\t  model: model,\n\t  on: on$1,\n\t  bind: bind$1,\n\t  el: el,\n\t  ref: ref,\n\t  cloak: cloak\n\t};\n\t\n\tvar vClass = {\n\t\n\t  deep: true,\n\t\n\t  update: function update(value) {\n\t    if (!value) {\n\t      this.cleanup();\n\t    } else if (typeof value === 'string') {\n\t      this.setClass(value.trim().split(/\\s+/));\n\t    } else {\n\t      this.setClass(normalize$1(value));\n\t    }\n\t  },\n\t\n\t  setClass: function setClass(value) {\n\t    this.cleanup(value);\n\t    for (var i = 0, l = value.length; i < l; i++) {\n\t      var val = value[i];\n\t      if (val) {\n\t        apply(this.el, val, addClass);\n\t      }\n\t    }\n\t    this.prevKeys = value;\n\t  },\n\t\n\t  cleanup: function cleanup(value) {\n\t    var prevKeys = this.prevKeys;\n\t    if (!prevKeys) return;\n\t    var i = prevKeys.length;\n\t    while (i--) {\n\t      var key = prevKeys[i];\n\t      if (!value || value.indexOf(key) < 0) {\n\t        apply(this.el, key, removeClass);\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Normalize objects and arrays (potentially containing objects)\n\t * into array of strings.\n\t *\n\t * @param {Object|Array<String|Object>} value\n\t * @return {Array<String>}\n\t */\n\t\n\tfunction normalize$1(value) {\n\t  var res = [];\n\t  if (isArray(value)) {\n\t    for (var i = 0, l = value.length; i < l; i++) {\n\t      var _key = value[i];\n\t      if (_key) {\n\t        if (typeof _key === 'string') {\n\t          res.push(_key);\n\t        } else {\n\t          for (var k in _key) {\n\t            if (_key[k]) res.push(k);\n\t          }\n\t        }\n\t      }\n\t    }\n\t  } else if (isObject(value)) {\n\t    for (var key in value) {\n\t      if (value[key]) res.push(key);\n\t    }\n\t  }\n\t  return res;\n\t}\n\t\n\t/**\n\t * Add or remove a class/classes on an element\n\t *\n\t * @param {Element} el\n\t * @param {String} key The class name. This may or may not\n\t *                     contain a space character, in such a\n\t *                     case we'll deal with multiple class\n\t *                     names at once.\n\t * @param {Function} fn\n\t */\n\t\n\tfunction apply(el, key, fn) {\n\t  key = key.trim();\n\t  if (key.indexOf(' ') === -1) {\n\t    fn(el, key);\n\t    return;\n\t  }\n\t  // The key contains one or more space characters.\n\t  // Since a class name doesn't accept such characters, we\n\t  // treat it as multiple classes.\n\t  var keys = key.split(/\\s+/);\n\t  for (var i = 0, l = keys.length; i < l; i++) {\n\t    fn(el, keys[i]);\n\t  }\n\t}\n\t\n\tvar component = {\n\t\n\t  priority: COMPONENT,\n\t\n\t  params: ['keep-alive', 'transition-mode', 'inline-template'],\n\t\n\t  /**\n\t   * Setup. Two possible usages:\n\t   *\n\t   * - static:\n\t   *   <comp> or <div v-component=\"comp\">\n\t   *\n\t   * - dynamic:\n\t   *   <component :is=\"view\">\n\t   */\n\t\n\t  bind: function bind() {\n\t    if (!this.el.__vue__) {\n\t      // keep-alive cache\n\t      this.keepAlive = this.params.keepAlive;\n\t      if (this.keepAlive) {\n\t        this.cache = {};\n\t      }\n\t      // check inline-template\n\t      if (this.params.inlineTemplate) {\n\t        // extract inline template as a DocumentFragment\n\t        this.inlineTemplate = extractContent(this.el, true);\n\t      }\n\t      // component resolution related state\n\t      this.pendingComponentCb = this.Component = null;\n\t      // transition related state\n\t      this.pendingRemovals = 0;\n\t      this.pendingRemovalCb = null;\n\t      // create a ref anchor\n\t      this.anchor = createAnchor('v-component');\n\t      replace(this.el, this.anchor);\n\t      // remove is attribute.\n\t      // this is removed during compilation, but because compilation is\n\t      // cached, when the component is used elsewhere this attribute\n\t      // will remain at link time.\n\t      this.el.removeAttribute('is');\n\t      this.el.removeAttribute(':is');\n\t      // remove ref, same as above\n\t      if (this.descriptor.ref) {\n\t        this.el.removeAttribute('v-ref:' + hyphenate(this.descriptor.ref));\n\t      }\n\t      // if static, build right now.\n\t      if (this.literal) {\n\t        this.setComponent(this.expression);\n\t      }\n\t    } else {\n\t      (\"production\") !== 'production' && warn('cannot mount component \"' + this.expression + '\" ' + 'on already mounted element: ' + this.el);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Public update, called by the watcher in the dynamic\n\t   * literal scenario, e.g. <component :is=\"view\">\n\t   */\n\t\n\t  update: function update(value) {\n\t    if (!this.literal) {\n\t      this.setComponent(value);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Switch dynamic components. May resolve the component\n\t   * asynchronously, and perform transition based on\n\t   * specified transition mode. Accepts a few additional\n\t   * arguments specifically for vue-router.\n\t   *\n\t   * The callback is called when the full transition is\n\t   * finished.\n\t   *\n\t   * @param {String} value\n\t   * @param {Function} [cb]\n\t   */\n\t\n\t  setComponent: function setComponent(value, cb) {\n\t    this.invalidatePending();\n\t    if (!value) {\n\t      // just remove current\n\t      this.unbuild(true);\n\t      this.remove(this.childVM, cb);\n\t      this.childVM = null;\n\t    } else {\n\t      var self = this;\n\t      this.resolveComponent(value, function () {\n\t        self.mountComponent(cb);\n\t      });\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Resolve the component constructor to use when creating\n\t   * the child vm.\n\t   *\n\t   * @param {String|Function} value\n\t   * @param {Function} cb\n\t   */\n\t\n\t  resolveComponent: function resolveComponent(value, cb) {\n\t    var self = this;\n\t    this.pendingComponentCb = cancellable(function (Component) {\n\t      self.ComponentName = Component.options.name || (typeof value === 'string' ? value : null);\n\t      self.Component = Component;\n\t      cb();\n\t    });\n\t    this.vm._resolveComponent(value, this.pendingComponentCb);\n\t  },\n\t\n\t  /**\n\t   * Create a new instance using the current constructor and\n\t   * replace the existing instance. This method doesn't care\n\t   * whether the new component and the old one are actually\n\t   * the same.\n\t   *\n\t   * @param {Function} [cb]\n\t   */\n\t\n\t  mountComponent: function mountComponent(cb) {\n\t    // actual mount\n\t    this.unbuild(true);\n\t    var self = this;\n\t    var activateHooks = this.Component.options.activate;\n\t    var cached = this.getCached();\n\t    var newComponent = this.build();\n\t    if (activateHooks && !cached) {\n\t      this.waitingFor = newComponent;\n\t      callActivateHooks(activateHooks, newComponent, function () {\n\t        if (self.waitingFor !== newComponent) {\n\t          return;\n\t        }\n\t        self.waitingFor = null;\n\t        self.transition(newComponent, cb);\n\t      });\n\t    } else {\n\t      // update ref for kept-alive component\n\t      if (cached) {\n\t        newComponent._updateRef();\n\t      }\n\t      this.transition(newComponent, cb);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * When the component changes or unbinds before an async\n\t   * constructor is resolved, we need to invalidate its\n\t   * pending callback.\n\t   */\n\t\n\t  invalidatePending: function invalidatePending() {\n\t    if (this.pendingComponentCb) {\n\t      this.pendingComponentCb.cancel();\n\t      this.pendingComponentCb = null;\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Instantiate/insert a new child vm.\n\t   * If keep alive and has cached instance, insert that\n\t   * instance; otherwise build a new one and cache it.\n\t   *\n\t   * @param {Object} [extraOptions]\n\t   * @return {Vue} - the created instance\n\t   */\n\t\n\t  build: function build(extraOptions) {\n\t    var cached = this.getCached();\n\t    if (cached) {\n\t      return cached;\n\t    }\n\t    if (this.Component) {\n\t      // default options\n\t      var options = {\n\t        name: this.ComponentName,\n\t        el: cloneNode(this.el),\n\t        template: this.inlineTemplate,\n\t        // make sure to add the child with correct parent\n\t        // if this is a transcluded component, its parent\n\t        // should be the transclusion host.\n\t        parent: this._host || this.vm,\n\t        // if no inline-template, then the compiled\n\t        // linker can be cached for better performance.\n\t        _linkerCachable: !this.inlineTemplate,\n\t        _ref: this.descriptor.ref,\n\t        _asComponent: true,\n\t        _isRouterView: this._isRouterView,\n\t        // if this is a transcluded component, context\n\t        // will be the common parent vm of this instance\n\t        // and its host.\n\t        _context: this.vm,\n\t        // if this is inside an inline v-for, the scope\n\t        // will be the intermediate scope created for this\n\t        // repeat fragment. this is used for linking props\n\t        // and container directives.\n\t        _scope: this._scope,\n\t        // pass in the owner fragment of this component.\n\t        // this is necessary so that the fragment can keep\n\t        // track of its contained components in order to\n\t        // call attach/detach hooks for them.\n\t        _frag: this._frag\n\t      };\n\t      // extra options\n\t      // in 1.0.0 this is used by vue-router only\n\t      /* istanbul ignore if */\n\t      if (extraOptions) {\n\t        extend(options, extraOptions);\n\t      }\n\t      var child = new this.Component(options);\n\t      if (this.keepAlive) {\n\t        this.cache[this.Component.cid] = child;\n\t      }\n\t      /* istanbul ignore if */\n\t      if (false) {\n\t        warn('Transitions will not work on a fragment instance. ' + 'Template: ' + child.$options.template, child);\n\t      }\n\t      return child;\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Try to get a cached instance of the current component.\n\t   *\n\t   * @return {Vue|undefined}\n\t   */\n\t\n\t  getCached: function getCached() {\n\t    return this.keepAlive && this.cache[this.Component.cid];\n\t  },\n\t\n\t  /**\n\t   * Teardown the current child, but defers cleanup so\n\t   * that we can separate the destroy and removal steps.\n\t   *\n\t   * @param {Boolean} defer\n\t   */\n\t\n\t  unbuild: function unbuild(defer) {\n\t    if (this.waitingFor) {\n\t      if (!this.keepAlive) {\n\t        this.waitingFor.$destroy();\n\t      }\n\t      this.waitingFor = null;\n\t    }\n\t    var child = this.childVM;\n\t    if (!child || this.keepAlive) {\n\t      if (child) {\n\t        // remove ref\n\t        child._inactive = true;\n\t        child._updateRef(true);\n\t      }\n\t      return;\n\t    }\n\t    // the sole purpose of `deferCleanup` is so that we can\n\t    // \"deactivate\" the vm right now and perform DOM removal\n\t    // later.\n\t    child.$destroy(false, defer);\n\t  },\n\t\n\t  /**\n\t   * Remove current destroyed child and manually do\n\t   * the cleanup after removal.\n\t   *\n\t   * @param {Function} cb\n\t   */\n\t\n\t  remove: function remove(child, cb) {\n\t    var keepAlive = this.keepAlive;\n\t    if (child) {\n\t      // we may have a component switch when a previous\n\t      // component is still being transitioned out.\n\t      // we want to trigger only one lastest insertion cb\n\t      // when the existing transition finishes. (#1119)\n\t      this.pendingRemovals++;\n\t      this.pendingRemovalCb = cb;\n\t      var self = this;\n\t      child.$remove(function () {\n\t        self.pendingRemovals--;\n\t        if (!keepAlive) child._cleanup();\n\t        if (!self.pendingRemovals && self.pendingRemovalCb) {\n\t          self.pendingRemovalCb();\n\t          self.pendingRemovalCb = null;\n\t        }\n\t      });\n\t    } else if (cb) {\n\t      cb();\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Actually swap the components, depending on the\n\t   * transition mode. Defaults to simultaneous.\n\t   *\n\t   * @param {Vue} target\n\t   * @param {Function} [cb]\n\t   */\n\t\n\t  transition: function transition(target, cb) {\n\t    var self = this;\n\t    var current = this.childVM;\n\t    // for devtool inspection\n\t    if (current) current._inactive = true;\n\t    target._inactive = false;\n\t    this.childVM = target;\n\t    switch (self.params.transitionMode) {\n\t      case 'in-out':\n\t        target.$before(self.anchor, function () {\n\t          self.remove(current, cb);\n\t        });\n\t        break;\n\t      case 'out-in':\n\t        self.remove(current, function () {\n\t          target.$before(self.anchor, cb);\n\t        });\n\t        break;\n\t      default:\n\t        self.remove(current);\n\t        target.$before(self.anchor, cb);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Unbind.\n\t   */\n\t\n\t  unbind: function unbind() {\n\t    this.invalidatePending();\n\t    // Do not defer cleanup when unbinding\n\t    this.unbuild();\n\t    // destroy all keep-alive cached instances\n\t    if (this.cache) {\n\t      for (var key in this.cache) {\n\t        this.cache[key].$destroy();\n\t      }\n\t      this.cache = null;\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Call activate hooks in order (asynchronous)\n\t *\n\t * @param {Array} hooks\n\t * @param {Vue} vm\n\t * @param {Function} cb\n\t */\n\t\n\tfunction callActivateHooks(hooks, vm, cb) {\n\t  var total = hooks.length;\n\t  var called = 0;\n\t  hooks[0].call(vm, next);\n\t  function next() {\n\t    if (++called >= total) {\n\t      cb();\n\t    } else {\n\t      hooks[called].call(vm, next);\n\t    }\n\t  }\n\t}\n\t\n\tvar propBindingModes = config._propBindingModes;\n\tvar empty = {};\n\t\n\t// regexes\n\tvar identRE$1 = /^[$_a-zA-Z]+[\\w$]*$/;\n\tvar settablePathRE = /^[A-Za-z_$][\\w$]*(\\.[A-Za-z_$][\\w$]*|\\[[^\\[\\]]+\\])*$/;\n\t\n\t/**\n\t * Compile props on a root element and return\n\t * a props link function.\n\t *\n\t * @param {Element|DocumentFragment} el\n\t * @param {Array} propOptions\n\t * @param {Vue} vm\n\t * @return {Function} propsLinkFn\n\t */\n\t\n\tfunction compileProps(el, propOptions, vm) {\n\t  var props = [];\n\t  var names = Object.keys(propOptions);\n\t  var i = names.length;\n\t  var options, name, attr, value, path, parsed, prop;\n\t  while (i--) {\n\t    name = names[i];\n\t    options = propOptions[name] || empty;\n\t\n\t    if (false) {\n\t      warn('Do not use $data as prop.', vm);\n\t      continue;\n\t    }\n\t\n\t    // props could contain dashes, which will be\n\t    // interpreted as minus calculations by the parser\n\t    // so we need to camelize the path here\n\t    path = camelize(name);\n\t    if (!identRE$1.test(path)) {\n\t      (\"production\") !== 'production' && warn('Invalid prop key: \"' + name + '\". Prop keys ' + 'must be valid identifiers.', vm);\n\t      continue;\n\t    }\n\t\n\t    prop = {\n\t      name: name,\n\t      path: path,\n\t      options: options,\n\t      mode: propBindingModes.ONE_WAY,\n\t      raw: null\n\t    };\n\t\n\t    attr = hyphenate(name);\n\t    // first check dynamic version\n\t    if ((value = getBindAttr(el, attr)) === null) {\n\t      if ((value = getBindAttr(el, attr + '.sync')) !== null) {\n\t        prop.mode = propBindingModes.TWO_WAY;\n\t      } else if ((value = getBindAttr(el, attr + '.once')) !== null) {\n\t        prop.mode = propBindingModes.ONE_TIME;\n\t      }\n\t    }\n\t    if (value !== null) {\n\t      // has dynamic binding!\n\t      prop.raw = value;\n\t      parsed = parseDirective(value);\n\t      value = parsed.expression;\n\t      prop.filters = parsed.filters;\n\t      // check binding type\n\t      if (isLiteral(value) && !parsed.filters) {\n\t        // for expressions containing literal numbers and\n\t        // booleans, there's no need to setup a prop binding,\n\t        // so we can optimize them as a one-time set.\n\t        prop.optimizedLiteral = true;\n\t      } else {\n\t        prop.dynamic = true;\n\t        // check non-settable path for two-way bindings\n\t        if (false) {\n\t          prop.mode = propBindingModes.ONE_WAY;\n\t          warn('Cannot bind two-way prop with non-settable ' + 'parent path: ' + value, vm);\n\t        }\n\t      }\n\t      prop.parentPath = value;\n\t\n\t      // warn required two-way\n\t      if (false) {\n\t        warn('Prop \"' + name + '\" expects a two-way binding type.', vm);\n\t      }\n\t    } else if ((value = getAttr(el, attr)) !== null) {\n\t      // has literal binding!\n\t      prop.raw = value;\n\t    } else if (false) {\n\t      // check possible camelCase prop usage\n\t      var lowerCaseName = path.toLowerCase();\n\t      value = /[A-Z\\-]/.test(name) && (el.getAttribute(lowerCaseName) || el.getAttribute(':' + lowerCaseName) || el.getAttribute('v-bind:' + lowerCaseName) || el.getAttribute(':' + lowerCaseName + '.once') || el.getAttribute('v-bind:' + lowerCaseName + '.once') || el.getAttribute(':' + lowerCaseName + '.sync') || el.getAttribute('v-bind:' + lowerCaseName + '.sync'));\n\t      if (value) {\n\t        warn('Possible usage error for prop `' + lowerCaseName + '` - ' + 'did you mean `' + attr + '`? HTML is case-insensitive, remember to use ' + 'kebab-case for props in templates.', vm);\n\t      } else if (options.required) {\n\t        // warn missing required\n\t        warn('Missing required prop: ' + name, vm);\n\t      }\n\t    }\n\t    // push prop\n\t    props.push(prop);\n\t  }\n\t  return makePropsLinkFn(props);\n\t}\n\t\n\t/**\n\t * Build a function that applies props to a vm.\n\t *\n\t * @param {Array} props\n\t * @return {Function} propsLinkFn\n\t */\n\t\n\tfunction makePropsLinkFn(props) {\n\t  return function propsLinkFn(vm, scope) {\n\t    // store resolved props info\n\t    vm._props = {};\n\t    var inlineProps = vm.$options.propsData;\n\t    var i = props.length;\n\t    var prop, path, options, value, raw;\n\t    while (i--) {\n\t      prop = props[i];\n\t      raw = prop.raw;\n\t      path = prop.path;\n\t      options = prop.options;\n\t      vm._props[path] = prop;\n\t      if (inlineProps && hasOwn(inlineProps, path)) {\n\t        initProp(vm, prop, inlineProps[path]);\n\t      }if (raw === null) {\n\t        // initialize absent prop\n\t        initProp(vm, prop, undefined);\n\t      } else if (prop.dynamic) {\n\t        // dynamic prop\n\t        if (prop.mode === propBindingModes.ONE_TIME) {\n\t          // one time binding\n\t          value = (scope || vm._context || vm).$get(prop.parentPath);\n\t          initProp(vm, prop, value);\n\t        } else {\n\t          if (vm._context) {\n\t            // dynamic binding\n\t            vm._bindDir({\n\t              name: 'prop',\n\t              def: propDef,\n\t              prop: prop\n\t            }, null, null, scope); // el, host, scope\n\t          } else {\n\t              // root instance\n\t              initProp(vm, prop, vm.$get(prop.parentPath));\n\t            }\n\t        }\n\t      } else if (prop.optimizedLiteral) {\n\t        // optimized literal, cast it and just set once\n\t        var stripped = stripQuotes(raw);\n\t        value = stripped === raw ? toBoolean(toNumber(raw)) : stripped;\n\t        initProp(vm, prop, value);\n\t      } else {\n\t        // string literal, but we need to cater for\n\t        // Boolean props with no value, or with same\n\t        // literal value (e.g. disabled=\"disabled\")\n\t        // see https://github.com/vuejs/vue-loader/issues/182\n\t        value = options.type === Boolean && (raw === '' || raw === hyphenate(prop.name)) ? true : raw;\n\t        initProp(vm, prop, value);\n\t      }\n\t    }\n\t  };\n\t}\n\t\n\t/**\n\t * Process a prop with a rawValue, applying necessary coersions,\n\t * default values & assertions and call the given callback with\n\t * processed value.\n\t *\n\t * @param {Vue} vm\n\t * @param {Object} prop\n\t * @param {*} rawValue\n\t * @param {Function} fn\n\t */\n\t\n\tfunction processPropValue(vm, prop, rawValue, fn) {\n\t  var isSimple = prop.dynamic && isSimplePath(prop.parentPath);\n\t  var value = rawValue;\n\t  if (value === undefined) {\n\t    value = getPropDefaultValue(vm, prop);\n\t  }\n\t  value = coerceProp(prop, value, vm);\n\t  var coerced = value !== rawValue;\n\t  if (!assertProp(prop, value, vm)) {\n\t    value = undefined;\n\t  }\n\t  if (isSimple && !coerced) {\n\t    withoutConversion(function () {\n\t      fn(value);\n\t    });\n\t  } else {\n\t    fn(value);\n\t  }\n\t}\n\t\n\t/**\n\t * Set a prop's initial value on a vm and its data object.\n\t *\n\t * @param {Vue} vm\n\t * @param {Object} prop\n\t * @param {*} value\n\t */\n\t\n\tfunction initProp(vm, prop, value) {\n\t  processPropValue(vm, prop, value, function (value) {\n\t    defineReactive(vm, prop.path, value);\n\t  });\n\t}\n\t\n\t/**\n\t * Update a prop's value on a vm.\n\t *\n\t * @param {Vue} vm\n\t * @param {Object} prop\n\t * @param {*} value\n\t */\n\t\n\tfunction updateProp(vm, prop, value) {\n\t  processPropValue(vm, prop, value, function (value) {\n\t    vm[prop.path] = value;\n\t  });\n\t}\n\t\n\t/**\n\t * Get the default value of a prop.\n\t *\n\t * @param {Vue} vm\n\t * @param {Object} prop\n\t * @return {*}\n\t */\n\t\n\tfunction getPropDefaultValue(vm, prop) {\n\t  // no default, return undefined\n\t  var options = prop.options;\n\t  if (!hasOwn(options, 'default')) {\n\t    // absent boolean value defaults to false\n\t    return options.type === Boolean ? false : undefined;\n\t  }\n\t  var def = options['default'];\n\t  // warn against non-factory defaults for Object & Array\n\t  if (isObject(def)) {\n\t    (\"production\") !== 'production' && warn('Invalid default value for prop \"' + prop.name + '\": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);\n\t  }\n\t  // call factory function for non-Function types\n\t  return typeof def === 'function' && options.type !== Function ? def.call(vm) : def;\n\t}\n\t\n\t/**\n\t * Assert whether a prop is valid.\n\t *\n\t * @param {Object} prop\n\t * @param {*} value\n\t * @param {Vue} vm\n\t */\n\t\n\tfunction assertProp(prop, value, vm) {\n\t  if (!prop.options.required && ( // non-required\n\t  prop.raw === null || // abscent\n\t  value == null) // null or undefined\n\t  ) {\n\t      return true;\n\t    }\n\t  var options = prop.options;\n\t  var type = options.type;\n\t  var valid = !type;\n\t  var expectedTypes = [];\n\t  if (type) {\n\t    if (!isArray(type)) {\n\t      type = [type];\n\t    }\n\t    for (var i = 0; i < type.length && !valid; i++) {\n\t      var assertedType = assertType(value, type[i]);\n\t      expectedTypes.push(assertedType.expectedType);\n\t      valid = assertedType.valid;\n\t    }\n\t  }\n\t  if (!valid) {\n\t    if (false) {\n\t      warn('Invalid prop: type check failed for prop \"' + prop.name + '\".' + ' Expected ' + expectedTypes.map(formatType).join(', ') + ', got ' + formatValue(value) + '.', vm);\n\t    }\n\t    return false;\n\t  }\n\t  var validator = options.validator;\n\t  if (validator) {\n\t    if (!validator(value)) {\n\t      (\"production\") !== 'production' && warn('Invalid prop: custom validator check failed for prop \"' + prop.name + '\".', vm);\n\t      return false;\n\t    }\n\t  }\n\t  return true;\n\t}\n\t\n\t/**\n\t * Force parsing value with coerce option.\n\t *\n\t * @param {*} value\n\t * @param {Object} options\n\t * @return {*}\n\t */\n\t\n\tfunction coerceProp(prop, value, vm) {\n\t  var coerce = prop.options.coerce;\n\t  if (!coerce) {\n\t    return value;\n\t  }\n\t  if (typeof coerce === 'function') {\n\t    return coerce(value);\n\t  } else {\n\t    (\"production\") !== 'production' && warn('Invalid coerce for prop \"' + prop.name + '\": expected function, got ' + typeof coerce + '.', vm);\n\t    return value;\n\t  }\n\t}\n\t\n\t/**\n\t * Assert the type of a value\n\t *\n\t * @param {*} value\n\t * @param {Function} type\n\t * @return {Object}\n\t */\n\t\n\tfunction assertType(value, type) {\n\t  var valid;\n\t  var expectedType;\n\t  if (type === String) {\n\t    expectedType = 'string';\n\t    valid = typeof value === expectedType;\n\t  } else if (type === Number) {\n\t    expectedType = 'number';\n\t    valid = typeof value === expectedType;\n\t  } else if (type === Boolean) {\n\t    expectedType = 'boolean';\n\t    valid = typeof value === expectedType;\n\t  } else if (type === Function) {\n\t    expectedType = 'function';\n\t    valid = typeof value === expectedType;\n\t  } else if (type === Object) {\n\t    expectedType = 'object';\n\t    valid = isPlainObject(value);\n\t  } else if (type === Array) {\n\t    expectedType = 'array';\n\t    valid = isArray(value);\n\t  } else {\n\t    valid = value instanceof type;\n\t  }\n\t  return {\n\t    valid: valid,\n\t    expectedType: expectedType\n\t  };\n\t}\n\t\n\t/**\n\t * Format type for output\n\t *\n\t * @param {String} type\n\t * @return {String}\n\t */\n\t\n\tfunction formatType(type) {\n\t  return type ? type.charAt(0).toUpperCase() + type.slice(1) : 'custom type';\n\t}\n\t\n\t/**\n\t * Format value\n\t *\n\t * @param {*} value\n\t * @return {String}\n\t */\n\t\n\tfunction formatValue(val) {\n\t  return Object.prototype.toString.call(val).slice(8, -1);\n\t}\n\t\n\tvar bindingModes = config._propBindingModes;\n\t\n\tvar propDef = {\n\t\n\t  bind: function bind() {\n\t    var child = this.vm;\n\t    var parent = child._context;\n\t    // passed in from compiler directly\n\t    var prop = this.descriptor.prop;\n\t    var childKey = prop.path;\n\t    var parentKey = prop.parentPath;\n\t    var twoWay = prop.mode === bindingModes.TWO_WAY;\n\t\n\t    var parentWatcher = this.parentWatcher = new Watcher(parent, parentKey, function (val) {\n\t      updateProp(child, prop, val);\n\t    }, {\n\t      twoWay: twoWay,\n\t      filters: prop.filters,\n\t      // important: props need to be observed on the\n\t      // v-for scope if present\n\t      scope: this._scope\n\t    });\n\t\n\t    // set the child initial value.\n\t    initProp(child, prop, parentWatcher.value);\n\t\n\t    // setup two-way binding\n\t    if (twoWay) {\n\t      // important: defer the child watcher creation until\n\t      // the created hook (after data observation)\n\t      var self = this;\n\t      child.$once('pre-hook:created', function () {\n\t        self.childWatcher = new Watcher(child, childKey, function (val) {\n\t          parentWatcher.set(val);\n\t        }, {\n\t          // ensure sync upward before parent sync down.\n\t          // this is necessary in cases e.g. the child\n\t          // mutates a prop array, then replaces it. (#1683)\n\t          sync: true\n\t        });\n\t      });\n\t    }\n\t  },\n\t\n\t  unbind: function unbind() {\n\t    this.parentWatcher.teardown();\n\t    if (this.childWatcher) {\n\t      this.childWatcher.teardown();\n\t    }\n\t  }\n\t};\n\t\n\tvar queue$1 = [];\n\tvar queued = false;\n\t\n\t/**\n\t * Push a job into the queue.\n\t *\n\t * @param {Function} job\n\t */\n\t\n\tfunction pushJob(job) {\n\t  queue$1.push(job);\n\t  if (!queued) {\n\t    queued = true;\n\t    nextTick(flush);\n\t  }\n\t}\n\t\n\t/**\n\t * Flush the queue, and do one forced reflow before\n\t * triggering transitions.\n\t */\n\t\n\tfunction flush() {\n\t  // Force layout\n\t  var f = document.documentElement.offsetHeight;\n\t  for (var i = 0; i < queue$1.length; i++) {\n\t    queue$1[i]();\n\t  }\n\t  queue$1 = [];\n\t  queued = false;\n\t  // dummy return, so js linters don't complain about\n\t  // unused variable f\n\t  return f;\n\t}\n\t\n\tvar TYPE_TRANSITION = 'transition';\n\tvar TYPE_ANIMATION = 'animation';\n\tvar transDurationProp = transitionProp + 'Duration';\n\tvar animDurationProp = animationProp + 'Duration';\n\t\n\t/**\n\t * If a just-entered element is applied the\n\t * leave class while its enter transition hasn't started yet,\n\t * and the transitioned property has the same value for both\n\t * enter/leave, then the leave transition will be skipped and\n\t * the transitionend event never fires. This function ensures\n\t * its callback to be called after a transition has started\n\t * by waiting for double raf.\n\t *\n\t * It falls back to setTimeout on devices that support CSS\n\t * transitions but not raf (e.g. Android 4.2 browser) - since\n\t * these environments are usually slow, we are giving it a\n\t * relatively large timeout.\n\t */\n\t\n\tvar raf = inBrowser && window.requestAnimationFrame;\n\tvar waitForTransitionStart = raf\n\t/* istanbul ignore next */\n\t? function (fn) {\n\t  raf(function () {\n\t    raf(fn);\n\t  });\n\t} : function (fn) {\n\t  setTimeout(fn, 50);\n\t};\n\t\n\t/**\n\t * A Transition object that encapsulates the state and logic\n\t * of the transition.\n\t *\n\t * @param {Element} el\n\t * @param {String} id\n\t * @param {Object} hooks\n\t * @param {Vue} vm\n\t */\n\tfunction Transition(el, id, hooks, vm) {\n\t  this.id = id;\n\t  this.el = el;\n\t  this.enterClass = hooks && hooks.enterClass || id + '-enter';\n\t  this.leaveClass = hooks && hooks.leaveClass || id + '-leave';\n\t  this.hooks = hooks;\n\t  this.vm = vm;\n\t  // async state\n\t  this.pendingCssEvent = this.pendingCssCb = this.cancel = this.pendingJsCb = this.op = this.cb = null;\n\t  this.justEntered = false;\n\t  this.entered = this.left = false;\n\t  this.typeCache = {};\n\t  // check css transition type\n\t  this.type = hooks && hooks.type;\n\t  /* istanbul ignore if */\n\t  if (false) {\n\t    if (this.type && this.type !== TYPE_TRANSITION && this.type !== TYPE_ANIMATION) {\n\t      warn('invalid CSS transition type for transition=\"' + this.id + '\": ' + this.type, vm);\n\t    }\n\t  }\n\t  // bind\n\t  var self = this;['enterNextTick', 'enterDone', 'leaveNextTick', 'leaveDone'].forEach(function (m) {\n\t    self[m] = bind(self[m], self);\n\t  });\n\t}\n\t\n\tvar p$1 = Transition.prototype;\n\t\n\t/**\n\t * Start an entering transition.\n\t *\n\t * 1. enter transition triggered\n\t * 2. call beforeEnter hook\n\t * 3. add enter class\n\t * 4. insert/show element\n\t * 5. call enter hook (with possible explicit js callback)\n\t * 6. reflow\n\t * 7. based on transition type:\n\t *    - transition:\n\t *        remove class now, wait for transitionend,\n\t *        then done if there's no explicit js callback.\n\t *    - animation:\n\t *        wait for animationend, remove class,\n\t *        then done if there's no explicit js callback.\n\t *    - no css transition:\n\t *        done now if there's no explicit js callback.\n\t * 8. wait for either done or js callback, then call\n\t *    afterEnter hook.\n\t *\n\t * @param {Function} op - insert/show the element\n\t * @param {Function} [cb]\n\t */\n\t\n\tp$1.enter = function (op, cb) {\n\t  this.cancelPending();\n\t  this.callHook('beforeEnter');\n\t  this.cb = cb;\n\t  addClass(this.el, this.enterClass);\n\t  op();\n\t  this.entered = false;\n\t  this.callHookWithCb('enter');\n\t  if (this.entered) {\n\t    return; // user called done synchronously.\n\t  }\n\t  this.cancel = this.hooks && this.hooks.enterCancelled;\n\t  pushJob(this.enterNextTick);\n\t};\n\t\n\t/**\n\t * The \"nextTick\" phase of an entering transition, which is\n\t * to be pushed into a queue and executed after a reflow so\n\t * that removing the class can trigger a CSS transition.\n\t */\n\t\n\tp$1.enterNextTick = function () {\n\t  var _this = this;\n\t\n\t  // prevent transition skipping\n\t  this.justEntered = true;\n\t  waitForTransitionStart(function () {\n\t    _this.justEntered = false;\n\t  });\n\t  var enterDone = this.enterDone;\n\t  var type = this.getCssTransitionType(this.enterClass);\n\t  if (!this.pendingJsCb) {\n\t    if (type === TYPE_TRANSITION) {\n\t      // trigger transition by removing enter class now\n\t      removeClass(this.el, this.enterClass);\n\t      this.setupCssCb(transitionEndEvent, enterDone);\n\t    } else if (type === TYPE_ANIMATION) {\n\t      this.setupCssCb(animationEndEvent, enterDone);\n\t    } else {\n\t      enterDone();\n\t    }\n\t  } else if (type === TYPE_TRANSITION) {\n\t    removeClass(this.el, this.enterClass);\n\t  }\n\t};\n\t\n\t/**\n\t * The \"cleanup\" phase of an entering transition.\n\t */\n\t\n\tp$1.enterDone = function () {\n\t  this.entered = true;\n\t  this.cancel = this.pendingJsCb = null;\n\t  removeClass(this.el, this.enterClass);\n\t  this.callHook('afterEnter');\n\t  if (this.cb) this.cb();\n\t};\n\t\n\t/**\n\t * Start a leaving transition.\n\t *\n\t * 1. leave transition triggered.\n\t * 2. call beforeLeave hook\n\t * 3. add leave class (trigger css transition)\n\t * 4. call leave hook (with possible explicit js callback)\n\t * 5. reflow if no explicit js callback is provided\n\t * 6. based on transition type:\n\t *    - transition or animation:\n\t *        wait for end event, remove class, then done if\n\t *        there's no explicit js callback.\n\t *    - no css transition:\n\t *        done if there's no explicit js callback.\n\t * 7. wait for either done or js callback, then call\n\t *    afterLeave hook.\n\t *\n\t * @param {Function} op - remove/hide the element\n\t * @param {Function} [cb]\n\t */\n\t\n\tp$1.leave = function (op, cb) {\n\t  this.cancelPending();\n\t  this.callHook('beforeLeave');\n\t  this.op = op;\n\t  this.cb = cb;\n\t  addClass(this.el, this.leaveClass);\n\t  this.left = false;\n\t  this.callHookWithCb('leave');\n\t  if (this.left) {\n\t    return; // user called done synchronously.\n\t  }\n\t  this.cancel = this.hooks && this.hooks.leaveCancelled;\n\t  // only need to handle leaveDone if\n\t  // 1. the transition is already done (synchronously called\n\t  //    by the user, which causes this.op set to null)\n\t  // 2. there's no explicit js callback\n\t  if (this.op && !this.pendingJsCb) {\n\t    // if a CSS transition leaves immediately after enter,\n\t    // the transitionend event never fires. therefore we\n\t    // detect such cases and end the leave immediately.\n\t    if (this.justEntered) {\n\t      this.leaveDone();\n\t    } else {\n\t      pushJob(this.leaveNextTick);\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * The \"nextTick\" phase of a leaving transition.\n\t */\n\t\n\tp$1.leaveNextTick = function () {\n\t  var type = this.getCssTransitionType(this.leaveClass);\n\t  if (type) {\n\t    var event = type === TYPE_TRANSITION ? transitionEndEvent : animationEndEvent;\n\t    this.setupCssCb(event, this.leaveDone);\n\t  } else {\n\t    this.leaveDone();\n\t  }\n\t};\n\t\n\t/**\n\t * The \"cleanup\" phase of a leaving transition.\n\t */\n\t\n\tp$1.leaveDone = function () {\n\t  this.left = true;\n\t  this.cancel = this.pendingJsCb = null;\n\t  this.op();\n\t  removeClass(this.el, this.leaveClass);\n\t  this.callHook('afterLeave');\n\t  if (this.cb) this.cb();\n\t  this.op = null;\n\t};\n\t\n\t/**\n\t * Cancel any pending callbacks from a previously running\n\t * but not finished transition.\n\t */\n\t\n\tp$1.cancelPending = function () {\n\t  this.op = this.cb = null;\n\t  var hasPending = false;\n\t  if (this.pendingCssCb) {\n\t    hasPending = true;\n\t    off(this.el, this.pendingCssEvent, this.pendingCssCb);\n\t    this.pendingCssEvent = this.pendingCssCb = null;\n\t  }\n\t  if (this.pendingJsCb) {\n\t    hasPending = true;\n\t    this.pendingJsCb.cancel();\n\t    this.pendingJsCb = null;\n\t  }\n\t  if (hasPending) {\n\t    removeClass(this.el, this.enterClass);\n\t    removeClass(this.el, this.leaveClass);\n\t  }\n\t  if (this.cancel) {\n\t    this.cancel.call(this.vm, this.el);\n\t    this.cancel = null;\n\t  }\n\t};\n\t\n\t/**\n\t * Call a user-provided synchronous hook function.\n\t *\n\t * @param {String} type\n\t */\n\t\n\tp$1.callHook = function (type) {\n\t  if (this.hooks && this.hooks[type]) {\n\t    this.hooks[type].call(this.vm, this.el);\n\t  }\n\t};\n\t\n\t/**\n\t * Call a user-provided, potentially-async hook function.\n\t * We check for the length of arguments to see if the hook\n\t * expects a `done` callback. If true, the transition's end\n\t * will be determined by when the user calls that callback;\n\t * otherwise, the end is determined by the CSS transition or\n\t * animation.\n\t *\n\t * @param {String} type\n\t */\n\t\n\tp$1.callHookWithCb = function (type) {\n\t  var hook = this.hooks && this.hooks[type];\n\t  if (hook) {\n\t    if (hook.length > 1) {\n\t      this.pendingJsCb = cancellable(this[type + 'Done']);\n\t    }\n\t    hook.call(this.vm, this.el, this.pendingJsCb);\n\t  }\n\t};\n\t\n\t/**\n\t * Get an element's transition type based on the\n\t * calculated styles.\n\t *\n\t * @param {String} className\n\t * @return {Number}\n\t */\n\t\n\tp$1.getCssTransitionType = function (className) {\n\t  /* istanbul ignore if */\n\t  if (!transitionEndEvent ||\n\t  // skip CSS transitions if page is not visible -\n\t  // this solves the issue of transitionend events not\n\t  // firing until the page is visible again.\n\t  // pageVisibility API is supported in IE10+, same as\n\t  // CSS transitions.\n\t  document.hidden ||\n\t  // explicit js-only transition\n\t  this.hooks && this.hooks.css === false ||\n\t  // element is hidden\n\t  isHidden(this.el)) {\n\t    return;\n\t  }\n\t  var type = this.type || this.typeCache[className];\n\t  if (type) return type;\n\t  var inlineStyles = this.el.style;\n\t  var computedStyles = window.getComputedStyle(this.el);\n\t  var transDuration = inlineStyles[transDurationProp] || computedStyles[transDurationProp];\n\t  if (transDuration && transDuration !== '0s') {\n\t    type = TYPE_TRANSITION;\n\t  } else {\n\t    var animDuration = inlineStyles[animDurationProp] || computedStyles[animDurationProp];\n\t    if (animDuration && animDuration !== '0s') {\n\t      type = TYPE_ANIMATION;\n\t    }\n\t  }\n\t  if (type) {\n\t    this.typeCache[className] = type;\n\t  }\n\t  return type;\n\t};\n\t\n\t/**\n\t * Setup a CSS transitionend/animationend callback.\n\t *\n\t * @param {String} event\n\t * @param {Function} cb\n\t */\n\t\n\tp$1.setupCssCb = function (event, cb) {\n\t  this.pendingCssEvent = event;\n\t  var self = this;\n\t  var el = this.el;\n\t  var onEnd = this.pendingCssCb = function (e) {\n\t    if (e.target === el) {\n\t      off(el, event, onEnd);\n\t      self.pendingCssEvent = self.pendingCssCb = null;\n\t      if (!self.pendingJsCb && cb) {\n\t        cb();\n\t      }\n\t    }\n\t  };\n\t  on(el, event, onEnd);\n\t};\n\t\n\t/**\n\t * Check if an element is hidden - in that case we can just\n\t * skip the transition alltogether.\n\t *\n\t * @param {Element} el\n\t * @return {Boolean}\n\t */\n\t\n\tfunction isHidden(el) {\n\t  if (/svg$/.test(el.namespaceURI)) {\n\t    // SVG elements do not have offset(Width|Height)\n\t    // so we need to check the client rect\n\t    var rect = el.getBoundingClientRect();\n\t    return !(rect.width || rect.height);\n\t  } else {\n\t    return !(el.offsetWidth || el.offsetHeight || el.getClientRects().length);\n\t  }\n\t}\n\t\n\tvar transition$1 = {\n\t\n\t  priority: TRANSITION,\n\t\n\t  update: function update(id, oldId) {\n\t    var el = this.el;\n\t    // resolve on owner vm\n\t    var hooks = resolveAsset(this.vm.$options, 'transitions', id);\n\t    id = id || 'v';\n\t    oldId = oldId || 'v';\n\t    el.__v_trans = new Transition(el, id, hooks, this.vm);\n\t    removeClass(el, oldId + '-transition');\n\t    addClass(el, id + '-transition');\n\t  }\n\t};\n\t\n\tvar internalDirectives = {\n\t  style: style,\n\t  'class': vClass,\n\t  component: component,\n\t  prop: propDef,\n\t  transition: transition$1\n\t};\n\t\n\t// special binding prefixes\n\tvar bindRE = /^v-bind:|^:/;\n\tvar onRE = /^v-on:|^@/;\n\tvar dirAttrRE = /^v-([^:]+)(?:$|:(.*)$)/;\n\tvar modifierRE = /\\.[^\\.]+/g;\n\tvar transitionRE = /^(v-bind:|:)?transition$/;\n\t\n\t// default directive priority\n\tvar DEFAULT_PRIORITY = 1000;\n\tvar DEFAULT_TERMINAL_PRIORITY = 2000;\n\t\n\t/**\n\t * Compile a template and return a reusable composite link\n\t * function, which recursively contains more link functions\n\t * inside. This top level compile function would normally\n\t * be called on instance root nodes, but can also be used\n\t * for partial compilation if the partial argument is true.\n\t *\n\t * The returned composite link function, when called, will\n\t * return an unlink function that tearsdown all directives\n\t * created during the linking phase.\n\t *\n\t * @param {Element|DocumentFragment} el\n\t * @param {Object} options\n\t * @param {Boolean} partial\n\t * @return {Function}\n\t */\n\t\n\tfunction compile(el, options, partial) {\n\t  // link function for the node itself.\n\t  var nodeLinkFn = partial || !options._asComponent ? compileNode(el, options) : null;\n\t  // link function for the childNodes\n\t  var childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && !isScript(el) && el.hasChildNodes() ? compileNodeList(el.childNodes, options) : null;\n\t\n\t  /**\n\t   * A composite linker function to be called on a already\n\t   * compiled piece of DOM, which instantiates all directive\n\t   * instances.\n\t   *\n\t   * @param {Vue} vm\n\t   * @param {Element|DocumentFragment} el\n\t   * @param {Vue} [host] - host vm of transcluded content\n\t   * @param {Object} [scope] - v-for scope\n\t   * @param {Fragment} [frag] - link context fragment\n\t   * @return {Function|undefined}\n\t   */\n\t\n\t  return function compositeLinkFn(vm, el, host, scope, frag) {\n\t    // cache childNodes before linking parent, fix #657\n\t    var childNodes = toArray(el.childNodes);\n\t    // link\n\t    var dirs = linkAndCapture(function compositeLinkCapturer() {\n\t      if (nodeLinkFn) nodeLinkFn(vm, el, host, scope, frag);\n\t      if (childLinkFn) childLinkFn(vm, childNodes, host, scope, frag);\n\t    }, vm);\n\t    return makeUnlinkFn(vm, dirs);\n\t  };\n\t}\n\t\n\t/**\n\t * Apply a linker to a vm/element pair and capture the\n\t * directives created during the process.\n\t *\n\t * @param {Function} linker\n\t * @param {Vue} vm\n\t */\n\t\n\tfunction linkAndCapture(linker, vm) {\n\t  /* istanbul ignore if */\n\t  if (true) {\n\t    // reset directives before every capture in production\n\t    // mode, so that when unlinking we don't need to splice\n\t    // them out (which turns out to be a perf hit).\n\t    // they are kept in development mode because they are\n\t    // useful for Vue's own tests.\n\t    vm._directives = [];\n\t  }\n\t  var originalDirCount = vm._directives.length;\n\t  linker();\n\t  var dirs = vm._directives.slice(originalDirCount);\n\t  dirs.sort(directiveComparator);\n\t  for (var i = 0, l = dirs.length; i < l; i++) {\n\t    dirs[i]._bind();\n\t  }\n\t  return dirs;\n\t}\n\t\n\t/**\n\t * Directive priority sort comparator\n\t *\n\t * @param {Object} a\n\t * @param {Object} b\n\t */\n\t\n\tfunction directiveComparator(a, b) {\n\t  a = a.descriptor.def.priority || DEFAULT_PRIORITY;\n\t  b = b.descriptor.def.priority || DEFAULT_PRIORITY;\n\t  return a > b ? -1 : a === b ? 0 : 1;\n\t}\n\t\n\t/**\n\t * Linker functions return an unlink function that\n\t * tearsdown all directives instances generated during\n\t * the process.\n\t *\n\t * We create unlink functions with only the necessary\n\t * information to avoid retaining additional closures.\n\t *\n\t * @param {Vue} vm\n\t * @param {Array} dirs\n\t * @param {Vue} [context]\n\t * @param {Array} [contextDirs]\n\t * @return {Function}\n\t */\n\t\n\tfunction makeUnlinkFn(vm, dirs, context, contextDirs) {\n\t  function unlink(destroying) {\n\t    teardownDirs(vm, dirs, destroying);\n\t    if (context && contextDirs) {\n\t      teardownDirs(context, contextDirs);\n\t    }\n\t  }\n\t  // expose linked directives\n\t  unlink.dirs = dirs;\n\t  return unlink;\n\t}\n\t\n\t/**\n\t * Teardown partial linked directives.\n\t *\n\t * @param {Vue} vm\n\t * @param {Array} dirs\n\t * @param {Boolean} destroying\n\t */\n\t\n\tfunction teardownDirs(vm, dirs, destroying) {\n\t  var i = dirs.length;\n\t  while (i--) {\n\t    dirs[i]._teardown();\n\t    if (false) {\n\t      vm._directives.$remove(dirs[i]);\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Compile link props on an instance.\n\t *\n\t * @param {Vue} vm\n\t * @param {Element} el\n\t * @param {Object} props\n\t * @param {Object} [scope]\n\t * @return {Function}\n\t */\n\t\n\tfunction compileAndLinkProps(vm, el, props, scope) {\n\t  var propsLinkFn = compileProps(el, props, vm);\n\t  var propDirs = linkAndCapture(function () {\n\t    propsLinkFn(vm, scope);\n\t  }, vm);\n\t  return makeUnlinkFn(vm, propDirs);\n\t}\n\t\n\t/**\n\t * Compile the root element of an instance.\n\t *\n\t * 1. attrs on context container (context scope)\n\t * 2. attrs on the component template root node, if\n\t *    replace:true (child scope)\n\t *\n\t * If this is a fragment instance, we only need to compile 1.\n\t *\n\t * @param {Element} el\n\t * @param {Object} options\n\t * @param {Object} contextOptions\n\t * @return {Function}\n\t */\n\t\n\tfunction compileRoot(el, options, contextOptions) {\n\t  var containerAttrs = options._containerAttrs;\n\t  var replacerAttrs = options._replacerAttrs;\n\t  var contextLinkFn, replacerLinkFn;\n\t\n\t  // only need to compile other attributes for\n\t  // non-fragment instances\n\t  if (el.nodeType !== 11) {\n\t    // for components, container and replacer need to be\n\t    // compiled separately and linked in different scopes.\n\t    if (options._asComponent) {\n\t      // 2. container attributes\n\t      if (containerAttrs && contextOptions) {\n\t        contextLinkFn = compileDirectives(containerAttrs, contextOptions);\n\t      }\n\t      if (replacerAttrs) {\n\t        // 3. replacer attributes\n\t        replacerLinkFn = compileDirectives(replacerAttrs, options);\n\t      }\n\t    } else {\n\t      // non-component, just compile as a normal element.\n\t      replacerLinkFn = compileDirectives(el.attributes, options);\n\t    }\n\t  } else if (false) {\n\t    // warn container directives for fragment instances\n\t    var names = containerAttrs.filter(function (attr) {\n\t      // allow vue-loader/vueify scoped css attributes\n\t      return attr.name.indexOf('_v-') < 0 &&\n\t      // allow event listeners\n\t      !onRE.test(attr.name) &&\n\t      // allow slots\n\t      attr.name !== 'slot';\n\t    }).map(function (attr) {\n\t      return '\"' + attr.name + '\"';\n\t    });\n\t    if (names.length) {\n\t      var plural = names.length > 1;\n\t      warn('Attribute' + (plural ? 's ' : ' ') + names.join(', ') + (plural ? ' are' : ' is') + ' ignored on component ' + '<' + options.el.tagName.toLowerCase() + '> because ' + 'the component is a fragment instance: ' + 'http://vuejs.org/guide/components.html#Fragment-Instance');\n\t    }\n\t  }\n\t\n\t  options._containerAttrs = options._replacerAttrs = null;\n\t  return function rootLinkFn(vm, el, scope) {\n\t    // link context scope dirs\n\t    var context = vm._context;\n\t    var contextDirs;\n\t    if (context && contextLinkFn) {\n\t      contextDirs = linkAndCapture(function () {\n\t        contextLinkFn(context, el, null, scope);\n\t      }, context);\n\t    }\n\t\n\t    // link self\n\t    var selfDirs = linkAndCapture(function () {\n\t      if (replacerLinkFn) replacerLinkFn(vm, el);\n\t    }, vm);\n\t\n\t    // return the unlink function that tearsdown context\n\t    // container directives.\n\t    return makeUnlinkFn(vm, selfDirs, context, contextDirs);\n\t  };\n\t}\n\t\n\t/**\n\t * Compile a node and return a nodeLinkFn based on the\n\t * node type.\n\t *\n\t * @param {Node} node\n\t * @param {Object} options\n\t * @return {Function|null}\n\t */\n\t\n\tfunction compileNode(node, options) {\n\t  var type = node.nodeType;\n\t  if (type === 1 && !isScript(node)) {\n\t    return compileElement(node, options);\n\t  } else if (type === 3 && node.data.trim()) {\n\t    return compileTextNode(node, options);\n\t  } else {\n\t    return null;\n\t  }\n\t}\n\t\n\t/**\n\t * Compile an element and return a nodeLinkFn.\n\t *\n\t * @param {Element} el\n\t * @param {Object} options\n\t * @return {Function|null}\n\t */\n\t\n\tfunction compileElement(el, options) {\n\t  // preprocess textareas.\n\t  // textarea treats its text content as the initial value.\n\t  // just bind it as an attr directive for value.\n\t  if (el.tagName === 'TEXTAREA') {\n\t    var tokens = parseText(el.value);\n\t    if (tokens) {\n\t      el.setAttribute(':value', tokensToExp(tokens));\n\t      el.value = '';\n\t    }\n\t  }\n\t  var linkFn;\n\t  var hasAttrs = el.hasAttributes();\n\t  var attrs = hasAttrs && toArray(el.attributes);\n\t  // check terminal directives (for & if)\n\t  if (hasAttrs) {\n\t    linkFn = checkTerminalDirectives(el, attrs, options);\n\t  }\n\t  // check element directives\n\t  if (!linkFn) {\n\t    linkFn = checkElementDirectives(el, options);\n\t  }\n\t  // check component\n\t  if (!linkFn) {\n\t    linkFn = checkComponent(el, options);\n\t  }\n\t  // normal directives\n\t  if (!linkFn && hasAttrs) {\n\t    linkFn = compileDirectives(attrs, options);\n\t  }\n\t  return linkFn;\n\t}\n\t\n\t/**\n\t * Compile a textNode and return a nodeLinkFn.\n\t *\n\t * @param {TextNode} node\n\t * @param {Object} options\n\t * @return {Function|null} textNodeLinkFn\n\t */\n\t\n\tfunction compileTextNode(node, options) {\n\t  // skip marked text nodes\n\t  if (node._skip) {\n\t    return removeText;\n\t  }\n\t\n\t  var tokens = parseText(node.wholeText);\n\t  if (!tokens) {\n\t    return null;\n\t  }\n\t\n\t  // mark adjacent text nodes as skipped,\n\t  // because we are using node.wholeText to compile\n\t  // all adjacent text nodes together. This fixes\n\t  // issues in IE where sometimes it splits up a single\n\t  // text node into multiple ones.\n\t  var next = node.nextSibling;\n\t  while (next && next.nodeType === 3) {\n\t    next._skip = true;\n\t    next = next.nextSibling;\n\t  }\n\t\n\t  var frag = document.createDocumentFragment();\n\t  var el, token;\n\t  for (var i = 0, l = tokens.length; i < l; i++) {\n\t    token = tokens[i];\n\t    el = token.tag ? processTextToken(token, options) : document.createTextNode(token.value);\n\t    frag.appendChild(el);\n\t  }\n\t  return makeTextNodeLinkFn(tokens, frag, options);\n\t}\n\t\n\t/**\n\t * Linker for an skipped text node.\n\t *\n\t * @param {Vue} vm\n\t * @param {Text} node\n\t */\n\t\n\tfunction removeText(vm, node) {\n\t  remove(node);\n\t}\n\t\n\t/**\n\t * Process a single text token.\n\t *\n\t * @param {Object} token\n\t * @param {Object} options\n\t * @return {Node}\n\t */\n\t\n\tfunction processTextToken(token, options) {\n\t  var el;\n\t  if (token.oneTime) {\n\t    el = document.createTextNode(token.value);\n\t  } else {\n\t    if (token.html) {\n\t      el = document.createComment('v-html');\n\t      setTokenType('html');\n\t    } else {\n\t      // IE will clean up empty textNodes during\n\t      // frag.cloneNode(true), so we have to give it\n\t      // something here...\n\t      el = document.createTextNode(' ');\n\t      setTokenType('text');\n\t    }\n\t  }\n\t  function setTokenType(type) {\n\t    if (token.descriptor) return;\n\t    var parsed = parseDirective(token.value);\n\t    token.descriptor = {\n\t      name: type,\n\t      def: directives[type],\n\t      expression: parsed.expression,\n\t      filters: parsed.filters\n\t    };\n\t  }\n\t  return el;\n\t}\n\t\n\t/**\n\t * Build a function that processes a textNode.\n\t *\n\t * @param {Array<Object>} tokens\n\t * @param {DocumentFragment} frag\n\t */\n\t\n\tfunction makeTextNodeLinkFn(tokens, frag) {\n\t  return function textNodeLinkFn(vm, el, host, scope) {\n\t    var fragClone = frag.cloneNode(true);\n\t    var childNodes = toArray(fragClone.childNodes);\n\t    var token, value, node;\n\t    for (var i = 0, l = tokens.length; i < l; i++) {\n\t      token = tokens[i];\n\t      value = token.value;\n\t      if (token.tag) {\n\t        node = childNodes[i];\n\t        if (token.oneTime) {\n\t          value = (scope || vm).$eval(value);\n\t          if (token.html) {\n\t            replace(node, parseTemplate(value, true));\n\t          } else {\n\t            node.data = _toString(value);\n\t          }\n\t        } else {\n\t          vm._bindDir(token.descriptor, node, host, scope);\n\t        }\n\t      }\n\t    }\n\t    replace(el, fragClone);\n\t  };\n\t}\n\t\n\t/**\n\t * Compile a node list and return a childLinkFn.\n\t *\n\t * @param {NodeList} nodeList\n\t * @param {Object} options\n\t * @return {Function|undefined}\n\t */\n\t\n\tfunction compileNodeList(nodeList, options) {\n\t  var linkFns = [];\n\t  var nodeLinkFn, childLinkFn, node;\n\t  for (var i = 0, l = nodeList.length; i < l; i++) {\n\t    node = nodeList[i];\n\t    nodeLinkFn = compileNode(node, options);\n\t    childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && node.tagName !== 'SCRIPT' && node.hasChildNodes() ? compileNodeList(node.childNodes, options) : null;\n\t    linkFns.push(nodeLinkFn, childLinkFn);\n\t  }\n\t  return linkFns.length ? makeChildLinkFn(linkFns) : null;\n\t}\n\t\n\t/**\n\t * Make a child link function for a node's childNodes.\n\t *\n\t * @param {Array<Function>} linkFns\n\t * @return {Function} childLinkFn\n\t */\n\t\n\tfunction makeChildLinkFn(linkFns) {\n\t  return function childLinkFn(vm, nodes, host, scope, frag) {\n\t    var node, nodeLinkFn, childrenLinkFn;\n\t    for (var i = 0, n = 0, l = linkFns.length; i < l; n++) {\n\t      node = nodes[n];\n\t      nodeLinkFn = linkFns[i++];\n\t      childrenLinkFn = linkFns[i++];\n\t      // cache childNodes before linking parent, fix #657\n\t      var childNodes = toArray(node.childNodes);\n\t      if (nodeLinkFn) {\n\t        nodeLinkFn(vm, node, host, scope, frag);\n\t      }\n\t      if (childrenLinkFn) {\n\t        childrenLinkFn(vm, childNodes, host, scope, frag);\n\t      }\n\t    }\n\t  };\n\t}\n\t\n\t/**\n\t * Check for element directives (custom elements that should\n\t * be resovled as terminal directives).\n\t *\n\t * @param {Element} el\n\t * @param {Object} options\n\t */\n\t\n\tfunction checkElementDirectives(el, options) {\n\t  var tag = el.tagName.toLowerCase();\n\t  if (commonTagRE.test(tag)) {\n\t    return;\n\t  }\n\t  var def = resolveAsset(options, 'elementDirectives', tag);\n\t  if (def) {\n\t    return makeTerminalNodeLinkFn(el, tag, '', options, def);\n\t  }\n\t}\n\t\n\t/**\n\t * Check if an element is a component. If yes, return\n\t * a component link function.\n\t *\n\t * @param {Element} el\n\t * @param {Object} options\n\t * @return {Function|undefined}\n\t */\n\t\n\tfunction checkComponent(el, options) {\n\t  var component = checkComponentAttr(el, options);\n\t  if (component) {\n\t    var ref = findRef(el);\n\t    var descriptor = {\n\t      name: 'component',\n\t      ref: ref,\n\t      expression: component.id,\n\t      def: internalDirectives.component,\n\t      modifiers: {\n\t        literal: !component.dynamic\n\t      }\n\t    };\n\t    var componentLinkFn = function componentLinkFn(vm, el, host, scope, frag) {\n\t      if (ref) {\n\t        defineReactive((scope || vm).$refs, ref, null);\n\t      }\n\t      vm._bindDir(descriptor, el, host, scope, frag);\n\t    };\n\t    componentLinkFn.terminal = true;\n\t    return componentLinkFn;\n\t  }\n\t}\n\t\n\t/**\n\t * Check an element for terminal directives in fixed order.\n\t * If it finds one, return a terminal link function.\n\t *\n\t * @param {Element} el\n\t * @param {Array} attrs\n\t * @param {Object} options\n\t * @return {Function} terminalLinkFn\n\t */\n\t\n\tfunction checkTerminalDirectives(el, attrs, options) {\n\t  // skip v-pre\n\t  if (getAttr(el, 'v-pre') !== null) {\n\t    return skip;\n\t  }\n\t  // skip v-else block, but only if following v-if\n\t  if (el.hasAttribute('v-else')) {\n\t    var prev = el.previousElementSibling;\n\t    if (prev && prev.hasAttribute('v-if')) {\n\t      return skip;\n\t    }\n\t  }\n\t\n\t  var attr, name, value, modifiers, matched, dirName, rawName, arg, def, termDef;\n\t  for (var i = 0, j = attrs.length; i < j; i++) {\n\t    attr = attrs[i];\n\t    name = attr.name.replace(modifierRE, '');\n\t    if (matched = name.match(dirAttrRE)) {\n\t      def = resolveAsset(options, 'directives', matched[1]);\n\t      if (def && def.terminal) {\n\t        if (!termDef || (def.priority || DEFAULT_TERMINAL_PRIORITY) > termDef.priority) {\n\t          termDef = def;\n\t          rawName = attr.name;\n\t          modifiers = parseModifiers(attr.name);\n\t          value = attr.value;\n\t          dirName = matched[1];\n\t          arg = matched[2];\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  if (termDef) {\n\t    return makeTerminalNodeLinkFn(el, dirName, value, options, termDef, rawName, arg, modifiers);\n\t  }\n\t}\n\t\n\tfunction skip() {}\n\tskip.terminal = true;\n\t\n\t/**\n\t * Build a node link function for a terminal directive.\n\t * A terminal link function terminates the current\n\t * compilation recursion and handles compilation of the\n\t * subtree in the directive.\n\t *\n\t * @param {Element} el\n\t * @param {String} dirName\n\t * @param {String} value\n\t * @param {Object} options\n\t * @param {Object} def\n\t * @param {String} [rawName]\n\t * @param {String} [arg]\n\t * @param {Object} [modifiers]\n\t * @return {Function} terminalLinkFn\n\t */\n\t\n\tfunction makeTerminalNodeLinkFn(el, dirName, value, options, def, rawName, arg, modifiers) {\n\t  var parsed = parseDirective(value);\n\t  var descriptor = {\n\t    name: dirName,\n\t    arg: arg,\n\t    expression: parsed.expression,\n\t    filters: parsed.filters,\n\t    raw: value,\n\t    attr: rawName,\n\t    modifiers: modifiers,\n\t    def: def\n\t  };\n\t  // check ref for v-for and router-view\n\t  if (dirName === 'for' || dirName === 'router-view') {\n\t    descriptor.ref = findRef(el);\n\t  }\n\t  var fn = function terminalNodeLinkFn(vm, el, host, scope, frag) {\n\t    if (descriptor.ref) {\n\t      defineReactive((scope || vm).$refs, descriptor.ref, null);\n\t    }\n\t    vm._bindDir(descriptor, el, host, scope, frag);\n\t  };\n\t  fn.terminal = true;\n\t  return fn;\n\t}\n\t\n\t/**\n\t * Compile the directives on an element and return a linker.\n\t *\n\t * @param {Array|NamedNodeMap} attrs\n\t * @param {Object} options\n\t * @return {Function}\n\t */\n\t\n\tfunction compileDirectives(attrs, options) {\n\t  var i = attrs.length;\n\t  var dirs = [];\n\t  var attr, name, value, rawName, rawValue, dirName, arg, modifiers, dirDef, tokens, matched;\n\t  while (i--) {\n\t    attr = attrs[i];\n\t    name = rawName = attr.name;\n\t    value = rawValue = attr.value;\n\t    tokens = parseText(value);\n\t    // reset arg\n\t    arg = null;\n\t    // check modifiers\n\t    modifiers = parseModifiers(name);\n\t    name = name.replace(modifierRE, '');\n\t\n\t    // attribute interpolations\n\t    if (tokens) {\n\t      value = tokensToExp(tokens);\n\t      arg = name;\n\t      pushDir('bind', directives.bind, tokens);\n\t      // warn against mixing mustaches with v-bind\n\t      if (false) {\n\t        if (name === 'class' && Array.prototype.some.call(attrs, function (attr) {\n\t          return attr.name === ':class' || attr.name === 'v-bind:class';\n\t        })) {\n\t          warn('class=\"' + rawValue + '\": Do not mix mustache interpolation ' + 'and v-bind for \"class\" on the same element. Use one or the other.', options);\n\t        }\n\t      }\n\t    } else\n\t\n\t      // special attribute: transition\n\t      if (transitionRE.test(name)) {\n\t        modifiers.literal = !bindRE.test(name);\n\t        pushDir('transition', internalDirectives.transition);\n\t      } else\n\t\n\t        // event handlers\n\t        if (onRE.test(name)) {\n\t          arg = name.replace(onRE, '');\n\t          pushDir('on', directives.on);\n\t        } else\n\t\n\t          // attribute bindings\n\t          if (bindRE.test(name)) {\n\t            dirName = name.replace(bindRE, '');\n\t            if (dirName === 'style' || dirName === 'class') {\n\t              pushDir(dirName, internalDirectives[dirName]);\n\t            } else {\n\t              arg = dirName;\n\t              pushDir('bind', directives.bind);\n\t            }\n\t          } else\n\t\n\t            // normal directives\n\t            if (matched = name.match(dirAttrRE)) {\n\t              dirName = matched[1];\n\t              arg = matched[2];\n\t\n\t              // skip v-else (when used with v-show)\n\t              if (dirName === 'else') {\n\t                continue;\n\t              }\n\t\n\t              dirDef = resolveAsset(options, 'directives', dirName, true);\n\t              if (dirDef) {\n\t                pushDir(dirName, dirDef);\n\t              }\n\t            }\n\t  }\n\t\n\t  /**\n\t   * Push a directive.\n\t   *\n\t   * @param {String} dirName\n\t   * @param {Object|Function} def\n\t   * @param {Array} [interpTokens]\n\t   */\n\t\n\t  function pushDir(dirName, def, interpTokens) {\n\t    var hasOneTimeToken = interpTokens && hasOneTime(interpTokens);\n\t    var parsed = !hasOneTimeToken && parseDirective(value);\n\t    dirs.push({\n\t      name: dirName,\n\t      attr: rawName,\n\t      raw: rawValue,\n\t      def: def,\n\t      arg: arg,\n\t      modifiers: modifiers,\n\t      // conversion from interpolation strings with one-time token\n\t      // to expression is differed until directive bind time so that we\n\t      // have access to the actual vm context for one-time bindings.\n\t      expression: parsed && parsed.expression,\n\t      filters: parsed && parsed.filters,\n\t      interp: interpTokens,\n\t      hasOneTime: hasOneTimeToken\n\t    });\n\t  }\n\t\n\t  if (dirs.length) {\n\t    return makeNodeLinkFn(dirs);\n\t  }\n\t}\n\t\n\t/**\n\t * Parse modifiers from directive attribute name.\n\t *\n\t * @param {String} name\n\t * @return {Object}\n\t */\n\t\n\tfunction parseModifiers(name) {\n\t  var res = Object.create(null);\n\t  var match = name.match(modifierRE);\n\t  if (match) {\n\t    var i = match.length;\n\t    while (i--) {\n\t      res[match[i].slice(1)] = true;\n\t    }\n\t  }\n\t  return res;\n\t}\n\t\n\t/**\n\t * Build a link function for all directives on a single node.\n\t *\n\t * @param {Array} directives\n\t * @return {Function} directivesLinkFn\n\t */\n\t\n\tfunction makeNodeLinkFn(directives) {\n\t  return function nodeLinkFn(vm, el, host, scope, frag) {\n\t    // reverse apply because it's sorted low to high\n\t    var i = directives.length;\n\t    while (i--) {\n\t      vm._bindDir(directives[i], el, host, scope, frag);\n\t    }\n\t  };\n\t}\n\t\n\t/**\n\t * Check if an interpolation string contains one-time tokens.\n\t *\n\t * @param {Array} tokens\n\t * @return {Boolean}\n\t */\n\t\n\tfunction hasOneTime(tokens) {\n\t  var i = tokens.length;\n\t  while (i--) {\n\t    if (tokens[i].oneTime) return true;\n\t  }\n\t}\n\t\n\tfunction isScript(el) {\n\t  return el.tagName === 'SCRIPT' && (!el.hasAttribute('type') || el.getAttribute('type') === 'text/javascript');\n\t}\n\t\n\tvar specialCharRE = /[^\\w\\-:\\.]/;\n\t\n\t/**\n\t * Process an element or a DocumentFragment based on a\n\t * instance option object. This allows us to transclude\n\t * a template node/fragment before the instance is created,\n\t * so the processed fragment can then be cloned and reused\n\t * in v-for.\n\t *\n\t * @param {Element} el\n\t * @param {Object} options\n\t * @return {Element|DocumentFragment}\n\t */\n\t\n\tfunction transclude(el, options) {\n\t  // extract container attributes to pass them down\n\t  // to compiler, because they need to be compiled in\n\t  // parent scope. we are mutating the options object here\n\t  // assuming the same object will be used for compile\n\t  // right after this.\n\t  if (options) {\n\t    options._containerAttrs = extractAttrs(el);\n\t  }\n\t  // for template tags, what we want is its content as\n\t  // a documentFragment (for fragment instances)\n\t  if (isTemplate(el)) {\n\t    el = parseTemplate(el);\n\t  }\n\t  if (options) {\n\t    if (options._asComponent && !options.template) {\n\t      options.template = '<slot></slot>';\n\t    }\n\t    if (options.template) {\n\t      options._content = extractContent(el);\n\t      el = transcludeTemplate(el, options);\n\t    }\n\t  }\n\t  if (isFragment(el)) {\n\t    // anchors for fragment instance\n\t    // passing in `persist: true` to avoid them being\n\t    // discarded by IE during template cloning\n\t    prepend(createAnchor('v-start', true), el);\n\t    el.appendChild(createAnchor('v-end', true));\n\t  }\n\t  return el;\n\t}\n\t\n\t/**\n\t * Process the template option.\n\t * If the replace option is true this will swap the $el.\n\t *\n\t * @param {Element} el\n\t * @param {Object} options\n\t * @return {Element|DocumentFragment}\n\t */\n\t\n\tfunction transcludeTemplate(el, options) {\n\t  var template = options.template;\n\t  var frag = parseTemplate(template, true);\n\t  if (frag) {\n\t    var replacer = frag.firstChild;\n\t    var tag = replacer.tagName && replacer.tagName.toLowerCase();\n\t    if (options.replace) {\n\t      /* istanbul ignore if */\n\t      if (el === document.body) {\n\t        (\"production\") !== 'production' && warn('You are mounting an instance with a template to ' + '<body>. This will replace <body> entirely. You ' + 'should probably use `replace: false` here.');\n\t      }\n\t      // there are many cases where the instance must\n\t      // become a fragment instance: basically anything that\n\t      // can create more than 1 root nodes.\n\t      if (\n\t      // multi-children template\n\t      frag.childNodes.length > 1 ||\n\t      // non-element template\n\t      replacer.nodeType !== 1 ||\n\t      // single nested component\n\t      tag === 'component' || resolveAsset(options, 'components', tag) || hasBindAttr(replacer, 'is') ||\n\t      // element directive\n\t      resolveAsset(options, 'elementDirectives', tag) ||\n\t      // for block\n\t      replacer.hasAttribute('v-for') ||\n\t      // if block\n\t      replacer.hasAttribute('v-if')) {\n\t        return frag;\n\t      } else {\n\t        options._replacerAttrs = extractAttrs(replacer);\n\t        mergeAttrs(el, replacer);\n\t        return replacer;\n\t      }\n\t    } else {\n\t      el.appendChild(frag);\n\t      return el;\n\t    }\n\t  } else {\n\t    (\"production\") !== 'production' && warn('Invalid template option: ' + template);\n\t  }\n\t}\n\t\n\t/**\n\t * Helper to extract a component container's attributes\n\t * into a plain object array.\n\t *\n\t * @param {Element} el\n\t * @return {Array}\n\t */\n\t\n\tfunction extractAttrs(el) {\n\t  if (el.nodeType === 1 && el.hasAttributes()) {\n\t    return toArray(el.attributes);\n\t  }\n\t}\n\t\n\t/**\n\t * Merge the attributes of two elements, and make sure\n\t * the class names are merged properly.\n\t *\n\t * @param {Element} from\n\t * @param {Element} to\n\t */\n\t\n\tfunction mergeAttrs(from, to) {\n\t  var attrs = from.attributes;\n\t  var i = attrs.length;\n\t  var name, value;\n\t  while (i--) {\n\t    name = attrs[i].name;\n\t    value = attrs[i].value;\n\t    if (!to.hasAttribute(name) && !specialCharRE.test(name)) {\n\t      to.setAttribute(name, value);\n\t    } else if (name === 'class' && !parseText(value) && (value = value.trim())) {\n\t      value.split(/\\s+/).forEach(function (cls) {\n\t        addClass(to, cls);\n\t      });\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Scan and determine slot content distribution.\n\t * We do this during transclusion instead at compile time so that\n\t * the distribution is decoupled from the compilation order of\n\t * the slots.\n\t *\n\t * @param {Element|DocumentFragment} template\n\t * @param {Element} content\n\t * @param {Vue} vm\n\t */\n\t\n\tfunction resolveSlots(vm, content) {\n\t  if (!content) {\n\t    return;\n\t  }\n\t  var contents = vm._slotContents = Object.create(null);\n\t  var el, name;\n\t  for (var i = 0, l = content.children.length; i < l; i++) {\n\t    el = content.children[i];\n\t    /* eslint-disable no-cond-assign */\n\t    if (name = el.getAttribute('slot')) {\n\t      (contents[name] || (contents[name] = [])).push(el);\n\t    }\n\t    /* eslint-enable no-cond-assign */\n\t    if (false) {\n\t      warn('The \"slot\" attribute must be static.', vm.$parent);\n\t    }\n\t  }\n\t  for (name in contents) {\n\t    contents[name] = extractFragment(contents[name], content);\n\t  }\n\t  if (content.hasChildNodes()) {\n\t    var nodes = content.childNodes;\n\t    if (nodes.length === 1 && nodes[0].nodeType === 3 && !nodes[0].data.trim()) {\n\t      return;\n\t    }\n\t    contents['default'] = extractFragment(content.childNodes, content);\n\t  }\n\t}\n\t\n\t/**\n\t * Extract qualified content nodes from a node list.\n\t *\n\t * @param {NodeList} nodes\n\t * @return {DocumentFragment}\n\t */\n\t\n\tfunction extractFragment(nodes, parent) {\n\t  var frag = document.createDocumentFragment();\n\t  nodes = toArray(nodes);\n\t  for (var i = 0, l = nodes.length; i < l; i++) {\n\t    var node = nodes[i];\n\t    if (isTemplate(node) && !node.hasAttribute('v-if') && !node.hasAttribute('v-for')) {\n\t      parent.removeChild(node);\n\t      node = parseTemplate(node, true);\n\t    }\n\t    frag.appendChild(node);\n\t  }\n\t  return frag;\n\t}\n\t\n\t\n\t\n\tvar compiler = Object.freeze({\n\t\tcompile: compile,\n\t\tcompileAndLinkProps: compileAndLinkProps,\n\t\tcompileRoot: compileRoot,\n\t\ttransclude: transclude,\n\t\tresolveSlots: resolveSlots\n\t});\n\t\n\tfunction stateMixin (Vue) {\n\t  /**\n\t   * Accessor for `$data` property, since setting $data\n\t   * requires observing the new object and updating\n\t   * proxied properties.\n\t   */\n\t\n\t  Object.defineProperty(Vue.prototype, '$data', {\n\t    get: function get() {\n\t      return this._data;\n\t    },\n\t    set: function set(newData) {\n\t      if (newData !== this._data) {\n\t        this._setData(newData);\n\t      }\n\t    }\n\t  });\n\t\n\t  /**\n\t   * Setup the scope of an instance, which contains:\n\t   * - observed data\n\t   * - computed properties\n\t   * - user methods\n\t   * - meta properties\n\t   */\n\t\n\t  Vue.prototype._initState = function () {\n\t    this._initProps();\n\t    this._initMeta();\n\t    this._initMethods();\n\t    this._initData();\n\t    this._initComputed();\n\t  };\n\t\n\t  /**\n\t   * Initialize props.\n\t   */\n\t\n\t  Vue.prototype._initProps = function () {\n\t    var options = this.$options;\n\t    var el = options.el;\n\t    var props = options.props;\n\t    if (props && !el) {\n\t      (\"production\") !== 'production' && warn('Props will not be compiled if no `el` option is ' + 'provided at instantiation.', this);\n\t    }\n\t    // make sure to convert string selectors into element now\n\t    el = options.el = query(el);\n\t    this._propsUnlinkFn = el && el.nodeType === 1 && props\n\t    // props must be linked in proper scope if inside v-for\n\t    ? compileAndLinkProps(this, el, props, this._scope) : null;\n\t  };\n\t\n\t  /**\n\t   * Initialize the data.\n\t   */\n\t\n\t  Vue.prototype._initData = function () {\n\t    var dataFn = this.$options.data;\n\t    var data = this._data = dataFn ? dataFn() : {};\n\t    if (!isPlainObject(data)) {\n\t      data = {};\n\t      (\"production\") !== 'production' && warn('data functions should return an object.', this);\n\t    }\n\t    var props = this._props;\n\t    // proxy data on instance\n\t    var keys = Object.keys(data);\n\t    var i, key;\n\t    i = keys.length;\n\t    while (i--) {\n\t      key = keys[i];\n\t      // there are two scenarios where we can proxy a data key:\n\t      // 1. it's not already defined as a prop\n\t      // 2. it's provided via a instantiation option AND there are no\n\t      //    template prop present\n\t      if (!props || !hasOwn(props, key)) {\n\t        this._proxy(key);\n\t      } else if (false) {\n\t        warn('Data field \"' + key + '\" is already defined ' + 'as a prop. To provide default value for a prop, use the \"default\" ' + 'prop option; if you want to pass prop values to an instantiation ' + 'call, use the \"propsData\" option.', this);\n\t      }\n\t    }\n\t    // observe data\n\t    observe(data, this);\n\t  };\n\t\n\t  /**\n\t   * Swap the instance's $data. Called in $data's setter.\n\t   *\n\t   * @param {Object} newData\n\t   */\n\t\n\t  Vue.prototype._setData = function (newData) {\n\t    newData = newData || {};\n\t    var oldData = this._data;\n\t    this._data = newData;\n\t    var keys, key, i;\n\t    // unproxy keys not present in new data\n\t    keys = Object.keys(oldData);\n\t    i = keys.length;\n\t    while (i--) {\n\t      key = keys[i];\n\t      if (!(key in newData)) {\n\t        this._unproxy(key);\n\t      }\n\t    }\n\t    // proxy keys not already proxied,\n\t    // and trigger change for changed values\n\t    keys = Object.keys(newData);\n\t    i = keys.length;\n\t    while (i--) {\n\t      key = keys[i];\n\t      if (!hasOwn(this, key)) {\n\t        // new property\n\t        this._proxy(key);\n\t      }\n\t    }\n\t    oldData.__ob__.removeVm(this);\n\t    observe(newData, this);\n\t    this._digest();\n\t  };\n\t\n\t  /**\n\t   * Proxy a property, so that\n\t   * vm.prop === vm._data.prop\n\t   *\n\t   * @param {String} key\n\t   */\n\t\n\t  Vue.prototype._proxy = function (key) {\n\t    if (!isReserved(key)) {\n\t      // need to store ref to self here\n\t      // because these getter/setters might\n\t      // be called by child scopes via\n\t      // prototype inheritance.\n\t      var self = this;\n\t      Object.defineProperty(self, key, {\n\t        configurable: true,\n\t        enumerable: true,\n\t        get: function proxyGetter() {\n\t          return self._data[key];\n\t        },\n\t        set: function proxySetter(val) {\n\t          self._data[key] = val;\n\t        }\n\t      });\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Unproxy a property.\n\t   *\n\t   * @param {String} key\n\t   */\n\t\n\t  Vue.prototype._unproxy = function (key) {\n\t    if (!isReserved(key)) {\n\t      delete this[key];\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Force update on every watcher in scope.\n\t   */\n\t\n\t  Vue.prototype._digest = function () {\n\t    for (var i = 0, l = this._watchers.length; i < l; i++) {\n\t      this._watchers[i].update(true); // shallow updates\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Setup computed properties. They are essentially\n\t   * special getter/setters\n\t   */\n\t\n\t  function noop() {}\n\t  Vue.prototype._initComputed = function () {\n\t    var computed = this.$options.computed;\n\t    if (computed) {\n\t      for (var key in computed) {\n\t        var userDef = computed[key];\n\t        var def = {\n\t          enumerable: true,\n\t          configurable: true\n\t        };\n\t        if (typeof userDef === 'function') {\n\t          def.get = makeComputedGetter(userDef, this);\n\t          def.set = noop;\n\t        } else {\n\t          def.get = userDef.get ? userDef.cache !== false ? makeComputedGetter(userDef.get, this) : bind(userDef.get, this) : noop;\n\t          def.set = userDef.set ? bind(userDef.set, this) : noop;\n\t        }\n\t        Object.defineProperty(this, key, def);\n\t      }\n\t    }\n\t  };\n\t\n\t  function makeComputedGetter(getter, owner) {\n\t    var watcher = new Watcher(owner, getter, null, {\n\t      lazy: true\n\t    });\n\t    return function computedGetter() {\n\t      if (watcher.dirty) {\n\t        watcher.evaluate();\n\t      }\n\t      if (Dep.target) {\n\t        watcher.depend();\n\t      }\n\t      return watcher.value;\n\t    };\n\t  }\n\t\n\t  /**\n\t   * Setup instance methods. Methods must be bound to the\n\t   * instance since they might be passed down as a prop to\n\t   * child components.\n\t   */\n\t\n\t  Vue.prototype._initMethods = function () {\n\t    var methods = this.$options.methods;\n\t    if (methods) {\n\t      for (var key in methods) {\n\t        this[key] = bind(methods[key], this);\n\t      }\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Initialize meta information like $index, $key & $value.\n\t   */\n\t\n\t  Vue.prototype._initMeta = function () {\n\t    var metas = this.$options._meta;\n\t    if (metas) {\n\t      for (var key in metas) {\n\t        defineReactive(this, key, metas[key]);\n\t      }\n\t    }\n\t  };\n\t}\n\t\n\tvar eventRE = /^v-on:|^@/;\n\t\n\tfunction eventsMixin (Vue) {\n\t  /**\n\t   * Setup the instance's option events & watchers.\n\t   * If the value is a string, we pull it from the\n\t   * instance's methods by name.\n\t   */\n\t\n\t  Vue.prototype._initEvents = function () {\n\t    var options = this.$options;\n\t    if (options._asComponent) {\n\t      registerComponentEvents(this, options.el);\n\t    }\n\t    registerCallbacks(this, '$on', options.events);\n\t    registerCallbacks(this, '$watch', options.watch);\n\t  };\n\t\n\t  /**\n\t   * Register v-on events on a child component\n\t   *\n\t   * @param {Vue} vm\n\t   * @param {Element} el\n\t   */\n\t\n\t  function registerComponentEvents(vm, el) {\n\t    var attrs = el.attributes;\n\t    var name, value, handler;\n\t    for (var i = 0, l = attrs.length; i < l; i++) {\n\t      name = attrs[i].name;\n\t      if (eventRE.test(name)) {\n\t        name = name.replace(eventRE, '');\n\t        // force the expression into a statement so that\n\t        // it always dynamically resolves the method to call (#2670)\n\t        // kinda ugly hack, but does the job.\n\t        value = attrs[i].value;\n\t        if (isSimplePath(value)) {\n\t          value += '.apply(this, $arguments)';\n\t        }\n\t        handler = (vm._scope || vm._context).$eval(value, true);\n\t        handler._fromParent = true;\n\t        vm.$on(name.replace(eventRE), handler);\n\t      }\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Register callbacks for option events and watchers.\n\t   *\n\t   * @param {Vue} vm\n\t   * @param {String} action\n\t   * @param {Object} hash\n\t   */\n\t\n\t  function registerCallbacks(vm, action, hash) {\n\t    if (!hash) return;\n\t    var handlers, key, i, j;\n\t    for (key in hash) {\n\t      handlers = hash[key];\n\t      if (isArray(handlers)) {\n\t        for (i = 0, j = handlers.length; i < j; i++) {\n\t          register(vm, action, key, handlers[i]);\n\t        }\n\t      } else {\n\t        register(vm, action, key, handlers);\n\t      }\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Helper to register an event/watch callback.\n\t   *\n\t   * @param {Vue} vm\n\t   * @param {String} action\n\t   * @param {String} key\n\t   * @param {Function|String|Object} handler\n\t   * @param {Object} [options]\n\t   */\n\t\n\t  function register(vm, action, key, handler, options) {\n\t    var type = typeof handler;\n\t    if (type === 'function') {\n\t      vm[action](key, handler, options);\n\t    } else if (type === 'string') {\n\t      var methods = vm.$options.methods;\n\t      var method = methods && methods[handler];\n\t      if (method) {\n\t        vm[action](key, method, options);\n\t      } else {\n\t        (\"production\") !== 'production' && warn('Unknown method: \"' + handler + '\" when ' + 'registering callback for ' + action + ': \"' + key + '\".', vm);\n\t      }\n\t    } else if (handler && type === 'object') {\n\t      register(vm, action, key, handler.handler, handler);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Setup recursive attached/detached calls\n\t   */\n\t\n\t  Vue.prototype._initDOMHooks = function () {\n\t    this.$on('hook:attached', onAttached);\n\t    this.$on('hook:detached', onDetached);\n\t  };\n\t\n\t  /**\n\t   * Callback to recursively call attached hook on children\n\t   */\n\t\n\t  function onAttached() {\n\t    if (!this._isAttached) {\n\t      this._isAttached = true;\n\t      this.$children.forEach(callAttach);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Iterator to call attached hook\n\t   *\n\t   * @param {Vue} child\n\t   */\n\t\n\t  function callAttach(child) {\n\t    if (!child._isAttached && inDoc(child.$el)) {\n\t      child._callHook('attached');\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Callback to recursively call detached hook on children\n\t   */\n\t\n\t  function onDetached() {\n\t    if (this._isAttached) {\n\t      this._isAttached = false;\n\t      this.$children.forEach(callDetach);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Iterator to call detached hook\n\t   *\n\t   * @param {Vue} child\n\t   */\n\t\n\t  function callDetach(child) {\n\t    if (child._isAttached && !inDoc(child.$el)) {\n\t      child._callHook('detached');\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Trigger all handlers for a hook\n\t   *\n\t   * @param {String} hook\n\t   */\n\t\n\t  Vue.prototype._callHook = function (hook) {\n\t    this.$emit('pre-hook:' + hook);\n\t    var handlers = this.$options[hook];\n\t    if (handlers) {\n\t      for (var i = 0, j = handlers.length; i < j; i++) {\n\t        handlers[i].call(this);\n\t      }\n\t    }\n\t    this.$emit('hook:' + hook);\n\t  };\n\t}\n\t\n\tfunction noop$1() {}\n\t\n\t/**\n\t * A directive links a DOM element with a piece of data,\n\t * which is the result of evaluating an expression.\n\t * It registers a watcher with the expression and calls\n\t * the DOM update function when a change is triggered.\n\t *\n\t * @param {Object} descriptor\n\t *                 - {String} name\n\t *                 - {Object} def\n\t *                 - {String} expression\n\t *                 - {Array<Object>} [filters]\n\t *                 - {Object} [modifiers]\n\t *                 - {Boolean} literal\n\t *                 - {String} attr\n\t *                 - {String} arg\n\t *                 - {String} raw\n\t *                 - {String} [ref]\n\t *                 - {Array<Object>} [interp]\n\t *                 - {Boolean} [hasOneTime]\n\t * @param {Vue} vm\n\t * @param {Node} el\n\t * @param {Vue} [host] - transclusion host component\n\t * @param {Object} [scope] - v-for scope\n\t * @param {Fragment} [frag] - owner fragment\n\t * @constructor\n\t */\n\tfunction Directive(descriptor, vm, el, host, scope, frag) {\n\t  this.vm = vm;\n\t  this.el = el;\n\t  // copy descriptor properties\n\t  this.descriptor = descriptor;\n\t  this.name = descriptor.name;\n\t  this.expression = descriptor.expression;\n\t  this.arg = descriptor.arg;\n\t  this.modifiers = descriptor.modifiers;\n\t  this.filters = descriptor.filters;\n\t  this.literal = this.modifiers && this.modifiers.literal;\n\t  // private\n\t  this._locked = false;\n\t  this._bound = false;\n\t  this._listeners = null;\n\t  // link context\n\t  this._host = host;\n\t  this._scope = scope;\n\t  this._frag = frag;\n\t  // store directives on node in dev mode\n\t  if (false) {\n\t    this.el._vue_directives = this.el._vue_directives || [];\n\t    this.el._vue_directives.push(this);\n\t  }\n\t}\n\t\n\t/**\n\t * Initialize the directive, mixin definition properties,\n\t * setup the watcher, call definition bind() and update()\n\t * if present.\n\t */\n\t\n\tDirective.prototype._bind = function () {\n\t  var name = this.name;\n\t  var descriptor = this.descriptor;\n\t\n\t  // remove attribute\n\t  if ((name !== 'cloak' || this.vm._isCompiled) && this.el && this.el.removeAttribute) {\n\t    var attr = descriptor.attr || 'v-' + name;\n\t    this.el.removeAttribute(attr);\n\t  }\n\t\n\t  // copy def properties\n\t  var def = descriptor.def;\n\t  if (typeof def === 'function') {\n\t    this.update = def;\n\t  } else {\n\t    extend(this, def);\n\t  }\n\t\n\t  // setup directive params\n\t  this._setupParams();\n\t\n\t  // initial bind\n\t  if (this.bind) {\n\t    this.bind();\n\t  }\n\t  this._bound = true;\n\t\n\t  if (this.literal) {\n\t    this.update && this.update(descriptor.raw);\n\t  } else if ((this.expression || this.modifiers) && (this.update || this.twoWay) && !this._checkStatement()) {\n\t    // wrapped updater for context\n\t    var dir = this;\n\t    if (this.update) {\n\t      this._update = function (val, oldVal) {\n\t        if (!dir._locked) {\n\t          dir.update(val, oldVal);\n\t        }\n\t      };\n\t    } else {\n\t      this._update = noop$1;\n\t    }\n\t    var preProcess = this._preProcess ? bind(this._preProcess, this) : null;\n\t    var postProcess = this._postProcess ? bind(this._postProcess, this) : null;\n\t    var watcher = this._watcher = new Watcher(this.vm, this.expression, this._update, // callback\n\t    {\n\t      filters: this.filters,\n\t      twoWay: this.twoWay,\n\t      deep: this.deep,\n\t      preProcess: preProcess,\n\t      postProcess: postProcess,\n\t      scope: this._scope\n\t    });\n\t    // v-model with inital inline value need to sync back to\n\t    // model instead of update to DOM on init. They would\n\t    // set the afterBind hook to indicate that.\n\t    if (this.afterBind) {\n\t      this.afterBind();\n\t    } else if (this.update) {\n\t      this.update(watcher.value);\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Setup all param attributes, e.g. track-by,\n\t * transition-mode, etc...\n\t */\n\t\n\tDirective.prototype._setupParams = function () {\n\t  if (!this.params) {\n\t    return;\n\t  }\n\t  var params = this.params;\n\t  // swap the params array with a fresh object.\n\t  this.params = Object.create(null);\n\t  var i = params.length;\n\t  var key, val, mappedKey;\n\t  while (i--) {\n\t    key = hyphenate(params[i]);\n\t    mappedKey = camelize(key);\n\t    val = getBindAttr(this.el, key);\n\t    if (val != null) {\n\t      // dynamic\n\t      this._setupParamWatcher(mappedKey, val);\n\t    } else {\n\t      // static\n\t      val = getAttr(this.el, key);\n\t      if (val != null) {\n\t        this.params[mappedKey] = val === '' ? true : val;\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Setup a watcher for a dynamic param.\n\t *\n\t * @param {String} key\n\t * @param {String} expression\n\t */\n\t\n\tDirective.prototype._setupParamWatcher = function (key, expression) {\n\t  var self = this;\n\t  var called = false;\n\t  var unwatch = (this._scope || this.vm).$watch(expression, function (val, oldVal) {\n\t    self.params[key] = val;\n\t    // since we are in immediate mode,\n\t    // only call the param change callbacks if this is not the first update.\n\t    if (called) {\n\t      var cb = self.paramWatchers && self.paramWatchers[key];\n\t      if (cb) {\n\t        cb.call(self, val, oldVal);\n\t      }\n\t    } else {\n\t      called = true;\n\t    }\n\t  }, {\n\t    immediate: true,\n\t    user: false\n\t  });(this._paramUnwatchFns || (this._paramUnwatchFns = [])).push(unwatch);\n\t};\n\t\n\t/**\n\t * Check if the directive is a function caller\n\t * and if the expression is a callable one. If both true,\n\t * we wrap up the expression and use it as the event\n\t * handler.\n\t *\n\t * e.g. on-click=\"a++\"\n\t *\n\t * @return {Boolean}\n\t */\n\t\n\tDirective.prototype._checkStatement = function () {\n\t  var expression = this.expression;\n\t  if (expression && this.acceptStatement && !isSimplePath(expression)) {\n\t    var fn = parseExpression(expression).get;\n\t    var scope = this._scope || this.vm;\n\t    var handler = function handler(e) {\n\t      scope.$event = e;\n\t      fn.call(scope, scope);\n\t      scope.$event = null;\n\t    };\n\t    if (this.filters) {\n\t      handler = scope._applyFilters(handler, null, this.filters);\n\t    }\n\t    this.update(handler);\n\t    return true;\n\t  }\n\t};\n\t\n\t/**\n\t * Set the corresponding value with the setter.\n\t * This should only be used in two-way directives\n\t * e.g. v-model.\n\t *\n\t * @param {*} value\n\t * @public\n\t */\n\t\n\tDirective.prototype.set = function (value) {\n\t  /* istanbul ignore else */\n\t  if (this.twoWay) {\n\t    this._withLock(function () {\n\t      this._watcher.set(value);\n\t    });\n\t  } else if (false) {\n\t    warn('Directive.set() can only be used inside twoWay' + 'directives.');\n\t  }\n\t};\n\t\n\t/**\n\t * Execute a function while preventing that function from\n\t * triggering updates on this directive instance.\n\t *\n\t * @param {Function} fn\n\t */\n\t\n\tDirective.prototype._withLock = function (fn) {\n\t  var self = this;\n\t  self._locked = true;\n\t  fn.call(self);\n\t  nextTick(function () {\n\t    self._locked = false;\n\t  });\n\t};\n\t\n\t/**\n\t * Convenience method that attaches a DOM event listener\n\t * to the directive element and autometically tears it down\n\t * during unbind.\n\t *\n\t * @param {String} event\n\t * @param {Function} handler\n\t * @param {Boolean} [useCapture]\n\t */\n\t\n\tDirective.prototype.on = function (event, handler, useCapture) {\n\t  on(this.el, event, handler, useCapture);(this._listeners || (this._listeners = [])).push([event, handler]);\n\t};\n\t\n\t/**\n\t * Teardown the watcher and call unbind.\n\t */\n\t\n\tDirective.prototype._teardown = function () {\n\t  if (this._bound) {\n\t    this._bound = false;\n\t    if (this.unbind) {\n\t      this.unbind();\n\t    }\n\t    if (this._watcher) {\n\t      this._watcher.teardown();\n\t    }\n\t    var listeners = this._listeners;\n\t    var i;\n\t    if (listeners) {\n\t      i = listeners.length;\n\t      while (i--) {\n\t        off(this.el, listeners[i][0], listeners[i][1]);\n\t      }\n\t    }\n\t    var unwatchFns = this._paramUnwatchFns;\n\t    if (unwatchFns) {\n\t      i = unwatchFns.length;\n\t      while (i--) {\n\t        unwatchFns[i]();\n\t      }\n\t    }\n\t    if (false) {\n\t      this.el._vue_directives.$remove(this);\n\t    }\n\t    this.vm = this.el = this._watcher = this._listeners = null;\n\t  }\n\t};\n\t\n\tfunction lifecycleMixin (Vue) {\n\t  /**\n\t   * Update v-ref for component.\n\t   *\n\t   * @param {Boolean} remove\n\t   */\n\t\n\t  Vue.prototype._updateRef = function (remove) {\n\t    var ref = this.$options._ref;\n\t    if (ref) {\n\t      var refs = (this._scope || this._context).$refs;\n\t      if (remove) {\n\t        if (refs[ref] === this) {\n\t          refs[ref] = null;\n\t        }\n\t      } else {\n\t        refs[ref] = this;\n\t      }\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Transclude, compile and link element.\n\t   *\n\t   * If a pre-compiled linker is available, that means the\n\t   * passed in element will be pre-transcluded and compiled\n\t   * as well - all we need to do is to call the linker.\n\t   *\n\t   * Otherwise we need to call transclude/compile/link here.\n\t   *\n\t   * @param {Element} el\n\t   */\n\t\n\t  Vue.prototype._compile = function (el) {\n\t    var options = this.$options;\n\t\n\t    // transclude and init element\n\t    // transclude can potentially replace original\n\t    // so we need to keep reference; this step also injects\n\t    // the template and caches the original attributes\n\t    // on the container node and replacer node.\n\t    var original = el;\n\t    el = transclude(el, options);\n\t    this._initElement(el);\n\t\n\t    // handle v-pre on root node (#2026)\n\t    if (el.nodeType === 1 && getAttr(el, 'v-pre') !== null) {\n\t      return;\n\t    }\n\t\n\t    // root is always compiled per-instance, because\n\t    // container attrs and props can be different every time.\n\t    var contextOptions = this._context && this._context.$options;\n\t    var rootLinker = compileRoot(el, options, contextOptions);\n\t\n\t    // resolve slot distribution\n\t    resolveSlots(this, options._content);\n\t\n\t    // compile and link the rest\n\t    var contentLinkFn;\n\t    var ctor = this.constructor;\n\t    // component compilation can be cached\n\t    // as long as it's not using inline-template\n\t    if (options._linkerCachable) {\n\t      contentLinkFn = ctor.linker;\n\t      if (!contentLinkFn) {\n\t        contentLinkFn = ctor.linker = compile(el, options);\n\t      }\n\t    }\n\t\n\t    // link phase\n\t    // make sure to link root with prop scope!\n\t    var rootUnlinkFn = rootLinker(this, el, this._scope);\n\t    var contentUnlinkFn = contentLinkFn ? contentLinkFn(this, el) : compile(el, options)(this, el);\n\t\n\t    // register composite unlink function\n\t    // to be called during instance destruction\n\t    this._unlinkFn = function () {\n\t      rootUnlinkFn();\n\t      // passing destroying: true to avoid searching and\n\t      // splicing the directives\n\t      contentUnlinkFn(true);\n\t    };\n\t\n\t    // finally replace original\n\t    if (options.replace) {\n\t      replace(original, el);\n\t    }\n\t\n\t    this._isCompiled = true;\n\t    this._callHook('compiled');\n\t  };\n\t\n\t  /**\n\t   * Initialize instance element. Called in the public\n\t   * $mount() method.\n\t   *\n\t   * @param {Element} el\n\t   */\n\t\n\t  Vue.prototype._initElement = function (el) {\n\t    if (isFragment(el)) {\n\t      this._isFragment = true;\n\t      this.$el = this._fragmentStart = el.firstChild;\n\t      this._fragmentEnd = el.lastChild;\n\t      // set persisted text anchors to empty\n\t      if (this._fragmentStart.nodeType === 3) {\n\t        this._fragmentStart.data = this._fragmentEnd.data = '';\n\t      }\n\t      this._fragment = el;\n\t    } else {\n\t      this.$el = el;\n\t    }\n\t    this.$el.__vue__ = this;\n\t    this._callHook('beforeCompile');\n\t  };\n\t\n\t  /**\n\t   * Create and bind a directive to an element.\n\t   *\n\t   * @param {Object} descriptor - parsed directive descriptor\n\t   * @param {Node} node   - target node\n\t   * @param {Vue} [host] - transclusion host component\n\t   * @param {Object} [scope] - v-for scope\n\t   * @param {Fragment} [frag] - owner fragment\n\t   */\n\t\n\t  Vue.prototype._bindDir = function (descriptor, node, host, scope, frag) {\n\t    this._directives.push(new Directive(descriptor, this, node, host, scope, frag));\n\t  };\n\t\n\t  /**\n\t   * Teardown an instance, unobserves the data, unbind all the\n\t   * directives, turn off all the event listeners, etc.\n\t   *\n\t   * @param {Boolean} remove - whether to remove the DOM node.\n\t   * @param {Boolean} deferCleanup - if true, defer cleanup to\n\t   *                                 be called later\n\t   */\n\t\n\t  Vue.prototype._destroy = function (remove, deferCleanup) {\n\t    if (this._isBeingDestroyed) {\n\t      if (!deferCleanup) {\n\t        this._cleanup();\n\t      }\n\t      return;\n\t    }\n\t\n\t    var destroyReady;\n\t    var pendingRemoval;\n\t\n\t    var self = this;\n\t    // Cleanup should be called either synchronously or asynchronoysly as\n\t    // callback of this.$remove(), or if remove and deferCleanup are false.\n\t    // In any case it should be called after all other removing, unbinding and\n\t    // turning of is done\n\t    var cleanupIfPossible = function cleanupIfPossible() {\n\t      if (destroyReady && !pendingRemoval && !deferCleanup) {\n\t        self._cleanup();\n\t      }\n\t    };\n\t\n\t    // remove DOM element\n\t    if (remove && this.$el) {\n\t      pendingRemoval = true;\n\t      this.$remove(function () {\n\t        pendingRemoval = false;\n\t        cleanupIfPossible();\n\t      });\n\t    }\n\t\n\t    this._callHook('beforeDestroy');\n\t    this._isBeingDestroyed = true;\n\t    var i;\n\t    // remove self from parent. only necessary\n\t    // if parent is not being destroyed as well.\n\t    var parent = this.$parent;\n\t    if (parent && !parent._isBeingDestroyed) {\n\t      parent.$children.$remove(this);\n\t      // unregister ref (remove: true)\n\t      this._updateRef(true);\n\t    }\n\t    // destroy all children.\n\t    i = this.$children.length;\n\t    while (i--) {\n\t      this.$children[i].$destroy();\n\t    }\n\t    // teardown props\n\t    if (this._propsUnlinkFn) {\n\t      this._propsUnlinkFn();\n\t    }\n\t    // teardown all directives. this also tearsdown all\n\t    // directive-owned watchers.\n\t    if (this._unlinkFn) {\n\t      this._unlinkFn();\n\t    }\n\t    i = this._watchers.length;\n\t    while (i--) {\n\t      this._watchers[i].teardown();\n\t    }\n\t    // remove reference to self on $el\n\t    if (this.$el) {\n\t      this.$el.__vue__ = null;\n\t    }\n\t\n\t    destroyReady = true;\n\t    cleanupIfPossible();\n\t  };\n\t\n\t  /**\n\t   * Clean up to ensure garbage collection.\n\t   * This is called after the leave transition if there\n\t   * is any.\n\t   */\n\t\n\t  Vue.prototype._cleanup = function () {\n\t    if (this._isDestroyed) {\n\t      return;\n\t    }\n\t    // remove self from owner fragment\n\t    // do it in cleanup so that we can call $destroy with\n\t    // defer right when a fragment is about to be removed.\n\t    if (this._frag) {\n\t      this._frag.children.$remove(this);\n\t    }\n\t    // remove reference from data ob\n\t    // frozen object may not have observer.\n\t    if (this._data && this._data.__ob__) {\n\t      this._data.__ob__.removeVm(this);\n\t    }\n\t    // Clean up references to private properties and other\n\t    // instances. preserve reference to _data so that proxy\n\t    // accessors still work. The only potential side effect\n\t    // here is that mutating the instance after it's destroyed\n\t    // may affect the state of other components that are still\n\t    // observing the same object, but that seems to be a\n\t    // reasonable responsibility for the user rather than\n\t    // always throwing an error on them.\n\t    this.$el = this.$parent = this.$root = this.$children = this._watchers = this._context = this._scope = this._directives = null;\n\t    // call the last hook...\n\t    this._isDestroyed = true;\n\t    this._callHook('destroyed');\n\t    // turn off all instance listeners.\n\t    this.$off();\n\t  };\n\t}\n\t\n\tfunction miscMixin (Vue) {\n\t  /**\n\t   * Apply a list of filter (descriptors) to a value.\n\t   * Using plain for loops here because this will be called in\n\t   * the getter of any watcher with filters so it is very\n\t   * performance sensitive.\n\t   *\n\t   * @param {*} value\n\t   * @param {*} [oldValue]\n\t   * @param {Array} filters\n\t   * @param {Boolean} write\n\t   * @return {*}\n\t   */\n\t\n\t  Vue.prototype._applyFilters = function (value, oldValue, filters, write) {\n\t    var filter, fn, args, arg, offset, i, l, j, k;\n\t    for (i = 0, l = filters.length; i < l; i++) {\n\t      filter = filters[write ? l - i - 1 : i];\n\t      fn = resolveAsset(this.$options, 'filters', filter.name, true);\n\t      if (!fn) continue;\n\t      fn = write ? fn.write : fn.read || fn;\n\t      if (typeof fn !== 'function') continue;\n\t      args = write ? [value, oldValue] : [value];\n\t      offset = write ? 2 : 1;\n\t      if (filter.args) {\n\t        for (j = 0, k = filter.args.length; j < k; j++) {\n\t          arg = filter.args[j];\n\t          args[j + offset] = arg.dynamic ? this.$get(arg.value) : arg.value;\n\t        }\n\t      }\n\t      value = fn.apply(this, args);\n\t    }\n\t    return value;\n\t  };\n\t\n\t  /**\n\t   * Resolve a component, depending on whether the component\n\t   * is defined normally or using an async factory function.\n\t   * Resolves synchronously if already resolved, otherwise\n\t   * resolves asynchronously and caches the resolved\n\t   * constructor on the factory.\n\t   *\n\t   * @param {String|Function} value\n\t   * @param {Function} cb\n\t   */\n\t\n\t  Vue.prototype._resolveComponent = function (value, cb) {\n\t    var factory;\n\t    if (typeof value === 'function') {\n\t      factory = value;\n\t    } else {\n\t      factory = resolveAsset(this.$options, 'components', value, true);\n\t    }\n\t    /* istanbul ignore if */\n\t    if (!factory) {\n\t      return;\n\t    }\n\t    // async component factory\n\t    if (!factory.options) {\n\t      if (factory.resolved) {\n\t        // cached\n\t        cb(factory.resolved);\n\t      } else if (factory.requested) {\n\t        // pool callbacks\n\t        factory.pendingCallbacks.push(cb);\n\t      } else {\n\t        factory.requested = true;\n\t        var cbs = factory.pendingCallbacks = [cb];\n\t        factory.call(this, function resolve(res) {\n\t          if (isPlainObject(res)) {\n\t            res = Vue.extend(res);\n\t          }\n\t          // cache resolved\n\t          factory.resolved = res;\n\t          // invoke callbacks\n\t          for (var i = 0, l = cbs.length; i < l; i++) {\n\t            cbs[i](res);\n\t          }\n\t        }, function reject(reason) {\n\t          (\"production\") !== 'production' && warn('Failed to resolve async component' + (typeof value === 'string' ? ': ' + value : '') + '. ' + (reason ? '\\nReason: ' + reason : ''));\n\t        });\n\t      }\n\t    } else {\n\t      // normal component\n\t      cb(factory);\n\t    }\n\t  };\n\t}\n\t\n\tvar filterRE$1 = /[^|]\\|[^|]/;\n\t\n\tfunction dataAPI (Vue) {\n\t  /**\n\t   * Get the value from an expression on this vm.\n\t   *\n\t   * @param {String} exp\n\t   * @param {Boolean} [asStatement]\n\t   * @return {*}\n\t   */\n\t\n\t  Vue.prototype.$get = function (exp, asStatement) {\n\t    var res = parseExpression(exp);\n\t    if (res) {\n\t      if (asStatement) {\n\t        var self = this;\n\t        return function statementHandler() {\n\t          self.$arguments = toArray(arguments);\n\t          var result = res.get.call(self, self);\n\t          self.$arguments = null;\n\t          return result;\n\t        };\n\t      } else {\n\t        try {\n\t          return res.get.call(this, this);\n\t        } catch (e) {}\n\t      }\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Set the value from an expression on this vm.\n\t   * The expression must be a valid left-hand\n\t   * expression in an assignment.\n\t   *\n\t   * @param {String} exp\n\t   * @param {*} val\n\t   */\n\t\n\t  Vue.prototype.$set = function (exp, val) {\n\t    var res = parseExpression(exp, true);\n\t    if (res && res.set) {\n\t      res.set.call(this, this, val);\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Delete a property on the VM\n\t   *\n\t   * @param {String} key\n\t   */\n\t\n\t  Vue.prototype.$delete = function (key) {\n\t    del(this._data, key);\n\t  };\n\t\n\t  /**\n\t   * Watch an expression, trigger callback when its\n\t   * value changes.\n\t   *\n\t   * @param {String|Function} expOrFn\n\t   * @param {Function} cb\n\t   * @param {Object} [options]\n\t   *                 - {Boolean} deep\n\t   *                 - {Boolean} immediate\n\t   * @return {Function} - unwatchFn\n\t   */\n\t\n\t  Vue.prototype.$watch = function (expOrFn, cb, options) {\n\t    var vm = this;\n\t    var parsed;\n\t    if (typeof expOrFn === 'string') {\n\t      parsed = parseDirective(expOrFn);\n\t      expOrFn = parsed.expression;\n\t    }\n\t    var watcher = new Watcher(vm, expOrFn, cb, {\n\t      deep: options && options.deep,\n\t      sync: options && options.sync,\n\t      filters: parsed && parsed.filters,\n\t      user: !options || options.user !== false\n\t    });\n\t    if (options && options.immediate) {\n\t      cb.call(vm, watcher.value);\n\t    }\n\t    return function unwatchFn() {\n\t      watcher.teardown();\n\t    };\n\t  };\n\t\n\t  /**\n\t   * Evaluate a text directive, including filters.\n\t   *\n\t   * @param {String} text\n\t   * @param {Boolean} [asStatement]\n\t   * @return {String}\n\t   */\n\t\n\t  Vue.prototype.$eval = function (text, asStatement) {\n\t    // check for filters.\n\t    if (filterRE$1.test(text)) {\n\t      var dir = parseDirective(text);\n\t      // the filter regex check might give false positive\n\t      // for pipes inside strings, so it's possible that\n\t      // we don't get any filters here\n\t      var val = this.$get(dir.expression, asStatement);\n\t      return dir.filters ? this._applyFilters(val, null, dir.filters) : val;\n\t    } else {\n\t      // no filter\n\t      return this.$get(text, asStatement);\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Interpolate a piece of template text.\n\t   *\n\t   * @param {String} text\n\t   * @return {String}\n\t   */\n\t\n\t  Vue.prototype.$interpolate = function (text) {\n\t    var tokens = parseText(text);\n\t    var vm = this;\n\t    if (tokens) {\n\t      if (tokens.length === 1) {\n\t        return vm.$eval(tokens[0].value) + '';\n\t      } else {\n\t        return tokens.map(function (token) {\n\t          return token.tag ? vm.$eval(token.value) : token.value;\n\t        }).join('');\n\t      }\n\t    } else {\n\t      return text;\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Log instance data as a plain JS object\n\t   * so that it is easier to inspect in console.\n\t   * This method assumes console is available.\n\t   *\n\t   * @param {String} [path]\n\t   */\n\t\n\t  Vue.prototype.$log = function (path) {\n\t    var data = path ? getPath(this._data, path) : this._data;\n\t    if (data) {\n\t      data = clean(data);\n\t    }\n\t    // include computed fields\n\t    if (!path) {\n\t      var key;\n\t      for (key in this.$options.computed) {\n\t        data[key] = clean(this[key]);\n\t      }\n\t      if (this._props) {\n\t        for (key in this._props) {\n\t          data[key] = clean(this[key]);\n\t        }\n\t      }\n\t    }\n\t    console.log(data);\n\t  };\n\t\n\t  /**\n\t   * \"clean\" a getter/setter converted object into a plain\n\t   * object copy.\n\t   *\n\t   * @param {Object} - obj\n\t   * @return {Object}\n\t   */\n\t\n\t  function clean(obj) {\n\t    return JSON.parse(JSON.stringify(obj));\n\t  }\n\t}\n\t\n\tfunction domAPI (Vue) {\n\t  /**\n\t   * Convenience on-instance nextTick. The callback is\n\t   * auto-bound to the instance, and this avoids component\n\t   * modules having to rely on the global Vue.\n\t   *\n\t   * @param {Function} fn\n\t   */\n\t\n\t  Vue.prototype.$nextTick = function (fn) {\n\t    nextTick(fn, this);\n\t  };\n\t\n\t  /**\n\t   * Append instance to target\n\t   *\n\t   * @param {Node} target\n\t   * @param {Function} [cb]\n\t   * @param {Boolean} [withTransition] - defaults to true\n\t   */\n\t\n\t  Vue.prototype.$appendTo = function (target, cb, withTransition) {\n\t    return insert(this, target, cb, withTransition, append, appendWithTransition);\n\t  };\n\t\n\t  /**\n\t   * Prepend instance to target\n\t   *\n\t   * @param {Node} target\n\t   * @param {Function} [cb]\n\t   * @param {Boolean} [withTransition] - defaults to true\n\t   */\n\t\n\t  Vue.prototype.$prependTo = function (target, cb, withTransition) {\n\t    target = query(target);\n\t    if (target.hasChildNodes()) {\n\t      this.$before(target.firstChild, cb, withTransition);\n\t    } else {\n\t      this.$appendTo(target, cb, withTransition);\n\t    }\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Insert instance before target\n\t   *\n\t   * @param {Node} target\n\t   * @param {Function} [cb]\n\t   * @param {Boolean} [withTransition] - defaults to true\n\t   */\n\t\n\t  Vue.prototype.$before = function (target, cb, withTransition) {\n\t    return insert(this, target, cb, withTransition, beforeWithCb, beforeWithTransition);\n\t  };\n\t\n\t  /**\n\t   * Insert instance after target\n\t   *\n\t   * @param {Node} target\n\t   * @param {Function} [cb]\n\t   * @param {Boolean} [withTransition] - defaults to true\n\t   */\n\t\n\t  Vue.prototype.$after = function (target, cb, withTransition) {\n\t    target = query(target);\n\t    if (target.nextSibling) {\n\t      this.$before(target.nextSibling, cb, withTransition);\n\t    } else {\n\t      this.$appendTo(target.parentNode, cb, withTransition);\n\t    }\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Remove instance from DOM\n\t   *\n\t   * @param {Function} [cb]\n\t   * @param {Boolean} [withTransition] - defaults to true\n\t   */\n\t\n\t  Vue.prototype.$remove = function (cb, withTransition) {\n\t    if (!this.$el.parentNode) {\n\t      return cb && cb();\n\t    }\n\t    var inDocument = this._isAttached && inDoc(this.$el);\n\t    // if we are not in document, no need to check\n\t    // for transitions\n\t    if (!inDocument) withTransition = false;\n\t    var self = this;\n\t    var realCb = function realCb() {\n\t      if (inDocument) self._callHook('detached');\n\t      if (cb) cb();\n\t    };\n\t    if (this._isFragment) {\n\t      removeNodeRange(this._fragmentStart, this._fragmentEnd, this, this._fragment, realCb);\n\t    } else {\n\t      var op = withTransition === false ? removeWithCb : removeWithTransition;\n\t      op(this.$el, this, realCb);\n\t    }\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Shared DOM insertion function.\n\t   *\n\t   * @param {Vue} vm\n\t   * @param {Element} target\n\t   * @param {Function} [cb]\n\t   * @param {Boolean} [withTransition]\n\t   * @param {Function} op1 - op for non-transition insert\n\t   * @param {Function} op2 - op for transition insert\n\t   * @return vm\n\t   */\n\t\n\t  function insert(vm, target, cb, withTransition, op1, op2) {\n\t    target = query(target);\n\t    var targetIsDetached = !inDoc(target);\n\t    var op = withTransition === false || targetIsDetached ? op1 : op2;\n\t    var shouldCallHook = !targetIsDetached && !vm._isAttached && !inDoc(vm.$el);\n\t    if (vm._isFragment) {\n\t      mapNodeRange(vm._fragmentStart, vm._fragmentEnd, function (node) {\n\t        op(node, target, vm);\n\t      });\n\t      cb && cb();\n\t    } else {\n\t      op(vm.$el, target, vm, cb);\n\t    }\n\t    if (shouldCallHook) {\n\t      vm._callHook('attached');\n\t    }\n\t    return vm;\n\t  }\n\t\n\t  /**\n\t   * Check for selectors\n\t   *\n\t   * @param {String|Element} el\n\t   */\n\t\n\t  function query(el) {\n\t    return typeof el === 'string' ? document.querySelector(el) : el;\n\t  }\n\t\n\t  /**\n\t   * Append operation that takes a callback.\n\t   *\n\t   * @param {Node} el\n\t   * @param {Node} target\n\t   * @param {Vue} vm - unused\n\t   * @param {Function} [cb]\n\t   */\n\t\n\t  function append(el, target, vm, cb) {\n\t    target.appendChild(el);\n\t    if (cb) cb();\n\t  }\n\t\n\t  /**\n\t   * InsertBefore operation that takes a callback.\n\t   *\n\t   * @param {Node} el\n\t   * @param {Node} target\n\t   * @param {Vue} vm - unused\n\t   * @param {Function} [cb]\n\t   */\n\t\n\t  function beforeWithCb(el, target, vm, cb) {\n\t    before(el, target);\n\t    if (cb) cb();\n\t  }\n\t\n\t  /**\n\t   * Remove operation that takes a callback.\n\t   *\n\t   * @param {Node} el\n\t   * @param {Vue} vm - unused\n\t   * @param {Function} [cb]\n\t   */\n\t\n\t  function removeWithCb(el, vm, cb) {\n\t    remove(el);\n\t    if (cb) cb();\n\t  }\n\t}\n\t\n\tfunction eventsAPI (Vue) {\n\t  /**\n\t   * Listen on the given `event` with `fn`.\n\t   *\n\t   * @param {String} event\n\t   * @param {Function} fn\n\t   */\n\t\n\t  Vue.prototype.$on = function (event, fn) {\n\t    (this._events[event] || (this._events[event] = [])).push(fn);\n\t    modifyListenerCount(this, event, 1);\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Adds an `event` listener that will be invoked a single\n\t   * time then automatically removed.\n\t   *\n\t   * @param {String} event\n\t   * @param {Function} fn\n\t   */\n\t\n\t  Vue.prototype.$once = function (event, fn) {\n\t    var self = this;\n\t    function on() {\n\t      self.$off(event, on);\n\t      fn.apply(this, arguments);\n\t    }\n\t    on.fn = fn;\n\t    this.$on(event, on);\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Remove the given callback for `event` or all\n\t   * registered callbacks.\n\t   *\n\t   * @param {String} event\n\t   * @param {Function} fn\n\t   */\n\t\n\t  Vue.prototype.$off = function (event, fn) {\n\t    var cbs;\n\t    // all\n\t    if (!arguments.length) {\n\t      if (this.$parent) {\n\t        for (event in this._events) {\n\t          cbs = this._events[event];\n\t          if (cbs) {\n\t            modifyListenerCount(this, event, -cbs.length);\n\t          }\n\t        }\n\t      }\n\t      this._events = {};\n\t      return this;\n\t    }\n\t    // specific event\n\t    cbs = this._events[event];\n\t    if (!cbs) {\n\t      return this;\n\t    }\n\t    if (arguments.length === 1) {\n\t      modifyListenerCount(this, event, -cbs.length);\n\t      this._events[event] = null;\n\t      return this;\n\t    }\n\t    // specific handler\n\t    var cb;\n\t    var i = cbs.length;\n\t    while (i--) {\n\t      cb = cbs[i];\n\t      if (cb === fn || cb.fn === fn) {\n\t        modifyListenerCount(this, event, -1);\n\t        cbs.splice(i, 1);\n\t        break;\n\t      }\n\t    }\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Trigger an event on self.\n\t   *\n\t   * @param {String|Object} event\n\t   * @return {Boolean} shouldPropagate\n\t   */\n\t\n\t  Vue.prototype.$emit = function (event) {\n\t    var isSource = typeof event === 'string';\n\t    event = isSource ? event : event.name;\n\t    var cbs = this._events[event];\n\t    var shouldPropagate = isSource || !cbs;\n\t    if (cbs) {\n\t      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n\t      // this is a somewhat hacky solution to the question raised\n\t      // in #2102: for an inline component listener like <comp @test=\"doThis\">,\n\t      // the propagation handling is somewhat broken. Therefore we\n\t      // need to treat these inline callbacks differently.\n\t      var hasParentCbs = isSource && cbs.some(function (cb) {\n\t        return cb._fromParent;\n\t      });\n\t      if (hasParentCbs) {\n\t        shouldPropagate = false;\n\t      }\n\t      var args = toArray(arguments, 1);\n\t      for (var i = 0, l = cbs.length; i < l; i++) {\n\t        var cb = cbs[i];\n\t        var res = cb.apply(this, args);\n\t        if (res === true && (!hasParentCbs || cb._fromParent)) {\n\t          shouldPropagate = true;\n\t        }\n\t      }\n\t    }\n\t    return shouldPropagate;\n\t  };\n\t\n\t  /**\n\t   * Recursively broadcast an event to all children instances.\n\t   *\n\t   * @param {String|Object} event\n\t   * @param {...*} additional arguments\n\t   */\n\t\n\t  Vue.prototype.$broadcast = function (event) {\n\t    var isSource = typeof event === 'string';\n\t    event = isSource ? event : event.name;\n\t    // if no child has registered for this event,\n\t    // then there's no need to broadcast.\n\t    if (!this._eventsCount[event]) return;\n\t    var children = this.$children;\n\t    var args = toArray(arguments);\n\t    if (isSource) {\n\t      // use object event to indicate non-source emit\n\t      // on children\n\t      args[0] = { name: event, source: this };\n\t    }\n\t    for (var i = 0, l = children.length; i < l; i++) {\n\t      var child = children[i];\n\t      var shouldPropagate = child.$emit.apply(child, args);\n\t      if (shouldPropagate) {\n\t        child.$broadcast.apply(child, args);\n\t      }\n\t    }\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Recursively propagate an event up the parent chain.\n\t   *\n\t   * @param {String} event\n\t   * @param {...*} additional arguments\n\t   */\n\t\n\t  Vue.prototype.$dispatch = function (event) {\n\t    var shouldPropagate = this.$emit.apply(this, arguments);\n\t    if (!shouldPropagate) return;\n\t    var parent = this.$parent;\n\t    var args = toArray(arguments);\n\t    // use object event to indicate non-source emit\n\t    // on parents\n\t    args[0] = { name: event, source: this };\n\t    while (parent) {\n\t      shouldPropagate = parent.$emit.apply(parent, args);\n\t      parent = shouldPropagate ? parent.$parent : null;\n\t    }\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Modify the listener counts on all parents.\n\t   * This bookkeeping allows $broadcast to return early when\n\t   * no child has listened to a certain event.\n\t   *\n\t   * @param {Vue} vm\n\t   * @param {String} event\n\t   * @param {Number} count\n\t   */\n\t\n\t  var hookRE = /^hook:/;\n\t  function modifyListenerCount(vm, event, count) {\n\t    var parent = vm.$parent;\n\t    // hooks do not get broadcasted so no need\n\t    // to do bookkeeping for them\n\t    if (!parent || !count || hookRE.test(event)) return;\n\t    while (parent) {\n\t      parent._eventsCount[event] = (parent._eventsCount[event] || 0) + count;\n\t      parent = parent.$parent;\n\t    }\n\t  }\n\t}\n\t\n\tfunction lifecycleAPI (Vue) {\n\t  /**\n\t   * Set instance target element and kick off the compilation\n\t   * process. The passed in `el` can be a selector string, an\n\t   * existing Element, or a DocumentFragment (for block\n\t   * instances).\n\t   *\n\t   * @param {Element|DocumentFragment|string} el\n\t   * @public\n\t   */\n\t\n\t  Vue.prototype.$mount = function (el) {\n\t    if (this._isCompiled) {\n\t      (\"production\") !== 'production' && warn('$mount() should be called only once.', this);\n\t      return;\n\t    }\n\t    el = query(el);\n\t    if (!el) {\n\t      el = document.createElement('div');\n\t    }\n\t    this._compile(el);\n\t    this._initDOMHooks();\n\t    if (inDoc(this.$el)) {\n\t      this._callHook('attached');\n\t      ready.call(this);\n\t    } else {\n\t      this.$once('hook:attached', ready);\n\t    }\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Mark an instance as ready.\n\t   */\n\t\n\t  function ready() {\n\t    this._isAttached = true;\n\t    this._isReady = true;\n\t    this._callHook('ready');\n\t  }\n\t\n\t  /**\n\t   * Teardown the instance, simply delegate to the internal\n\t   * _destroy.\n\t   *\n\t   * @param {Boolean} remove\n\t   * @param {Boolean} deferCleanup\n\t   */\n\t\n\t  Vue.prototype.$destroy = function (remove, deferCleanup) {\n\t    this._destroy(remove, deferCleanup);\n\t  };\n\t\n\t  /**\n\t   * Partially compile a piece of DOM and return a\n\t   * decompile function.\n\t   *\n\t   * @param {Element|DocumentFragment} el\n\t   * @param {Vue} [host]\n\t   * @param {Object} [scope]\n\t   * @param {Fragment} [frag]\n\t   * @return {Function}\n\t   */\n\t\n\t  Vue.prototype.$compile = function (el, host, scope, frag) {\n\t    return compile(el, this.$options, true)(this, el, host, scope, frag);\n\t  };\n\t}\n\t\n\t/**\n\t * The exposed Vue constructor.\n\t *\n\t * API conventions:\n\t * - public API methods/properties are prefixed with `$`\n\t * - internal methods/properties are prefixed with `_`\n\t * - non-prefixed properties are assumed to be proxied user\n\t *   data.\n\t *\n\t * @constructor\n\t * @param {Object} [options]\n\t * @public\n\t */\n\t\n\tfunction Vue(options) {\n\t  this._init(options);\n\t}\n\t\n\t// install internals\n\tinitMixin(Vue);\n\tstateMixin(Vue);\n\teventsMixin(Vue);\n\tlifecycleMixin(Vue);\n\tmiscMixin(Vue);\n\t\n\t// install instance APIs\n\tdataAPI(Vue);\n\tdomAPI(Vue);\n\teventsAPI(Vue);\n\tlifecycleAPI(Vue);\n\t\n\tvar slot = {\n\t\n\t  priority: SLOT,\n\t  params: ['name'],\n\t\n\t  bind: function bind() {\n\t    // this was resolved during component transclusion\n\t    var name = this.params.name || 'default';\n\t    var content = this.vm._slotContents && this.vm._slotContents[name];\n\t    if (!content || !content.hasChildNodes()) {\n\t      this.fallback();\n\t    } else {\n\t      this.compile(content.cloneNode(true), this.vm._context, this.vm);\n\t    }\n\t  },\n\t\n\t  compile: function compile(content, context, host) {\n\t    if (content && context) {\n\t      if (this.el.hasChildNodes() && content.childNodes.length === 1 && content.childNodes[0].nodeType === 1 && content.childNodes[0].hasAttribute('v-if')) {\n\t        // if the inserted slot has v-if\n\t        // inject fallback content as the v-else\n\t        var elseBlock = document.createElement('template');\n\t        elseBlock.setAttribute('v-else', '');\n\t        elseBlock.innerHTML = this.el.innerHTML;\n\t        // the else block should be compiled in child scope\n\t        elseBlock._context = this.vm;\n\t        content.appendChild(elseBlock);\n\t      }\n\t      var scope = host ? host._scope : this._scope;\n\t      this.unlink = context.$compile(content, host, scope, this._frag);\n\t    }\n\t    if (content) {\n\t      replace(this.el, content);\n\t    } else {\n\t      remove(this.el);\n\t    }\n\t  },\n\t\n\t  fallback: function fallback() {\n\t    this.compile(extractContent(this.el, true), this.vm);\n\t  },\n\t\n\t  unbind: function unbind() {\n\t    if (this.unlink) {\n\t      this.unlink();\n\t    }\n\t  }\n\t};\n\t\n\tvar partial = {\n\t\n\t  priority: PARTIAL,\n\t\n\t  params: ['name'],\n\t\n\t  // watch changes to name for dynamic partials\n\t  paramWatchers: {\n\t    name: function name(value) {\n\t      vIf.remove.call(this);\n\t      if (value) {\n\t        this.insert(value);\n\t      }\n\t    }\n\t  },\n\t\n\t  bind: function bind() {\n\t    this.anchor = createAnchor('v-partial');\n\t    replace(this.el, this.anchor);\n\t    this.insert(this.params.name);\n\t  },\n\t\n\t  insert: function insert(id) {\n\t    var partial = resolveAsset(this.vm.$options, 'partials', id, true);\n\t    if (partial) {\n\t      this.factory = new FragmentFactory(this.vm, partial);\n\t      vIf.insert.call(this);\n\t    }\n\t  },\n\t\n\t  unbind: function unbind() {\n\t    if (this.frag) {\n\t      this.frag.destroy();\n\t    }\n\t  }\n\t};\n\t\n\tvar elementDirectives = {\n\t  slot: slot,\n\t  partial: partial\n\t};\n\t\n\tvar convertArray = vFor._postProcess;\n\t\n\t/**\n\t * Limit filter for arrays\n\t *\n\t * @param {Number} n\n\t * @param {Number} offset (Decimal expected)\n\t */\n\t\n\tfunction limitBy(arr, n, offset) {\n\t  offset = offset ? parseInt(offset, 10) : 0;\n\t  n = toNumber(n);\n\t  return typeof n === 'number' ? arr.slice(offset, offset + n) : arr;\n\t}\n\t\n\t/**\n\t * Filter filter for arrays\n\t *\n\t * @param {String} search\n\t * @param {String} [delimiter]\n\t * @param {String} ...dataKeys\n\t */\n\t\n\tfunction filterBy(arr, search, delimiter) {\n\t  arr = convertArray(arr);\n\t  if (search == null) {\n\t    return arr;\n\t  }\n\t  if (typeof search === 'function') {\n\t    return arr.filter(search);\n\t  }\n\t  // cast to lowercase string\n\t  search = ('' + search).toLowerCase();\n\t  // allow optional `in` delimiter\n\t  // because why not\n\t  var n = delimiter === 'in' ? 3 : 2;\n\t  // extract and flatten keys\n\t  var keys = Array.prototype.concat.apply([], toArray(arguments, n));\n\t  var res = [];\n\t  var item, key, val, j;\n\t  for (var i = 0, l = arr.length; i < l; i++) {\n\t    item = arr[i];\n\t    val = item && item.$value || item;\n\t    j = keys.length;\n\t    if (j) {\n\t      while (j--) {\n\t        key = keys[j];\n\t        if (key === '$key' && contains(item.$key, search) || contains(getPath(val, key), search)) {\n\t          res.push(item);\n\t          break;\n\t        }\n\t      }\n\t    } else if (contains(item, search)) {\n\t      res.push(item);\n\t    }\n\t  }\n\t  return res;\n\t}\n\t\n\t/**\n\t * Filter filter for arrays\n\t *\n\t * @param {String|Array<String>|Function} ...sortKeys\n\t * @param {Number} [order]\n\t */\n\t\n\tfunction orderBy(arr) {\n\t  var comparator = null;\n\t  var sortKeys = undefined;\n\t  arr = convertArray(arr);\n\t\n\t  // determine order (last argument)\n\t  var args = toArray(arguments, 1);\n\t  var order = args[args.length - 1];\n\t  if (typeof order === 'number') {\n\t    order = order < 0 ? -1 : 1;\n\t    args = args.length > 1 ? args.slice(0, -1) : args;\n\t  } else {\n\t    order = 1;\n\t  }\n\t\n\t  // determine sortKeys & comparator\n\t  var firstArg = args[0];\n\t  if (!firstArg) {\n\t    return arr;\n\t  } else if (typeof firstArg === 'function') {\n\t    // custom comparator\n\t    comparator = function (a, b) {\n\t      return firstArg(a, b) * order;\n\t    };\n\t  } else {\n\t    // string keys. flatten first\n\t    sortKeys = Array.prototype.concat.apply([], args);\n\t    comparator = function (a, b, i) {\n\t      i = i || 0;\n\t      return i >= sortKeys.length - 1 ? baseCompare(a, b, i) : baseCompare(a, b, i) || comparator(a, b, i + 1);\n\t    };\n\t  }\n\t\n\t  function baseCompare(a, b, sortKeyIndex) {\n\t    var sortKey = sortKeys[sortKeyIndex];\n\t    if (sortKey) {\n\t      if (sortKey !== '$key') {\n\t        if (isObject(a) && '$value' in a) a = a.$value;\n\t        if (isObject(b) && '$value' in b) b = b.$value;\n\t      }\n\t      a = isObject(a) ? getPath(a, sortKey) : a;\n\t      b = isObject(b) ? getPath(b, sortKey) : b;\n\t    }\n\t    return a === b ? 0 : a > b ? order : -order;\n\t  }\n\t\n\t  // sort on a copy to avoid mutating original array\n\t  return arr.slice().sort(comparator);\n\t}\n\t\n\t/**\n\t * String contain helper\n\t *\n\t * @param {*} val\n\t * @param {String} search\n\t */\n\t\n\tfunction contains(val, search) {\n\t  var i;\n\t  if (isPlainObject(val)) {\n\t    var keys = Object.keys(val);\n\t    i = keys.length;\n\t    while (i--) {\n\t      if (contains(val[keys[i]], search)) {\n\t        return true;\n\t      }\n\t    }\n\t  } else if (isArray(val)) {\n\t    i = val.length;\n\t    while (i--) {\n\t      if (contains(val[i], search)) {\n\t        return true;\n\t      }\n\t    }\n\t  } else if (val != null) {\n\t    return val.toString().toLowerCase().indexOf(search) > -1;\n\t  }\n\t}\n\t\n\tvar digitsRE = /(\\d{3})(?=\\d)/g;\n\t\n\t// asset collections must be a plain object.\n\tvar filters = {\n\t\n\t  orderBy: orderBy,\n\t  filterBy: filterBy,\n\t  limitBy: limitBy,\n\t\n\t  /**\n\t   * Stringify value.\n\t   *\n\t   * @param {Number} indent\n\t   */\n\t\n\t  json: {\n\t    read: function read(value, indent) {\n\t      return typeof value === 'string' ? value : JSON.stringify(value, null, arguments.length > 1 ? indent : 2);\n\t    },\n\t    write: function write(value) {\n\t      try {\n\t        return JSON.parse(value);\n\t      } catch (e) {\n\t        return value;\n\t      }\n\t    }\n\t  },\n\t\n\t  /**\n\t   * 'abc' => 'Abc'\n\t   */\n\t\n\t  capitalize: function capitalize(value) {\n\t    if (!value && value !== 0) return '';\n\t    value = value.toString();\n\t    return value.charAt(0).toUpperCase() + value.slice(1);\n\t  },\n\t\n\t  /**\n\t   * 'abc' => 'ABC'\n\t   */\n\t\n\t  uppercase: function uppercase(value) {\n\t    return value || value === 0 ? value.toString().toUpperCase() : '';\n\t  },\n\t\n\t  /**\n\t   * 'AbC' => 'abc'\n\t   */\n\t\n\t  lowercase: function lowercase(value) {\n\t    return value || value === 0 ? value.toString().toLowerCase() : '';\n\t  },\n\t\n\t  /**\n\t   * 12345 => $12,345.00\n\t   *\n\t   * @param {String} sign\n\t   * @param {Number} decimals Decimal places\n\t   */\n\t\n\t  currency: function currency(value, _currency, decimals) {\n\t    value = parseFloat(value);\n\t    if (!isFinite(value) || !value && value !== 0) return '';\n\t    _currency = _currency != null ? _currency : '$';\n\t    decimals = decimals != null ? decimals : 2;\n\t    var stringified = Math.abs(value).toFixed(decimals);\n\t    var _int = decimals ? stringified.slice(0, -1 - decimals) : stringified;\n\t    var i = _int.length % 3;\n\t    var head = i > 0 ? _int.slice(0, i) + (_int.length > 3 ? ',' : '') : '';\n\t    var _float = decimals ? stringified.slice(-1 - decimals) : '';\n\t    var sign = value < 0 ? '-' : '';\n\t    return sign + _currency + head + _int.slice(i).replace(digitsRE, '$1,') + _float;\n\t  },\n\t\n\t  /**\n\t   * 'item' => 'items'\n\t   *\n\t   * @params\n\t   *  an array of strings corresponding to\n\t   *  the single, double, triple ... forms of the word to\n\t   *  be pluralized. When the number to be pluralized\n\t   *  exceeds the length of the args, it will use the last\n\t   *  entry in the array.\n\t   *\n\t   *  e.g. ['single', 'double', 'triple', 'multiple']\n\t   */\n\t\n\t  pluralize: function pluralize(value) {\n\t    var args = toArray(arguments, 1);\n\t    return args.length > 1 ? args[value % 10 - 1] || args[args.length - 1] : args[0] + (value === 1 ? '' : 's');\n\t  },\n\t\n\t  /**\n\t   * Debounce a handler function.\n\t   *\n\t   * @param {Function} handler\n\t   * @param {Number} delay = 300\n\t   * @return {Function}\n\t   */\n\t\n\t  debounce: function debounce(handler, delay) {\n\t    if (!handler) return;\n\t    if (!delay) {\n\t      delay = 300;\n\t    }\n\t    return _debounce(handler, delay);\n\t  }\n\t};\n\t\n\tfunction installGlobalAPI (Vue) {\n\t  /**\n\t   * Vue and every constructor that extends Vue has an\n\t   * associated options object, which can be accessed during\n\t   * compilation steps as `this.constructor.options`.\n\t   *\n\t   * These can be seen as the default options of every\n\t   * Vue instance.\n\t   */\n\t\n\t  Vue.options = {\n\t    directives: directives,\n\t    elementDirectives: elementDirectives,\n\t    filters: filters,\n\t    transitions: {},\n\t    components: {},\n\t    partials: {},\n\t    replace: true\n\t  };\n\t\n\t  /**\n\t   * Expose useful internals\n\t   */\n\t\n\t  Vue.util = util;\n\t  Vue.config = config;\n\t  Vue.set = set;\n\t  Vue['delete'] = del;\n\t  Vue.nextTick = nextTick;\n\t\n\t  /**\n\t   * The following are exposed for advanced usage / plugins\n\t   */\n\t\n\t  Vue.compiler = compiler;\n\t  Vue.FragmentFactory = FragmentFactory;\n\t  Vue.internalDirectives = internalDirectives;\n\t  Vue.parsers = {\n\t    path: path,\n\t    text: text,\n\t    template: template,\n\t    directive: directive,\n\t    expression: expression\n\t  };\n\t\n\t  /**\n\t   * Each instance constructor, including Vue, has a unique\n\t   * cid. This enables us to create wrapped \"child\n\t   * constructors\" for prototypal inheritance and cache them.\n\t   */\n\t\n\t  Vue.cid = 0;\n\t  var cid = 1;\n\t\n\t  /**\n\t   * Class inheritance\n\t   *\n\t   * @param {Object} extendOptions\n\t   */\n\t\n\t  Vue.extend = function (extendOptions) {\n\t    extendOptions = extendOptions || {};\n\t    var Super = this;\n\t    var isFirstExtend = Super.cid === 0;\n\t    if (isFirstExtend && extendOptions._Ctor) {\n\t      return extendOptions._Ctor;\n\t    }\n\t    var name = extendOptions.name || Super.options.name;\n\t    if (false) {\n\t      if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n\t        warn('Invalid component name: \"' + name + '\". Component names ' + 'can only contain alphanumeric characaters and the hyphen.');\n\t        name = null;\n\t      }\n\t    }\n\t    var Sub = createClass(name || 'VueComponent');\n\t    Sub.prototype = Object.create(Super.prototype);\n\t    Sub.prototype.constructor = Sub;\n\t    Sub.cid = cid++;\n\t    Sub.options = mergeOptions(Super.options, extendOptions);\n\t    Sub['super'] = Super;\n\t    // allow further extension\n\t    Sub.extend = Super.extend;\n\t    // create asset registers, so extended classes\n\t    // can have their private assets too.\n\t    config._assetTypes.forEach(function (type) {\n\t      Sub[type] = Super[type];\n\t    });\n\t    // enable recursive self-lookup\n\t    if (name) {\n\t      Sub.options.components[name] = Sub;\n\t    }\n\t    // cache constructor\n\t    if (isFirstExtend) {\n\t      extendOptions._Ctor = Sub;\n\t    }\n\t    return Sub;\n\t  };\n\t\n\t  /**\n\t   * A function that returns a sub-class constructor with the\n\t   * given name. This gives us much nicer output when\n\t   * logging instances in the console.\n\t   *\n\t   * @param {String} name\n\t   * @return {Function}\n\t   */\n\t\n\t  function createClass(name) {\n\t    /* eslint-disable no-new-func */\n\t    return new Function('return function ' + classify(name) + ' (options) { this._init(options) }')();\n\t    /* eslint-enable no-new-func */\n\t  }\n\t\n\t  /**\n\t   * Plugin system\n\t   *\n\t   * @param {Object} plugin\n\t   */\n\t\n\t  Vue.use = function (plugin) {\n\t    /* istanbul ignore if */\n\t    if (plugin.installed) {\n\t      return;\n\t    }\n\t    // additional parameters\n\t    var args = toArray(arguments, 1);\n\t    args.unshift(this);\n\t    if (typeof plugin.install === 'function') {\n\t      plugin.install.apply(plugin, args);\n\t    } else {\n\t      plugin.apply(null, args);\n\t    }\n\t    plugin.installed = true;\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * Apply a global mixin by merging it into the default\n\t   * options.\n\t   */\n\t\n\t  Vue.mixin = function (mixin) {\n\t    Vue.options = mergeOptions(Vue.options, mixin);\n\t  };\n\t\n\t  /**\n\t   * Create asset registration methods with the following\n\t   * signature:\n\t   *\n\t   * @param {String} id\n\t   * @param {*} definition\n\t   */\n\t\n\t  config._assetTypes.forEach(function (type) {\n\t    Vue[type] = function (id, definition) {\n\t      if (!definition) {\n\t        return this.options[type + 's'][id];\n\t      } else {\n\t        /* istanbul ignore if */\n\t        if (false) {\n\t          if (type === 'component' && (commonTagRE.test(id) || reservedTagRE.test(id))) {\n\t            warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);\n\t          }\n\t        }\n\t        if (type === 'component' && isPlainObject(definition)) {\n\t          if (!definition.name) {\n\t            definition.name = id;\n\t          }\n\t          definition = Vue.extend(definition);\n\t        }\n\t        this.options[type + 's'][id] = definition;\n\t        return definition;\n\t      }\n\t    };\n\t  });\n\t\n\t  // expose internal transition API\n\t  extend(Vue.transition, transition);\n\t}\n\t\n\tinstallGlobalAPI(Vue);\n\t\n\tVue.version = '1.0.25';\n\t\n\t// devtools global hook\n\t/* istanbul ignore next */\n\tsetTimeout(function () {\n\t  if (config.devtools) {\n\t    if (devtools) {\n\t      devtools.emit('init', Vue);\n\t    } else if (false) {\n\t      console.log('Download the Vue Devtools for a better development experience:\\n' + 'https://github.com/vuejs/vue-devtools');\n\t    }\n\t  }\n\t}, 0);\n\t\n\tmodule.exports = Vue;\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** build.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap eb3810306eedc3d9dc1d\n **/","import Vue from 'vue'\nimport VueResource from 'vue-resource'\nimport THREE from 'three'\n\nVue.use(VueResource)\n\nconst AlbumCube = Vue.extend({\n  template: ' <div id=\"main\"></div>'\n})\n\nVue.component('app', AlbumCube)\n\nnew Vue({\n  el: 'body',\n  components: { AlbumCube },\n  ready() {\n\n\n    // global variables\n    let renderer, scene, camera, stats, cameraControl, cube\n\n    /**\n     * Initializes the scene, camera and objects. Called when the window is\n     * loaded by using window.onload (see below)\n     */\n    function init() {\n\n        THREE.ImageUtils.crossOrigin = ''\n        // create a scene, that will hold all our elements such as objects, cameras and lights.\n        scene = new THREE.Scene()\n\n        // create a camera, which defines where we're looking at.\n        camera = new THREE.PerspectiveCamera(35,  document.getElementById('main').offsetWidth / window.innerHeight, 0.1, 1000)\n\n        // create a render, sets the background color and the size\n        renderer = new THREE.WebGLRenderer()\n        renderer.setClearColor(0x000000, 1.0)\n        renderer.setSize(document.getElementById('main').offsetWidth, window.innerHeight - 10)\n        renderer.shadowMap.enabled = true\n\n        // add the output of the renderer to the html element\n        document.getElementById('main').appendChild(renderer.domElement)\n\n\n        var ambientLight = new THREE.AmbientLight( 0x000000 )\n        scene.add( ambientLight )\n\n        var lights = []\n        lights[0] = new THREE.PointLight( 0xffffff, 1, 0 )\n        lights[1] = new THREE.PointLight( 0xffffff, 1, 0 )\n        lights[2] = new THREE.PointLight( 0xffffff, 1, 0 )\n        lights[0].position.set( 0, 200, 0 )\n        lights[1].position.set( 100, 200, 100 )\n        lights[2].position.set( -100, -200, -100 )\n\n        scene.add( lights[0] )\n        scene.add( lights[1] )\n        scene.add( lights[2] )\n\n        let geometry = new THREE.BoxGeometry( 1, 1, 1 )\n        let material = new THREE.MeshLambertMaterial({color: 0x6C6C6C, transparent: true, opacity: 0.7})\n        cube = new THREE.Mesh( geometry, material )\n        scene.add( cube )\n        camera.position.z = 5\n        // call the render function, after the first render, interval is determined\n        // by requestAnimationFrame\n        render()\n    }\n\n    /**\n     * Called when the scene needs to be rendered. Delegates to requestAnimationFrame\n     * for future renders\n     */\n    function render() {\n        requestAnimationFrame( render )\n        cube.rotation.x += 0.01\n        cube.rotation.y += 0.01\n        renderer.render( scene, camera )\n    }\n\n    /**\n     * Function handles the resize event. This make sure the camera and the renderer\n     * are updated at the correct moment.\n     */\n    function handleResize() {\n        camera.aspect = document.getElementById('main').offsetWidth / window.innerHeight\n        camera.updateProjectionMatrix()\n        renderer.setSize(document.getElementById('main').offsetWidth, window.innerHeight - 10)\n    }\n\n    // calls the init function when the window is done loading.\n    window.onload = init\n    // calls the handleResize function when the window is resized\n    window.addEventListener('resize', handleResize, false)\n\n    function componentToHex(c) {\n      var hex = c.toString(16)\n      return hex.length == 1 ? \"0\" + hex : hex\n    }\n\n    function rgbToHex(rgb) {\n      let c = ''\n      for(let i=0; i<3; i++){\n        c += componentToHex(rgb[i])\n      }\n      return c\n    }\n\n    function intervalTexture(datas) {\n        var file = datas.shift()\n        datas.push(file)\n        var loader = new THREE.TextureLoader()\n        loader.load(\n          'http://162.243.40.125/albums/' + file,\n          function ( texture ) {\n            cube.material.map = texture\n            cube.material.needsUpdate = true\n          },\n          function ( xhr ) {\n          },\n          function ( xhr ) {\n            console.log( 'An error happened' )\n          }\n        )\n        let url = 'http://162.243.40.125/albums/' + file\n        let albumColors = new AlbumColors(url)\n\n          albumColors.getColors(function(colors) {\n            \n            renderer.setClearColor(parseInt(rgbToHex(colors[0]), 16), 1.0)\n            document.body.style.background = '#'+rgbToHex(colors[0])\n            document.body.style.color = '#'+rgbToHex(colors[1])\n            document.getElementsByTagName('header')[0].firstElementChild.style.color = '#'+rgbToHex(colors[2])\n          })\n    }\n\n    let APIkey = \"4dff88a0423651b3570253b10b745b2c\", \n      Limit = 100, \n      Page = 1, \n      User = \"fakelbst\"\n\n    this.$http.get(\"http://ws.audioscrobbler.com/2.0/\", {\n      params: {\n        method: 'user.gettopalbums',\n        format: 'json',\n        user: User,\n        api_key: APIkey,\n        limit: Limit,\n        page: 1\n      }\n    }).then((d) => {\n        let datas = d.json()\n        let allCovers = []\n        let albums = datas.topalbums.album\n        let src = albums[0].image[3]['#text']\n        for(let i=0,j=albums.length; i<j; i++){\n            let title = albums[i].name.split(' ').join('-')\n            let ext = albums[i].image[3]['#text'].split('.').pop()\n            allCovers.push(title + '.' + ext)\n        }\n        setInterval(function(){\n            intervalTexture(allCovers)\n        }, 6000)\n    })\n\n\n  }\n})\n\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/main.js\n **/","// File:src/Three.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar THREE = { REVISION: '78' };\n\n//\n\nif ( typeof define === 'function' && define.amd ) {\n\n\tdefine( 'three', THREE );\n\n} else if ( 'undefined' !== typeof exports && 'undefined' !== typeof module ) {\n\n\tmodule.exports = THREE;\n\n}\n\n// Polyfills\n\nif ( Number.EPSILON === undefined ) {\n\n\tNumber.EPSILON = Math.pow( 2, - 52 );\n\n}\n\n//\n\nif ( Math.sign === undefined ) {\n\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\n\n\tMath.sign = function ( x ) {\n\n\t\treturn ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;\n\n\t};\n\n}\n\nif ( Function.prototype.name === undefined ) {\n\n\t// Missing in IE9-11.\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\n\n\tObject.defineProperty( Function.prototype, 'name', {\n\n\t\tget: function () {\n\n\t\t\treturn this.toString().match( /^\\s*function\\s*(\\S*)\\s*\\(/ )[ 1 ];\n\n\t\t}\n\n\t} );\n\n}\n\nif ( Object.assign === undefined ) {\n\n\t// Missing in IE.\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n\n\t( function () {\n\n\t\tObject.assign = function ( target ) {\n\n\t\t\t'use strict';\n\n\t\t\tif ( target === undefined || target === null ) {\n\n\t\t\t\tthrow new TypeError( 'Cannot convert undefined or null to object' );\n\n\t\t\t}\n\n\t\t\tvar output = Object( target );\n\n\t\t\tfor ( var index = 1; index < arguments.length; index ++ ) {\n\n\t\t\t\tvar source = arguments[ index ];\n\n\t\t\t\tif ( source !== undefined && source !== null ) {\n\n\t\t\t\t\tfor ( var nextKey in source ) {\n\n\t\t\t\t\t\tif ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {\n\n\t\t\t\t\t\t\toutput[ nextKey ] = source[ nextKey ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn output;\n\n\t\t};\n\n\t} )();\n\n}\n\n//\n\nObject.assign( THREE, {\n\n\t// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button\n\n\tMOUSE: { LEFT: 0, MIDDLE: 1, RIGHT: 2 },\n\n\t// GL STATE CONSTANTS\n\n\tCullFaceNone: 0,\n\tCullFaceBack: 1,\n\tCullFaceFront: 2,\n\tCullFaceFrontBack: 3,\n\n\tFrontFaceDirectionCW: 0,\n\tFrontFaceDirectionCCW: 1,\n\n\t// SHADOWING TYPES\n\n\tBasicShadowMap: 0,\n\tPCFShadowMap: 1,\n\tPCFSoftShadowMap: 2,\n\n\t// MATERIAL CONSTANTS\n\n\t// side\n\n\tFrontSide: 0,\n\tBackSide: 1,\n\tDoubleSide: 2,\n\n\t// shading\n\n\tFlatShading: 1,\n\tSmoothShading: 2,\n\n\t// colors\n\n\tNoColors: 0,\n\tFaceColors: 1,\n\tVertexColors: 2,\n\n\t// blending modes\n\n\tNoBlending: 0,\n\tNormalBlending: 1,\n\tAdditiveBlending: 2,\n\tSubtractiveBlending: 3,\n\tMultiplyBlending: 4,\n\tCustomBlending: 5,\n\n\t// custom blending equations\n\t// (numbers start from 100 not to clash with other\n\t// mappings to OpenGL constants defined in Texture.js)\n\n\tAddEquation: 100,\n\tSubtractEquation: 101,\n\tReverseSubtractEquation: 102,\n\tMinEquation: 103,\n\tMaxEquation: 104,\n\n\t// custom blending destination factors\n\n\tZeroFactor: 200,\n\tOneFactor: 201,\n\tSrcColorFactor: 202,\n\tOneMinusSrcColorFactor: 203,\n\tSrcAlphaFactor: 204,\n\tOneMinusSrcAlphaFactor: 205,\n\tDstAlphaFactor: 206,\n\tOneMinusDstAlphaFactor: 207,\n\n\t// custom blending source factors\n\n\t//ZeroFactor: 200,\n\t//OneFactor: 201,\n\t//SrcAlphaFactor: 204,\n\t//OneMinusSrcAlphaFactor: 205,\n\t//DstAlphaFactor: 206,\n\t//OneMinusDstAlphaFactor: 207,\n\tDstColorFactor: 208,\n\tOneMinusDstColorFactor: 209,\n\tSrcAlphaSaturateFactor: 210,\n\n\t// depth modes\n\n\tNeverDepth: 0,\n\tAlwaysDepth: 1,\n\tLessDepth: 2,\n\tLessEqualDepth: 3,\n\tEqualDepth: 4,\n\tGreaterEqualDepth: 5,\n\tGreaterDepth: 6,\n\tNotEqualDepth: 7,\n\n\n\t// TEXTURE CONSTANTS\n\n\tMultiplyOperation: 0,\n\tMixOperation: 1,\n\tAddOperation: 2,\n\n\t// Tone Mapping modes\n\n\tNoToneMapping: 0, // do not do any tone mapping, not even exposure (required for special purpose passes.)\n\tLinearToneMapping: 1, // only apply exposure.\n\tReinhardToneMapping: 2,\n\tUncharted2ToneMapping: 3, // John Hable\n\tCineonToneMapping: 4, // optimized filmic operator by Jim Hejl and Richard Burgess-Dawson\n\n\t// Mapping modes\n\n\tUVMapping: 300,\n\n\tCubeReflectionMapping: 301,\n\tCubeRefractionMapping: 302,\n\n\tEquirectangularReflectionMapping: 303,\n\tEquirectangularRefractionMapping: 304,\n\n\tSphericalReflectionMapping: 305,\n\tCubeUVReflectionMapping: 306,\n\tCubeUVRefractionMapping: 307,\n\n\t// Wrapping modes\n\n\tRepeatWrapping: 1000,\n\tClampToEdgeWrapping: 1001,\n\tMirroredRepeatWrapping: 1002,\n\n\t// Filters\n\n\tNearestFilter: 1003,\n\tNearestMipMapNearestFilter: 1004,\n\tNearestMipMapLinearFilter: 1005,\n\tLinearFilter: 1006,\n\tLinearMipMapNearestFilter: 1007,\n\tLinearMipMapLinearFilter: 1008,\n\n\t// Data types\n\n\tUnsignedByteType: 1009,\n\tByteType: 1010,\n\tShortType: 1011,\n\tUnsignedShortType: 1012,\n\tIntType: 1013,\n\tUnsignedIntType: 1014,\n\tFloatType: 1015,\n\tHalfFloatType: 1025,\n\n\t// Pixel types\n\n\t//UnsignedByteType: 1009,\n\tUnsignedShort4444Type: 1016,\n\tUnsignedShort5551Type: 1017,\n\tUnsignedShort565Type: 1018,\n\n\t// Pixel formats\n\n\tAlphaFormat: 1019,\n\tRGBFormat: 1020,\n\tRGBAFormat: 1021,\n\tLuminanceFormat: 1022,\n\tLuminanceAlphaFormat: 1023,\n\t// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders\n\tRGBEFormat: THREE.RGBAFormat, //1024;\n\tDepthFormat: 1026,\n\n\t// DDS / ST3C Compressed texture formats\n\n\tRGB_S3TC_DXT1_Format: 2001,\n\tRGBA_S3TC_DXT1_Format: 2002,\n\tRGBA_S3TC_DXT3_Format: 2003,\n\tRGBA_S3TC_DXT5_Format: 2004,\n\n\t// PVRTC compressed texture formats\n\n\tRGB_PVRTC_4BPPV1_Format: 2100,\n\tRGB_PVRTC_2BPPV1_Format: 2101,\n\tRGBA_PVRTC_4BPPV1_Format: 2102,\n\tRGBA_PVRTC_2BPPV1_Format: 2103,\n\n\t// ETC compressed texture formats\n\n\tRGB_ETC1_Format: 2151,\n\n\t// Loop styles for AnimationAction\n\n\tLoopOnce: 2200,\n\tLoopRepeat: 2201,\n\tLoopPingPong: 2202,\n\n\t// Interpolation\n\n\tInterpolateDiscrete: 2300,\n\tInterpolateLinear: 2301,\n\tInterpolateSmooth: 2302,\n\n\t// Interpolant ending modes\n\n\tZeroCurvatureEnding: 2400,\n\tZeroSlopeEnding: 2401,\n\tWrapAroundEnding: 2402,\n\n\t// Triangle Draw modes\n\n\tTrianglesDrawMode: 0,\n\tTriangleStripDrawMode: 1,\n\tTriangleFanDrawMode: 2,\n\n\t// Texture Encodings\n\n\tLinearEncoding: 3000, // No encoding at all.\n\tsRGBEncoding: 3001,\n\tGammaEncoding: 3007, // uses GAMMA_FACTOR, for backwards compatibility with WebGLRenderer.gammaInput/gammaOutput\n\n\t// The following Texture Encodings are for RGB-only (no alpha) HDR light emission sources.\n\t// These encodings should not specified as output encodings except in rare situations.\n\tRGBEEncoding: 3002, // AKA Radiance.\n\tLogLuvEncoding: 3003,\n\tRGBM7Encoding: 3004,\n\tRGBM16Encoding: 3005,\n\tRGBDEncoding: 3006, // MaxRange is 256.\n\n\t// Depth packing strategies\n\n\tBasicDepthPacking: 3200, // for writing to float textures for high precision or for visualizing results in RGB buffers\n\tRGBADepthPacking: 3201 // for packing into RGBA buffers.\n\n} );\n\n// File:src/math/Color.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Color = function ( r, g, b ) {\n\n\tif ( g === undefined && b === undefined ) {\n\n\t\t// r is THREE.Color, hex or string\n\t\treturn this.set( r );\n\n\t}\n\n\treturn this.setRGB( r, g, b );\n\n};\n\nTHREE.Color.prototype = {\n\n\tconstructor: THREE.Color,\n\n\tr: 1, g: 1, b: 1,\n\n\tset: function ( value ) {\n\n\t\tif ( value instanceof THREE.Color ) {\n\n\t\t\tthis.copy( value );\n\n\t\t} else if ( typeof value === 'number' ) {\n\n\t\t\tthis.setHex( value );\n\n\t\t} else if ( typeof value === 'string' ) {\n\n\t\t\tthis.setStyle( value );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetScalar: function ( scalar ) {\n\n\t\tthis.r = scalar;\n\t\tthis.g = scalar;\n\t\tthis.b = scalar;\n\n\t},\n\n\tsetHex: function ( hex ) {\n\n\t\thex = Math.floor( hex );\n\n\t\tthis.r = ( hex >> 16 & 255 ) / 255;\n\t\tthis.g = ( hex >> 8 & 255 ) / 255;\n\t\tthis.b = ( hex & 255 ) / 255;\n\n\t\treturn this;\n\n\t},\n\n\tsetRGB: function ( r, g, b ) {\n\n\t\tthis.r = r;\n\t\tthis.g = g;\n\t\tthis.b = b;\n\n\t\treturn this;\n\n\t},\n\n\tsetHSL: function () {\n\n\t\tfunction hue2rgb( p, q, t ) {\n\n\t\t\tif ( t < 0 ) t += 1;\n\t\t\tif ( t > 1 ) t -= 1;\n\t\t\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\n\t\t\tif ( t < 1 / 2 ) return q;\n\t\t\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\n\t\t\treturn p;\n\n\t\t}\n\n\t\treturn function setHSL( h, s, l ) {\n\n\t\t\t// h,s,l ranges are in 0.0 - 1.0\n\t\t\th = THREE.Math.euclideanModulo( h, 1 );\n\t\t\ts = THREE.Math.clamp( s, 0, 1 );\n\t\t\tl = THREE.Math.clamp( l, 0, 1 );\n\n\t\t\tif ( s === 0 ) {\n\n\t\t\t\tthis.r = this.g = this.b = l;\n\n\t\t\t} else {\n\n\t\t\t\tvar p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\n\t\t\t\tvar q = ( 2 * l ) - p;\n\n\t\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\n\t\t\t\tthis.g = hue2rgb( q, p, h );\n\t\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tsetStyle: function ( style ) {\n\n\t\tfunction handleAlpha( string ) {\n\n\t\t\tif ( string === undefined ) return;\n\n\t\t\tif ( parseFloat( string ) < 1 ) {\n\n\t\t\t\tconsole.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tvar m;\n\n\t\tif ( m = /^((?:rgb|hsl)a?)\\(\\s*([^\\)]*)\\)/.exec( style ) ) {\n\n\t\t\t// rgb / hsl\n\n\t\t\tvar color;\n\t\t\tvar name = m[ 1 ];\n\t\t\tvar components = m[ 2 ];\n\n\t\t\tswitch ( name ) {\n\n\t\t\t\tcase 'rgb':\n\t\t\t\tcase 'rgba':\n\n\t\t\t\t\tif ( color = /^(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// rgb(255,0,0) rgba(255,0,0,0.5)\n\t\t\t\t\t\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\n\t\t\t\t\t\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\n\t\t\t\t\t\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\n\n\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\n\t\t\t\t\t\treturn this;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( color = /^(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\n\t\t\t\t\t\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\n\t\t\t\t\t\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\n\t\t\t\t\t\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\n\n\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\n\t\t\t\t\t\treturn this;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'hsl':\n\t\t\t\tcase 'hsla':\n\n\t\t\t\t\tif ( color = /^([0-9]*\\.?[0-9]+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\n\t\t\t\t\t\tvar h = parseFloat( color[ 1 ] ) / 360;\n\t\t\t\t\t\tvar s = parseInt( color[ 2 ], 10 ) / 100;\n\t\t\t\t\t\tvar l = parseInt( color[ 3 ], 10 ) / 100;\n\n\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\n\t\t\t\t\t\treturn this.setHSL( h, s, l );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t} else if ( m = /^\\#([A-Fa-f0-9]+)$/.exec( style ) ) {\n\n\t\t\t// hex color\n\n\t\t\tvar hex = m[ 1 ];\n\t\t\tvar size = hex.length;\n\n\t\t\tif ( size === 3 ) {\n\n\t\t\t\t// #ff0\n\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;\n\t\t\t\tthis.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;\n\t\t\t\tthis.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;\n\n\t\t\t\treturn this;\n\n\t\t\t} else if ( size === 6 ) {\n\n\t\t\t\t// #ff0000\n\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;\n\t\t\t\tthis.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;\n\t\t\t\tthis.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;\n\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( style && style.length > 0 ) {\n\n\t\t\t// color keywords\n\t\t\tvar hex = THREE.ColorKeywords[ style ];\n\n\t\t\tif ( hex !== undefined ) {\n\n\t\t\t\t// red\n\t\t\t\tthis.setHex( hex );\n\n\t\t\t} else {\n\n\t\t\t\t// unknown color\n\t\t\t\tconsole.warn( 'THREE.Color: Unknown color ' + style );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.r, this.g, this.b );\n\n\t},\n\n\tcopy: function ( color ) {\n\n\t\tthis.r = color.r;\n\t\tthis.g = color.g;\n\t\tthis.b = color.b;\n\n\t\treturn this;\n\n\t},\n\n\tcopyGammaToLinear: function ( color, gammaFactor ) {\n\n\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\n\n\t\tthis.r = Math.pow( color.r, gammaFactor );\n\t\tthis.g = Math.pow( color.g, gammaFactor );\n\t\tthis.b = Math.pow( color.b, gammaFactor );\n\n\t\treturn this;\n\n\t},\n\n\tcopyLinearToGamma: function ( color, gammaFactor ) {\n\n\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\n\n\t\tvar safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;\n\n\t\tthis.r = Math.pow( color.r, safeInverse );\n\t\tthis.g = Math.pow( color.g, safeInverse );\n\t\tthis.b = Math.pow( color.b, safeInverse );\n\n\t\treturn this;\n\n\t},\n\n\tconvertGammaToLinear: function () {\n\n\t\tvar r = this.r, g = this.g, b = this.b;\n\n\t\tthis.r = r * r;\n\t\tthis.g = g * g;\n\t\tthis.b = b * b;\n\n\t\treturn this;\n\n\t},\n\n\tconvertLinearToGamma: function () {\n\n\t\tthis.r = Math.sqrt( this.r );\n\t\tthis.g = Math.sqrt( this.g );\n\t\tthis.b = Math.sqrt( this.b );\n\n\t\treturn this;\n\n\t},\n\n\tgetHex: function () {\n\n\t\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\n\n\t},\n\n\tgetHexString: function () {\n\n\t\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\n\n\t},\n\n\tgetHSL: function ( optionalTarget ) {\n\n\t\t// h,s,l ranges are in 0.0 - 1.0\n\n\t\tvar hsl = optionalTarget || { h: 0, s: 0, l: 0 };\n\n\t\tvar r = this.r, g = this.g, b = this.b;\n\n\t\tvar max = Math.max( r, g, b );\n\t\tvar min = Math.min( r, g, b );\n\n\t\tvar hue, saturation;\n\t\tvar lightness = ( min + max ) / 2.0;\n\n\t\tif ( min === max ) {\n\n\t\t\thue = 0;\n\t\t\tsaturation = 0;\n\n\t\t} else {\n\n\t\t\tvar delta = max - min;\n\n\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\n\n\t\t\tswitch ( max ) {\n\n\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\n\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\n\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\n\n\t\t\t}\n\n\t\t\thue /= 6;\n\n\t\t}\n\n\t\thsl.h = hue;\n\t\thsl.s = saturation;\n\t\thsl.l = lightness;\n\n\t\treturn hsl;\n\n\t},\n\n\tgetStyle: function () {\n\n\t\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\n\n\t},\n\n\toffsetHSL: function ( h, s, l ) {\n\n\t\tvar hsl = this.getHSL();\n\n\t\thsl.h += h; hsl.s += s; hsl.l += l;\n\n\t\tthis.setHSL( hsl.h, hsl.s, hsl.l );\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( color ) {\n\n\t\tthis.r += color.r;\n\t\tthis.g += color.g;\n\t\tthis.b += color.b;\n\n\t\treturn this;\n\n\t},\n\n\taddColors: function ( color1, color2 ) {\n\n\t\tthis.r = color1.r + color2.r;\n\t\tthis.g = color1.g + color2.g;\n\t\tthis.b = color1.b + color2.b;\n\n\t\treturn this;\n\n\t},\n\n\taddScalar: function ( s ) {\n\n\t\tthis.r += s;\n\t\tthis.g += s;\n\t\tthis.b += s;\n\n\t\treturn this;\n\n\t},\n\n\tmultiply: function ( color ) {\n\n\t\tthis.r *= color.r;\n\t\tthis.g *= color.g;\n\t\tthis.b *= color.b;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( s ) {\n\n\t\tthis.r *= s;\n\t\tthis.g *= s;\n\t\tthis.b *= s;\n\n\t\treturn this;\n\n\t},\n\n\tlerp: function ( color, alpha ) {\n\n\t\tthis.r += ( color.r - this.r ) * alpha;\n\t\tthis.g += ( color.g - this.g ) * alpha;\n\t\tthis.b += ( color.b - this.b ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( c ) {\n\n\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\n\n\t},\n\n\tfromArray: function ( array, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.r = array[ offset ];\n\t\tthis.g = array[ offset + 1 ];\n\t\tthis.b = array[ offset + 2 ];\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this.r;\n\t\tarray[ offset + 1 ] = this.g;\n\t\tarray[ offset + 2 ] = this.b;\n\n\t\treturn array;\n\n\t}\n\n};\n\nTHREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\n'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\n'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\n'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\n'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\n'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\n'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\n'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\n'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\n'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\n'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\n'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\n'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\n'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\n'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\n'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\n'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\n'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\n'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\n'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\n'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\n'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\n'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\n'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\n\n// File:src/math/Quaternion.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author bhouston / http://clara.io\n */\n\nTHREE.Quaternion = function ( x, y, z, w ) {\n\n\tthis._x = x || 0;\n\tthis._y = y || 0;\n\tthis._z = z || 0;\n\tthis._w = ( w !== undefined ) ? w : 1;\n\n};\n\nTHREE.Quaternion.prototype = {\n\n\tconstructor: THREE.Quaternion,\n\n\tget x () {\n\n\t\treturn this._x;\n\n\t},\n\n\tset x ( value ) {\n\n\t\tthis._x = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tget y () {\n\n\t\treturn this._y;\n\n\t},\n\n\tset y ( value ) {\n\n\t\tthis._y = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tget z () {\n\n\t\treturn this._z;\n\n\t},\n\n\tset z ( value ) {\n\n\t\tthis._z = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tget w () {\n\n\t\treturn this._w;\n\n\t},\n\n\tset w ( value ) {\n\n\t\tthis._w = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tset: function ( x, y, z, w ) {\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._w = w;\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this._x, this._y, this._z, this._w );\n\n\t},\n\n\tcopy: function ( quaternion ) {\n\n\t\tthis._x = quaternion.x;\n\t\tthis._y = quaternion.y;\n\t\tthis._z = quaternion.z;\n\t\tthis._w = quaternion.w;\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromEuler: function ( euler, update ) {\n\n\t\tif ( euler instanceof THREE.Euler === false ) {\n\n\t\t\tthrow new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\n\n\t\t}\n\n\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\n\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n\t\t//\tcontent/SpinCalc.m\n\n\t\tvar c1 = Math.cos( euler._x / 2 );\n\t\tvar c2 = Math.cos( euler._y / 2 );\n\t\tvar c3 = Math.cos( euler._z / 2 );\n\t\tvar s1 = Math.sin( euler._x / 2 );\n\t\tvar s2 = Math.sin( euler._y / 2 );\n\t\tvar s3 = Math.sin( euler._z / 2 );\n\n\t\tvar order = euler.order;\n\n\t\tif ( order === 'XYZ' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t} else if ( order === 'YXZ' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t} else if ( order === 'ZXY' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t} else if ( order === 'ZYX' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t} else if ( order === 'YZX' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t} else if ( order === 'XZY' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t}\n\n\t\tif ( update !== false ) this.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromAxisAngle: function ( axis, angle ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\n\t\t// assumes axis is normalized\n\n\t\tvar halfAngle = angle / 2, s = Math.sin( halfAngle );\n\n\t\tthis._x = axis.x * s;\n\t\tthis._y = axis.y * s;\n\t\tthis._z = axis.z * s;\n\t\tthis._w = Math.cos( halfAngle );\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromRotationMatrix: function ( m ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tvar te = m.elements,\n\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\n\n\t\t\ttrace = m11 + m22 + m33,\n\t\t\ts;\n\n\t\tif ( trace > 0 ) {\n\n\t\t\ts = 0.5 / Math.sqrt( trace + 1.0 );\n\n\t\t\tthis._w = 0.25 / s;\n\t\t\tthis._x = ( m32 - m23 ) * s;\n\t\t\tthis._y = ( m13 - m31 ) * s;\n\t\t\tthis._z = ( m21 - m12 ) * s;\n\n\t\t} else if ( m11 > m22 && m11 > m33 ) {\n\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\n\n\t\t\tthis._w = ( m32 - m23 ) / s;\n\t\t\tthis._x = 0.25 * s;\n\t\t\tthis._y = ( m12 + m21 ) / s;\n\t\t\tthis._z = ( m13 + m31 ) / s;\n\n\t\t} else if ( m22 > m33 ) {\n\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\n\n\t\t\tthis._w = ( m13 - m31 ) / s;\n\t\t\tthis._x = ( m12 + m21 ) / s;\n\t\t\tthis._y = 0.25 * s;\n\t\t\tthis._z = ( m23 + m32 ) / s;\n\n\t\t} else {\n\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\n\n\t\t\tthis._w = ( m21 - m12 ) / s;\n\t\t\tthis._x = ( m13 + m31 ) / s;\n\t\t\tthis._y = ( m23 + m32 ) / s;\n\t\t\tthis._z = 0.25 * s;\n\n\t\t}\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromUnitVectors: function () {\n\n\t\t// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final\n\n\t\t// assumes direction vectors vFrom and vTo are normalized\n\n\t\tvar v1, r;\n\n\t\tvar EPS = 0.000001;\n\n\t\treturn function setFromUnitVectors( vFrom, vTo ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\n\t\t\tr = vFrom.dot( vTo ) + 1;\n\n\t\t\tif ( r < EPS ) {\n\n\t\t\t\tr = 0;\n\n\t\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\n\n\t\t\t\t\tv1.set( - vFrom.y, vFrom.x, 0 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tv1.set( 0, - vFrom.z, vFrom.y );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tv1.crossVectors( vFrom, vTo );\n\n\t\t\t}\n\n\t\t\tthis._x = v1.x;\n\t\t\tthis._y = v1.y;\n\t\t\tthis._z = v1.z;\n\t\t\tthis._w = r;\n\n\t\t\treturn this.normalize();\n\n\t\t};\n\n\t}(),\n\n\tinverse: function () {\n\n\t\treturn this.conjugate().normalize();\n\n\t},\n\n\tconjugate: function () {\n\n\t\tthis._x *= - 1;\n\t\tthis._y *= - 1;\n\t\tthis._z *= - 1;\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tdot: function ( v ) {\n\n\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n\n\t},\n\n\tlengthSq: function () {\n\n\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\n\n\t},\n\n\tnormalize: function () {\n\n\t\tvar l = this.length();\n\n\t\tif ( l === 0 ) {\n\n\t\t\tthis._x = 0;\n\t\t\tthis._y = 0;\n\t\t\tthis._z = 0;\n\t\t\tthis._w = 1;\n\n\t\t} else {\n\n\t\t\tl = 1 / l;\n\n\t\t\tthis._x = this._x * l;\n\t\t\tthis._y = this._y * l;\n\t\t\tthis._z = this._z * l;\n\t\t\tthis._w = this._w * l;\n\n\t\t}\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tmultiply: function ( q, p ) {\n\n\t\tif ( p !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\n\t\t\treturn this.multiplyQuaternions( q, p );\n\n\t\t}\n\n\t\treturn this.multiplyQuaternions( this, q );\n\n\t},\n\n\tpremultiply: function ( q ) {\n\n\t\treturn this.multiplyQuaternions( q, this );\n\n\t},\n\n\tmultiplyQuaternions: function ( a, b ) {\n\n\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\n\t\tvar qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n\t\tvar qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n\n\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tslerp: function ( qb, t ) {\n\n\t\tif ( t === 0 ) return this;\n\t\tif ( t === 1 ) return this.copy( qb );\n\n\t\tvar x = this._x, y = this._y, z = this._z, w = this._w;\n\n\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n\t\tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\n\t\tif ( cosHalfTheta < 0 ) {\n\n\t\t\tthis._w = - qb._w;\n\t\t\tthis._x = - qb._x;\n\t\t\tthis._y = - qb._y;\n\t\t\tthis._z = - qb._z;\n\n\t\t\tcosHalfTheta = - cosHalfTheta;\n\n\t\t} else {\n\n\t\t\tthis.copy( qb );\n\n\t\t}\n\n\t\tif ( cosHalfTheta >= 1.0 ) {\n\n\t\t\tthis._w = w;\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tvar sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\n\n\t\tif ( Math.abs( sinHalfTheta ) < 0.001 ) {\n\n\t\t\tthis._w = 0.5 * ( w + this._w );\n\t\t\tthis._x = 0.5 * ( x + this._x );\n\t\t\tthis._y = 0.5 * ( y + this._y );\n\t\t\tthis._z = 0.5 * ( z + this._z );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tvar halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\n\t\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\n\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\n\n\t\tthis._w = ( w * ratioA + this._w * ratioB );\n\t\tthis._x = ( x * ratioA + this._x * ratioB );\n\t\tthis._y = ( y * ratioA + this._y * ratioB );\n\t\tthis._z = ( z * ratioA + this._z * ratioB );\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( quaternion ) {\n\n\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\n\n\t},\n\n\tfromArray: function ( array, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis._x = array[ offset ];\n\t\tthis._y = array[ offset + 1 ];\n\t\tthis._z = array[ offset + 2 ];\n\t\tthis._w = array[ offset + 3 ];\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this._x;\n\t\tarray[ offset + 1 ] = this._y;\n\t\tarray[ offset + 2 ] = this._z;\n\t\tarray[ offset + 3 ] = this._w;\n\n\t\treturn array;\n\n\t},\n\n\tonChange: function ( callback ) {\n\n\t\tthis.onChangeCallback = callback;\n\n\t\treturn this;\n\n\t},\n\n\tonChangeCallback: function () {}\n\n};\n\nObject.assign( THREE.Quaternion, {\n\n\tslerp: function( qa, qb, qm, t ) {\n\n\t\treturn qm.copy( qa ).slerp( qb, t );\n\n\t},\n\n\tslerpFlat: function(\n\t\t\tdst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\n\n\t\t// fuzz-free, array-based Quaternion SLERP operation\n\n\t\tvar x0 = src0[ srcOffset0 + 0 ],\n\t\t\ty0 = src0[ srcOffset0 + 1 ],\n\t\t\tz0 = src0[ srcOffset0 + 2 ],\n\t\t\tw0 = src0[ srcOffset0 + 3 ],\n\n\t\t\tx1 = src1[ srcOffset1 + 0 ],\n\t\t\ty1 = src1[ srcOffset1 + 1 ],\n\t\t\tz1 = src1[ srcOffset1 + 2 ],\n\t\t\tw1 = src1[ srcOffset1 + 3 ];\n\n\t\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\n\n\t\t\tvar s = 1 - t,\n\n\t\t\t\tcos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n\n\t\t\t\tdir = ( cos >= 0 ? 1 : - 1 ),\n\t\t\t\tsqrSin = 1 - cos * cos;\n\n\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems:\n\t\t\tif ( sqrSin > Number.EPSILON ) {\n\n\t\t\t\tvar sin = Math.sqrt( sqrSin ),\n\t\t\t\t\tlen = Math.atan2( sin, cos * dir );\n\n\t\t\t\ts = Math.sin( s * len ) / sin;\n\t\t\t\tt = Math.sin( t * len ) / sin;\n\n\t\t\t}\n\n\t\t\tvar tDir = t * dir;\n\n\t\t\tx0 = x0 * s + x1 * tDir;\n\t\t\ty0 = y0 * s + y1 * tDir;\n\t\t\tz0 = z0 * s + z1 * tDir;\n\t\t\tw0 = w0 * s + w1 * tDir;\n\n\t\t\t// Normalize in case we just did a lerp:\n\t\t\tif ( s === 1 - t ) {\n\n\t\t\t\tvar f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\n\n\t\t\t\tx0 *= f;\n\t\t\t\ty0 *= f;\n\t\t\t\tz0 *= f;\n\t\t\t\tw0 *= f;\n\n\t\t\t}\n\n\t\t}\n\n\t\tdst[ dstOffset ] = x0;\n\t\tdst[ dstOffset + 1 ] = y0;\n\t\tdst[ dstOffset + 2 ] = z0;\n\t\tdst[ dstOffset + 3 ] = w0;\n\n\t}\n\n} );\n\n// File:src/math/Vector2.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author philogb / http://blog.thejit.org/\n * @author egraether / http://egraether.com/\n * @author zz85 / http://www.lab4games.net/zz85/blog\n */\n\nTHREE.Vector2 = function ( x, y ) {\n\n\tthis.x = x || 0;\n\tthis.y = y || 0;\n\n};\n\nTHREE.Vector2.prototype = {\n\n\tconstructor: THREE.Vector2,\n\n\tget width() {\n\n\t\treturn this.x;\n\n\t},\n\n\tset width( value ) {\n\n\t\tthis.x = value;\n\n\t},\n\n\tget height() {\n\n\t\treturn this.y;\n\n\t},\n\n\tset height( value ) {\n\n\t\tthis.y = value;\n\n\t},\n\n\t//\n\n\tset: function ( x, y ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetScalar: function ( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\n\t\treturn this;\n\n\t},\n\n\tsetX: function ( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t},\n\n\tsetY: function ( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetComponent: function ( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t},\n\n\tgetComponent: function ( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.x, this.y );\n\n\t},\n\n\tcopy: function ( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\treturn this.addVectors( v, w );\n\n\t\t}\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\n\t\treturn this;\n\n\t},\n\n\taddScalar: function ( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\n\t\treturn this;\n\n\t},\n\n\taddVectors: function ( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\n\t\treturn this;\n\n\t},\n\n\taddScaledVector: function ( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\n\t\treturn this;\n\n\t},\n\n\tsub: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\treturn this.subVectors( v, w );\n\n\t\t}\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\n\t\treturn this;\n\n\t},\n\n\tsubScalar: function ( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\n\t\treturn this;\n\n\t},\n\n\tsubVectors: function ( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\n\t\treturn this;\n\n\t},\n\n\tmultiply: function ( v ) {\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( scalar ) {\n\n\t\tif ( isFinite( scalar ) ) {\n\n\t\t\tthis.x *= scalar;\n\t\t\tthis.y *= scalar;\n\n\t\t} else {\n\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tdivide: function ( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\n\t\treturn this;\n\n\t},\n\n\tdivideScalar: function ( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t},\n\n\tmin: function ( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\n\t\treturn this;\n\n\t},\n\n\tmax: function ( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\n\t\treturn this;\n\n\t},\n\n\tclamp: function ( min, max ) {\n\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\n\t\treturn this;\n\n\t},\n\n\tclampScalar: function () {\n\n\t\tvar min, max;\n\n\t\treturn function clampScalar( minVal, maxVal ) {\n\n\t\t\tif ( min === undefined ) {\n\n\t\t\t\tmin = new THREE.Vector2();\n\t\t\t\tmax = new THREE.Vector2();\n\n\t\t\t}\n\n\t\t\tmin.set( minVal, minVal );\n\t\t\tmax.set( maxVal, maxVal );\n\n\t\t\treturn this.clamp( min, max );\n\n\t\t};\n\n\t}(),\n\n\tclampLength: function ( min, max ) {\n\n\t\tvar length = this.length();\n\n\t\treturn this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\n\n\t},\n\n\tfloor: function () {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\n\t\treturn this;\n\n\t},\n\n\tceil: function () {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\n\t\treturn this;\n\n\t},\n\n\tround: function () {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\n\t\treturn this;\n\n\t},\n\n\troundToZero: function () {\n\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function () {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\n\t\treturn this;\n\n\t},\n\n\tdot: function ( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y;\n\n\t},\n\n\tlengthSq: function () {\n\n\t\treturn this.x * this.x + this.y * this.y;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\n\n\t},\n\n\tlengthManhattan: function() {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y );\n\n\t},\n\n\tnormalize: function () {\n\n\t\treturn this.divideScalar( this.length() );\n\n\t},\n\n\tangle: function () {\n\n\t\t// computes the angle in radians with respect to the positive x-axis\n\n\t\tvar angle = Math.atan2( this.y, this.x );\n\n\t\tif ( angle < 0 ) angle += 2 * Math.PI;\n\n\t\treturn angle;\n\n\t},\n\n\tdistanceTo: function ( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t},\n\n\tdistanceToSquared: function ( v ) {\n\n\t\tvar dx = this.x - v.x, dy = this.y - v.y;\n\t\treturn dx * dx + dy * dy;\n\n\t},\n\n\tsetLength: function ( length ) {\n\n\t\treturn this.multiplyScalar( length / this.length() );\n\n\t},\n\n\tlerp: function ( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tlerpVectors: function ( v1, v2, alpha ) {\n\n\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\n\t},\n\n\tequals: function ( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\n\n\t},\n\n\tfromArray: function ( array, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\n\t\treturn array;\n\n\t},\n\n\tfromAttribute: function ( attribute, index, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tindex = index * attribute.itemSize + offset;\n\n\t\tthis.x = attribute.array[ index ];\n\t\tthis.y = attribute.array[ index + 1 ];\n\n\t\treturn this;\n\n\t},\n\n\trotateAround: function ( center, angle ) {\n\n\t\tvar c = Math.cos( angle ), s = Math.sin( angle );\n\n\t\tvar x = this.x - center.x;\n\t\tvar y = this.y - center.y;\n\n\t\tthis.x = x * c - y * s + center.x;\n\t\tthis.y = x * s + y * c + center.y;\n\n\t\treturn this;\n\n\t}\n\n};\n\n// File:src/math/Vector3.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author *kile / http://kile.stravaganza.org/\n * @author philogb / http://blog.thejit.org/\n * @author mikael emtinger / http://gomo.se/\n * @author egraether / http://egraether.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.Vector3 = function ( x, y, z ) {\n\n\tthis.x = x || 0;\n\tthis.y = y || 0;\n\tthis.z = z || 0;\n\n};\n\nTHREE.Vector3.prototype = {\n\n\tconstructor: THREE.Vector3,\n\n\tset: function ( x, y, z ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetScalar: function ( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\t\tthis.z = scalar;\n\n\t\treturn this;\n\n\t},\n\n\tsetX: function ( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t},\n\n\tsetY: function ( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetZ: function ( z ) {\n\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetComponent: function ( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tcase 2: this.z = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t},\n\n\tgetComponent: function ( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tcase 2: return this.z;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.x, this.y, this.z );\n\n\t},\n\n\tcopy: function ( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\treturn this.addVectors( v, w );\n\n\t\t}\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\tthis.z += v.z;\n\n\t\treturn this;\n\n\t},\n\n\taddScalar: function ( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\t\tthis.z += s;\n\n\t\treturn this;\n\n\t},\n\n\taddVectors: function ( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\t\tthis.z = a.z + b.z;\n\n\t\treturn this;\n\n\t},\n\n\taddScaledVector: function ( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\t\tthis.z += v.z * s;\n\n\t\treturn this;\n\n\t},\n\n\tsub: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\treturn this.subVectors( v, w );\n\n\t\t}\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\t\tthis.z -= v.z;\n\n\t\treturn this;\n\n\t},\n\n\tsubScalar: function ( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\t\tthis.z -= s;\n\n\t\treturn this;\n\n\t},\n\n\tsubVectors: function ( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\t\tthis.z = a.z - b.z;\n\n\t\treturn this;\n\n\t},\n\n\tmultiply: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\n\t\t\treturn this.multiplyVectors( v, w );\n\n\t\t}\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\t\tthis.z *= v.z;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( scalar ) {\n\n\t\tif ( isFinite( scalar ) ) {\n\n\t\t\tthis.x *= scalar;\n\t\t\tthis.y *= scalar;\n\t\t\tthis.z *= scalar;\n\n\t\t} else {\n\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\t\t\tthis.z = 0;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyVectors: function ( a, b ) {\n\n\t\tthis.x = a.x * b.x;\n\t\tthis.y = a.y * b.y;\n\t\tthis.z = a.z * b.z;\n\n\t\treturn this;\n\n\t},\n\n\tapplyEuler: function () {\n\n\t\tvar quaternion;\n\n\t\treturn function applyEuler( euler ) {\n\n\t\t\tif ( euler instanceof THREE.Euler === false ) {\n\n\t\t\t\tconsole.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );\n\n\t\t\t}\n\n\t\t\tif ( quaternion === undefined ) quaternion = new THREE.Quaternion();\n\n\t\t\treturn this.applyQuaternion( quaternion.setFromEuler( euler ) );\n\n\t\t};\n\n\t}(),\n\n\tapplyAxisAngle: function () {\n\n\t\tvar quaternion;\n\n\t\treturn function applyAxisAngle( axis, angle ) {\n\n\t\t\tif ( quaternion === undefined ) quaternion = new THREE.Quaternion();\n\n\t\t\treturn this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );\n\n\t\t};\n\n\t}(),\n\n\tapplyMatrix3: function ( m ) {\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\n\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\n\n\t\treturn this;\n\n\t},\n\n\tapplyMatrix4: function ( m ) {\n\n\t\t// input: THREE.Matrix4 affine matrix\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];\n\n\t\treturn this;\n\n\t},\n\n\tapplyProjection: function ( m ) {\n\n\t\t// input: THREE.Matrix4 projection matrix\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\t\tvar e = m.elements;\n\t\tvar d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide\n\n\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;\n\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;\n\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;\n\n\t\treturn this;\n\n\t},\n\n\tapplyQuaternion: function ( q ) {\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\t\tvar qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n\n\t\t// calculate quat * vector\n\n\t\tvar ix =  qw * x + qy * z - qz * y;\n\t\tvar iy =  qw * y + qz * x - qx * z;\n\t\tvar iz =  qw * z + qx * y - qy * x;\n\t\tvar iw = - qx * x - qy * y - qz * z;\n\n\t\t// calculate result * inverse quat\n\n\t\tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\n\t\tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\n\t\tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\n\n\t\treturn this;\n\n\t},\n\n\tproject: function () {\n\n\t\tvar matrix;\n\n\t\treturn function project( camera ) {\n\n\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\n\n\t\t\tmatrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );\n\t\t\treturn this.applyProjection( matrix );\n\n\t\t};\n\n\t}(),\n\n\tunproject: function () {\n\n\t\tvar matrix;\n\n\t\treturn function unproject( camera ) {\n\n\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\n\n\t\t\tmatrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );\n\t\t\treturn this.applyProjection( matrix );\n\n\t\t};\n\n\t}(),\n\n\ttransformDirection: function ( m ) {\n\n\t\t// input: THREE.Matrix4 affine matrix\n\t\t// vector interpreted as a direction\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\n\n\t\treturn this.normalize();\n\n\t},\n\n\tdivide: function ( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\t\tthis.z /= v.z;\n\n\t\treturn this;\n\n\t},\n\n\tdivideScalar: function ( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t},\n\n\tmin: function ( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\t\tthis.z = Math.min( this.z, v.z );\n\n\t\treturn this;\n\n\t},\n\n\tmax: function ( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\t\tthis.z = Math.max( this.z, v.z );\n\n\t\treturn this;\n\n\t},\n\n\tclamp: function ( min, max ) {\n\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\n\t\treturn this;\n\n\t},\n\n\tclampScalar: function () {\n\n\t\tvar min, max;\n\n\t\treturn function clampScalar( minVal, maxVal ) {\n\n\t\t\tif ( min === undefined ) {\n\n\t\t\t\tmin = new THREE.Vector3();\n\t\t\t\tmax = new THREE.Vector3();\n\n\t\t\t}\n\n\t\t\tmin.set( minVal, minVal, minVal );\n\t\t\tmax.set( maxVal, maxVal, maxVal );\n\n\t\t\treturn this.clamp( min, max );\n\n\t\t};\n\n\t}(),\n\n\tclampLength: function ( min, max ) {\n\n\t\tvar length = this.length();\n\n\t\treturn this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\n\n\t},\n\n\tfloor: function () {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\t\tthis.z = Math.floor( this.z );\n\n\t\treturn this;\n\n\t},\n\n\tceil: function () {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\t\tthis.z = Math.ceil( this.z );\n\n\t\treturn this;\n\n\t},\n\n\tround: function () {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\t\tthis.z = Math.round( this.z );\n\n\t\treturn this;\n\n\t},\n\n\troundToZero: function () {\n\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function () {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\t\tthis.z = - this.z;\n\n\t\treturn this;\n\n\t},\n\n\tdot: function ( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\n\n\t},\n\n\tlengthSq: function () {\n\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\n\n\t},\n\n\tlengthManhattan: function () {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\n\n\t},\n\n\tnormalize: function () {\n\n\t\treturn this.divideScalar( this.length() );\n\n\t},\n\n\tsetLength: function ( length ) {\n\n\t\treturn this.multiplyScalar( length / this.length() );\n\n\t},\n\n\tlerp: function ( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\tthis.z += ( v.z - this.z ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tlerpVectors: function ( v1, v2, alpha ) {\n\n\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\n\t},\n\n\tcross: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\n\t\t\treturn this.crossVectors( v, w );\n\n\t\t}\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\n\t\tthis.x = y * v.z - z * v.y;\n\t\tthis.y = z * v.x - x * v.z;\n\t\tthis.z = x * v.y - y * v.x;\n\n\t\treturn this;\n\n\t},\n\n\tcrossVectors: function ( a, b ) {\n\n\t\tvar ax = a.x, ay = a.y, az = a.z;\n\t\tvar bx = b.x, by = b.y, bz = b.z;\n\n\t\tthis.x = ay * bz - az * by;\n\t\tthis.y = az * bx - ax * bz;\n\t\tthis.z = ax * by - ay * bx;\n\n\t\treturn this;\n\n\t},\n\n\tprojectOnVector: function ( vector ) {\n\n\t\tvar scalar = vector.dot( this ) / vector.lengthSq();\n\t\n\t\treturn this.copy( vector ).multiplyScalar( scalar );\n\t\n\t},\n\n\tprojectOnPlane: function () {\n\n\t\tvar v1;\n\n\t\treturn function projectOnPlane( planeNormal ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\n\t\t\tv1.copy( this ).projectOnVector( planeNormal );\n\n\t\t\treturn this.sub( v1 );\n\n\t\t};\n\n\t}(),\n\n\treflect: function () {\n\n\t\t// reflect incident vector off plane orthogonal to normal\n\t\t// normal is assumed to have unit length\n\n\t\tvar v1;\n\n\t\treturn function reflect( normal ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\n\t\t\treturn this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\n\n\t\t};\n\n\t}(),\n\n\tangleTo: function ( v ) {\n\n\t\tvar theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );\n\n\t\t// clamp, to handle numerical problems\n\n\t\treturn Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );\n\n\t},\n\n\tdistanceTo: function ( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t},\n\n\tdistanceToSquared: function ( v ) {\n\n\t\tvar dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n\n\t\treturn dx * dx + dy * dy + dz * dz;\n\n\t},\n\n\tsetFromSpherical: function( s ) {\n\n\t\tvar sinPhiRadius = Math.sin( s.phi ) * s.radius;\n\n\t\tthis.x = sinPhiRadius * Math.sin( s.theta );\n\t\tthis.y = Math.cos( s.phi ) * s.radius;\n\t\tthis.z = sinPhiRadius * Math.cos( s.theta );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromMatrixPosition: function ( m ) {\n\n\t\treturn this.setFromMatrixColumn( m, 3 );\n\n\t},\n\n\tsetFromMatrixScale: function ( m ) {\n\n\t\tvar sx = this.setFromMatrixColumn( m, 0 ).length();\n\t\tvar sy = this.setFromMatrixColumn( m, 1 ).length();\n\t\tvar sz = this.setFromMatrixColumn( m, 2 ).length();\n\n\t\tthis.x = sx;\n\t\tthis.y = sy;\n\t\tthis.z = sz;\n\n\t\treturn this;\n\n\t},\n\n\tsetFromMatrixColumn: function ( m, index ) {\n\n\t\tif ( typeof m === 'number' ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).' );\n\t\t\tvar temp = m\n\t\t\tm = index;\n\t\t\tindex = temp;\n\n\t\t}\n\n\t\treturn this.fromArray( m.elements, index * 4 );\n\n\t},\n\n\tequals: function ( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\n\n\t},\n\n\tfromArray: function ( array, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\t\tthis.z = array[ offset + 2 ];\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\t\tarray[ offset + 2 ] = this.z;\n\n\t\treturn array;\n\n\t},\n\n\tfromAttribute: function ( attribute, index, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tindex = index * attribute.itemSize + offset;\n\n\t\tthis.x = attribute.array[ index ];\n\t\tthis.y = attribute.array[ index + 1 ];\n\t\tthis.z = attribute.array[ index + 2 ];\n\n\t\treturn this;\n\n\t}\n\n};\n\n// File:src/math/Vector4.js\n\n/**\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author philogb / http://blog.thejit.org/\n * @author mikael emtinger / http://gomo.se/\n * @author egraether / http://egraether.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.Vector4 = function ( x, y, z, w ) {\n\n\tthis.x = x || 0;\n\tthis.y = y || 0;\n\tthis.z = z || 0;\n\tthis.w = ( w !== undefined ) ? w : 1;\n\n};\n\nTHREE.Vector4.prototype = {\n\n\tconstructor: THREE.Vector4,\n\n\tset: function ( x, y, z, w ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\n\t\treturn this;\n\n\t},\n\n\tsetScalar: function ( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\t\tthis.z = scalar;\n\t\tthis.w = scalar;\n\n\t\treturn this;\n\n\t},\n\n\tsetX: function ( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t},\n\n\tsetY: function ( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetZ: function ( z ) {\n\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetW: function ( w ) {\n\n\t\tthis.w = w;\n\n\t\treturn this;\n\n\t},\n\n\tsetComponent: function ( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tcase 2: this.z = value; break;\n\t\t\tcase 3: this.w = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t},\n\n\tgetComponent: function ( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tcase 2: return this.z;\n\t\t\tcase 3: return this.w;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.x, this.y, this.z, this.w );\n\n\t},\n\n\tcopy: function ( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\treturn this.addVectors( v, w );\n\n\t\t}\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\tthis.z += v.z;\n\t\tthis.w += v.w;\n\n\t\treturn this;\n\n\t},\n\n\taddScalar: function ( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\t\tthis.z += s;\n\t\tthis.w += s;\n\n\t\treturn this;\n\n\t},\n\n\taddVectors: function ( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\t\tthis.z = a.z + b.z;\n\t\tthis.w = a.w + b.w;\n\n\t\treturn this;\n\n\t},\n\n\taddScaledVector: function ( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\t\tthis.z += v.z * s;\n\t\tthis.w += v.w * s;\n\n\t\treturn this;\n\n\t},\n\n\tsub: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\treturn this.subVectors( v, w );\n\n\t\t}\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\t\tthis.z -= v.z;\n\t\tthis.w -= v.w;\n\n\t\treturn this;\n\n\t},\n\n\tsubScalar: function ( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\t\tthis.z -= s;\n\t\tthis.w -= s;\n\n\t\treturn this;\n\n\t},\n\n\tsubVectors: function ( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\t\tthis.z = a.z - b.z;\n\t\tthis.w = a.w - b.w;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( scalar ) {\n\n\t\tif ( isFinite( scalar ) ) {\n\n\t\t\tthis.x *= scalar;\n\t\t\tthis.y *= scalar;\n\t\t\tthis.z *= scalar;\n\t\t\tthis.w *= scalar;\n\n\t\t} else {\n\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\t\t\tthis.z = 0;\n\t\t\tthis.w = 0;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tapplyMatrix4: function ( m ) {\n\n\t\tvar x = this.x, y = this.y, z = this.z, w = this.w;\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\n\t\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\n\n\t\treturn this;\n\n\t},\n\n\tdivideScalar: function ( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t},\n\n\tsetAxisAngleFromQuaternion: function ( q ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\n\t\t// q is assumed to be normalized\n\n\t\tthis.w = 2 * Math.acos( q.w );\n\n\t\tvar s = Math.sqrt( 1 - q.w * q.w );\n\n\t\tif ( s < 0.0001 ) {\n\n\t\t\t this.x = 1;\n\t\t\t this.y = 0;\n\t\t\t this.z = 0;\n\n\t\t} else {\n\n\t\t\t this.x = q.x / s;\n\t\t\t this.y = q.y / s;\n\t\t\t this.z = q.z / s;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetAxisAngleFromRotationMatrix: function ( m ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tvar angle, x, y, z,\t\t// variables for result\n\t\t\tepsilon = 0.01,\t\t// margin to allow for rounding errors\n\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\n\n\t\t\tte = m.elements,\n\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\tif ( ( Math.abs( m12 - m21 ) < epsilon ) &&\n\t\t     ( Math.abs( m13 - m31 ) < epsilon ) &&\n\t\t     ( Math.abs( m23 - m32 ) < epsilon ) ) {\n\n\t\t\t// singularity found\n\t\t\t// first check for identity matrix which must have +1 for all terms\n\t\t\t// in leading diagonal and zero in other terms\n\n\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m13 + m31 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m23 + m32 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\n\n\t\t\t\t// this singularity is identity matrix so angle = 0\n\n\t\t\t\tthis.set( 1, 0, 0, 0 );\n\n\t\t\t\treturn this; // zero angle, arbitrary axis\n\n\t\t\t}\n\n\t\t\t// otherwise this singularity is angle = 180\n\n\t\t\tangle = Math.PI;\n\n\t\t\tvar xx = ( m11 + 1 ) / 2;\n\t\t\tvar yy = ( m22 + 1 ) / 2;\n\t\t\tvar zz = ( m33 + 1 ) / 2;\n\t\t\tvar xy = ( m12 + m21 ) / 4;\n\t\t\tvar xz = ( m13 + m31 ) / 4;\n\t\t\tvar yz = ( m23 + m32 ) / 4;\n\n\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) {\n\n\t\t\t\t// m11 is the largest diagonal term\n\n\t\t\t\tif ( xx < epsilon ) {\n\n\t\t\t\t\tx = 0;\n\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tx = Math.sqrt( xx );\n\t\t\t\t\ty = xy / x;\n\t\t\t\t\tz = xz / x;\n\n\t\t\t\t}\n\n\t\t\t} else if ( yy > zz ) {\n\n\t\t\t\t// m22 is the largest diagonal term\n\n\t\t\t\tif ( yy < epsilon ) {\n\n\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\ty = 0;\n\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ty = Math.sqrt( yy );\n\t\t\t\t\tx = xy / y;\n\t\t\t\t\tz = yz / y;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// m33 is the largest diagonal term so base result on this\n\n\t\t\t\tif ( zz < epsilon ) {\n\n\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\tz = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tz = Math.sqrt( zz );\n\t\t\t\t\tx = xz / z;\n\t\t\t\t\ty = yz / z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.set( x, y, z, angle );\n\n\t\t\treturn this; // return 180 deg rotation\n\n\t\t}\n\n\t\t// as we have reached here there are no singularities so we can handle normally\n\n\t\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +\n\t\t                   ( m13 - m31 ) * ( m13 - m31 ) +\n\t\t                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\n\n\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\n\n\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\n\t\t// caught by singularity test above, but I've left it in just in case\n\n\t\tthis.x = ( m32 - m23 ) / s;\n\t\tthis.y = ( m13 - m31 ) / s;\n\t\tthis.z = ( m21 - m12 ) / s;\n\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\n\n\t\treturn this;\n\n\t},\n\n\tmin: function ( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\t\tthis.z = Math.min( this.z, v.z );\n\t\tthis.w = Math.min( this.w, v.w );\n\n\t\treturn this;\n\n\t},\n\n\tmax: function ( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\t\tthis.z = Math.max( this.z, v.z );\n\t\tthis.w = Math.max( this.w, v.w );\n\n\t\treturn this;\n\n\t},\n\n\tclamp: function ( min, max ) {\n\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\t\tthis.w = Math.max( min.w, Math.min( max.w, this.w ) );\n\n\t\treturn this;\n\n\t},\n\n\tclampScalar: function () {\n\n\t\tvar min, max;\n\n\t\treturn function clampScalar( minVal, maxVal ) {\n\n\t\t\tif ( min === undefined ) {\n\n\t\t\t\tmin = new THREE.Vector4();\n\t\t\t\tmax = new THREE.Vector4();\n\n\t\t\t}\n\n\t\t\tmin.set( minVal, minVal, minVal, minVal );\n\t\t\tmax.set( maxVal, maxVal, maxVal, maxVal );\n\n\t\t\treturn this.clamp( min, max );\n\n\t\t};\n\n\t}(),\n\n\tfloor: function () {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\t\tthis.z = Math.floor( this.z );\n\t\tthis.w = Math.floor( this.w );\n\n\t\treturn this;\n\n\t},\n\n\tceil: function () {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\t\tthis.z = Math.ceil( this.z );\n\t\tthis.w = Math.ceil( this.w );\n\n\t\treturn this;\n\n\t},\n\n\tround: function () {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\t\tthis.z = Math.round( this.z );\n\t\tthis.w = Math.round( this.w );\n\n\t\treturn this;\n\n\t},\n\n\troundToZero: function () {\n\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\t\tthis.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function () {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\t\tthis.z = - this.z;\n\t\tthis.w = - this.w;\n\n\t\treturn this;\n\n\t},\n\n\tdot: function ( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n\n\t},\n\n\tlengthSq: function () {\n\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\n\n\t},\n\n\tlengthManhattan: function () {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\n\n\t},\n\n\tnormalize: function () {\n\n\t\treturn this.divideScalar( this.length() );\n\n\t},\n\n\tsetLength: function ( length ) {\n\n\t\treturn this.multiplyScalar( length / this.length() );\n\n\t},\n\n\tlerp: function ( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\tthis.z += ( v.z - this.z ) * alpha;\n\t\tthis.w += ( v.w - this.w ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tlerpVectors: function ( v1, v2, alpha ) {\n\n\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\n\t},\n\n\tequals: function ( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\n\n\t},\n\n\tfromArray: function ( array, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\t\tthis.z = array[ offset + 2 ];\n\t\tthis.w = array[ offset + 3 ];\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\t\tarray[ offset + 2 ] = this.z;\n\t\tarray[ offset + 3 ] = this.w;\n\n\t\treturn array;\n\n\t},\n\n\tfromAttribute: function ( attribute, index, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tindex = index * attribute.itemSize + offset;\n\n\t\tthis.x = attribute.array[ index ];\n\t\tthis.y = attribute.array[ index + 1 ];\n\t\tthis.z = attribute.array[ index + 2 ];\n\t\tthis.w = attribute.array[ index + 3 ];\n\n\t\treturn this;\n\n\t}\n\n};\n\n// File:src/math/Euler.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author bhouston / http://clara.io\n */\n\nTHREE.Euler = function ( x, y, z, order ) {\n\n\tthis._x = x || 0;\n\tthis._y = y || 0;\n\tthis._z = z || 0;\n\tthis._order = order || THREE.Euler.DefaultOrder;\n\n};\n\nTHREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\n\nTHREE.Euler.DefaultOrder = 'XYZ';\n\nTHREE.Euler.prototype = {\n\n\tconstructor: THREE.Euler,\n\n\tget x () {\n\n\t\treturn this._x;\n\n\t},\n\n\tset x ( value ) {\n\n\t\tthis._x = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tget y () {\n\n\t\treturn this._y;\n\n\t},\n\n\tset y ( value ) {\n\n\t\tthis._y = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tget z () {\n\n\t\treturn this._z;\n\n\t},\n\n\tset z ( value ) {\n\n\t\tthis._z = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tget order () {\n\n\t\treturn this._order;\n\n\t},\n\n\tset order ( value ) {\n\n\t\tthis._order = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tset: function ( x, y, z, order ) {\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._order = order || this._order;\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this._x, this._y, this._z, this._order );\n\n\t},\n\n\tcopy: function ( euler ) {\n\n\t\tthis._x = euler._x;\n\t\tthis._y = euler._y;\n\t\tthis._z = euler._z;\n\t\tthis._order = euler._order;\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromRotationMatrix: function ( m, order, update ) {\n\n\t\tvar clamp = THREE.Math.clamp;\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tvar te = m.elements;\n\t\tvar m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\n\t\tvar m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\n\t\tvar m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\torder = order || this._order;\n\n\t\tif ( order === 'XYZ' ) {\n\n\t\t\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m13 ) < 0.99999 ) {\n\n\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\tthis._z = Math.atan2( - m12, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\tthis._z = 0;\n\n\t\t\t}\n\n\t\t} else if ( order === 'YXZ' ) {\n\n\t\t\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m23 ) < 0.99999 ) {\n\n\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\t\t\t\tthis._z = Math.atan2( m21, m22 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\t\t\t\tthis._z = 0;\n\n\t\t\t}\n\n\t\t} else if ( order === 'ZXY' ) {\n\n\t\t\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m32 ) < 0.99999 ) {\n\n\t\t\t\tthis._y = Math.atan2( - m31, m33 );\n\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._y = 0;\n\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t}\n\n\t\t} else if ( order === 'ZYX' ) {\n\n\t\t\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m31 ) < 0.99999 ) {\n\n\t\t\t\tthis._x = Math.atan2( m32, m33 );\n\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = 0;\n\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t}\n\n\t\t} else if ( order === 'YZX' ) {\n\n\t\t\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m21 ) < 0.99999 ) {\n\n\t\t\t\tthis._x = Math.atan2( - m23, m22 );\n\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = 0;\n\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\n\t\t\t}\n\n\t\t} else if ( order === 'XZY' ) {\n\n\t\t\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m12 ) < 0.99999 ) {\n\n\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\tthis._y = Math.atan2( m13, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\tthis._y = 0;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );\n\n\t\t}\n\n\t\tthis._order = order;\n\n\t\tif ( update !== false ) this.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromQuaternion: function () {\n\n\t\tvar matrix;\n\n\t\treturn function setFromQuaternion( q, order, update ) {\n\n\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\n\n\t\t\tmatrix.makeRotationFromQuaternion( q );\n\n\t\t\treturn this.setFromRotationMatrix( matrix, order, update );\n\n\t\t};\n\n\t}(),\n\n\tsetFromVector3: function ( v, order ) {\n\n\t\treturn this.set( v.x, v.y, v.z, order || this._order );\n\n\t},\n\n\treorder: function () {\n\n\t\t// WARNING: this discards revolution information -bhouston\n\n\t\tvar q = new THREE.Quaternion();\n\n\t\treturn function reorder( newOrder ) {\n\n\t\t\tq.setFromEuler( this );\n\t\t\t\n\t\t\treturn this.setFromQuaternion( q, newOrder );\n\n\t\t};\n\n\t}(),\n\n\tequals: function ( euler ) {\n\n\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\n\n\t},\n\n\tfromArray: function ( array ) {\n\n\t\tthis._x = array[ 0 ];\n\t\tthis._y = array[ 1 ];\n\t\tthis._z = array[ 2 ];\n\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this._x;\n\t\tarray[ offset + 1 ] = this._y;\n\t\tarray[ offset + 2 ] = this._z;\n\t\tarray[ offset + 3 ] = this._order;\n\n\t\treturn array;\n\n\t},\n\n\ttoVector3: function ( optionalResult ) {\n\n\t\tif ( optionalResult ) {\n\n\t\t\treturn optionalResult.set( this._x, this._y, this._z );\n\n\t\t} else {\n\n\t\t\treturn new THREE.Vector3( this._x, this._y, this._z );\n\n\t\t}\n\n\t},\n\n\tonChange: function ( callback ) {\n\n\t\tthis.onChangeCallback = callback;\n\n\t\treturn this;\n\n\t},\n\n\tonChangeCallback: function () {}\n\n};\n\n// File:src/math/Line3.js\n\n/**\n * @author bhouston / http://clara.io\n */\n\nTHREE.Line3 = function ( start, end ) {\n\n\tthis.start = ( start !== undefined ) ? start : new THREE.Vector3();\n\tthis.end = ( end !== undefined ) ? end : new THREE.Vector3();\n\n};\n\nTHREE.Line3.prototype = {\n\n\tconstructor: THREE.Line3,\n\n\tset: function ( start, end ) {\n\n\t\tthis.start.copy( start );\n\t\tthis.end.copy( end );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( line ) {\n\n\t\tthis.start.copy( line.start );\n\t\tthis.end.copy( line.end );\n\n\t\treturn this;\n\n\t},\n\n\tcenter: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\n\n\t},\n\n\tdelta: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.subVectors( this.end, this.start );\n\n\t},\n\n\tdistanceSq: function () {\n\n\t\treturn this.start.distanceToSquared( this.end );\n\n\t},\n\n\tdistance: function () {\n\n\t\treturn this.start.distanceTo( this.end );\n\n\t},\n\n\tat: function ( t, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\n\n\t},\n\n\tclosestPointToPointParameter: function () {\n\n\t\tvar startP = new THREE.Vector3();\n\t\tvar startEnd = new THREE.Vector3();\n\n\t\treturn function closestPointToPointParameter( point, clampToLine ) {\n\n\t\t\tstartP.subVectors( point, this.start );\n\t\t\tstartEnd.subVectors( this.end, this.start );\n\n\t\t\tvar startEnd2 = startEnd.dot( startEnd );\n\t\t\tvar startEnd_startP = startEnd.dot( startP );\n\n\t\t\tvar t = startEnd_startP / startEnd2;\n\n\t\t\tif ( clampToLine ) {\n\n\t\t\t\tt = THREE.Math.clamp( t, 0, 1 );\n\n\t\t\t}\n\n\t\t\treturn t;\n\n\t\t};\n\n\t}(),\n\n\tclosestPointToPoint: function ( point, clampToLine, optionalTarget ) {\n\n\t\tvar t = this.closestPointToPointParameter( point, clampToLine );\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\n\n\t},\n\n\tapplyMatrix4: function ( matrix ) {\n\n\t\tthis.start.applyMatrix4( matrix );\n\t\tthis.end.applyMatrix4( matrix );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( line ) {\n\n\t\treturn line.start.equals( this.start ) && line.end.equals( this.end );\n\n\t}\n\n};\n\n// File:src/math/Box2.js\n\n/**\n * @author bhouston / http://clara.io\n */\n\nTHREE.Box2 = function ( min, max ) {\n\n\tthis.min = ( min !== undefined ) ? min : new THREE.Vector2( + Infinity, + Infinity );\n\tthis.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );\n\n};\n\nTHREE.Box2.prototype = {\n\n\tconstructor: THREE.Box2,\n\n\tset: function ( min, max ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromPoints: function ( points ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetFromCenterAndSize: function () {\n\n\t\tvar v1 = new THREE.Vector2();\n\n\t\treturn function setFromCenterAndSize( center, size ) {\n\n\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\tthis.max.copy( center ).add( halfSize );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( box ) {\n\n\t\tthis.min.copy( box.min );\n\t\tthis.max.copy( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tmakeEmpty: function () {\n\n\t\tthis.min.x = this.min.y = + Infinity;\n\t\tthis.max.x = this.max.y = - Infinity;\n\n\t\treturn this;\n\n\t},\n\n\tisEmpty: function () {\n\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\n\n\t},\n\n\tcenter: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector2();\n\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t},\n\n\tsize: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector2();\n\t\treturn result.subVectors( this.max, this.min );\n\n\t},\n\n\texpandByPoint: function ( point ) {\n\n\t\tthis.min.min( point );\n\t\tthis.max.max( point );\n\n\t\treturn this;\n\n\t},\n\n\texpandByVector: function ( vector ) {\n\n\t\tthis.min.sub( vector );\n\t\tthis.max.add( vector );\n\n\t\treturn this;\n\n\t},\n\n\texpandByScalar: function ( scalar ) {\n\n\t\tthis.min.addScalar( - scalar );\n\t\tthis.max.addScalar( scalar );\n\n\t\treturn this;\n\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\tif ( point.x < this.min.x || point.x > this.max.x ||\n\t\t     point.y < this.min.y || point.y > this.max.y ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tcontainsBox: function ( box ) {\n\n\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\n\t\t     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t},\n\n\tgetParameter: function ( point, optionalTarget ) {\n\n\t\t// This can potentially have a divide by zero if the box\n\t\t// has a size dimension of 0.\n\n\t\tvar result = optionalTarget || new THREE.Vector2();\n\n\t\treturn result.set(\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\n\t\t);\n\n\t},\n\n\tintersectsBox: function ( box ) {\n\n\t\t// using 6 splitting planes to rule out intersections.\n\n\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t     box.max.y < this.min.y || box.min.y > this.max.y ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tclampPoint: function ( point, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector2();\n\t\treturn result.copy( point ).clamp( this.min, this.max );\n\n\t},\n\n\tdistanceToPoint: function () {\n\n\t\tvar v1 = new THREE.Vector2();\n\n\t\treturn function distanceToPoint( point ) {\n\n\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\treturn clampedPoint.sub( point ).length();\n\n\t\t};\n\n\t}(),\n\n\tintersect: function ( box ) {\n\n\t\tthis.min.max( box.min );\n\t\tthis.max.min( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tunion: function ( box ) {\n\n\t\tthis.min.min( box.min );\n\t\tthis.max.max( box.max );\n\n\t\treturn this;\n\n\t},\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.min.add( offset );\n\t\tthis.max.add( offset );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( box ) {\n\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t}\n\n};\n\n// File:src/math/Box3.js\n\n/**\n * @author bhouston / http://clara.io\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.Box3 = function ( min, max ) {\n\n\tthis.min = ( min !== undefined ) ? min : new THREE.Vector3( + Infinity, + Infinity, + Infinity );\n\tthis.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );\n\n};\n\nTHREE.Box3.prototype = {\n\n\tconstructor: THREE.Box3,\n\n\tset: function ( min, max ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromArray: function ( array ) {\n\n\t\tvar minX = + Infinity;\n\t\tvar minY = + Infinity;\n\t\tvar minZ = + Infinity;\n\n\t\tvar maxX = - Infinity;\n\t\tvar maxY = - Infinity;\n\t\tvar maxZ = - Infinity;\n\n\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\tvar x = array[ i ];\n\t\t\tvar y = array[ i + 1 ];\n\t\t\tvar z = array[ i + 2 ];\n\n\t\t\tif ( x < minX ) minX = x;\n\t\t\tif ( y < minY ) minY = y;\n\t\t\tif ( z < minZ ) minZ = z;\n\n\t\t\tif ( x > maxX ) maxX = x;\n\t\t\tif ( y > maxY ) maxY = y;\n\t\t\tif ( z > maxZ ) maxZ = z;\n\n\t\t}\n\n\t\tthis.min.set( minX, minY, minZ );\n\t\tthis.max.set( maxX, maxY, maxZ );\n\n\t},\n\n\tsetFromPoints: function ( points ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetFromCenterAndSize: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function setFromCenterAndSize( center, size ) {\n\n\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\n\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\tthis.max.copy( center ).add( halfSize );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tsetFromObject: function () {\n\n\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\n\t\t// accounting for both the object's, and children's, world transforms\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function setFromObject( object ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tobject.updateMatrixWorld( true );\n\n\t\t\tthis.makeEmpty();\n\n\t\t\tobject.traverse( function ( node ) {\n\n\t\t\t\tvar geometry = node.geometry;\n\n\t\t\t\tif ( geometry !== undefined ) {\n\n\t\t\t\t\tif ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\t\t\tvar vertices = geometry.vertices;\n\n\t\t\t\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\tv1.copy( vertices[ i ] );\n\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\n\n\t\t\t\t\t\t\tscope.expandByPoint( v1 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( geometry instanceof THREE.BufferGeometry && geometry.attributes[ 'position' ] !== undefined ) {\n\n\t\t\t\t\t\tvar positions = geometry.attributes[ 'position' ].array;\n\n\t\t\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 3 ) {\n\n\t\t\t\t\t\t\tv1.fromArray( positions, i );\n\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\n\n\t\t\t\t\t\t\tscope.expandByPoint( v1 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( box ) {\n\n\t\tthis.min.copy( box.min );\n\t\tthis.max.copy( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tmakeEmpty: function () {\n\n\t\tthis.min.x = this.min.y = this.min.z = + Infinity;\n\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\n\n\t\treturn this;\n\n\t},\n\n\tisEmpty: function () {\n\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\n\n\t},\n\n\tcenter: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t},\n\n\tsize: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.subVectors( this.max, this.min );\n\n\t},\n\n\texpandByPoint: function ( point ) {\n\n\t\tthis.min.min( point );\n\t\tthis.max.max( point );\n\n\t\treturn this;\n\n\t},\n\n\texpandByVector: function ( vector ) {\n\n\t\tthis.min.sub( vector );\n\t\tthis.max.add( vector );\n\n\t\treturn this;\n\n\t},\n\n\texpandByScalar: function ( scalar ) {\n\n\t\tthis.min.addScalar( - scalar );\n\t\tthis.max.addScalar( scalar );\n\n\t\treturn this;\n\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\tif ( point.x < this.min.x || point.x > this.max.x ||\n\t\t\t\t point.y < this.min.y || point.y > this.max.y ||\n\t\t\t\t point.z < this.min.z || point.z > this.max.z ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tcontainsBox: function ( box ) {\n\n\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\n\t\t\t ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&\n\t\t\t ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t},\n\n\tgetParameter: function ( point, optionalTarget ) {\n\n\t\t// This can potentially have a divide by zero if the box\n\t\t// has a size dimension of 0.\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\treturn result.set(\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\n\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\n\t\t);\n\n\t},\n\n\tintersectsBox: function ( box ) {\n\n\t\t// using 6 splitting planes to rule out intersections.\n\n\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\t\t box.max.y < this.min.y || box.min.y > this.max.y ||\n\t\t\t\t box.max.z < this.min.z || box.min.z > this.max.z ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tintersectsSphere: ( function () {\n\n\t\tvar closestPoint;\n\n\t\treturn function intersectsSphere( sphere ) {\n\n\t\t\tif ( closestPoint === undefined ) closestPoint = new THREE.Vector3();\n\n\t\t\t// Find the point on the AABB closest to the sphere center.\n\t\t\tthis.clampPoint( sphere.center, closestPoint );\n\n\t\t\t// If that point is inside the sphere, the AABB and sphere intersect.\n\t\t\treturn closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t\t};\n\n\t} )(),\n\n\tintersectsPlane: function ( plane ) {\n\n\t\t// We compute the minimum and maximum dot product values. If those values\n\t\t// are on the same side (back or front) of the plane, then there is no intersection.\n\n\t\tvar min, max;\n\n\t\tif ( plane.normal.x > 0 ) {\n\n\t\t\tmin = plane.normal.x * this.min.x;\n\t\t\tmax = plane.normal.x * this.max.x;\n\n\t\t} else {\n\n\t\t\tmin = plane.normal.x * this.max.x;\n\t\t\tmax = plane.normal.x * this.min.x;\n\n\t\t}\n\n\t\tif ( plane.normal.y > 0 ) {\n\n\t\t\tmin += plane.normal.y * this.min.y;\n\t\t\tmax += plane.normal.y * this.max.y;\n\n\t\t} else {\n\n\t\t\tmin += plane.normal.y * this.max.y;\n\t\t\tmax += plane.normal.y * this.min.y;\n\n\t\t}\n\n\t\tif ( plane.normal.z > 0 ) {\n\n\t\t\tmin += plane.normal.z * this.min.z;\n\t\t\tmax += plane.normal.z * this.max.z;\n\n\t\t} else {\n\n\t\t\tmin += plane.normal.z * this.max.z;\n\t\t\tmax += plane.normal.z * this.min.z;\n\n\t\t}\n\n\t\treturn ( min <= plane.constant && max >= plane.constant );\n\n\t},\n\n\tclampPoint: function ( point, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.copy( point ).clamp( this.min, this.max );\n\n\t},\n\n\tdistanceToPoint: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function distanceToPoint( point ) {\n\n\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\treturn clampedPoint.sub( point ).length();\n\n\t\t};\n\n\t}(),\n\n\tgetBoundingSphere: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function getBoundingSphere( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new THREE.Sphere();\n\n\t\t\tresult.center = this.center();\n\t\t\tresult.radius = this.size( v1 ).length() * 0.5;\n\n\t\t\treturn result;\n\n\t\t};\n\n\t}(),\n\n\tintersect: function ( box ) {\n\n\t\tthis.min.max( box.min );\n\t\tthis.max.min( box.max );\n\n\t\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n\t\tif( this.isEmpty() ) this.makeEmpty();\n\n\t\treturn this;\n\n\t},\n\n\tunion: function ( box ) {\n\n\t\tthis.min.min( box.min );\n\t\tthis.max.max( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tapplyMatrix4: function () {\n\n\t\tvar points = [\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3()\n\t\t];\n\n\t\treturn function applyMatrix4( matrix ) {\n\n\t\t\t// transform of empty box is an empty box.\n\t\t\tif( this.isEmpty() ) return this;\n\n\t\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\n\t\t\tpoints[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\n\t\t\tpoints[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\n\t\t\tpoints[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\n\t\t\tpoints[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\n\t\t\tpoints[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\n\t\t\tpoints[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\n\t\t\tpoints[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\n\t\t\tpoints[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );\t// 111\n\n\t\t\tthis.setFromPoints( points );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.min.add( offset );\n\t\tthis.max.add( offset );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( box ) {\n\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t}\n\n};\n\n// File:src/math/Matrix3.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author bhouston / http://clara.io\n * @author tschw\n */\n\nTHREE.Matrix3 = function () {\n\n\tthis.elements = new Float32Array( [\n\n\t\t1, 0, 0,\n\t\t0, 1, 0,\n\t\t0, 0, 1\n\n\t] );\n\n\tif ( arguments.length > 0 ) {\n\n\t\tconsole.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );\n\n\t}\n\n};\n\nTHREE.Matrix3.prototype = {\n\n\tconstructor: THREE.Matrix3,\n\n\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\n\t\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\n\t\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\n\n\t\treturn this;\n\n\t},\n\n\tidentity: function () {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0,\n\t\t\t0, 1, 0,\n\t\t\t0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().fromArray( this.elements );\n\n\t},\n\n\tcopy: function ( m ) {\n\n\t\tvar me = m.elements;\n\n\t\tthis.set(\n\n\t\t\tme[ 0 ], me[ 3 ], me[ 6 ],\n\t\t\tme[ 1 ], me[ 4 ], me[ 7 ],\n\t\t\tme[ 2 ], me[ 5 ], me[ 8 ]\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tsetFromMatrix4: function( m ) {\n\n\t\tvar me = m.elements;\n\n\t\tthis.set(\n\n\t\t\tme[ 0 ], me[ 4 ], me[  8 ],\n\t\t\tme[ 1 ], me[ 5 ], me[  9 ],\n\t\t\tme[ 2 ], me[ 6 ], me[ 10 ]\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tapplyToVector3Array: function () {\n\n\t\tvar v1;\n\n\t\treturn function applyToVector3Array( array, offset, length ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\tif ( length === undefined ) length = array.length;\n\n\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\n\n\t\t\t\tv1.fromArray( array, j );\n\t\t\t\tv1.applyMatrix3( this );\n\t\t\t\tv1.toArray( array, j );\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t};\n\n\t}(),\n\n\tapplyToBuffer: function () {\n\n\t\tvar v1;\n\n\t\treturn function applyToBuffer( buffer, offset, length ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\tif ( length === undefined ) length = buffer.length / buffer.itemSize;\n\n\t\t\tfor ( var i = 0, j = offset; i < length; i ++, j ++ ) {\n\n\t\t\t\tv1.x = buffer.getX( j );\n\t\t\t\tv1.y = buffer.getY( j );\n\t\t\t\tv1.z = buffer.getZ( j );\n\n\t\t\t\tv1.applyMatrix3( this );\n\n\t\t\t\tbuffer.setXYZ( v1.x, v1.y, v1.z );\n\n\t\t\t}\n\n\t\t\treturn buffer;\n\n\t\t};\n\n\t}(),\n\n\tmultiplyScalar: function ( s ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\n\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\n\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\n\n\t\treturn this;\n\n\t},\n\n\tdeterminant: function () {\n\n\t\tvar te = this.elements;\n\n\t\tvar a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\n\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\n\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\n\n\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n\n\t},\n\n\tgetInverse: function ( matrix, throwOnDegenerate ) {\n\n\t\tif ( matrix instanceof THREE.Matrix4 ) {\n\n\t\t\tconsole.error( \"THREE.Matrix3.getInverse no longer takes a Matrix4 argument.\" );\n\n\t\t}\n\n\t\tvar me = matrix.elements,\n\t\t\tte = this.elements,\n\n\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],\n\t\t\tn12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],\n\t\t\tn13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],\n\n\t\t\tt11 = n33 * n22 - n32 * n23,\n\t\t\tt12 = n32 * n13 - n33 * n12,\n\t\t\tt13 = n23 * n12 - n22 * n13,\n\n\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\n\n\t\tif ( det === 0 ) {\n\n\t\t\tvar msg = \"THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0\";\n\n\t\t\tif ( throwOnDegenerate || false ) {\n\n\t\t\t\tthrow new Error( msg );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( msg );\n\n\t\t\t}\n\n\t\t\treturn this.identity();\n\t\t}\n\t\t\n\t\tvar detInv = 1 / det;\n\n\t\tte[ 0 ] = t11 * detInv;\n\t\tte[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;\n\t\tte[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;\n\n\t\tte[ 3 ] = t12 * detInv;\n\t\tte[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;\n\t\tte[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;\n\n\t\tte[ 6 ] = t13 * detInv;\n\t\tte[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;\n\t\tte[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;\n\n\t\treturn this;\n\n\t},\n\n\ttranspose: function () {\n\n\t\tvar tmp, m = this.elements;\n\n\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\n\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\n\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\n\n\t\treturn this;\n\n\t},\n\n\tflattenToArrayOffset: function ( array, offset ) {\n\n\t\tconsole.warn( \"THREE.Matrix3: .flattenToArrayOffset is deprecated \" +\n\t\t\t\t\"- just use .toArray instead.\" );\n\n\t\treturn this.toArray( array, offset );\n\n\t},\n\n\tgetNormalMatrix: function ( matrix4 ) {\n\n\t\treturn this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();\n\n\t},\n\n\ttransposeIntoArray: function ( r ) {\n\n\t\tvar m = this.elements;\n\n\t\tr[ 0 ] = m[ 0 ];\n\t\tr[ 1 ] = m[ 3 ];\n\t\tr[ 2 ] = m[ 6 ];\n\t\tr[ 3 ] = m[ 1 ];\n\t\tr[ 4 ] = m[ 4 ];\n\t\tr[ 5 ] = m[ 7 ];\n\t\tr[ 6 ] = m[ 2 ];\n\t\tr[ 7 ] = m[ 5 ];\n\t\tr[ 8 ] = m[ 8 ];\n\n\t\treturn this;\n\n\t},\n\n\tfromArray: function ( array ) {\n\n\t\tthis.elements.set( array );\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tvar te = this.elements;\n\n\t\tarray[ offset ] = te[ 0 ];\n\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\tarray[ offset + 2 ] = te[ 2 ];\n\n\t\tarray[ offset + 3 ] = te[ 3 ];\n\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\tarray[ offset + 5 ] = te[ 5 ];\n\n\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\tarray[ offset + 7 ] = te[ 7 ];\n\t\tarray[ offset + 8 ]  = te[ 8 ];\n\n\t\treturn array;\n\n\t}\n\n};\n\n// File:src/math/Matrix4.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author philogb / http://blog.thejit.org/\n * @author jordi_ros / http://plattsoft.com\n * @author D1plo1d / http://github.com/D1plo1d\n * @author alteredq / http://alteredqualia.com/\n * @author mikael emtinger / http://gomo.se/\n * @author timknip / http://www.floorplanner.com/\n * @author bhouston / http://clara.io\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.Matrix4 = function () {\n\n\tthis.elements = new Float32Array( [\n\n\t\t1, 0, 0, 0,\n\t\t0, 1, 0, 0,\n\t\t0, 0, 1, 0,\n\t\t0, 0, 0, 1\n\n\t] );\n\n\tif ( arguments.length > 0 ) {\n\n\t\tconsole.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );\n\n\t}\n\n};\n\nTHREE.Matrix4.prototype = {\n\n\tconstructor: THREE.Matrix4,\n\n\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\n\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\n\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\n\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\n\n\t\treturn this;\n\n\t},\n\n\tidentity: function () {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, 1, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Matrix4().fromArray( this.elements );\n\n\t},\n\n\tcopy: function ( m ) {\n\n\t\tthis.elements.set( m.elements );\n\n\t\treturn this;\n\n\t},\n\n\tcopyPosition: function ( m ) {\n\n\t\tvar te = this.elements;\n\t\tvar me = m.elements;\n\n\t\tte[ 12 ] = me[ 12 ];\n\t\tte[ 13 ] = me[ 13 ];\n\t\tte[ 14 ] = me[ 14 ];\n\n\t\treturn this;\n\n\t},\n\n\textractBasis: function ( xAxis, yAxis, zAxis ) {\n\n\t\txAxis.setFromMatrixColumn( this, 0 );\n\t\tyAxis.setFromMatrixColumn( this, 1 );\n\t\tzAxis.setFromMatrixColumn( this, 2 );\n\n\t\treturn this;\n\n\t},\n\n\tmakeBasis: function ( xAxis, yAxis, zAxis ) {\n\n\t\tthis.set(\n\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\n\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\n\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\n\t\t\t0,       0,       0,       1\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\textractRotation: function () {\n\n\t\tvar v1;\n\n\t\treturn function extractRotation( m ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\n\t\t\tvar te = this.elements;\n\t\t\tvar me = m.elements;\n\n\t\t\tvar scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();\n\t\t\tvar scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();\n\t\t\tvar scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();\n\n\t\t\tte[ 0 ] = me[ 0 ] * scaleX;\n\t\t\tte[ 1 ] = me[ 1 ] * scaleX;\n\t\t\tte[ 2 ] = me[ 2 ] * scaleX;\n\n\t\t\tte[ 4 ] = me[ 4 ] * scaleY;\n\t\t\tte[ 5 ] = me[ 5 ] * scaleY;\n\t\t\tte[ 6 ] = me[ 6 ] * scaleY;\n\n\t\t\tte[ 8 ] = me[ 8 ] * scaleZ;\n\t\t\tte[ 9 ] = me[ 9 ] * scaleZ;\n\t\t\tte[ 10 ] = me[ 10 ] * scaleZ;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tmakeRotationFromEuler: function ( euler ) {\n\n\t\tif ( euler instanceof THREE.Euler === false ) {\n\n\t\t\tconsole.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\n\n\t\t}\n\n\t\tvar te = this.elements;\n\n\t\tvar x = euler.x, y = euler.y, z = euler.z;\n\t\tvar a = Math.cos( x ), b = Math.sin( x );\n\t\tvar c = Math.cos( y ), d = Math.sin( y );\n\t\tvar e = Math.cos( z ), f = Math.sin( z );\n\n\t\tif ( euler.order === 'XYZ' ) {\n\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = - c * f;\n\t\t\tte[ 8 ] = d;\n\n\t\t\tte[ 1 ] = af + be * d;\n\t\t\tte[ 5 ] = ae - bf * d;\n\t\t\tte[ 9 ] = - b * c;\n\n\t\t\tte[ 2 ] = bf - ae * d;\n\t\t\tte[ 6 ] = be + af * d;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'YXZ' ) {\n\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\tte[ 0 ] = ce + df * b;\n\t\t\tte[ 4 ] = de * b - cf;\n\t\t\tte[ 8 ] = a * d;\n\n\t\t\tte[ 1 ] = a * f;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = - b;\n\n\t\t\tte[ 2 ] = cf * b - de;\n\t\t\tte[ 6 ] = df + ce * b;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'ZXY' ) {\n\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\tte[ 0 ] = ce - df * b;\n\t\t\tte[ 4 ] = - a * f;\n\t\t\tte[ 8 ] = de + cf * b;\n\n\t\t\tte[ 1 ] = cf + de * b;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = df - ce * b;\n\n\t\t\tte[ 2 ] = - a * d;\n\t\t\tte[ 6 ] = b;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'ZYX' ) {\n\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = be * d - af;\n\t\t\tte[ 8 ] = ae * d + bf;\n\n\t\t\tte[ 1 ] = c * f;\n\t\t\tte[ 5 ] = bf * d + ae;\n\t\t\tte[ 9 ] = af * d - be;\n\n\t\t\tte[ 2 ] = - d;\n\t\t\tte[ 6 ] = b * c;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'YZX' ) {\n\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = bd - ac * f;\n\t\t\tte[ 8 ] = bc * f + ad;\n\n\t\t\tte[ 1 ] = f;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = - b * e;\n\n\t\t\tte[ 2 ] = - d * e;\n\t\t\tte[ 6 ] = ad * f + bc;\n\t\t\tte[ 10 ] = ac - bd * f;\n\n\t\t} else if ( euler.order === 'XZY' ) {\n\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = - f;\n\t\t\tte[ 8 ] = d * e;\n\n\t\t\tte[ 1 ] = ac * f + bd;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = ad * f - bc;\n\n\t\t\tte[ 2 ] = bc * f - ad;\n\t\t\tte[ 6 ] = b * e;\n\t\t\tte[ 10 ] = bd * f + ac;\n\n\t\t}\n\n\t\t// last column\n\t\tte[ 3 ] = 0;\n\t\tte[ 7 ] = 0;\n\t\tte[ 11 ] = 0;\n\n\t\t// bottom row\n\t\tte[ 12 ] = 0;\n\t\tte[ 13 ] = 0;\n\t\tte[ 14 ] = 0;\n\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationFromQuaternion: function ( q ) {\n\n\t\tvar te = this.elements;\n\n\t\tvar x = q.x, y = q.y, z = q.z, w = q.w;\n\t\tvar x2 = x + x, y2 = y + y, z2 = z + z;\n\t\tvar xx = x * x2, xy = x * y2, xz = x * z2;\n\t\tvar yy = y * y2, yz = y * z2, zz = z * z2;\n\t\tvar wx = w * x2, wy = w * y2, wz = w * z2;\n\n\t\tte[ 0 ] = 1 - ( yy + zz );\n\t\tte[ 4 ] = xy - wz;\n\t\tte[ 8 ] = xz + wy;\n\n\t\tte[ 1 ] = xy + wz;\n\t\tte[ 5 ] = 1 - ( xx + zz );\n\t\tte[ 9 ] = yz - wx;\n\n\t\tte[ 2 ] = xz - wy;\n\t\tte[ 6 ] = yz + wx;\n\t\tte[ 10 ] = 1 - ( xx + yy );\n\n\t\t// last column\n\t\tte[ 3 ] = 0;\n\t\tte[ 7 ] = 0;\n\t\tte[ 11 ] = 0;\n\n\t\t// bottom row\n\t\tte[ 12 ] = 0;\n\t\tte[ 13 ] = 0;\n\t\tte[ 14 ] = 0;\n\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t},\n\n\tlookAt: function () {\n\n\t\tvar x, y, z;\n\n\t\treturn function lookAt( eye, target, up ) {\n\n\t\t\tif ( x === undefined ) {\n\n\t\t\t\tx = new THREE.Vector3();\n\t\t\t\ty = new THREE.Vector3();\n\t\t\t\tz = new THREE.Vector3();\n\n\t\t\t}\n\n\t\t\tvar te = this.elements;\n\n\t\t\tz.subVectors( eye, target ).normalize();\n\n\t\t\tif ( z.lengthSq() === 0 ) {\n\n\t\t\t\tz.z = 1;\n\n\t\t\t}\n\n\t\t\tx.crossVectors( up, z ).normalize();\n\n\t\t\tif ( x.lengthSq() === 0 ) {\n\n\t\t\t\tz.z += 0.0001;\n\t\t\t\tx.crossVectors( up, z ).normalize();\n\n\t\t\t}\n\n\t\t\ty.crossVectors( z, x );\n\n\n\t\t\tte[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;\n\t\t\tte[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;\n\t\t\tte[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tmultiply: function ( m, n ) {\n\n\t\tif ( n !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\n\t\t\treturn this.multiplyMatrices( m, n );\n\n\t\t}\n\n\t\treturn this.multiplyMatrices( this, m );\n\n\t},\n\n\tpremultiply: function ( m ) {\n\n\t\treturn this.multiplyMatrices( m, this );\n\n\t},\n\n\tmultiplyMatrices: function ( a, b ) {\n\n\t\tvar ae = a.elements;\n\t\tvar be = b.elements;\n\t\tvar te = this.elements;\n\n\t\tvar a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\n\t\tvar a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\n\t\tvar a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\n\t\tvar a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\n\n\t\tvar b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\n\t\tvar b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\n\t\tvar b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\n\t\tvar b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\n\n\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\n\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\n\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\n\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyToArray: function ( a, b, r ) {\n\n\t\tvar te = this.elements;\n\n\t\tthis.multiplyMatrices( a, b );\n\n\t\tr[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];\n\t\tr[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];\n\t\tr[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];\n\t\tr[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( s ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\n\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\n\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\n\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\n\n\t\treturn this;\n\n\t},\n\n\tapplyToVector3Array: function () {\n\n\t\tvar v1;\n\n\t\treturn function applyToVector3Array( array, offset, length ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\tif ( length === undefined ) length = array.length;\n\n\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\n\n\t\t\t\tv1.fromArray( array, j );\n\t\t\t\tv1.applyMatrix4( this );\n\t\t\t\tv1.toArray( array, j );\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t};\n\n\t}(),\n\n\tapplyToBuffer: function () {\n\n\t\tvar v1;\n\n\t\treturn function applyToBuffer( buffer, offset, length ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\tif ( length === undefined ) length = buffer.length / buffer.itemSize;\n\n\t\t\tfor ( var i = 0, j = offset; i < length; i ++, j ++ ) {\n\n\t\t\t\tv1.x = buffer.getX( j );\n\t\t\t\tv1.y = buffer.getY( j );\n\t\t\t\tv1.z = buffer.getZ( j );\n\n\t\t\t\tv1.applyMatrix4( this );\n\n\t\t\t\tbuffer.setXYZ( v1.x, v1.y, v1.z );\n\n\t\t\t}\n\n\t\t\treturn buffer;\n\n\t\t};\n\n\t}(),\n\n\tdeterminant: function () {\n\n\t\tvar te = this.elements;\n\n\t\tvar n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\n\t\tvar n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\n\t\tvar n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\n\t\tvar n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\n\n\t\t//TODO: make this more efficient\n\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\n\t\treturn (\n\t\t\tn41 * (\n\t\t\t\t+ n14 * n23 * n32\n\t\t\t\t - n13 * n24 * n32\n\t\t\t\t - n14 * n22 * n33\n\t\t\t\t + n12 * n24 * n33\n\t\t\t\t + n13 * n22 * n34\n\t\t\t\t - n12 * n23 * n34\n\t\t\t) +\n\t\t\tn42 * (\n\t\t\t\t+ n11 * n23 * n34\n\t\t\t\t - n11 * n24 * n33\n\t\t\t\t + n14 * n21 * n33\n\t\t\t\t - n13 * n21 * n34\n\t\t\t\t + n13 * n24 * n31\n\t\t\t\t - n14 * n23 * n31\n\t\t\t) +\n\t\t\tn43 * (\n\t\t\t\t+ n11 * n24 * n32\n\t\t\t\t - n11 * n22 * n34\n\t\t\t\t - n14 * n21 * n32\n\t\t\t\t + n12 * n21 * n34\n\t\t\t\t + n14 * n22 * n31\n\t\t\t\t - n12 * n24 * n31\n\t\t\t) +\n\t\t\tn44 * (\n\t\t\t\t- n13 * n22 * n31\n\t\t\t\t - n11 * n23 * n32\n\t\t\t\t + n11 * n22 * n33\n\t\t\t\t + n13 * n21 * n32\n\t\t\t\t - n12 * n21 * n33\n\t\t\t\t + n12 * n23 * n31\n\t\t\t)\n\n\t\t);\n\n\t},\n\n\ttranspose: function () {\n\n\t\tvar te = this.elements;\n\t\tvar tmp;\n\n\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\n\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\n\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\n\n\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\n\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\n\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\n\n\t\treturn this;\n\n\t},\n\n\tflattenToArrayOffset: function ( array, offset ) {\n\n\t\tconsole.warn( \"THREE.Matrix3: .flattenToArrayOffset is deprecated \" +\n\t\t\t\t\"- just use .toArray instead.\" );\n\n\t\treturn this.toArray( array, offset );\n\n\t},\n\n\tgetPosition: function () {\n\n\t\tvar v1;\n\n\t\treturn function getPosition() {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\t\tconsole.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );\n\n\t\t\treturn v1.setFromMatrixColumn( this, 3 );\n\n\t\t};\n\n\t}(),\n\n\tsetPosition: function ( v ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[ 12 ] = v.x;\n\t\tte[ 13 ] = v.y;\n\t\tte[ 14 ] = v.z;\n\n\t\treturn this;\n\n\t},\n\n\tgetInverse: function ( m, throwOnDegenerate ) {\n\n\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n\t\tvar te = this.elements,\n\t\t\tme = m.elements,\n\n\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],\n\t\t\tn12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],\n\t\t\tn13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],\n\t\t\tn14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],\n\n\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\n\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\n\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\n\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n\n\t\tvar det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n\n\t\tif ( det === 0 ) {\n\n\t\t\tvar msg = \"THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0\";\n\n\t\t\tif ( throwOnDegenerate || false ) {\n\n\t\t\t\tthrow new Error( msg );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( msg );\n\n\t\t\t}\n\n\t\t\treturn this.identity();\n\n\t\t}\n\t\t\n\t\tvar detInv = 1 / det;\n\n\t\tte[ 0 ] = t11 * detInv;\n\t\tte[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;\n\t\tte[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;\n\t\tte[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;\n\n\t\tte[ 4 ] = t12 * detInv;\n\t\tte[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;\n\t\tte[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;\n\t\tte[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;\n\n\t\tte[ 8 ] = t13 * detInv;\n\t\tte[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;\n\t\tte[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;\n\t\tte[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;\n\n\t\tte[ 12 ] = t14 * detInv;\n\t\tte[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;\n\t\tte[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;\n\t\tte[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;\n\n\t\treturn this;\n\n\t},\n\n\tscale: function ( v ) {\n\n\t\tvar te = this.elements;\n\t\tvar x = v.x, y = v.y, z = v.z;\n\n\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\n\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\n\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\n\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\n\n\t\treturn this;\n\n\t},\n\n\tgetMaxScaleOnAxis: function () {\n\n\t\tvar te = this.elements;\n\n\t\tvar scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\n\t\tvar scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\n\t\tvar scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\n\n\t\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\n\n\t},\n\n\tmakeTranslation: function ( x, y, z ) {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, x,\n\t\t\t0, 1, 0, y,\n\t\t\t0, 0, 1, z,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationX: function ( theta ) {\n\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\t1, 0,  0, 0,\n\t\t\t0, c, - s, 0,\n\t\t\t0, s,  c, 0,\n\t\t\t0, 0,  0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationY: function ( theta ) {\n\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\t c, 0, s, 0,\n\t\t\t 0, 1, 0, 0,\n\t\t\t- s, 0, c, 0,\n\t\t\t 0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationZ: function ( theta ) {\n\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\tc, - s, 0, 0,\n\t\t\ts,  c, 0, 0,\n\t\t\t0,  0, 1, 0,\n\t\t\t0,  0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationAxis: function ( axis, angle ) {\n\n\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\n\n\t\tvar c = Math.cos( angle );\n\t\tvar s = Math.sin( angle );\n\t\tvar t = 1 - c;\n\t\tvar x = axis.x, y = axis.y, z = axis.z;\n\t\tvar tx = t * x, ty = t * y;\n\n\t\tthis.set(\n\n\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\n\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\n\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\t return this;\n\n\t},\n\n\tmakeScale: function ( x, y, z ) {\n\n\t\tthis.set(\n\n\t\t\tx, 0, 0, 0,\n\t\t\t0, y, 0, 0,\n\t\t\t0, 0, z, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tcompose: function ( position, quaternion, scale ) {\n\n\t\tthis.makeRotationFromQuaternion( quaternion );\n\t\tthis.scale( scale );\n\t\tthis.setPosition( position );\n\n\t\treturn this;\n\n\t},\n\n\tdecompose: function () {\n\n\t\tvar vector, matrix;\n\n\t\treturn function decompose( position, quaternion, scale ) {\n\n\t\t\tif ( vector === undefined ) {\n\n\t\t\t\tvector = new THREE.Vector3();\n\t\t\t\tmatrix = new THREE.Matrix4();\n\n\t\t\t}\n\n\t\t\tvar te = this.elements;\n\n\t\t\tvar sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\n\t\t\tvar sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\n\t\t\tvar sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\n\n\t\t\t// if determine is negative, we need to invert one scale\n\t\t\tvar det = this.determinant();\n\t\t\tif ( det < 0 ) {\n\n\t\t\t\tsx = - sx;\n\n\t\t\t}\n\n\t\t\tposition.x = te[ 12 ];\n\t\t\tposition.y = te[ 13 ];\n\t\t\tposition.z = te[ 14 ];\n\n\t\t\t// scale the rotation part\n\n\t\t\tmatrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()\n\n\t\t\tvar invSX = 1 / sx;\n\t\t\tvar invSY = 1 / sy;\n\t\t\tvar invSZ = 1 / sz;\n\n\t\t\tmatrix.elements[ 0 ] *= invSX;\n\t\t\tmatrix.elements[ 1 ] *= invSX;\n\t\t\tmatrix.elements[ 2 ] *= invSX;\n\n\t\t\tmatrix.elements[ 4 ] *= invSY;\n\t\t\tmatrix.elements[ 5 ] *= invSY;\n\t\t\tmatrix.elements[ 6 ] *= invSY;\n\n\t\t\tmatrix.elements[ 8 ] *= invSZ;\n\t\t\tmatrix.elements[ 9 ] *= invSZ;\n\t\t\tmatrix.elements[ 10 ] *= invSZ;\n\n\t\t\tquaternion.setFromRotationMatrix( matrix );\n\n\t\t\tscale.x = sx;\n\t\t\tscale.y = sy;\n\t\t\tscale.z = sz;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tmakeFrustum: function ( left, right, bottom, top, near, far ) {\n\n\t\tvar te = this.elements;\n\t\tvar x = 2 * near / ( right - left );\n\t\tvar y = 2 * near / ( top - bottom );\n\n\t\tvar a = ( right + left ) / ( right - left );\n\t\tvar b = ( top + bottom ) / ( top - bottom );\n\t\tvar c = - ( far + near ) / ( far - near );\n\t\tvar d = - 2 * far * near / ( far - near );\n\n\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a;\tte[ 12 ] = 0;\n\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b;\tte[ 13 ] = 0;\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c;\tte[ 14 ] = d;\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = - 1;\tte[ 15 ] = 0;\n\n\t\treturn this;\n\n\t},\n\n\tmakePerspective: function ( fov, aspect, near, far ) {\n\n\t\tvar ymax = near * Math.tan( THREE.Math.DEG2RAD * fov * 0.5 );\n\t\tvar ymin = - ymax;\n\t\tvar xmin = ymin * aspect;\n\t\tvar xmax = ymax * aspect;\n\n\t\treturn this.makeFrustum( xmin, xmax, ymin, ymax, near, far );\n\n\t},\n\n\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\n\n\t\tvar te = this.elements;\n\t\tvar w = 1.0 / ( right - left );\n\t\tvar h = 1.0 / ( top - bottom );\n\t\tvar p = 1.0 / ( far - near );\n\n\t\tvar x = ( right + left ) * w;\n\t\tvar y = ( top + bottom ) * h;\n\t\tvar z = ( far + near ) * p;\n\n\t\tte[ 0 ] = 2 * w;\tte[ 4 ] = 0;\tte[ 8 ] = 0;\tte[ 12 ] = - x;\n\t\tte[ 1 ] = 0;\tte[ 5 ] = 2 * h;\tte[ 9 ] = 0;\tte[ 13 ] = - y;\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = - 2 * p;\tte[ 14 ] = - z;\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = 0;\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( matrix ) {\n\n\t\tvar te = this.elements;\n\t\tvar me = matrix.elements;\n\n\t\tfor ( var i = 0; i < 16; i ++ ) {\n\n\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tfromArray: function ( array ) {\n\n\t\tthis.elements.set( array );\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tvar te = this.elements;\n\n\t\tarray[ offset ] = te[ 0 ];\n\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\tarray[ offset + 2 ] = te[ 2 ];\n\t\tarray[ offset + 3 ] = te[ 3 ];\n\n\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\tarray[ offset + 5 ] = te[ 5 ];\n\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\tarray[ offset + 7 ] = te[ 7 ];\n\n\t\tarray[ offset + 8 ]  = te[ 8 ];\n\t\tarray[ offset + 9 ]  = te[ 9 ];\n\t\tarray[ offset + 10 ] = te[ 10 ];\n\t\tarray[ offset + 11 ] = te[ 11 ];\n\n\t\tarray[ offset + 12 ] = te[ 12 ];\n\t\tarray[ offset + 13 ] = te[ 13 ];\n\t\tarray[ offset + 14 ] = te[ 14 ];\n\t\tarray[ offset + 15 ] = te[ 15 ];\n\n\t\treturn array;\n\n\t}\n\n};\n\n// File:src/math/Ray.js\n\n/**\n * @author bhouston / http://clara.io\n */\n\nTHREE.Ray = function ( origin, direction ) {\n\n\tthis.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();\n\tthis.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();\n\n};\n\nTHREE.Ray.prototype = {\n\n\tconstructor: THREE.Ray,\n\n\tset: function ( origin, direction ) {\n\n\t\tthis.origin.copy( origin );\n\t\tthis.direction.copy( direction );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( ray ) {\n\n\t\tthis.origin.copy( ray.origin );\n\t\tthis.direction.copy( ray.direction );\n\n\t\treturn this;\n\n\t},\n\n\tat: function ( t, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\treturn result.copy( this.direction ).multiplyScalar( t ).add( this.origin );\n\n\t},\n\n\tlookAt: function ( v ) {\n\n\t\tthis.direction.copy( v ).sub( this.origin ).normalize();\n\n\t\treturn this;\n\n\t},\n\n\trecast: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function recast( t ) {\n\n\t\t\tthis.origin.copy( this.at( t, v1 ) );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tclosestPointToPoint: function ( point, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\tresult.subVectors( point, this.origin );\n\t\tvar directionDistance = result.dot( this.direction );\n\n\t\tif ( directionDistance < 0 ) {\n\n\t\t\treturn result.copy( this.origin );\n\n\t\t}\n\n\t\treturn result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t},\n\n\tdistanceToPoint: function ( point ) {\n\n\t\treturn Math.sqrt( this.distanceSqToPoint( point ) );\n\n\t},\n\n\tdistanceSqToPoint: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function distanceSqToPoint( point ) {\n\n\t\t\tvar directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\n\n\t\t\t// point behind the ray\n\n\t\t\tif ( directionDistance < 0 ) {\n\n\t\t\t\treturn this.origin.distanceToSquared( point );\n\n\t\t\t}\n\n\t\t\tv1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t\t\treturn v1.distanceToSquared( point );\n\n\t\t};\n\n\t}(),\n\n\tdistanceSqToSegment: function () {\n\n\t\tvar segCenter = new THREE.Vector3();\n\t\tvar segDir = new THREE.Vector3();\n\t\tvar diff = new THREE.Vector3();\n\n\t\treturn function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\n\n\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\n\t\t\t// It returns the min distance between the ray and the segment\n\t\t\t// defined by v0 and v1\n\t\t\t// It can also set two optional targets :\n\t\t\t// - The closest point on the ray\n\t\t\t// - The closest point on the segment\n\n\t\t\tsegCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\n\t\t\tsegDir.copy( v1 ).sub( v0 ).normalize();\n\t\t\tdiff.copy( this.origin ).sub( segCenter );\n\n\t\t\tvar segExtent = v0.distanceTo( v1 ) * 0.5;\n\t\t\tvar a01 = - this.direction.dot( segDir );\n\t\t\tvar b0 = diff.dot( this.direction );\n\t\t\tvar b1 = - diff.dot( segDir );\n\t\t\tvar c = diff.lengthSq();\n\t\t\tvar det = Math.abs( 1 - a01 * a01 );\n\t\t\tvar s0, s1, sqrDist, extDet;\n\n\t\t\tif ( det > 0 ) {\n\n\t\t\t\t// The ray and segment are not parallel.\n\n\t\t\t\ts0 = a01 * b1 - b0;\n\t\t\t\ts1 = a01 * b0 - b1;\n\t\t\t\textDet = segExtent * det;\n\n\t\t\t\tif ( s0 >= 0 ) {\n\n\t\t\t\t\tif ( s1 >= - extDet ) {\n\n\t\t\t\t\t\tif ( s1 <= extDet ) {\n\n\t\t\t\t\t\t\t// region 0\n\t\t\t\t\t\t\t// Minimum at interior points of ray and segment.\n\n\t\t\t\t\t\t\tvar invDet = 1 / det;\n\t\t\t\t\t\t\ts0 *= invDet;\n\t\t\t\t\t\t\ts1 *= invDet;\n\t\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// region 1\n\n\t\t\t\t\t\t\ts1 = segExtent;\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// region 5\n\n\t\t\t\t\t\ts1 = - segExtent;\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( s1 <= - extDet ) {\n\n\t\t\t\t\t\t// region 4\n\n\t\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\n\t\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t} else if ( s1 <= extDet ) {\n\n\t\t\t\t\t\t// region 3\n\n\t\t\t\t\t\ts0 = 0;\n\t\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// region 2\n\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\n\t\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// Ray and segment are parallel.\n\n\t\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\n\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t}\n\n\t\t\tif ( optionalPointOnRay ) {\n\n\t\t\t\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\n\n\t\t\t}\n\n\t\t\tif ( optionalPointOnSegment ) {\n\n\t\t\t\toptionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );\n\n\t\t\t}\n\n\t\t\treturn sqrDist;\n\n\t\t};\n\n\t}(),\n\n\tintersectSphere: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function intersectSphere( sphere, optionalTarget ) {\n\n\t\t\tv1.subVectors( sphere.center, this.origin );\n\t\t\tvar tca = v1.dot( this.direction );\n\t\t\tvar d2 = v1.dot( v1 ) - tca * tca;\n\t\t\tvar radius2 = sphere.radius * sphere.radius;\n\n\t\t\tif ( d2 > radius2 ) return null;\n\n\t\t\tvar thc = Math.sqrt( radius2 - d2 );\n\n\t\t\t// t0 = first intersect point - entrance on front of sphere\n\t\t\tvar t0 = tca - thc;\n\n\t\t\t// t1 = second intersect point - exit point on back of sphere\n\t\t\tvar t1 = tca + thc;\n\n\t\t\t// test to see if both t0 and t1 are behind the ray - if so, return null\n\t\t\tif ( t0 < 0 && t1 < 0 ) return null;\n\n\t\t\t// test to see if t0 is behind the ray:\n\t\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n\t\t\t// in order to always return an intersect point that is in front of the ray.\n\t\t\tif ( t0 < 0 ) return this.at( t1, optionalTarget );\n\n\t\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\n\t\t\treturn this.at( t0, optionalTarget );\n\n\t\t};\n\n\t}(),\n\n\tintersectsSphere: function ( sphere ) {\n\n\t\treturn this.distanceToPoint( sphere.center ) <= sphere.radius;\n\n\t},\n\n\tdistanceToPlane: function ( plane ) {\n\n\t\tvar denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator === 0 ) {\n\n\t\t\t// line is coplanar, return origin\n\t\t\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tvar t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\n\n\t\t// Return if the ray never intersects the plane\n\n\t\treturn t >= 0 ? t :  null;\n\n\t},\n\n\tintersectPlane: function ( plane, optionalTarget ) {\n\n\t\tvar t = this.distanceToPlane( plane );\n\n\t\tif ( t === null ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\treturn this.at( t, optionalTarget );\n\n\t},\n\n\n\n\tintersectsPlane: function ( plane ) {\n\n\t\t// check if the ray lies on the plane first\n\n\t\tvar distToPoint = plane.distanceToPoint( this.origin );\n\n\t\tif ( distToPoint === 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tvar denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator * distToPoint < 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\t// ray origin is behind the plane (and is pointing behind it)\n\n\t\treturn false;\n\n\t},\n\n\tintersectBox: function ( box, optionalTarget ) {\n\n\t\tvar tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n\t\tvar invdirx = 1 / this.direction.x,\n\t\t\tinvdiry = 1 / this.direction.y,\n\t\t\tinvdirz = 1 / this.direction.z;\n\n\t\tvar origin = this.origin;\n\n\t\tif ( invdirx >= 0 ) {\n\n\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\n\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\n\n\t\t} else {\n\n\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\n\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\n\n\t\t}\n\n\t\tif ( invdiry >= 0 ) {\n\n\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\n\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\n\n\t\t} else {\n\n\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\n\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\n\n\t\t}\n\n\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\n\n\t\t// These lines also handle the case where tmin or tmax is NaN\n\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\n\n\t\tif ( tymin > tmin || tmin !== tmin ) tmin = tymin;\n\n\t\tif ( tymax < tmax || tmax !== tmax ) tmax = tymax;\n\n\t\tif ( invdirz >= 0 ) {\n\n\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\n\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\n\n\t\t} else {\n\n\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\n\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\n\n\t\t}\n\n\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\n\n\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\n\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\n\t\t//return point closest to the ray (positive side)\n\n\t\tif ( tmax < 0 ) return null;\n\n\t\treturn this.at( tmin >= 0 ? tmin : tmax, optionalTarget );\n\n\t},\n\n\tintersectsBox: ( function () {\n\n\t\tvar v = new THREE.Vector3();\n\n\t\treturn function intersectsBox( box ) {\n\n\t\t\treturn this.intersectBox( box, v ) !== null;\n\n\t\t};\n\n\t} )(),\n\n\tintersectTriangle: function () {\n\n\t\t// Compute the offset origin, edges, and normal.\n\t\tvar diff = new THREE.Vector3();\n\t\tvar edge1 = new THREE.Vector3();\n\t\tvar edge2 = new THREE.Vector3();\n\t\tvar normal = new THREE.Vector3();\n\n\t\treturn function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {\n\n\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n\n\t\t\tedge1.subVectors( b, a );\n\t\t\tedge2.subVectors( c, a );\n\t\t\tnormal.crossVectors( edge1, edge2 );\n\n\t\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n\t\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n\t\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n\t\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n\t\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\t\t\tvar DdN = this.direction.dot( normal );\n\t\t\tvar sign;\n\n\t\t\tif ( DdN > 0 ) {\n\n\t\t\t\tif ( backfaceCulling ) return null;\n\t\t\t\tsign = 1;\n\n\t\t\t} else if ( DdN < 0 ) {\n\n\t\t\t\tsign = - 1;\n\t\t\t\tDdN = - DdN;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tdiff.subVectors( this.origin, a );\n\t\t\tvar DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );\n\n\t\t\t// b1 < 0, no intersection\n\t\t\tif ( DdQxE2 < 0 ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tvar DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );\n\n\t\t\t// b2 < 0, no intersection\n\t\t\tif ( DdE1xQ < 0 ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// b1+b2 > 1, no intersection\n\t\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// Line intersects triangle, check if ray does.\n\t\t\tvar QdN = - sign * diff.dot( normal );\n\n\t\t\t// t < 0, no intersection\n\t\t\tif ( QdN < 0 ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// Ray intersects triangle.\n\t\t\treturn this.at( QdN / DdN, optionalTarget );\n\n\t\t};\n\n\t}(),\n\n\tapplyMatrix4: function ( matrix4 ) {\n\n\t\tthis.direction.add( this.origin ).applyMatrix4( matrix4 );\n\t\tthis.origin.applyMatrix4( matrix4 );\n\t\tthis.direction.sub( this.origin );\n\t\tthis.direction.normalize();\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( ray ) {\n\n\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\n\n\t}\n\n};\n\n// File:src/math/Sphere.js\n\n/**\n * @author bhouston / http://clara.io\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Sphere = function ( center, radius ) {\n\n\tthis.center = ( center !== undefined ) ? center : new THREE.Vector3();\n\tthis.radius = ( radius !== undefined ) ? radius : 0;\n\n};\n\nTHREE.Sphere.prototype = {\n\n\tconstructor: THREE.Sphere,\n\n\tset: function ( center, radius ) {\n\n\t\tthis.center.copy( center );\n\t\tthis.radius = radius;\n\n\t\treturn this;\n\n\t},\n\n\tsetFromPoints: function () {\n\n\t\tvar box = new THREE.Box3();\n\n\t\treturn function setFromPoints( points, optionalCenter ) {\n\n\t\t\tvar center = this.center;\n\n\t\t\tif ( optionalCenter !== undefined ) {\n\n\t\t\t\tcenter.copy( optionalCenter );\n\n\t\t\t} else {\n\n\t\t\t\tbox.setFromPoints( points ).center( center );\n\n\t\t\t}\n\n\t\t\tvar maxRadiusSq = 0;\n\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\n\n\t\t\t}\n\n\t\t\tthis.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( sphere ) {\n\n\t\tthis.center.copy( sphere.center );\n\t\tthis.radius = sphere.radius;\n\n\t\treturn this;\n\n\t},\n\n\tempty: function () {\n\n\t\treturn ( this.radius <= 0 );\n\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\n\n\t},\n\n\tdistanceToPoint: function ( point ) {\n\n\t\treturn ( point.distanceTo( this.center ) - this.radius );\n\n\t},\n\n\tintersectsSphere: function ( sphere ) {\n\n\t\tvar radiusSum = this.radius + sphere.radius;\n\n\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\n\n\t},\n\n\tintersectsBox: function ( box ) {\n\n\t\treturn box.intersectsSphere( this );\n\n\t},\n\n\tintersectsPlane: function ( plane ) {\n\n\t\t// We use the following equation to compute the signed distance from\n\t\t// the center of the sphere to the plane.\n\t\t//\n\t\t// distance = q * n - d\n\t\t//\n\t\t// If this distance is greater than the radius of the sphere,\n\t\t// then there is no intersection.\n\n\t\treturn Math.abs( this.center.dot( plane.normal ) - plane.constant ) <= this.radius;\n\n\t},\n\n\tclampPoint: function ( point, optionalTarget ) {\n\n\t\tvar deltaLengthSq = this.center.distanceToSquared( point );\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\tresult.copy( point );\n\n\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\n\n\t\t\tresult.sub( this.center ).normalize();\n\t\t\tresult.multiplyScalar( this.radius ).add( this.center );\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\tgetBoundingBox: function ( optionalTarget ) {\n\n\t\tvar box = optionalTarget || new THREE.Box3();\n\n\t\tbox.set( this.center, this.center );\n\t\tbox.expandByScalar( this.radius );\n\n\t\treturn box;\n\n\t},\n\n\tapplyMatrix4: function ( matrix ) {\n\n\t\tthis.center.applyMatrix4( matrix );\n\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\n\n\t\treturn this;\n\n\t},\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.center.add( offset );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( sphere ) {\n\n\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\n\n\t}\n\n};\n\n// File:src/math/Frustum.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author bhouston / http://clara.io\n */\n\nTHREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {\n\n\tthis.planes = [\n\n\t\t( p0 !== undefined ) ? p0 : new THREE.Plane(),\n\t\t( p1 !== undefined ) ? p1 : new THREE.Plane(),\n\t\t( p2 !== undefined ) ? p2 : new THREE.Plane(),\n\t\t( p3 !== undefined ) ? p3 : new THREE.Plane(),\n\t\t( p4 !== undefined ) ? p4 : new THREE.Plane(),\n\t\t( p5 !== undefined ) ? p5 : new THREE.Plane()\n\n\t];\n\n};\n\nTHREE.Frustum.prototype = {\n\n\tconstructor: THREE.Frustum,\n\n\tset: function ( p0, p1, p2, p3, p4, p5 ) {\n\n\t\tvar planes = this.planes;\n\n\t\tplanes[ 0 ].copy( p0 );\n\t\tplanes[ 1 ].copy( p1 );\n\t\tplanes[ 2 ].copy( p2 );\n\t\tplanes[ 3 ].copy( p3 );\n\t\tplanes[ 4 ].copy( p4 );\n\t\tplanes[ 5 ].copy( p5 );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( frustum ) {\n\n\t\tvar planes = this.planes;\n\n\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\tplanes[ i ].copy( frustum.planes[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetFromMatrix: function ( m ) {\n\n\t\tvar planes = this.planes;\n\t\tvar me = m.elements;\n\t\tvar me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\n\t\tvar me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\n\t\tvar me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\n\t\tvar me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\n\n\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\n\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\n\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\n\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\n\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\n\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\n\n\t\treturn this;\n\n\t},\n\n\tintersectsObject: function () {\n\n\t\tvar sphere = new THREE.Sphere();\n\n\t\treturn function intersectsObject( object ) {\n\n\t\t\tvar geometry = object.geometry;\n\n\t\t\tif ( geometry.boundingSphere === null )\n\t\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\tsphere.copy( geometry.boundingSphere )\n\t\t\t\t.applyMatrix4( object.matrixWorld );\n\n\t\t\treturn this.intersectsSphere( sphere );\n\n\t\t};\n\n\t}(),\n\n\tintersectsSprite: function () {\n\n\t\tvar sphere = new THREE.Sphere();\n\n\t\treturn function intersectsSprite( sprite ) {\n\n\t\t\tsphere.center.set( 0, 0, 0 );\n\t\t\tsphere.radius = 0.7071067811865476;\n\t\t\tsphere.applyMatrix4( sprite.matrixWorld );\n\n\t\t\treturn this.intersectsSphere( sphere );\n\n\t\t};\n\n\t}(),\n\n\tintersectsSphere: function ( sphere ) {\n\n\t\tvar planes = this.planes;\n\t\tvar center = sphere.center;\n\t\tvar negRadius = - sphere.radius;\n\n\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\tvar distance = planes[ i ].distanceToPoint( center );\n\n\t\t\tif ( distance < negRadius ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tintersectsBox: function () {\n\n\t\tvar p1 = new THREE.Vector3(),\n\t\t\tp2 = new THREE.Vector3();\n\n\t\treturn function intersectsBox( box ) {\n\n\t\t\tvar planes = this.planes;\n\n\t\t\tfor ( var i = 0; i < 6 ; i ++ ) {\n\n\t\t\t\tvar plane = planes[ i ];\n\n\t\t\t\tp1.x = plane.normal.x > 0 ? box.min.x : box.max.x;\n\t\t\t\tp2.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n\t\t\t\tp1.y = plane.normal.y > 0 ? box.min.y : box.max.y;\n\t\t\t\tp2.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n\t\t\t\tp1.z = plane.normal.z > 0 ? box.min.z : box.max.z;\n\t\t\t\tp2.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n\n\t\t\t\tvar d1 = plane.distanceToPoint( p1 );\n\t\t\t\tvar d2 = plane.distanceToPoint( p2 );\n\n\t\t\t\t// if both outside plane, no intersection\n\n\t\t\t\tif ( d1 < 0 && d2 < 0 ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t};\n\n\t}(),\n\n\n\tcontainsPoint: function ( point ) {\n\n\t\tvar planes = this.planes;\n\n\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n};\n\n// File:src/math/Plane.js\n\n/**\n * @author bhouston / http://clara.io\n */\n\nTHREE.Plane = function ( normal, constant ) {\n\n\tthis.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );\n\tthis.constant = ( constant !== undefined ) ? constant : 0;\n\n};\n\nTHREE.Plane.prototype = {\n\n\tconstructor: THREE.Plane,\n\n\tset: function ( normal, constant ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = constant;\n\n\t\treturn this;\n\n\t},\n\n\tsetComponents: function ( x, y, z, w ) {\n\n\t\tthis.normal.set( x, y, z );\n\t\tthis.constant = w;\n\n\t\treturn this;\n\n\t},\n\n\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = - point.dot( this.normal );\t// must be this.normal, not normal, as this.normal is normalized\n\n\t\treturn this;\n\n\t},\n\n\tsetFromCoplanarPoints: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\t\tvar v2 = new THREE.Vector3();\n\n\t\treturn function setFromCoplanarPoints( a, b, c ) {\n\n\t\t\tvar normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\n\n\t\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n\t\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( plane ) {\n\n\t\tthis.normal.copy( plane.normal );\n\t\tthis.constant = plane.constant;\n\n\t\treturn this;\n\n\t},\n\n\tnormalize: function () {\n\n\t\t// Note: will lead to a divide by zero if the plane is invalid.\n\n\t\tvar inverseNormalLength = 1.0 / this.normal.length();\n\t\tthis.normal.multiplyScalar( inverseNormalLength );\n\t\tthis.constant *= inverseNormalLength;\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function () {\n\n\t\tthis.constant *= - 1;\n\t\tthis.normal.negate();\n\n\t\treturn this;\n\n\t},\n\n\tdistanceToPoint: function ( point ) {\n\n\t\treturn this.normal.dot( point ) + this.constant;\n\n\t},\n\n\tdistanceToSphere: function ( sphere ) {\n\n\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\n\n\t},\n\n\tprojectPoint: function ( point, optionalTarget ) {\n\n\t\treturn this.orthoPoint( point, optionalTarget ).sub( point ).negate();\n\n\t},\n\n\torthoPoint: function ( point, optionalTarget ) {\n\n\t\tvar perpendicularMagnitude = this.distanceToPoint( point );\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );\n\n\t},\n\n\tintersectLine: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function intersectLine( line, optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\t\tvar direction = line.delta( v1 );\n\n\t\t\tvar denominator = this.normal.dot( direction );\n\n\t\t\tif ( denominator === 0 ) {\n\n\t\t\t\t// line is coplanar, return origin\n\t\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\n\n\t\t\t\t\treturn result.copy( line.start );\n\n\t\t\t\t}\n\n\t\t\t\t// Unsure if this is the correct method to handle this case.\n\t\t\t\treturn undefined;\n\n\t\t\t}\n\n\t\t\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\n\n\t\t\tif ( t < 0 || t > 1 ) {\n\n\t\t\t\treturn undefined;\n\n\t\t\t}\n\n\t\t\treturn result.copy( direction ).multiplyScalar( t ).add( line.start );\n\n\t\t};\n\n\t}(),\n\n\tintersectsLine: function ( line ) {\n\n\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\n\t\tvar startSign = this.distanceToPoint( line.start );\n\t\tvar endSign = this.distanceToPoint( line.end );\n\n\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\n\n\t},\n\n\tintersectsBox: function ( box ) {\n\n\t\treturn box.intersectsPlane( this );\n\n\t},\n\n\tintersectsSphere: function ( sphere ) {\n\n\t\treturn sphere.intersectsPlane( this );\n\n\t},\n\n\tcoplanarPoint: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.copy( this.normal ).multiplyScalar( - this.constant );\n\n\t},\n\n\tapplyMatrix4: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\t\tvar m1 = new THREE.Matrix3();\n\n\t\treturn function applyMatrix4( matrix, optionalNormalMatrix ) {\n\n\t\t\tvar referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );\n\n\t\t\t// transform normal based on theory here:\n\t\t\t// http://www.songho.ca/opengl/gl_normaltransform.html\n\t\t\tvar normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );\n\t\t\tvar normal = this.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t// recalculate constant (like in setFromNormalAndCoplanarPoint)\n\t\t\tthis.constant = - referencePoint.dot( normal );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.constant = this.constant - offset.dot( this.normal );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( plane ) {\n\n\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\n\n\t}\n\n};\n\n// File:src/math/Spherical.js\n\n/**\n * @author bhouston / http://clara.io\n * @author WestLangley / http://github.com/WestLangley\n *\n * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\n *\n * The poles (phi) are at the positive and negative y axis.\n * The equator starts at positive z.\n */\n\nTHREE.Spherical = function ( radius, phi, theta ) {\n\n\tthis.radius = ( radius !== undefined ) ? radius : 1.0;\n\tthis.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole\n\tthis.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere\n\n\treturn this;\n\n};\n\nTHREE.Spherical.prototype = {\n\n\tconstructor: THREE.Spherical,\n\n\tset: function ( radius, phi, theta ) {\n\n\t\tthis.radius = radius;\n\t\tthis.phi = phi;\n\t\tthis.theta = theta;\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( other ) {\n\n\t\tthis.radius.copy( other.radius );\n\t\tthis.phi.copy( other.phi );\n\t\tthis.theta.copy( other.theta );\n\n\t\treturn this;\n\n\t},\n\n\t// restrict phi to be betwee EPS and PI-EPS\n\tmakeSafe: function() {\n\n\t\tvar EPS = 0.000001;\n\t\tthis.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromVector3: function( vec3 ) {\n\n\t\tthis.radius = vec3.length();\n\n\t\tif ( this.radius === 0 ) {\n\n\t\t\tthis.theta = 0;\n\t\t\tthis.phi = 0;\n\n\t\t} else {\n\n\t\t\tthis.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis\n\t\t\tthis.phi = Math.acos( THREE.Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n};\n\n// File:src/math/Math.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Math = {\n\n\tDEG2RAD: Math.PI / 180,\n\tRAD2DEG: 180 / Math.PI,\n\n\tgenerateUUID: function () {\n\n\t\t// http://www.broofa.com/Tools/Math.uuid.htm\n\n\t\tvar chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );\n\t\tvar uuid = new Array( 36 );\n\t\tvar rnd = 0, r;\n\n\t\treturn function generateUUID() {\n\n\t\t\tfor ( var i = 0; i < 36; i ++ ) {\n\n\t\t\t\tif ( i === 8 || i === 13 || i === 18 || i === 23 ) {\n\n\t\t\t\t\tuuid[ i ] = '-';\n\n\t\t\t\t} else if ( i === 14 ) {\n\n\t\t\t\t\tuuid[ i ] = '4';\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;\n\t\t\t\t\tr = rnd & 0xf;\n\t\t\t\t\trnd = rnd >> 4;\n\t\t\t\t\tuuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn uuid.join( '' );\n\n\t\t};\n\n\t}(),\n\n\tclamp: function ( value, min, max ) {\n\n\t\treturn Math.max( min, Math.min( max, value ) );\n\n\t},\n\n\t// compute euclidian modulo of m % n\n\t// https://en.wikipedia.org/wiki/Modulo_operation\n\n\teuclideanModulo: function ( n, m ) {\n\n\t\treturn ( ( n % m ) + m ) % m;\n\n\t},\n\n\t// Linear mapping from range <a1, a2> to range <b1, b2>\n\n\tmapLinear: function ( x, a1, a2, b1, b2 ) {\n\n\t\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\n\t},\n\n\t// http://en.wikipedia.org/wiki/Smoothstep\n\n\tsmoothstep: function ( x, min, max ) {\n\n\t\tif ( x <= min ) return 0;\n\t\tif ( x >= max ) return 1;\n\n\t\tx = ( x - min ) / ( max - min );\n\n\t\treturn x * x * ( 3 - 2 * x );\n\n\t},\n\n\tsmootherstep: function ( x, min, max ) {\n\n\t\tif ( x <= min ) return 0;\n\t\tif ( x >= max ) return 1;\n\n\t\tx = ( x - min ) / ( max - min );\n\n\t\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\n\n\t},\n\n\trandom16: function () {\n\n\t\tconsole.warn( 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' );\n\t\treturn Math.random();\n\n\t},\n\n\t// Random integer from <low, high> interval\n\n\trandInt: function ( low, high ) {\n\n\t\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\n\n\t},\n\n\t// Random float from <low, high> interval\n\n\trandFloat: function ( low, high ) {\n\n\t\treturn low + Math.random() * ( high - low );\n\n\t},\n\n\t// Random float from <-range/2, range/2> interval\n\n\trandFloatSpread: function ( range ) {\n\n\t\treturn range * ( 0.5 - Math.random() );\n\n\t},\n\n\tdegToRad: function ( degrees ) {\n\n\t\treturn degrees * THREE.Math.DEG2RAD;\n\n\t},\n\n\tradToDeg: function ( radians ) {\n\n\t\treturn radians * THREE.Math.RAD2DEG;\n\n\t},\n\n\tisPowerOfTwo: function ( value ) {\n\n\t\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\n\n\t},\n\n\tnearestPowerOfTwo: function ( value ) {\n\n\t\treturn Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );\n\n\t},\n\n\tnextPowerOfTwo: function ( value ) {\n\n\t\tvalue --;\n\t\tvalue |= value >> 1;\n\t\tvalue |= value >> 2;\n\t\tvalue |= value >> 4;\n\t\tvalue |= value >> 8;\n\t\tvalue |= value >> 16;\n\t\tvalue ++;\n\n\t\treturn value;\n\n\t}\n\n};\n\n// File:src/math/Spline.js\n\n/**\n * Spline from Tween.js, slightly optimized (and trashed)\n * http://sole.github.com/tween.js/examples/05_spline.html\n *\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Spline = function ( points ) {\n\n\tthis.points = points;\n\n\tvar c = [], v3 = { x: 0, y: 0, z: 0 },\n\tpoint, intPoint, weight, w2, w3,\n\tpa, pb, pc, pd;\n\n\tthis.initFromArray = function ( a ) {\n\n\t\tthis.points = [];\n\n\t\tfor ( var i = 0; i < a.length; i ++ ) {\n\n\t\t\tthis.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };\n\n\t\t}\n\n\t};\n\n\tthis.getPoint = function ( k ) {\n\n\t\tpoint = ( this.points.length - 1 ) * k;\n\t\tintPoint = Math.floor( point );\n\t\tweight = point - intPoint;\n\n\t\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\n\t\tc[ 1 ] = intPoint;\n\t\tc[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;\n\t\tc[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;\n\n\t\tpa = this.points[ c[ 0 ] ];\n\t\tpb = this.points[ c[ 1 ] ];\n\t\tpc = this.points[ c[ 2 ] ];\n\t\tpd = this.points[ c[ 3 ] ];\n\n\t\tw2 = weight * weight;\n\t\tw3 = weight * w2;\n\n\t\tv3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );\n\t\tv3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );\n\t\tv3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );\n\n\t\treturn v3;\n\n\t};\n\n\tthis.getControlPointsArray = function () {\n\n\t\tvar i, p, l = this.points.length,\n\t\t\tcoords = [];\n\n\t\tfor ( i = 0; i < l; i ++ ) {\n\n\t\t\tp = this.points[ i ];\n\t\t\tcoords[ i ] = [ p.x, p.y, p.z ];\n\n\t\t}\n\n\t\treturn coords;\n\n\t};\n\n\t// approximate length by summing linear segments\n\n\tthis.getLength = function ( nSubDivisions ) {\n\n\t\tvar i, index, nSamples, position,\n\t\t\tpoint = 0, intPoint = 0, oldIntPoint = 0,\n\t\t\toldPosition = new THREE.Vector3(),\n\t\t\ttmpVec = new THREE.Vector3(),\n\t\t\tchunkLengths = [],\n\t\t\ttotalLength = 0;\n\n\t\t// first point has 0 length\n\n\t\tchunkLengths[ 0 ] = 0;\n\n\t\tif ( ! nSubDivisions ) nSubDivisions = 100;\n\n\t\tnSamples = this.points.length * nSubDivisions;\n\n\t\toldPosition.copy( this.points[ 0 ] );\n\n\t\tfor ( i = 1; i < nSamples; i ++ ) {\n\n\t\t\tindex = i / nSamples;\n\n\t\t\tposition = this.getPoint( index );\n\t\t\ttmpVec.copy( position );\n\n\t\t\ttotalLength += tmpVec.distanceTo( oldPosition );\n\n\t\t\toldPosition.copy( position );\n\n\t\t\tpoint = ( this.points.length - 1 ) * index;\n\t\t\tintPoint = Math.floor( point );\n\n\t\t\tif ( intPoint !== oldIntPoint ) {\n\n\t\t\t\tchunkLengths[ intPoint ] = totalLength;\n\t\t\t\toldIntPoint = intPoint;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// last point ends with total length\n\n\t\tchunkLengths[ chunkLengths.length ] = totalLength;\n\n\t\treturn { chunks: chunkLengths, total: totalLength };\n\n\t};\n\n\tthis.reparametrizeByArcLength = function ( samplingCoef ) {\n\n\t\tvar i, j,\n\t\t\tindex, indexCurrent, indexNext,\n\t\t\trealDistance,\n\t\t\tsampling, position,\n\t\t\tnewpoints = [],\n\t\t\ttmpVec = new THREE.Vector3(),\n\t\t\tsl = this.getLength();\n\n\t\tnewpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );\n\n\t\tfor ( i = 1; i < this.points.length; i ++ ) {\n\n\t\t\t//tmpVec.copy( this.points[ i - 1 ] );\n\t\t\t//linearDistance = tmpVec.distanceTo( this.points[ i ] );\n\n\t\t\trealDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];\n\n\t\t\tsampling = Math.ceil( samplingCoef * realDistance / sl.total );\n\n\t\t\tindexCurrent = ( i - 1 ) / ( this.points.length - 1 );\n\t\t\tindexNext = i / ( this.points.length - 1 );\n\n\t\t\tfor ( j = 1; j < sampling - 1; j ++ ) {\n\n\t\t\t\tindex = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );\n\n\t\t\t\tposition = this.getPoint( index );\n\t\t\t\tnewpoints.push( tmpVec.copy( position ).clone() );\n\n\t\t\t}\n\n\t\t\tnewpoints.push( tmpVec.copy( this.points[ i ] ).clone() );\n\n\t\t}\n\n\t\tthis.points = newpoints;\n\n\t};\n\n\t// Catmull-Rom\n\n\tfunction interpolate( p0, p1, p2, p3, t, t2, t3 ) {\n\n\t\tvar v0 = ( p2 - p0 ) * 0.5,\n\t\t\tv1 = ( p3 - p1 ) * 0.5;\n\n\t\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n\t}\n\n};\n\n// File:src/math/Triangle.js\n\n/**\n * @author bhouston / http://clara.io\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Triangle = function ( a, b, c ) {\n\n\tthis.a = ( a !== undefined ) ? a : new THREE.Vector3();\n\tthis.b = ( b !== undefined ) ? b : new THREE.Vector3();\n\tthis.c = ( c !== undefined ) ? c : new THREE.Vector3();\n\n};\n\nTHREE.Triangle.normal = function () {\n\n\tvar v0 = new THREE.Vector3();\n\n\treturn function normal( a, b, c, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\tresult.subVectors( c, b );\n\t\tv0.subVectors( a, b );\n\t\tresult.cross( v0 );\n\n\t\tvar resultLengthSq = result.lengthSq();\n\t\tif ( resultLengthSq > 0 ) {\n\n\t\t\treturn result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );\n\n\t\t}\n\n\t\treturn result.set( 0, 0, 0 );\n\n\t};\n\n}();\n\n// static/instance method to calculate barycentric coordinates\n// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\nTHREE.Triangle.barycoordFromPoint = function () {\n\n\tvar v0 = new THREE.Vector3();\n\tvar v1 = new THREE.Vector3();\n\tvar v2 = new THREE.Vector3();\n\n\treturn function barycoordFromPoint( point, a, b, c, optionalTarget ) {\n\n\t\tv0.subVectors( c, a );\n\t\tv1.subVectors( b, a );\n\t\tv2.subVectors( point, a );\n\n\t\tvar dot00 = v0.dot( v0 );\n\t\tvar dot01 = v0.dot( v1 );\n\t\tvar dot02 = v0.dot( v2 );\n\t\tvar dot11 = v1.dot( v1 );\n\t\tvar dot12 = v1.dot( v2 );\n\n\t\tvar denom = ( dot00 * dot11 - dot01 * dot01 );\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\t// collinear or singular triangle\n\t\tif ( denom === 0 ) {\n\n\t\t\t// arbitrary location outside of triangle?\n\t\t\t// not sure if this is the best idea, maybe should be returning undefined\n\t\t\treturn result.set( - 2, - 1, - 1 );\n\n\t\t}\n\n\t\tvar invDenom = 1 / denom;\n\t\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\n\t\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\n\n\t\t// barycentric coordinates must always sum to 1\n\t\treturn result.set( 1 - u - v, v, u );\n\n\t};\n\n}();\n\nTHREE.Triangle.containsPoint = function () {\n\n\tvar v1 = new THREE.Vector3();\n\n\treturn function containsPoint( point, a, b, c ) {\n\n\t\tvar result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );\n\n\t\treturn ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );\n\n\t};\n\n}();\n\nTHREE.Triangle.prototype = {\n\n\tconstructor: THREE.Triangle,\n\n\tset: function ( a, b, c ) {\n\n\t\tthis.a.copy( a );\n\t\tthis.b.copy( b );\n\t\tthis.c.copy( c );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\n\n\t\tthis.a.copy( points[ i0 ] );\n\t\tthis.b.copy( points[ i1 ] );\n\t\tthis.c.copy( points[ i2 ] );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( triangle ) {\n\n\t\tthis.a.copy( triangle.a );\n\t\tthis.b.copy( triangle.b );\n\t\tthis.c.copy( triangle.c );\n\n\t\treturn this;\n\n\t},\n\n\tarea: function () {\n\n\t\tvar v0 = new THREE.Vector3();\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function area() {\n\n\t\t\tv0.subVectors( this.c, this.b );\n\t\t\tv1.subVectors( this.a, this.b );\n\n\t\t\treturn v0.cross( v1 ).length() * 0.5;\n\n\t\t};\n\n\t}(),\n\n\tmidpoint: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\n\n\t},\n\n\tnormal: function ( optionalTarget ) {\n\n\t\treturn THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );\n\n\t},\n\n\tplane: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Plane();\n\n\t\treturn result.setFromCoplanarPoints( this.a, this.b, this.c );\n\n\t},\n\n\tbarycoordFromPoint: function ( point, optionalTarget ) {\n\n\t\treturn THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );\n\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\treturn THREE.Triangle.containsPoint( point, this.a, this.b, this.c );\n\n\t},\n\n\tclosestPointToPoint: function () {\n\n\t\tvar plane, edgeList, projectedPoint, closestPoint;\n\n\t\treturn function closestPointToPoint( point, optionalTarget ) {\n\n\t\t\tif ( plane === undefined ) {\n\n\t\t\t\tplane = new THREE.Plane();\n\t\t\t\tedgeList = [ new THREE.Line3(), new THREE.Line3(), new THREE.Line3() ];\n\t\t\t\tprojectedPoint = new THREE.Vector3();\n\t\t\t\tclosestPoint = new THREE.Vector3();\n\n\t\t\t}\n\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\t\tvar minDistance = Infinity;\n\n\t\t\t// project the point onto the plane of the triangle\n\n\t\t\tplane.setFromCoplanarPoints( this.a, this.b, this.c );\n\t\t\tplane.projectPoint( point, projectedPoint );\n\n\t\t\t// check if the projection lies within the triangle\n\n\t\t\tif( this.containsPoint( projectedPoint ) === true ) {\n\n\t\t\t\t// if so, this is the closest point\n\n\t\t\t\tresult.copy( projectedPoint );\n\n\t\t\t} else {\n\n\t\t\t\t// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices\n\n\t\t\t\tedgeList[ 0 ].set( this.a, this.b );\n\t\t\t\tedgeList[ 1 ].set( this.b, this.c );\n\t\t\t\tedgeList[ 2 ].set( this.c, this.a );\n\n\t\t\t\tfor( var i = 0; i < edgeList.length; i ++ ) {\n\n\t\t\t\t\tedgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );\n\n\t\t\t\t\tvar distance = projectedPoint.distanceToSquared( closestPoint );\n\n\t\t\t\t\tif( distance < minDistance ) {\n\n\t\t\t\t\t\tminDistance = distance;\n\n\t\t\t\t\t\tresult.copy( closestPoint );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t};\n\n\t}(),\n\n\tequals: function ( triangle ) {\n\n\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\n\n\t}\n\n};\n\n// File:src/math/Interpolant.js\n\n/**\n * Abstract base class of interpolants over parametric samples.\n *\n * The parameter domain is one dimensional, typically the time or a path\n * along a curve defined by the data.\n *\n * The sample values can have any dimensionality and derived classes may\n * apply special interpretations to the data.\n *\n * This class provides the interval seek in a Template Method, deferring\n * the actual interpolation to derived classes.\n *\n * Time complexity is O(1) for linear access crossing at most two points\n * and O(log N) for random access, where N is the number of positions.\n *\n * References:\n *\n * \t\thttp://www.oodesign.com/template-method-pattern.html\n *\n * @author tschw\n */\n\nTHREE.Interpolant = function(\n\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tthis.parameterPositions = parameterPositions;\n\tthis._cachedIndex = 0;\n\n\tthis.resultBuffer = resultBuffer !== undefined ?\n\t\t\tresultBuffer : new sampleValues.constructor( sampleSize );\n\tthis.sampleValues = sampleValues;\n\tthis.valueSize = sampleSize;\n\n};\n\nTHREE.Interpolant.prototype = {\n\n\tconstructor: THREE.Interpolant,\n\n\tevaluate: function( t ) {\n\n\t\tvar pp = this.parameterPositions,\n\t\t\ti1 = this._cachedIndex,\n\n\t\t\tt1 = pp[   i1   ],\n\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\tvalidate_interval: {\n\n\t\t\tseek: {\n\n\t\t\t\tvar right;\n\n\t\t\t\tlinear_scan: {\n//- See http://jsperf.com/comparison-to-undefined/3\n//- slower code:\n//-\n//- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\n\t\t\t\t\tforward_scan: if ( ! ( t < t1 ) ) {\n\n\t\t\t\t\t\tfor ( var giveUpAt = i1 + 2; ;) {\n\n\t\t\t\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\t\t\t\tif ( t < t0 ) break forward_scan;\n\n\t\t\t\t\t\t\t\t// after end\n\n\t\t\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t, t0 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\tt0 = t1;\n\t\t\t\t\t\t\tt1 = pp[ ++ i1 ];\n\n\t\t\t\t\t\t\tif ( t < t1 ) {\n\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// prepare binary search on the right side of the index\n\t\t\t\t\t\tright = pp.length;\n\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t}\n\n//- slower code:\n//-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\n\t\t\t\t\tif ( ! ( t >= t0 ) ) {\n\n\t\t\t\t\t\t// looping?\n\n\t\t\t\t\t\tvar t1global = pp[ 1 ];\n\n\t\t\t\t\t\tif ( t < t1global ) {\n\n\t\t\t\t\t\t\ti1 = 2; // + 1, using the scan for the details\n\t\t\t\t\t\t\tt0 = t1global;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// linear reverse scan\n\n\t\t\t\t\t\tfor ( var giveUpAt = i1 - 2; ;) {\n\n\t\t\t\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\t\t\t\t// before start\n\n\t\t\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\tt1 = t0;\n\t\t\t\t\t\t\tt0 = pp[ -- i1 - 1 ];\n\n\t\t\t\t\t\t\tif ( t >= t0 ) {\n\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// prepare binary search on the left side of the index\n\t\t\t\t\t\tright = i1;\n\t\t\t\t\t\ti1 = 0;\n\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// the interval is valid\n\n\t\t\t\t\tbreak validate_interval;\n\n\t\t\t\t} // linear scan\n\n\t\t\t\t// binary search\n\n\t\t\t\twhile ( i1 < right ) {\n\n\t\t\t\t\tvar mid = ( i1 + right ) >>> 1;\n\n\t\t\t\t\tif ( t < pp[ mid ] ) {\n\n\t\t\t\t\t\tright = mid;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ti1 = mid + 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tt1 = pp[   i1   ];\n\t\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\t\t\t// check boundary cases, again\n\n\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\treturn this.afterEnd_( i1 - 1, t0, t );\n\n\t\t\t\t}\n\n\t\t\t} // seek\n\n\t\t\tthis._cachedIndex = i1;\n\n\t\t\tthis.intervalChanged_( i1, t0, t1 );\n\n\t\t} // validate_interval\n\n\t\treturn this.interpolate_( i1, t0, t, t1 );\n\n\t},\n\n\tsettings: null, // optional, subclass-specific settings structure\n\t// Note: The indirection allows central control of many interpolants.\n\n\t// --- Protected interface\n\n\tDefaultSettings_: {},\n\n\tgetSettings_: function() {\n\n\t\treturn this.settings || this.DefaultSettings_;\n\n\t},\n\n\tcopySampleValue_: function( index ) {\n\n\t\t// copies a sample value to the result buffer\n\n\t\tvar result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = index * stride;\n\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] = values[ offset + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\t// Template methods for derived classes:\n\n\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\tthrow new Error( \"call to abstract method\" );\n\t\t// implementations shall return this.resultBuffer\n\n\t},\n\n\tintervalChanged_: function( i1, t0, t1 ) {\n\n\t\t// empty\n\n\t}\n\n};\n\nObject.assign( THREE.Interpolant.prototype, {\n\n\tbeforeStart_: //( 0, t, t0 ), returns this.resultBuffer\n\t\tTHREE.Interpolant.prototype.copySampleValue_,\n\n\tafterEnd_: //( N-1, tN-1, t ), returns this.resultBuffer\n\t\tTHREE.Interpolant.prototype.copySampleValue_\n\n} );\n\n// File:src/math/interpolants/CubicInterpolant.js\n\n/**\n * Fast and simple cubic spline interpolant.\n *\n * It was derived from a Hermitian construction setting the first derivative\n * at each sample position to the linear slope between neighboring positions\n * over their parameter interval.\n *\n * @author tschw\n */\n\nTHREE.CubicInterpolant = function(\n\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tTHREE.Interpolant.call(\n\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\tthis._weightPrev = -0;\n\tthis._offsetPrev = -0;\n\tthis._weightNext = -0;\n\tthis._offsetNext = -0;\n\n};\n\nTHREE.CubicInterpolant.prototype =\n\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\n\n\tconstructor: THREE.CubicInterpolant,\n\n\tDefaultSettings_: {\n\n\t\tendingStart: \tTHREE.ZeroCurvatureEnding,\n\t\tendingEnd:\t\tTHREE.ZeroCurvatureEnding\n\n\t},\n\n\tintervalChanged_: function( i1, t0, t1 ) {\n\n\t\tvar pp = this.parameterPositions,\n\t\t\tiPrev = i1 - 2,\n\t\t\tiNext = i1 + 1,\n\n\t\t\ttPrev = pp[ iPrev ],\n\t\t\ttNext = pp[ iNext ];\n\n\t\tif ( tPrev === undefined ) {\n\n\t\t\tswitch ( this.getSettings_().endingStart ) {\n\n\t\t\t\tcase THREE.ZeroSlopeEnding:\n\n\t\t\t\t\t// f'(t0) = 0\n\t\t\t\t\tiPrev = i1;\n\t\t\t\t\ttPrev = 2 * t0 - t1;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.WrapAroundEnding:\n\n\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\tiPrev = pp.length - 2;\n\t\t\t\t\ttPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t// f''(t0) = 0 a.k.a. Natural Spline\n\t\t\t\t\tiPrev = i1;\n\t\t\t\t\ttPrev = t1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( tNext === undefined ) {\n\n\t\t\tswitch ( this.getSettings_().endingEnd ) {\n\n\t\t\t\tcase THREE.ZeroSlopeEnding:\n\n\t\t\t\t\t// f'(tN) = 0\n\t\t\t\t\tiNext = i1;\n\t\t\t\t\ttNext = 2 * t1 - t0;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.WrapAroundEnding:\n\n\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\tiNext = 1;\n\t\t\t\t\ttNext = t1 + pp[ 1 ] - pp[ 0 ];\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t// f''(tN) = 0, a.k.a. Natural Spline\n\t\t\t\t\tiNext = i1 - 1;\n\t\t\t\t\ttNext = t0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar halfDt = ( t1 - t0 ) * 0.5,\n\t\t\tstride = this.valueSize;\n\n\t\tthis._weightPrev = halfDt / ( t0 - tPrev );\n\t\tthis._weightNext = halfDt / ( tNext - t1 );\n\t\tthis._offsetPrev = iPrev * stride;\n\t\tthis._offsetNext = iNext * stride;\n\n\t},\n\n\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\tvar result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\to1 = i1 * stride,\t\to0 = o1 - stride,\n\t\t\toP = this._offsetPrev, \toN = this._offsetNext,\n\t\t\twP = this._weightPrev,\twN = this._weightNext,\n\n\t\t\tp = ( t - t0 ) / ( t1 - t0 ),\n\t\t\tpp = p * p,\n\t\t\tppp = pp * p;\n\n\t\t// evaluate polynomials\n\n\t\tvar sP =     - wP   * ppp   +         2 * wP    * pp    -          wP   * p;\n\t\tvar s0 = ( 1 + wP ) * ppp   + (-1.5 - 2 * wP )  * pp    + ( -0.5 + wP ) * p     + 1;\n\t\tvar s1 = (-1 - wN ) * ppp   + ( 1.5 +   wN   )  * pp    +    0.5        * p;\n\t\tvar sN =       wN   * ppp   -           wN      * pp;\n\n\t\t// combine data linearly\n\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] =\n\t\t\t\t\tsP * values[ oP + i ] +\n\t\t\t\t\ts0 * values[ o0 + i ] +\n\t\t\t\t\ts1 * values[ o1 + i ] +\n\t\t\t\t\tsN * values[ oN + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n} );\n\n// File:src/math/interpolants/DiscreteInterpolant.js\n\n/**\n *\n * Interpolant that evaluates to the sample value at the position preceeding\n * the parameter.\n *\n * @author tschw\n */\n\nTHREE.DiscreteInterpolant = function(\n\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tTHREE.Interpolant.call(\n\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n};\n\nTHREE.DiscreteInterpolant.prototype =\n\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\n\n\tconstructor: THREE.DiscreteInterpolant,\n\n\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\treturn this.copySampleValue_( i1 - 1 );\n\n\t}\n\n} );\n\n// File:src/math/interpolants/LinearInterpolant.js\n\n/**\n * @author tschw\n */\n\nTHREE.LinearInterpolant = function(\n\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tTHREE.Interpolant.call(\n\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n};\n\nTHREE.LinearInterpolant.prototype =\n\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\n\n\tconstructor: THREE.LinearInterpolant,\n\n\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\tvar result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\toffset1 = i1 * stride,\n\t\t\toffset0 = offset1 - stride,\n\n\t\t\tweight1 = ( t - t0 ) / ( t1 - t0 ),\n\t\t\tweight0 = 1 - weight1;\n\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] =\n\t\t\t\t\tvalues[ offset0 + i ] * weight0 +\n\t\t\t\t\tvalues[ offset1 + i ] * weight1;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n} );\n\n// File:src/math/interpolants/QuaternionLinearInterpolant.js\n\n/**\n * Spherical linear unit quaternion interpolant.\n *\n * @author tschw\n */\n\nTHREE.QuaternionLinearInterpolant = function(\n\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tTHREE.Interpolant.call(\n\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n};\n\nTHREE.QuaternionLinearInterpolant.prototype =\n\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\n\n\tconstructor: THREE.QuaternionLinearInterpolant,\n\n\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\tvar result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\toffset = i1 * stride,\n\n\t\t\talpha = ( t - t0 ) / ( t1 - t0 );\n\n\t\tfor ( var end = offset + stride; offset !== end; offset += 4 ) {\n\n\t\t\tTHREE.Quaternion.slerpFlat( result, 0,\n\t\t\t\t\tvalues, offset - stride, values, offset, alpha );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n} );\n\n// File:src/core/Clock.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Clock = function ( autoStart ) {\n\n\tthis.autoStart = ( autoStart !== undefined ) ? autoStart : true;\n\n\tthis.startTime = 0;\n\tthis.oldTime = 0;\n\tthis.elapsedTime = 0;\n\n\tthis.running = false;\n\n};\n\nTHREE.Clock.prototype = {\n\n\tconstructor: THREE.Clock,\n\n\tstart: function () {\n\n\t\tthis.startTime = ( performance || Date ).now();\n\n\t\tthis.oldTime = this.startTime;\n\t\tthis.running = true;\n\n\t},\n\n\tstop: function () {\n\n\t\tthis.getElapsedTime();\n\t\tthis.running = false;\n\n\t},\n\n\tgetElapsedTime: function () {\n\n\t\tthis.getDelta();\n\t\treturn this.elapsedTime;\n\n\t},\n\n\tgetDelta: function () {\n\n\t\tvar diff = 0;\n\n\t\tif ( this.autoStart && ! this.running ) {\n\n\t\t\tthis.start();\n\n\t\t}\n\n\t\tif ( this.running ) {\n\n\t\t\tvar newTime = ( performance || Date ).now();\n\n\t\t\tdiff = ( newTime - this.oldTime ) / 1000;\n\t\t\tthis.oldTime = newTime;\n\n\t\t\tthis.elapsedTime += diff;\n\n\t\t}\n\n\t\treturn diff;\n\n\t}\n\n};\n\n// File:src/core/EventDispatcher.js\n\n/**\n * https://github.com/mrdoob/eventdispatcher.js/\n */\n\nTHREE.EventDispatcher = function () {};\n\nObject.assign( THREE.EventDispatcher.prototype, {\n\n\taddEventListener: function ( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) this._listeners = {};\n\n\t\tvar listeners = this._listeners;\n\n\t\tif ( listeners[ type ] === undefined ) {\n\n\t\t\tlisteners[ type ] = [];\n\n\t\t}\n\n\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\n\n\t\t\tlisteners[ type ].push( listener );\n\n\t\t}\n\n\t},\n\n\thasEventListener: function ( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) return false;\n\n\t\tvar listeners = this._listeners;\n\n\t\tif ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t},\n\n\tremoveEventListener: function ( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tvar listeners = this._listeners;\n\t\tvar listenerArray = listeners[ type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tvar index = listenerArray.indexOf( listener );\n\n\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\tlistenerArray.splice( index, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tdispatchEvent: function ( event ) {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tvar listeners = this._listeners;\n\t\tvar listenerArray = listeners[ event.type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tevent.target = this;\n\n\t\t\tvar array = [], i = 0;\n\t\t\tvar length = listenerArray.length;\n\n\t\t\tfor ( i = 0; i < length; i ++ ) {\n\n\t\t\t\tarray[ i ] = listenerArray[ i ];\n\n\t\t\t}\n\n\t\t\tfor ( i = 0; i < length; i ++ ) {\n\n\t\t\t\tarray[ i ].call( this, event );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n} );\n\n// File:src/core/Layers.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Layers = function () {\n\n\tthis.mask = 1;\n\n};\n\nTHREE.Layers.prototype = {\n\n\tconstructor: THREE.Layers,\n\n\tset: function ( channel ) {\n\n\t\tthis.mask = 1 << channel;\n\n\t},\n\n\tenable: function ( channel ) {\n\n\t\tthis.mask |= 1 << channel;\n\n\t},\n\n\ttoggle: function ( channel ) {\n\n\t\tthis.mask ^= 1 << channel;\n\n\t},\n\n\tdisable: function ( channel ) {\n\n\t\tthis.mask &= ~ ( 1 << channel );\n\n\t},\n\n\ttest: function ( layers ) {\n\n\t\treturn ( this.mask & layers.mask ) !== 0;\n\n\t}\n\n};\n\n// File:src/core/Raycaster.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author bhouston / http://clara.io/\n * @author stephomi / http://stephaneginier.com/\n */\n\n( function ( THREE ) {\n\n\tTHREE.Raycaster = function ( origin, direction, near, far ) {\n\n\t\tthis.ray = new THREE.Ray( origin, direction );\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\tthis.near = near || 0;\n\t\tthis.far = far || Infinity;\n\n\t\tthis.params = {\n\t\t\tMesh: {},\n\t\t\tLine: {},\n\t\t\tLOD: {},\n\t\t\tPoints: { threshold: 1 },\n\t\t\tSprite: {}\n\t\t};\n\n\t\tObject.defineProperties( this.params, {\n\t\t\tPointCloud: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );\n\t\t\t\t\treturn this.Points;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t};\n\n\tfunction ascSort( a, b ) {\n\n\t\treturn a.distance - b.distance;\n\n\t}\n\n\tfunction intersectObject( object, raycaster, intersects, recursive ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tobject.raycast( raycaster, intersects );\n\n\t\tif ( recursive === true ) {\n\n\t\t\tvar children = object.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tintersectObject( children[ i ], raycaster, intersects, true );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t//\n\n\tTHREE.Raycaster.prototype = {\n\n\t\tconstructor: THREE.Raycaster,\n\n\t\tlinePrecision: 1,\n\n\t\tset: function ( origin, direction ) {\n\n\t\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\t\tthis.ray.set( origin, direction );\n\n\t\t},\n\n\t\tsetFromCamera: function ( coords, camera ) {\n\n\t\t\tif ( camera instanceof THREE.PerspectiveCamera ) {\n\n\t\t\t\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\n\n\t\t\t} else if ( camera instanceof THREE.OrthographicCamera ) {\n\n\t\t\t\tthis.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera\n\t\t\t\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.Raycaster: Unsupported camera type.' );\n\n\t\t\t}\n\n\t\t},\n\n\t\tintersectObject: function ( object, recursive ) {\n\n\t\t\tvar intersects = [];\n\n\t\t\tintersectObject( object, this, intersects, recursive );\n\n\t\t\tintersects.sort( ascSort );\n\n\t\t\treturn intersects;\n\n\t\t},\n\n\t\tintersectObjects: function ( objects, recursive ) {\n\n\t\t\tvar intersects = [];\n\n\t\t\tif ( Array.isArray( objects ) === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );\n\t\t\t\treturn intersects;\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\n\n\t\t\t\tintersectObject( objects[ i ], this, intersects, recursive );\n\n\t\t\t}\n\n\t\t\tintersects.sort( ascSort );\n\n\t\t\treturn intersects;\n\n\t\t}\n\n\t};\n\n}( THREE ) );\n\n// File:src/core/Object3D.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author elephantatwork / www.elephantatwork.ch\n */\n\nTHREE.Object3D = function () {\n\n\tObject.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'Object3D';\n\n\tthis.parent = null;\n\tthis.children = [];\n\n\tthis.up = THREE.Object3D.DefaultUp.clone();\n\n\tvar position = new THREE.Vector3();\n\tvar rotation = new THREE.Euler();\n\tvar quaternion = new THREE.Quaternion();\n\tvar scale = new THREE.Vector3( 1, 1, 1 );\n\n\tfunction onRotationChange() {\n\n\t\tquaternion.setFromEuler( rotation, false );\n\n\t}\n\n\tfunction onQuaternionChange() {\n\n\t\trotation.setFromQuaternion( quaternion, undefined, false );\n\n\t}\n\n\trotation.onChange( onRotationChange );\n\tquaternion.onChange( onQuaternionChange );\n\n\tObject.defineProperties( this, {\n\t\tposition: {\n\t\t\tenumerable: true,\n\t\t\tvalue: position\n\t\t},\n\t\trotation: {\n\t\t\tenumerable: true,\n\t\t\tvalue: rotation\n\t\t},\n\t\tquaternion: {\n\t\t\tenumerable: true,\n\t\t\tvalue: quaternion\n\t\t},\n\t\tscale: {\n\t\t\tenumerable: true,\n\t\t\tvalue: scale\n\t\t},\n\t\tmodelViewMatrix: {\n\t\t\tvalue: new THREE.Matrix4()\n\t\t},\n\t\tnormalMatrix: {\n\t\t\tvalue: new THREE.Matrix3()\n\t\t}\n\t} );\n\n\tthis.matrix = new THREE.Matrix4();\n\tthis.matrixWorld = new THREE.Matrix4();\n\n\tthis.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate;\n\tthis.matrixWorldNeedsUpdate = false;\n\n\tthis.layers = new THREE.Layers();\n\tthis.visible = true;\n\n\tthis.castShadow = false;\n\tthis.receiveShadow = false;\n\n\tthis.frustumCulled = true;\n\tthis.renderOrder = 0;\n\n\tthis.userData = {};\n\n};\n\nTHREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );\nTHREE.Object3D.DefaultMatrixAutoUpdate = true;\n\nObject.assign( THREE.Object3D.prototype, THREE.EventDispatcher.prototype, {\n\n\tapplyMatrix: function ( matrix ) {\n\n\t\tthis.matrix.multiplyMatrices( matrix, this.matrix );\n\n\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\n\n\t},\n\n\tsetRotationFromAxisAngle: function ( axis, angle ) {\n\n\t\t// assumes axis is normalized\n\n\t\tthis.quaternion.setFromAxisAngle( axis, angle );\n\n\t},\n\n\tsetRotationFromEuler: function ( euler ) {\n\n\t\tthis.quaternion.setFromEuler( euler, true );\n\n\t},\n\n\tsetRotationFromMatrix: function ( m ) {\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tthis.quaternion.setFromRotationMatrix( m );\n\n\t},\n\n\tsetRotationFromQuaternion: function ( q ) {\n\n\t\t// assumes q is normalized\n\n\t\tthis.quaternion.copy( q );\n\n\t},\n\n\trotateOnAxis: function () {\n\n\t\t// rotate object on axis in object space\n\t\t// axis is assumed to be normalized\n\n\t\tvar q1 = new THREE.Quaternion();\n\n\t\treturn function rotateOnAxis( axis, angle ) {\n\n\t\t\tq1.setFromAxisAngle( axis, angle );\n\n\t\t\tthis.quaternion.multiply( q1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\trotateX: function () {\n\n\t\tvar v1 = new THREE.Vector3( 1, 0, 0 );\n\n\t\treturn function rotateX( angle ) {\n\n\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t};\n\n\t}(),\n\n\trotateY: function () {\n\n\t\tvar v1 = new THREE.Vector3( 0, 1, 0 );\n\n\t\treturn function rotateY( angle ) {\n\n\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t};\n\n\t}(),\n\n\trotateZ: function () {\n\n\t\tvar v1 = new THREE.Vector3( 0, 0, 1 );\n\n\t\treturn function rotateZ( angle ) {\n\n\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t};\n\n\t}(),\n\n\ttranslateOnAxis: function () {\n\n\t\t// translate object by distance along axis in object space\n\t\t// axis is assumed to be normalized\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function translateOnAxis( axis, distance ) {\n\n\t\t\tv1.copy( axis ).applyQuaternion( this.quaternion );\n\n\t\t\tthis.position.add( v1.multiplyScalar( distance ) );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslateX: function () {\n\n\t\tvar v1 = new THREE.Vector3( 1, 0, 0 );\n\n\t\treturn function translateX( distance ) {\n\n\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t};\n\n\t}(),\n\n\ttranslateY: function () {\n\n\t\tvar v1 = new THREE.Vector3( 0, 1, 0 );\n\n\t\treturn function translateY( distance ) {\n\n\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t};\n\n\t}(),\n\n\ttranslateZ: function () {\n\n\t\tvar v1 = new THREE.Vector3( 0, 0, 1 );\n\n\t\treturn function translateZ( distance ) {\n\n\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t};\n\n\t}(),\n\n\tlocalToWorld: function ( vector ) {\n\n\t\treturn vector.applyMatrix4( this.matrixWorld );\n\n\t},\n\n\tworldToLocal: function () {\n\n\t\tvar m1 = new THREE.Matrix4();\n\n\t\treturn function worldToLocal( vector ) {\n\n\t\t\treturn vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );\n\n\t\t};\n\n\t}(),\n\n\tlookAt: function () {\n\n\t\t// This routine does not support objects with rotated and/or translated parent(s)\n\n\t\tvar m1 = new THREE.Matrix4();\n\n\t\treturn function lookAt( vector ) {\n\n\t\t\tm1.lookAt( vector, this.position, this.up );\n\n\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\n\n\t\t};\n\n\t}(),\n\n\tadd: function ( object ) {\n\n\t\tif ( arguments.length > 1 ) {\n\n\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\tthis.add( arguments[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( object === this ) {\n\n\t\t\tconsole.error( \"THREE.Object3D.add: object can't be added as a child of itself.\", object );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( object instanceof THREE.Object3D ) {\n\n\t\t\tif ( object.parent !== null ) {\n\n\t\t\t\tobject.parent.remove( object );\n\n\t\t\t}\n\n\t\t\tobject.parent = this;\n\t\t\tobject.dispatchEvent( { type: 'added' } );\n\n\t\t\tthis.children.push( object );\n\n\t\t} else {\n\n\t\t\tconsole.error( \"THREE.Object3D.add: object not an instance of THREE.Object3D.\", object );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tremove: function ( object ) {\n\n\t\tif ( arguments.length > 1 ) {\n\n\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\tthis.remove( arguments[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar index = this.children.indexOf( object );\n\n\t\tif ( index !== - 1 ) {\n\n\t\t\tobject.parent = null;\n\n\t\t\tobject.dispatchEvent( { type: 'removed' } );\n\n\t\t\tthis.children.splice( index, 1 );\n\n\t\t}\n\n\t},\n\n\tgetObjectById: function ( id ) {\n\n\t\treturn this.getObjectByProperty( 'id', id );\n\n\t},\n\n\tgetObjectByName: function ( name ) {\n\n\t\treturn this.getObjectByProperty( 'name', name );\n\n\t},\n\n\tgetObjectByProperty: function ( name, value ) {\n\n\t\tif ( this[ name ] === value ) return this;\n\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\tvar child = this.children[ i ];\n\t\t\tvar object = child.getObjectByProperty( name, value );\n\n\t\t\tif ( object !== undefined ) {\n\n\t\t\t\treturn object;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn undefined;\n\n\t},\n\n\tgetWorldPosition: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\tthis.updateMatrixWorld( true );\n\n\t\treturn result.setFromMatrixPosition( this.matrixWorld );\n\n\t},\n\n\tgetWorldQuaternion: function () {\n\n\t\tvar position = new THREE.Vector3();\n\t\tvar scale = new THREE.Vector3();\n\n\t\treturn function getWorldQuaternion( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new THREE.Quaternion();\n\n\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\tthis.matrixWorld.decompose( position, result, scale );\n\n\t\t\treturn result;\n\n\t\t};\n\n\t}(),\n\n\tgetWorldRotation: function () {\n\n\t\tvar quaternion = new THREE.Quaternion();\n\n\t\treturn function getWorldRotation( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new THREE.Euler();\n\n\t\t\tthis.getWorldQuaternion( quaternion );\n\n\t\t\treturn result.setFromQuaternion( quaternion, this.rotation.order, false );\n\n\t\t};\n\n\t}(),\n\n\tgetWorldScale: function () {\n\n\t\tvar position = new THREE.Vector3();\n\t\tvar quaternion = new THREE.Quaternion();\n\n\t\treturn function getWorldScale( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\tthis.matrixWorld.decompose( position, quaternion, result );\n\n\t\t\treturn result;\n\n\t\t};\n\n\t}(),\n\n\tgetWorldDirection: function () {\n\n\t\tvar quaternion = new THREE.Quaternion();\n\n\t\treturn function getWorldDirection( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\t\tthis.getWorldQuaternion( quaternion );\n\n\t\t\treturn result.set( 0, 0, 1 ).applyQuaternion( quaternion );\n\n\t\t};\n\n\t}(),\n\n\traycast: function () {},\n\n\ttraverse: function ( callback ) {\n\n\t\tcallback( this );\n\n\t\tvar children = this.children;\n\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].traverse( callback );\n\n\t\t}\n\n\t},\n\n\ttraverseVisible: function ( callback ) {\n\n\t\tif ( this.visible === false ) return;\n\n\t\tcallback( this );\n\n\t\tvar children = this.children;\n\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].traverseVisible( callback );\n\n\t\t}\n\n\t},\n\n\ttraverseAncestors: function ( callback ) {\n\n\t\tvar parent = this.parent;\n\n\t\tif ( parent !== null ) {\n\n\t\t\tcallback( parent );\n\n\t\t\tparent.traverseAncestors( callback );\n\n\t\t}\n\n\t},\n\n\tupdateMatrix: function () {\n\n\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\n\n\t\tthis.matrixWorldNeedsUpdate = true;\n\n\t},\n\n\tupdateMatrixWorld: function ( force ) {\n\n\t\tif ( this.matrixAutoUpdate === true ) this.updateMatrix();\n\n\t\tif ( this.matrixWorldNeedsUpdate === true || force === true ) {\n\n\t\t\tif ( this.parent === null ) {\n\n\t\t\t\tthis.matrixWorld.copy( this.matrix );\n\n\t\t\t} else {\n\n\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t\t}\n\n\t\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\t\tforce = true;\n\n\t\t}\n\n\t\t// update children\n\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\tthis.children[ i ].updateMatrixWorld( force );\n\n\t\t}\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\t// meta is '' when called from JSON.stringify\n\t\tvar isRootObject = ( meta === undefined || meta === '' );\n\n\t\tvar output = {};\n\n\t\t// meta is a hash used to collect geometries, materials.\n\t\t// not providing it implies that this is the root object\n\t\t// being serialized.\n\t\tif ( isRootObject ) {\n\n\t\t\t// initialize meta obj\n\t\t\tmeta = {\n\t\t\t\tgeometries: {},\n\t\t\t\tmaterials: {},\n\t\t\t\ttextures: {},\n\t\t\t\timages: {}\n\t\t\t};\n\n\t\t\toutput.metadata = {\n\t\t\t\tversion: 4.4,\n\t\t\t\ttype: 'Object',\n\t\t\t\tgenerator: 'Object3D.toJSON'\n\t\t\t};\n\n\t\t}\n\n\t\t// standard Object3D serialization\n\n\t\tvar object = {};\n\n\t\tobject.uuid = this.uuid;\n\t\tobject.type = this.type;\n\n\t\tif ( this.name !== '' ) object.name = this.name;\n\t\tif ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;\n\t\tif ( this.castShadow === true ) object.castShadow = true;\n\t\tif ( this.receiveShadow === true ) object.receiveShadow = true;\n\t\tif ( this.visible === false ) object.visible = false;\n\n\t\tobject.matrix = this.matrix.toArray();\n\n\t\t//\n\n\t\tif ( this.geometry !== undefined ) {\n\n\t\t\tif ( meta.geometries[ this.geometry.uuid ] === undefined ) {\n\n\t\t\t\tmeta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );\n\n\t\t\t}\n\n\t\t\tobject.geometry = this.geometry.uuid;\n\n\t\t}\n\n\t\tif ( this.material !== undefined ) {\n\n\t\t\tif ( meta.materials[ this.material.uuid ] === undefined ) {\n\n\t\t\t\tmeta.materials[ this.material.uuid ] = this.material.toJSON( meta );\n\n\t\t\t}\n\n\t\t\tobject.material = this.material.uuid;\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.children.length > 0 ) {\n\n\t\t\tobject.children = [];\n\n\t\t\tfor ( var i = 0; i < this.children.length; i ++ ) {\n\n\t\t\t\tobject.children.push( this.children[ i ].toJSON( meta ).object );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( isRootObject ) {\n\n\t\t\tvar geometries = extractFromCache( meta.geometries );\n\t\t\tvar materials = extractFromCache( meta.materials );\n\t\t\tvar textures = extractFromCache( meta.textures );\n\t\t\tvar images = extractFromCache( meta.images );\n\n\t\t\tif ( geometries.length > 0 ) output.geometries = geometries;\n\t\t\tif ( materials.length > 0 ) output.materials = materials;\n\t\t\tif ( textures.length > 0 ) output.textures = textures;\n\t\t\tif ( images.length > 0 ) output.images = images;\n\n\t\t}\n\n\t\toutput.object = object;\n\n\t\treturn output;\n\n\t\t// extract data from the cache hash\n\t\t// remove metadata on each item\n\t\t// and return as array\n\t\tfunction extractFromCache ( cache ) {\n\n\t\t\tvar values = [];\n\t\t\tfor ( var key in cache ) {\n\n\t\t\t\tvar data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\t\t\treturn values;\n\n\t\t}\n\n\t},\n\n\tclone: function ( recursive ) {\n\n\t\treturn new this.constructor().copy( this, recursive );\n\n\t},\n\n\tcopy: function ( source, recursive ) {\n\n\t\tif ( recursive === undefined ) recursive = true;\n\n\t\tthis.name = source.name;\n\n\t\tthis.up.copy( source.up );\n\n\t\tthis.position.copy( source.position );\n\t\tthis.quaternion.copy( source.quaternion );\n\t\tthis.scale.copy( source.scale );\n\n\t\tthis.matrix.copy( source.matrix );\n\t\tthis.matrixWorld.copy( source.matrixWorld );\n\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n\n\t\tthis.visible = source.visible;\n\n\t\tthis.castShadow = source.castShadow;\n\t\tthis.receiveShadow = source.receiveShadow;\n\n\t\tthis.frustumCulled = source.frustumCulled;\n\t\tthis.renderOrder = source.renderOrder;\n\n\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n\t\tif ( recursive === true ) {\n\n\t\t\tfor ( var i = 0; i < source.children.length; i ++ ) {\n\n\t\t\t\tvar child = source.children[ i ];\n\t\t\t\tthis.add( child.clone() );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n} );\n\nTHREE.Object3DIdCount = 0;\n\n// File:src/core/Face3.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {\n\n\tthis.a = a;\n\tthis.b = b;\n\tthis.c = c;\n\n\tthis.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();\n\tthis.vertexNormals = Array.isArray( normal ) ? normal : [];\n\n\tthis.color = color instanceof THREE.Color ? color : new THREE.Color();\n\tthis.vertexColors = Array.isArray( color ) ? color : [];\n\n\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\n\n};\n\nTHREE.Face3.prototype = {\n\n\tconstructor: THREE.Face3,\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.a = source.a;\n\t\tthis.b = source.b;\n\t\tthis.c = source.c;\n\n\t\tthis.normal.copy( source.normal );\n\t\tthis.color.copy( source.color );\n\n\t\tthis.materialIndex = source.materialIndex;\n\n\t\tfor ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {\n\n\t\t\tthis.vertexNormals[ i ] = source.vertexNormals[ i ].clone();\n\n\t\t}\n\n\t\tfor ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {\n\n\t\t\tthis.vertexColors[ i ] = source.vertexColors[ i ].clone();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n};\n\n// File:src/core/BufferAttribute.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.BufferAttribute = function ( array, itemSize, normalized ) {\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.array = array;\n\tthis.itemSize = itemSize;\n\n\tthis.dynamic = false;\n\tthis.updateRange = { offset: 0, count: - 1 };\n\n\tthis.version = 0;\n\tthis.normalized = normalized === true;\n\n};\n\nTHREE.BufferAttribute.prototype = {\n\n\tconstructor: THREE.BufferAttribute,\n\n\tget count() {\n\n\t\treturn this.array.length / this.itemSize;\n\n\t},\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t},\n\n\tsetDynamic: function ( value ) {\n\n\t\tthis.dynamic = value;\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.array = new source.array.constructor( source.array );\n\t\tthis.itemSize = source.itemSize;\n\n\t\tthis.dynamic = source.dynamic;\n\n\t\treturn this;\n\n\t},\n\n\tcopyAt: function ( index1, attribute, index2 ) {\n\n\t\tindex1 *= this.itemSize;\n\t\tindex2 *= attribute.itemSize;\n\n\t\tfor ( var i = 0, l = this.itemSize; i < l; i ++ ) {\n\n\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcopyArray: function ( array ) {\n\n\t\tthis.array.set( array );\n\n\t\treturn this;\n\n\t},\n\n\tcopyColorsArray: function ( colors ) {\n\n\t\tvar array = this.array, offset = 0;\n\n\t\tfor ( var i = 0, l = colors.length; i < l; i ++ ) {\n\n\t\t\tvar color = colors[ i ];\n\n\t\t\tif ( color === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );\n\t\t\t\tcolor = new THREE.Color();\n\n\t\t\t}\n\n\t\t\tarray[ offset ++ ] = color.r;\n\t\t\tarray[ offset ++ ] = color.g;\n\t\t\tarray[ offset ++ ] = color.b;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcopyIndicesArray: function ( indices ) {\n\n\t\tvar array = this.array, offset = 0;\n\n\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\tvar index = indices[ i ];\n\n\t\t\tarray[ offset ++ ] = index.a;\n\t\t\tarray[ offset ++ ] = index.b;\n\t\t\tarray[ offset ++ ] = index.c;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcopyVector2sArray: function ( vectors ) {\n\n\t\tvar array = this.array, offset = 0;\n\n\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\tvar vector = vectors[ i ];\n\n\t\t\tif ( vector === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );\n\t\t\t\tvector = new THREE.Vector2();\n\n\t\t\t}\n\n\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\tarray[ offset ++ ] = vector.y;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcopyVector3sArray: function ( vectors ) {\n\n\t\tvar array = this.array, offset = 0;\n\n\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\tvar vector = vectors[ i ];\n\n\t\t\tif ( vector === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );\n\t\t\t\tvector = new THREE.Vector3();\n\n\t\t\t}\n\n\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\tarray[ offset ++ ] = vector.y;\n\t\t\tarray[ offset ++ ] = vector.z;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcopyVector4sArray: function ( vectors ) {\n\n\t\tvar array = this.array, offset = 0;\n\n\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\tvar vector = vectors[ i ];\n\n\t\t\tif ( vector === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );\n\t\t\t\tvector = new THREE.Vector4();\n\n\t\t\t}\n\n\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\tarray[ offset ++ ] = vector.y;\n\t\t\tarray[ offset ++ ] = vector.z;\n\t\t\tarray[ offset ++ ] = vector.w;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tset: function ( value, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.array.set( value, offset );\n\n\t\treturn this;\n\n\t},\n\n\tgetX: function ( index ) {\n\n\t\treturn this.array[ index * this.itemSize ];\n\n\t},\n\n\tsetX: function ( index, x ) {\n\n\t\tthis.array[ index * this.itemSize ] = x;\n\n\t\treturn this;\n\n\t},\n\n\tgetY: function ( index ) {\n\n\t\treturn this.array[ index * this.itemSize + 1 ];\n\n\t},\n\n\tsetY: function ( index, y ) {\n\n\t\tthis.array[ index * this.itemSize + 1 ] = y;\n\n\t\treturn this;\n\n\t},\n\n\tgetZ: function ( index ) {\n\n\t\treturn this.array[ index * this.itemSize + 2 ];\n\n\t},\n\n\tsetZ: function ( index, z ) {\n\n\t\tthis.array[ index * this.itemSize + 2 ] = z;\n\n\t\treturn this;\n\n\t},\n\n\tgetW: function ( index ) {\n\n\t\treturn this.array[ index * this.itemSize + 3 ];\n\n\t},\n\n\tsetW: function ( index, w ) {\n\n\t\tthis.array[ index * this.itemSize + 3 ] = w;\n\n\t\treturn this;\n\n\t},\n\n\tsetXY: function ( index, x, y ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetXYZ: function ( index, x, y, z ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\t\tthis.array[ index + 2 ] = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetXYZW: function ( index, x, y, z, w ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\t\tthis.array[ index + 2 ] = z;\n\t\tthis.array[ index + 3 ] = w;\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n};\n\n//\n\nTHREE.Int8Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Int8Array( array ), itemSize );\n\n};\n\nTHREE.Uint8Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Uint8Array( array ), itemSize );\n\n};\n\nTHREE.Uint8ClampedAttribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Uint8ClampedArray( array ), itemSize );\n\n};\n\nTHREE.Int16Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Int16Array( array ), itemSize );\n\n};\n\nTHREE.Uint16Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Uint16Array( array ), itemSize );\n\n};\n\nTHREE.Int32Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Int32Array( array ), itemSize );\n\n};\n\nTHREE.Uint32Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Uint32Array( array ), itemSize );\n\n};\n\nTHREE.Float32Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Float32Array( array ), itemSize );\n\n};\n\nTHREE.Float64Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Float64Array( array ), itemSize );\n\n};\n\n\n// Deprecated\n\nTHREE.DynamicBufferAttribute = function ( array, itemSize ) {\n\n\tconsole.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );\n\treturn new THREE.BufferAttribute( array, itemSize ).setDynamic( true );\n\n};\n\n// File:src/core/InstancedBufferAttribute.js\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nTHREE.InstancedBufferAttribute = function ( array, itemSize, meshPerAttribute ) {\n\n\tTHREE.BufferAttribute.call( this, array, itemSize );\n\n\tthis.meshPerAttribute = meshPerAttribute || 1;\n\n};\n\nTHREE.InstancedBufferAttribute.prototype = Object.create( THREE.BufferAttribute.prototype );\nTHREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute;\n\nTHREE.InstancedBufferAttribute.prototype.copy = function ( source ) {\n\n\tTHREE.BufferAttribute.prototype.copy.call( this, source );\n\n\tthis.meshPerAttribute = source.meshPerAttribute;\n\n\treturn this;\n\n};\n\n// File:src/core/InterleavedBuffer.js\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nTHREE.InterleavedBuffer = function ( array, stride ) {\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.array = array;\n\tthis.stride = stride;\n\n\tthis.dynamic = false;\n\tthis.updateRange = { offset: 0, count: - 1 };\n\n\tthis.version = 0;\n\n};\n\nTHREE.InterleavedBuffer.prototype = {\n\n\tconstructor: THREE.InterleavedBuffer,\n\n\tget length () {\n\n\t\treturn this.array.length;\n\n\t},\n\n\tget count () {\n\n\t\treturn this.array.length / this.stride;\n\n\t},\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t},\n\n\tsetDynamic: function ( value ) {\n\n\t\tthis.dynamic = value;\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.array = new source.array.constructor( source.array );\n\t\tthis.stride = source.stride;\n\t\tthis.dynamic = source.dynamic;\n\n\t\treturn this;\n\n\t},\n\n\tcopyAt: function ( index1, attribute, index2 ) {\n\n\t\tindex1 *= this.stride;\n\t\tindex2 *= attribute.stride;\n\n\t\tfor ( var i = 0, l = this.stride; i < l; i ++ ) {\n\n\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tset: function ( value, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.array.set( value, offset );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n};\n\n// File:src/core/InstancedInterleavedBuffer.js\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nTHREE.InstancedInterleavedBuffer = function ( array, stride, meshPerAttribute ) {\n\n\tTHREE.InterleavedBuffer.call( this, array, stride );\n\n\tthis.meshPerAttribute = meshPerAttribute || 1;\n\n};\n\nTHREE.InstancedInterleavedBuffer.prototype = Object.create( THREE.InterleavedBuffer.prototype );\nTHREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer;\n\nTHREE.InstancedInterleavedBuffer.prototype.copy = function ( source ) {\n\n\tTHREE.InterleavedBuffer.prototype.copy.call( this, source );\n\n\tthis.meshPerAttribute = source.meshPerAttribute;\n\n\treturn this;\n\n};\n\n// File:src/core/InterleavedBufferAttribute.js\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nTHREE.InterleavedBufferAttribute = function ( interleavedBuffer, itemSize, offset ) {\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.data = interleavedBuffer;\n\tthis.itemSize = itemSize;\n\tthis.offset = offset;\n\n};\n\n\nTHREE.InterleavedBufferAttribute.prototype = {\n\n\tconstructor: THREE.InterleavedBufferAttribute,\n\n\tget length() {\n\n\t\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );\n\t\treturn this.array.length;\n\n\t},\n\n\tget count() {\n\n\t\treturn this.data.count;\n\n\t},\n\n\tsetX: function ( index, x ) {\n\n\t\tthis.data.array[ index * this.data.stride + this.offset ] = x;\n\n\t\treturn this;\n\n\t},\n\n\tsetY: function ( index, y ) {\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 1 ] = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetZ: function ( index, z ) {\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 2 ] = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetW: function ( index, w ) {\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 3 ] = w;\n\n\t\treturn this;\n\n\t},\n\n\tgetX: function ( index ) {\n\n\t\treturn this.data.array[ index * this.data.stride + this.offset ];\n\n\t},\n\n\tgetY: function ( index ) {\n\n\t\treturn this.data.array[ index * this.data.stride + this.offset + 1 ];\n\n\t},\n\n\tgetZ: function ( index ) {\n\n\t\treturn this.data.array[ index * this.data.stride + this.offset + 2 ];\n\n\t},\n\n\tgetW: function ( index ) {\n\n\t\treturn this.data.array[ index * this.data.stride + this.offset + 3 ];\n\n\t},\n\n\tsetXY: function ( index, x, y ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetXYZ: function ( index, x, y, z ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\t\tthis.data.array[ index + 2 ] = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetXYZW: function ( index, x, y, z, w ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\t\tthis.data.array[ index + 2 ] = z;\n\t\tthis.data.array[ index + 3 ] = w;\n\n\t\treturn this;\n\n\t}\n\n};\n\n// File:src/core/Geometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author kile / http://kile.stravaganza.org/\n * @author alteredq / http://alteredqualia.com/\n * @author mikael emtinger / http://gomo.se/\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author bhouston / http://clara.io\n */\n\nTHREE.Geometry = function () {\n\n\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'Geometry';\n\n\tthis.vertices = [];\n\tthis.colors = [];\n\tthis.faces = [];\n\tthis.faceVertexUvs = [ [] ];\n\n\tthis.morphTargets = [];\n\tthis.morphNormals = [];\n\n\tthis.skinWeights = [];\n\tthis.skinIndices = [];\n\n\tthis.lineDistances = [];\n\n\tthis.boundingBox = null;\n\tthis.boundingSphere = null;\n\n\t// update flags\n\n\tthis.verticesNeedUpdate = false;\n\tthis.elementsNeedUpdate = false;\n\tthis.uvsNeedUpdate = false;\n\tthis.normalsNeedUpdate = false;\n\tthis.colorsNeedUpdate = false;\n\tthis.lineDistancesNeedUpdate = false;\n\tthis.groupsNeedUpdate = false;\n\n};\n\nObject.assign( THREE.Geometry.prototype, THREE.EventDispatcher.prototype, {\n\n\tapplyMatrix: function ( matrix ) {\n\n\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\n\n\t\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\tvar vertex = this.vertices[ i ];\n\t\t\tvertex.applyMatrix4( matrix );\n\n\t\t}\n\n\t\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\tvar face = this.faces[ i ];\n\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\tthis.verticesNeedUpdate = true;\n\t\tthis.normalsNeedUpdate = true;\n\n\t\treturn this;\n\n\t},\n\n\trotateX: function () {\n\n\t\t// rotate geometry around world x-axis\n\n\t\tvar m1;\n\n\t\treturn function rotateX( angle ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeRotationX( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\trotateY: function () {\n\n\t\t// rotate geometry around world y-axis\n\n\t\tvar m1;\n\n\t\treturn function rotateY( angle ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeRotationY( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\trotateZ: function () {\n\n\t\t// rotate geometry around world z-axis\n\n\t\tvar m1;\n\n\t\treturn function rotateZ( angle ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeRotationZ( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslate: function () {\n\n\t\t// translate geometry\n\n\t\tvar m1;\n\n\t\treturn function translate( x, y, z ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeTranslation( x, y, z );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tscale: function () {\n\n\t\t// scale geometry\n\n\t\tvar m1;\n\n\t\treturn function scale( x, y, z ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeScale( x, y, z );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tlookAt: function () {\n\n\t\tvar obj;\n\n\t\treturn function lookAt( vector ) {\n\n\t\t\tif ( obj === undefined ) obj = new THREE.Object3D();\n\n\t\t\tobj.lookAt( vector );\n\n\t\t\tobj.updateMatrix();\n\n\t\t\tthis.applyMatrix( obj.matrix );\n\n\t\t};\n\n\t}(),\n\n\tfromBufferGeometry: function ( geometry ) {\n\n\t\tvar scope = this;\n\n\t\tvar indices = geometry.index !== null ? geometry.index.array : undefined;\n\t\tvar attributes = geometry.attributes;\n\n\t\tvar positions = attributes.position.array;\n\t\tvar normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\n\t\tvar colors = attributes.color !== undefined ? attributes.color.array : undefined;\n\t\tvar uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\n\t\tvar uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;\n\n\t\tif ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];\n\n\t\tvar tempNormals = [];\n\t\tvar tempUVs = [];\n\t\tvar tempUVs2 = [];\n\n\t\tfor ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {\n\n\t\t\tscope.vertices.push( new THREE.Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );\n\n\t\t\tif ( normals !== undefined ) {\n\n\t\t\t\ttempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );\n\n\t\t\t}\n\n\t\t\tif ( colors !== undefined ) {\n\n\t\t\t\tscope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );\n\n\t\t\t}\n\n\t\t\tif ( uvs !== undefined ) {\n\n\t\t\t\ttempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );\n\n\t\t\t}\n\n\t\t\tif ( uvs2 !== undefined ) {\n\n\t\t\t\ttempUVs2.push( new THREE.Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction addFace( a, b, c, materialIndex ) {\n\n\t\t\tvar vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];\n\t\t\tvar vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];\n\n\t\t\tvar face = new THREE.Face3( a, b, c, vertexNormals, vertexColors, materialIndex );\n\n\t\t\tscope.faces.push( face );\n\n\t\t\tif ( uvs !== undefined ) {\n\n\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );\n\n\t\t\t}\n\n\t\t\tif ( uvs2 !== undefined ) {\n\n\t\t\t\tscope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( indices !== undefined ) {\n\n\t\t\tvar groups = geometry.groups;\n\n\t\t\tif ( groups.length > 0 ) {\n\n\t\t\t\tfor ( var i = 0; i < groups.length; i ++ ) {\n\n\t\t\t\t\tvar group = groups[ i ];\n\n\t\t\t\t\tvar start = group.start;\n\t\t\t\t\tvar count = group.count;\n\n\t\t\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\t\t\taddFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex  );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\n\n\t\t\t\t\taddFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( var i = 0; i < positions.length / 3; i += 3 ) {\n\n\t\t\t\taddFace( i, i + 1, i + 2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.computeFaceNormals();\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t}\n\n\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcenter: function () {\n\n\t\tthis.computeBoundingBox();\n\n\t\tvar offset = this.boundingBox.center().negate();\n\n\t\tthis.translate( offset.x, offset.y, offset.z );\n\n\t\treturn offset;\n\n\t},\n\n\tnormalize: function () {\n\n\t\tthis.computeBoundingSphere();\n\n\t\tvar center = this.boundingSphere.center;\n\t\tvar radius = this.boundingSphere.radius;\n\n\t\tvar s = radius === 0 ? 1 : 1.0 / radius;\n\n\t\tvar matrix = new THREE.Matrix4();\n\t\tmatrix.set(\n\t\t\ts, 0, 0, - s * center.x,\n\t\t\t0, s, 0, - s * center.y,\n\t\t\t0, 0, s, - s * center.z,\n\t\t\t0, 0, 0, 1\n\t\t);\n\n\t\tthis.applyMatrix( matrix );\n\n\t\treturn this;\n\n\t},\n\n\tcomputeFaceNormals: function () {\n\n\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\n\n\t\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tvar face = this.faces[ f ];\n\n\t\t\tvar vA = this.vertices[ face.a ];\n\t\t\tvar vB = this.vertices[ face.b ];\n\t\t\tvar vC = this.vertices[ face.c ];\n\n\t\t\tcb.subVectors( vC, vB );\n\t\t\tab.subVectors( vA, vB );\n\t\t\tcb.cross( ab );\n\n\t\t\tcb.normalize();\n\n\t\t\tface.normal.copy( cb );\n\n\t\t}\n\n\t},\n\n\tcomputeVertexNormals: function ( areaWeighted ) {\n\n\t\tif ( areaWeighted === undefined ) areaWeighted = true;\n\n\t\tvar v, vl, f, fl, face, vertices;\n\n\t\tvertices = new Array( this.vertices.length );\n\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\tvertices[ v ] = new THREE.Vector3();\n\n\t\t}\n\n\t\tif ( areaWeighted ) {\n\n\t\t\t// vertex normals weighted by triangle areas\n\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\n\n\t\t\tvar vA, vB, vC;\n\t\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tvA = this.vertices[ face.a ];\n\t\t\t\tvB = this.vertices[ face.b ];\n\t\t\t\tvC = this.vertices[ face.c ];\n\n\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\tcb.cross( ab );\n\n\t\t\t\tvertices[ face.a ].add( cb );\n\t\t\t\tvertices[ face.b ].add( cb );\n\t\t\t\tvertices[ face.c ].add( cb );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tvertices[ face.a ].add( face.normal );\n\t\t\t\tvertices[ face.b ].add( face.normal );\n\t\t\t\tvertices[ face.c ].add( face.normal );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\tvertices[ v ].normalize();\n\n\t\t}\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\tvertexNormals[ 0 ].copy( vertices[ face.a ] );\n\t\t\t\tvertexNormals[ 1 ].copy( vertices[ face.b ] );\n\t\t\t\tvertexNormals[ 2 ].copy( vertices[ face.c ] );\n\n\t\t\t} else {\n\n\t\t\t\tvertexNormals[ 0 ] = vertices[ face.a ].clone();\n\t\t\t\tvertexNormals[ 1 ] = vertices[ face.b ].clone();\n\t\t\t\tvertexNormals[ 2 ] = vertices[ face.c ].clone();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.faces.length > 0 ) {\n\n\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t}\n\n\t},\n\n\tcomputeMorphNormals: function () {\n\n\t\tvar i, il, f, fl, face;\n\n\t\t// save original normals\n\t\t// - create temp variables on first access\n\t\t//   otherwise just copy (for faster repeated calls)\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tif ( ! face.__originalFaceNormal ) {\n\n\t\t\t\tface.__originalFaceNormal = face.normal.clone();\n\n\t\t\t} else {\n\n\t\t\t\tface.__originalFaceNormal.copy( face.normal );\n\n\t\t\t}\n\n\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\n\n\t\t\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\n\n\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\n\n\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// use temp geometry to compute face and vertex normals for each morph\n\n\t\tvar tmpGeo = new THREE.Geometry();\n\t\ttmpGeo.faces = this.faces;\n\n\t\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\n\n\t\t\t// create on first access\n\n\t\t\tif ( ! this.morphNormals[ i ] ) {\n\n\t\t\t\tthis.morphNormals[ i ] = {};\n\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\n\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\n\n\t\t\t\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\n\t\t\t\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\n\n\t\t\t\tvar faceNormal, vertexNormals;\n\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tfaceNormal = new THREE.Vector3();\n\t\t\t\t\tvertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };\n\n\t\t\t\t\tdstNormalsFace.push( faceNormal );\n\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar morphNormals = this.morphNormals[ i ];\n\n\t\t\t// set vertices to morph target\n\n\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\n\n\t\t\t// compute morph normals\n\n\t\t\ttmpGeo.computeFaceNormals();\n\t\t\ttmpGeo.computeVertexNormals();\n\n\t\t\t// store morph normals\n\n\t\t\tvar faceNormal, vertexNormals;\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tfaceNormal = morphNormals.faceNormals[ f ];\n\t\t\t\tvertexNormals = morphNormals.vertexNormals[ f ];\n\n\t\t\t\tfaceNormal.copy( face.normal );\n\n\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\n\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\n\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// restore original normals\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tface.normal = face.__originalFaceNormal;\n\t\t\tface.vertexNormals = face.__originalVertexNormals;\n\n\t\t}\n\n\t},\n\n\tcomputeTangents: function () {\n\n\t\tconsole.warn( 'THREE.Geometry: .computeTangents() has been removed.' );\n\n\t},\n\n\tcomputeLineDistances: function () {\n\n\t\tvar d = 0;\n\t\tvar vertices = this.vertices;\n\n\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\tif ( i > 0 ) {\n\n\t\t\t\td += vertices[ i ].distanceTo( vertices[ i - 1 ] );\n\n\t\t\t}\n\n\t\t\tthis.lineDistances[ i ] = d;\n\n\t\t}\n\n\t},\n\n\tcomputeBoundingBox: function () {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new THREE.Box3();\n\n\t\t}\n\n\t\tthis.boundingBox.setFromPoints( this.vertices );\n\n\t},\n\n\tcomputeBoundingSphere: function () {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new THREE.Sphere();\n\n\t\t}\n\n\t\tthis.boundingSphere.setFromPoints( this.vertices );\n\n\t},\n\n\tmerge: function ( geometry, matrix, materialIndexOffset ) {\n\n\t\tif ( geometry instanceof THREE.Geometry === false ) {\n\n\t\t\tconsole.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar normalMatrix,\n\t\tvertexOffset = this.vertices.length,\n\t\tvertices1 = this.vertices,\n\t\tvertices2 = geometry.vertices,\n\t\tfaces1 = this.faces,\n\t\tfaces2 = geometry.faces,\n\t\tuvs1 = this.faceVertexUvs[ 0 ],\n\t\tuvs2 = geometry.faceVertexUvs[ 0 ];\n\n\t\tif ( materialIndexOffset === undefined ) materialIndexOffset = 0;\n\n\t\tif ( matrix !== undefined ) {\n\n\t\t\tnormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\n\n\t\t}\n\n\t\t// vertices\n\n\t\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\n\n\t\t\tvar vertex = vertices2[ i ];\n\n\t\t\tvar vertexCopy = vertex.clone();\n\n\t\t\tif ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\n\n\t\t\tvertices1.push( vertexCopy );\n\n\t\t}\n\n\t\t// faces\n\n\t\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\n\n\t\t\tvar face = faces2[ i ], faceCopy, normal, color,\n\t\t\tfaceVertexNormals = face.vertexNormals,\n\t\t\tfaceVertexColors = face.vertexColors;\n\n\t\t\tfaceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\n\t\t\tfaceCopy.normal.copy( face.normal );\n\n\t\t\tif ( normalMatrix !== undefined ) {\n\n\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t}\n\n\t\t\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\tnormal = faceVertexNormals[ j ].clone();\n\n\t\t\t\tif ( normalMatrix !== undefined ) {\n\n\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\t}\n\n\t\t\t\tfaceCopy.vertexNormals.push( normal );\n\n\t\t\t}\n\n\t\t\tfaceCopy.color.copy( face.color );\n\n\t\t\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\n\n\t\t\t\tcolor = faceVertexColors[ j ];\n\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\n\n\t\t\t}\n\n\t\t\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n\n\t\t\tfaces1.push( faceCopy );\n\n\t\t}\n\n\t\t// uvs\n\n\t\tfor ( i = 0, il = uvs2.length; i < il; i ++ ) {\n\n\t\t\tvar uv = uvs2[ i ], uvCopy = [];\n\n\t\t\tif ( uv === undefined ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\n\n\t\t\t\tuvCopy.push( uv[ j ].clone() );\n\n\t\t\t}\n\n\t\t\tuvs1.push( uvCopy );\n\n\t\t}\n\n\t},\n\n\tmergeMesh: function ( mesh ) {\n\n\t\tif ( mesh instanceof THREE.Mesh === false ) {\n\n\t\t\tconsole.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );\n\t\t\treturn;\n\n\t\t}\n\n\t\tmesh.matrixAutoUpdate && mesh.updateMatrix();\n\n\t\tthis.merge( mesh.geometry, mesh.matrix );\n\n\t},\n\n\t/*\n\t * Checks for duplicate vertices with hashmap.\n\t * Duplicated vertices are removed\n\t * and faces' vertices are updated.\n\t */\n\n\tmergeVertices: function () {\n\n\t\tvar verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n\t\tvar unique = [], changes = [];\n\n\t\tvar v, key;\n\t\tvar precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n\t\tvar precision = Math.pow( 10, precisionPoints );\n\t\tvar i, il, face;\n\t\tvar indices, j, jl;\n\n\t\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\tv = this.vertices[ i ];\n\t\t\tkey = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\n\n\t\t\tif ( verticesMap[ key ] === undefined ) {\n\n\t\t\t\tverticesMap[ key ] = i;\n\t\t\t\tunique.push( this.vertices[ i ] );\n\t\t\t\tchanges[ i ] = unique.length - 1;\n\n\t\t\t} else {\n\n\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\n\n\t\t\t}\n\n\t\t}\n\n\n\t\t// if faces are completely degenerate after merging vertices, we\n\t\t// have to remove them from the geometry.\n\t\tvar faceIndicesToRemove = [];\n\n\t\tfor ( i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\tface = this.faces[ i ];\n\n\t\t\tface.a = changes[ face.a ];\n\t\t\tface.b = changes[ face.b ];\n\t\t\tface.c = changes[ face.c ];\n\n\t\t\tindices = [ face.a, face.b, face.c ];\n\n\t\t\tvar dupIndex = - 1;\n\n\t\t\t// if any duplicate vertices are found in a Face3\n\t\t\t// we have to remove the face as nothing can be saved\n\t\t\tfor ( var n = 0; n < 3; n ++ ) {\n\n\t\t\t\tif ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {\n\n\t\t\t\t\tdupIndex = n;\n\t\t\t\t\tfaceIndicesToRemove.push( i );\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\n\n\t\t\tvar idx = faceIndicesToRemove[ i ];\n\n\t\t\tthis.faces.splice( idx, 1 );\n\n\t\t\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\tthis.faceVertexUvs[ j ].splice( idx, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Use unique set of vertices\n\n\t\tvar diff = this.vertices.length - unique.length;\n\t\tthis.vertices = unique;\n\t\treturn diff;\n\n\t},\n\n\tsortFacesByMaterialIndex: function () {\n\n\t\tvar faces = this.faces;\n\t\tvar length = faces.length;\n\n\t\t// tag faces\n\n\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\tfaces[ i ]._id = i;\n\n\t\t}\n\n\t\t// sort faces\n\n\t\tfunction materialIndexSort( a, b ) {\n\n\t\t\treturn a.materialIndex - b.materialIndex;\n\n\t\t}\n\n\t\tfaces.sort( materialIndexSort );\n\n\t\t// sort uvs\n\n\t\tvar uvs1 = this.faceVertexUvs[ 0 ];\n\t\tvar uvs2 = this.faceVertexUvs[ 1 ];\n\n\t\tvar newUvs1, newUvs2;\n\n\t\tif ( uvs1 && uvs1.length === length ) newUvs1 = [];\n\t\tif ( uvs2 && uvs2.length === length ) newUvs2 = [];\n\n\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\tvar id = faces[ i ]._id;\n\n\t\t\tif ( newUvs1 ) newUvs1.push( uvs1[ id ] );\n\t\t\tif ( newUvs2 ) newUvs2.push( uvs2[ id ] );\n\n\t\t}\n\n\t\tif ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;\n\t\tif ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;\n\n\t},\n\n\ttoJSON: function () {\n\n\t\tvar data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.4,\n\t\t\t\ttype: 'Geometry',\n\t\t\t\tgenerator: 'Geometry.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard Geometry serialization\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\tif ( this.parameters !== undefined ) {\n\n\t\t\tvar parameters = this.parameters;\n\n\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tvar vertices = [];\n\n\t\tfor ( var i = 0; i < this.vertices.length; i ++ ) {\n\n\t\t\tvar vertex = this.vertices[ i ];\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t}\n\n\t\tvar faces = [];\n\t\tvar normals = [];\n\t\tvar normalsHash = {};\n\t\tvar colors = [];\n\t\tvar colorsHash = {};\n\t\tvar uvs = [];\n\t\tvar uvsHash = {};\n\n\t\tfor ( var i = 0; i < this.faces.length; i ++ ) {\n\n\t\t\tvar face = this.faces[ i ];\n\n\t\t\tvar hasMaterial = true;\n\t\t\tvar hasFaceUv = false; // deprecated\n\t\t\tvar hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\n\t\t\tvar hasFaceNormal = face.normal.length() > 0;\n\t\t\tvar hasFaceVertexNormal = face.vertexNormals.length > 0;\n\t\t\tvar hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n\t\t\tvar hasFaceVertexColor = face.vertexColors.length > 0;\n\n\t\t\tvar faceType = 0;\n\n\t\t\tfaceType = setBit( faceType, 0, 0 ); // isQuad\n\t\t\tfaceType = setBit( faceType, 1, hasMaterial );\n\t\t\tfaceType = setBit( faceType, 2, hasFaceUv );\n\t\t\tfaceType = setBit( faceType, 3, hasFaceVertexUv );\n\t\t\tfaceType = setBit( faceType, 4, hasFaceNormal );\n\t\t\tfaceType = setBit( faceType, 5, hasFaceVertexNormal );\n\t\t\tfaceType = setBit( faceType, 6, hasFaceColor );\n\t\t\tfaceType = setBit( faceType, 7, hasFaceVertexColor );\n\n\t\t\tfaces.push( faceType );\n\t\t\tfaces.push( face.a, face.b, face.c );\n\t\t\tfaces.push( face.materialIndex );\n\n\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\tvar faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 0 ] ),\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 1 ] ),\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 2 ] )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\tfaces.push( getNormalIndex( face.normal ) );\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 0 ] ),\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 1 ] ),\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 2 ] )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\tfaces.push( getColorIndex( face.color ) );\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\tvar vertexColors = face.vertexColors;\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tgetColorIndex( vertexColors[ 0 ] ),\n\t\t\t\t\tgetColorIndex( vertexColors[ 1 ] ),\n\t\t\t\t\tgetColorIndex( vertexColors[ 2 ] )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction setBit( value, position, enabled ) {\n\n\t\t\treturn enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );\n\n\t\t}\n\n\t\tfunction getNormalIndex( normal ) {\n\n\t\t\tvar hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n\n\t\t\tif ( normalsHash[ hash ] !== undefined ) {\n\n\t\t\t\treturn normalsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tnormalsHash[ hash ] = normals.length / 3;\n\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\treturn normalsHash[ hash ];\n\n\t\t}\n\n\t\tfunction getColorIndex( color ) {\n\n\t\t\tvar hash = color.r.toString() + color.g.toString() + color.b.toString();\n\n\t\t\tif ( colorsHash[ hash ] !== undefined ) {\n\n\t\t\t\treturn colorsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tcolorsHash[ hash ] = colors.length;\n\t\t\tcolors.push( color.getHex() );\n\n\t\t\treturn colorsHash[ hash ];\n\n\t\t}\n\n\t\tfunction getUvIndex( uv ) {\n\n\t\t\tvar hash = uv.x.toString() + uv.y.toString();\n\n\t\t\tif ( uvsHash[ hash ] !== undefined ) {\n\n\t\t\t\treturn uvsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tuvsHash[ hash ] = uvs.length / 2;\n\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\treturn uvsHash[ hash ];\n\n\t\t}\n\n\t\tdata.data = {};\n\n\t\tdata.data.vertices = vertices;\n\t\tdata.data.normals = normals;\n\t\tif ( colors.length > 0 ) data.data.colors = colors;\n\t\tif ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility\n\t\tdata.data.faces = faces;\n\n\t\treturn data;\n\n\t},\n\n\tclone: function () {\n\n\t\t/*\n\t\t// Handle primitives\n\n\t\tvar parameters = this.parameters;\n\n\t\tif ( parameters !== undefined ) {\n\n\t\t\tvar values = [];\n\n\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\tvalues.push( parameters[ key ] );\n\n\t\t\t}\n\n\t\t\tvar geometry = Object.create( this.constructor.prototype );\n\t\t\tthis.constructor.apply( geometry, values );\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\treturn new this.constructor().copy( this );\n\t\t*/\n\n\t\treturn new THREE.Geometry().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.vertices = [];\n\t\tthis.faces = [];\n\t\tthis.faceVertexUvs = [ [] ];\n\n\t\tvar vertices = source.vertices;\n\n\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\tthis.vertices.push( vertices[ i ].clone() );\n\n\t\t}\n\n\t\tvar faces = source.faces;\n\n\t\tfor ( var i = 0, il = faces.length; i < il; i ++ ) {\n\n\t\t\tthis.faces.push( faces[ i ].clone() );\n\n\t\t}\n\n\t\tfor ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {\n\n\t\t\tvar faceVertexUvs = source.faceVertexUvs[ i ];\n\n\t\t\tif ( this.faceVertexUvs[ i ] === undefined ) {\n\n\t\t\t\tthis.faceVertexUvs[ i ] = [];\n\n\t\t\t}\n\n\t\t\tfor ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\tvar uvs = faceVertexUvs[ j ], uvsCopy = [];\n\n\t\t\t\tfor ( var k = 0, kl = uvs.length; k < kl; k ++ ) {\n\n\t\t\t\t\tvar uv = uvs[ k ];\n\n\t\t\t\t\tuvsCopy.push( uv.clone() );\n\n\t\t\t\t}\n\n\t\t\t\tthis.faceVertexUvs[ i ].push( uvsCopy );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\nTHREE.GeometryIdCount = 0;\n\n// File:src/core/DirectGeometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.DirectGeometry = function () {\n\n\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'DirectGeometry';\n\n\tthis.indices = [];\n\tthis.vertices = [];\n\tthis.normals = [];\n\tthis.colors = [];\n\tthis.uvs = [];\n\tthis.uvs2 = [];\n\n\tthis.groups = [];\n\n\tthis.morphTargets = {};\n\n\tthis.skinWeights = [];\n\tthis.skinIndices = [];\n\n\t// this.lineDistances = [];\n\n\tthis.boundingBox = null;\n\tthis.boundingSphere = null;\n\n\t// update flags\n\n\tthis.verticesNeedUpdate = false;\n\tthis.normalsNeedUpdate = false;\n\tthis.colorsNeedUpdate = false;\n\tthis.uvsNeedUpdate = false;\n\tthis.groupsNeedUpdate = false;\n\n};\n\nObject.assign( THREE.DirectGeometry.prototype, THREE.EventDispatcher.prototype, {\n\n\tcomputeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,\n\tcomputeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,\n\n\tcomputeFaceNormals: function () {\n\n\t\tconsole.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );\n\n\t},\n\n\tcomputeVertexNormals: function () {\n\n\t\tconsole.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );\n\n\t},\n\n\tcomputeGroups: function ( geometry ) {\n\n\t\tvar group;\n\t\tvar groups = [];\n\t\tvar materialIndex;\n\n\t\tvar faces = geometry.faces;\n\n\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\t// materials\n\n\t\t\tif ( face.materialIndex !== materialIndex ) {\n\n\t\t\t\tmaterialIndex = face.materialIndex;\n\n\t\t\t\tif ( group !== undefined ) {\n\n\t\t\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\t\t\tgroups.push( group );\n\n\t\t\t\t}\n\n\t\t\t\tgroup = {\n\t\t\t\t\tstart: i * 3,\n\t\t\t\t\tmaterialIndex: materialIndex\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( group !== undefined ) {\n\n\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\tgroups.push( group );\n\n\t\t}\n\n\t\tthis.groups = groups;\n\n\t},\n\n\tfromGeometry: function ( geometry ) {\n\n\t\tvar faces = geometry.faces;\n\t\tvar vertices = geometry.vertices;\n\t\tvar faceVertexUvs = geometry.faceVertexUvs;\n\n\t\tvar hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;\n\t\tvar hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;\n\n\t\t// morphs\n\n\t\tvar morphTargets = geometry.morphTargets;\n\t\tvar morphTargetsLength = morphTargets.length;\n\n\t\tvar morphTargetsPosition;\n\n\t\tif ( morphTargetsLength > 0 ) {\n\n\t\t\tmorphTargetsPosition = [];\n\n\t\t\tfor ( var i = 0; i < morphTargetsLength; i ++ ) {\n\n\t\t\t\tmorphTargetsPosition[ i ] = [];\n\n\t\t\t}\n\n\t\t\tthis.morphTargets.position = morphTargetsPosition;\n\n\t\t}\n\n\t\tvar morphNormals = geometry.morphNormals;\n\t\tvar morphNormalsLength = morphNormals.length;\n\n\t\tvar morphTargetsNormal;\n\n\t\tif ( morphNormalsLength > 0 ) {\n\n\t\t\tmorphTargetsNormal = [];\n\n\t\t\tfor ( var i = 0; i < morphNormalsLength; i ++ ) {\n\n\t\t\t\tmorphTargetsNormal[ i ] = [];\n\n\t\t\t}\n\n\t\t\tthis.morphTargets.normal = morphTargetsNormal;\n\n\t\t}\n\n\t\t// skins\n\n\t\tvar skinIndices = geometry.skinIndices;\n\t\tvar skinWeights = geometry.skinWeights;\n\n\t\tvar hasSkinIndices = skinIndices.length === vertices.length;\n\t\tvar hasSkinWeights = skinWeights.length === vertices.length;\n\n\t\t//\n\n\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tthis.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );\n\n\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\tthis.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );\n\n\t\t\t} else {\n\n\t\t\t\tvar normal = face.normal;\n\n\t\t\t\tthis.normals.push( normal, normal, normal );\n\n\t\t\t}\n\n\t\t\tvar vertexColors = face.vertexColors;\n\n\t\t\tif ( vertexColors.length === 3 ) {\n\n\t\t\t\tthis.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );\n\n\t\t\t} else {\n\n\t\t\t\tvar color = face.color;\n\n\t\t\t\tthis.colors.push( color, color, color );\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexUv === true ) {\n\n\t\t\t\tvar vertexUvs = faceVertexUvs[ 0 ][ i ];\n\n\t\t\t\tif ( vertexUvs !== undefined ) {\n\n\t\t\t\t\tthis.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );\n\n\t\t\t\t\tthis.uvs.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexUv2 === true ) {\n\n\t\t\t\tvar vertexUvs = faceVertexUvs[ 1 ][ i ];\n\n\t\t\t\tif ( vertexUvs !== undefined ) {\n\n\t\t\t\t\tthis.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );\n\n\t\t\t\t\tthis.uvs2.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// morphs\n\n\t\t\tfor ( var j = 0; j < morphTargetsLength; j ++ ) {\n\n\t\t\t\tvar morphTarget = morphTargets[ j ].vertices;\n\n\t\t\t\tmorphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );\n\n\t\t\t}\n\n\t\t\tfor ( var j = 0; j < morphNormalsLength; j ++ ) {\n\n\t\t\t\tvar morphNormal = morphNormals[ j ].vertexNormals[ i ];\n\n\t\t\t\tmorphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );\n\n\t\t\t}\n\n\t\t\t// skins\n\n\t\t\tif ( hasSkinIndices ) {\n\n\t\t\t\tthis.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );\n\n\t\t\t}\n\n\t\t\tif ( hasSkinWeights ) {\n\n\t\t\t\tthis.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.computeGroups( geometry );\n\n\t\tthis.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\tthis.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\tthis.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\tthis.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\tthis.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n\t\treturn this;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\n// File:src/core/BufferGeometry.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.BufferGeometry = function () {\n\n\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'BufferGeometry';\n\n\tthis.index = null;\n\tthis.attributes = {};\n\n\tthis.morphAttributes = {};\n\n\tthis.groups = [];\n\n\tthis.boundingBox = null;\n\tthis.boundingSphere = null;\n\n\tthis.drawRange = { start: 0, count: Infinity };\n\n};\n\nObject.assign( THREE.BufferGeometry.prototype, THREE.EventDispatcher.prototype, {\n\n\tgetIndex: function () {\n\n\t\treturn this.index;\n\n\t},\n\n\tsetIndex: function ( index ) {\n\n\t\tthis.index = index;\n\n\t},\n\n\taddAttribute: function ( name, attribute ) {\n\n\t\tif ( attribute instanceof THREE.BufferAttribute === false && attribute instanceof THREE.InterleavedBufferAttribute === false ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );\n\n\t\t\tthis.addAttribute( name, new THREE.BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( name === 'index' ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );\n\t\t\tthis.setIndex( attribute );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t},\n\n\tgetAttribute: function ( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t},\n\n\tremoveAttribute: function ( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t},\n\n\taddGroup: function ( start, count, materialIndex ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex !== undefined ? materialIndex : 0\n\n\t\t} );\n\n\t},\n\n\tclearGroups: function () {\n\n\t\tthis.groups = [];\n\n\t},\n\n\tsetDrawRange: function ( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t},\n\n\tapplyMatrix: function ( matrix ) {\n\n\t\tvar position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tmatrix.applyToVector3Array( position.array );\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tvar normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormalMatrix.applyToVector3Array( normal.array );\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\trotateX: function () {\n\n\t\t// rotate geometry around world x-axis\n\n\t\tvar m1;\n\n\t\treturn function rotateX( angle ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeRotationX( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\trotateY: function () {\n\n\t\t// rotate geometry around world y-axis\n\n\t\tvar m1;\n\n\t\treturn function rotateY( angle ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeRotationY( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\trotateZ: function () {\n\n\t\t// rotate geometry around world z-axis\n\n\t\tvar m1;\n\n\t\treturn function rotateZ( angle ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeRotationZ( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslate: function () {\n\n\t\t// translate geometry\n\n\t\tvar m1;\n\n\t\treturn function translate( x, y, z ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeTranslation( x, y, z );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tscale: function () {\n\n\t\t// scale geometry\n\n\t\tvar m1;\n\n\t\treturn function scale( x, y, z ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeScale( x, y, z );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tlookAt: function () {\n\n\t\tvar obj;\n\n\t\treturn function lookAt( vector ) {\n\n\t\t\tif ( obj === undefined ) obj = new THREE.Object3D();\n\n\t\t\tobj.lookAt( vector );\n\n\t\t\tobj.updateMatrix();\n\n\t\t\tthis.applyMatrix( obj.matrix );\n\n\t\t};\n\n\t}(),\n\n\tcenter: function () {\n\n\t\tthis.computeBoundingBox();\n\n\t\tvar offset = this.boundingBox.center().negate();\n\n\t\tthis.translate( offset.x, offset.y, offset.z );\n\n\t\treturn offset;\n\n\t},\n\n\tsetFromObject: function ( object ) {\n\n\t\t// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );\n\n\t\tvar geometry = object.geometry;\n\n\t\tif ( object instanceof THREE.Points || object instanceof THREE.Line ) {\n\n\t\t\tvar positions = new THREE.Float32Attribute( geometry.vertices.length * 3, 3 );\n\t\t\tvar colors = new THREE.Float32Attribute( geometry.colors.length * 3, 3 );\n\n\t\t\tthis.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );\n\t\t\tthis.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );\n\n\t\t\tif ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {\n\n\t\t\t\tvar lineDistances = new THREE.Float32Attribute( geometry.lineDistances.length, 1 );\n\n\t\t\t\tthis.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );\n\n\t\t\t}\n\n\t\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t\t}\n\n\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t\t}\n\n\t\t} else if ( object instanceof THREE.Mesh ) {\n\n\t\t\tif ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\tthis.fromGeometry( geometry );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tupdateFromObject: function ( object ) {\n\n\t\tvar geometry = object.geometry;\n\n\t\tif ( object instanceof THREE.Mesh ) {\n\n\t\t\tvar direct = geometry.__directGeometry;\n\n\t\t\tif ( direct === undefined ) {\n\n\t\t\t\treturn this.fromGeometry( geometry );\n\n\t\t\t}\n\n\t\t\tdirect.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\t\tdirect.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\t\tdirect.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\t\tdirect.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\t\tdirect.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n\t\t\tgeometry.verticesNeedUpdate = false;\n\t\t\tgeometry.normalsNeedUpdate = false;\n\t\t\tgeometry.colorsNeedUpdate = false;\n\t\t\tgeometry.uvsNeedUpdate = false;\n\t\t\tgeometry.groupsNeedUpdate = false;\n\n\t\t\tgeometry = direct;\n\n\t\t}\n\n\t\tif ( geometry.verticesNeedUpdate === true ) {\n\n\t\t\tvar attribute = this.attributes.position;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyVector3sArray( geometry.vertices );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.verticesNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.normalsNeedUpdate === true ) {\n\n\t\t\tvar attribute = this.attributes.normal;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyVector3sArray( geometry.normals );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.normalsNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.colorsNeedUpdate === true ) {\n\n\t\t\tvar attribute = this.attributes.color;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyColorsArray( geometry.colors );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.colorsNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.uvsNeedUpdate ) {\n\n\t\t\tvar attribute = this.attributes.uv;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyVector2sArray( geometry.uvs );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.uvsNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.lineDistancesNeedUpdate ) {\n\n\t\t\tvar attribute = this.attributes.lineDistance;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyArray( geometry.lineDistances );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.lineDistancesNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.groupsNeedUpdate ) {\n\n\t\t\tgeometry.computeGroups( object.geometry );\n\t\t\tthis.groups = geometry.groups;\n\n\t\t\tgeometry.groupsNeedUpdate = false;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tfromGeometry: function ( geometry ) {\n\n\t\tgeometry.__directGeometry = new THREE.DirectGeometry().fromGeometry( geometry );\n\n\t\treturn this.fromDirectGeometry( geometry.__directGeometry );\n\n\t},\n\n\tfromDirectGeometry: function ( geometry ) {\n\n\t\tvar positions = new Float32Array( geometry.vertices.length * 3 );\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\n\n\t\tif ( geometry.normals.length > 0 ) {\n\n\t\t\tvar normals = new Float32Array( geometry.normals.length * 3 );\n\t\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\n\n\t\t}\n\n\t\tif ( geometry.colors.length > 0 ) {\n\n\t\t\tvar colors = new Float32Array( geometry.colors.length * 3 );\n\t\t\tthis.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\n\n\t\t}\n\n\t\tif ( geometry.uvs.length > 0 ) {\n\n\t\t\tvar uvs = new Float32Array( geometry.uvs.length * 2 );\n\t\t\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\n\n\t\t}\n\n\t\tif ( geometry.uvs2.length > 0 ) {\n\n\t\t\tvar uvs2 = new Float32Array( geometry.uvs2.length * 2 );\n\t\t\tthis.addAttribute( 'uv2', new THREE.BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\n\n\t\t}\n\n\t\tif ( geometry.indices.length > 0 ) {\n\n\t\t\tvar TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;\n\t\t\tvar indices = new TypeArray( geometry.indices.length * 3 );\n\t\t\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );\n\n\t\t}\n\n\t\t// groups\n\n\t\tthis.groups = geometry.groups;\n\n\t\t// morphs\n\n\t\tfor ( var name in geometry.morphTargets ) {\n\n\t\t\tvar array = [];\n\t\t\tvar morphTargets = geometry.morphTargets[ name ];\n\n\t\t\tfor ( var i = 0, l = morphTargets.length; i < l; i ++ ) {\n\n\t\t\t\tvar morphTarget = morphTargets[ i ];\n\n\t\t\t\tvar attribute = new THREE.Float32Attribute( morphTarget.length * 3, 3 );\n\n\t\t\t\tarray.push( attribute.copyVector3sArray( morphTarget ) );\n\n\t\t\t}\n\n\t\t\tthis.morphAttributes[ name ] = array;\n\n\t\t}\n\n\t\t// skinning\n\n\t\tif ( geometry.skinIndices.length > 0 ) {\n\n\t\t\tvar skinIndices = new THREE.Float32Attribute( geometry.skinIndices.length * 4, 4 );\n\t\t\tthis.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );\n\n\t\t}\n\n\t\tif ( geometry.skinWeights.length > 0 ) {\n\n\t\t\tvar skinWeights = new THREE.Float32Attribute( geometry.skinWeights.length * 4, 4 );\n\t\t\tthis.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t}\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcomputeBoundingBox: function () {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new THREE.Box3();\n\n\t\t}\n\n\t\tvar positions = this.attributes.position.array;\n\n\t\tif ( positions !== undefined ) {\n\n\t\t\tthis.boundingBox.setFromArray( positions );\n\n\t\t} else {\n\n\t\t\tthis.boundingBox.makeEmpty();\n\n\t\t}\n\n\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t}\n\n\t},\n\n\tcomputeBoundingSphere: function () {\n\n\t\tvar box = new THREE.Box3();\n\t\tvar vector = new THREE.Vector3();\n\n\t\treturn function computeBoundingSphere() {\n\n\t\t\tif ( this.boundingSphere === null ) {\n\n\t\t\t\tthis.boundingSphere = new THREE.Sphere();\n\n\t\t\t}\n\n\t\t\tvar positions = this.attributes.position;\n\n\t\t\tif ( positions ) {\n\n\t\t\t\tvar array = positions.array;\n\t\t\t\tvar center = this.boundingSphere.center;\n\n\t\t\t\tbox.setFromArray( array );\n\t\t\t\tbox.center( center );\n\n\t\t\t\t// hoping to find a boundingSphere with a radius smaller than the\n\t\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\t\t\t\tvar maxRadiusSq = 0;\n\n\t\t\t\tfor ( var i = 0, il = array.length; i < il; i += 3 ) {\n\n\t\t\t\t\tvector.fromArray( array, i );\n\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\n\n\t\t\t\t}\n\n\t\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}(),\n\n\tcomputeFaceNormals: function () {\n\n\t\t// backwards compatibility\n\n\t},\n\n\tcomputeVertexNormals: function () {\n\n\t\tvar index = this.index;\n\t\tvar attributes = this.attributes;\n\t\tvar groups = this.groups;\n\n\t\tif ( attributes.position ) {\n\n\t\t\tvar positions = attributes.position.array;\n\n\t\t\tif ( attributes.normal === undefined ) {\n\n\t\t\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );\n\n\t\t\t} else {\n\n\t\t\t\t// reset existing normals to zero\n\n\t\t\t\tvar array = attributes.normal.array;\n\n\t\t\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\n\n\t\t\t\t\tarray[ i ] = 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar normals = attributes.normal.array;\n\n\t\t\tvar vA, vB, vC,\n\n\t\t\tpA = new THREE.Vector3(),\n\t\t\tpB = new THREE.Vector3(),\n\t\t\tpC = new THREE.Vector3(),\n\n\t\t\tcb = new THREE.Vector3(),\n\t\t\tab = new THREE.Vector3();\n\n\t\t\t// indexed elements\n\n\t\t\tif ( index ) {\n\n\t\t\t\tvar indices = index.array;\n\n\t\t\t\tif ( groups.length === 0 ) {\n\n\t\t\t\t\tthis.addGroup( 0, indices.length );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var j = 0, jl = groups.length; j < jl; ++ j ) {\n\n\t\t\t\t\tvar group = groups[ j ];\n\n\t\t\t\t\tvar start = group.start;\n\t\t\t\t\tvar count = group.count;\n\n\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\n\n\t\t\t\t\t\tvA = indices[ i + 0 ] * 3;\n\t\t\t\t\t\tvB = indices[ i + 1 ] * 3;\n\t\t\t\t\t\tvC = indices[ i + 2 ] * 3;\n\n\t\t\t\t\t\tpA.fromArray( positions, vA );\n\t\t\t\t\t\tpB.fromArray( positions, vB );\n\t\t\t\t\t\tpC.fromArray( positions, vC );\n\n\t\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\t\tnormals[ vA ] += cb.x;\n\t\t\t\t\t\tnormals[ vA + 1 ] += cb.y;\n\t\t\t\t\t\tnormals[ vA + 2 ] += cb.z;\n\n\t\t\t\t\t\tnormals[ vB ] += cb.x;\n\t\t\t\t\t\tnormals[ vB + 1 ] += cb.y;\n\t\t\t\t\t\tnormals[ vB + 2 ] += cb.z;\n\n\t\t\t\t\t\tnormals[ vC ] += cb.x;\n\t\t\t\t\t\tnormals[ vC + 1 ] += cb.y;\n\t\t\t\t\t\tnormals[ vC + 2 ] += cb.z;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\n\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 9 ) {\n\n\t\t\t\t\tpA.fromArray( positions, i );\n\t\t\t\t\tpB.fromArray( positions, i + 3 );\n\t\t\t\t\tpC.fromArray( positions, i + 6 );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnormals[ i ] = cb.x;\n\t\t\t\t\tnormals[ i + 1 ] = cb.y;\n\t\t\t\t\tnormals[ i + 2 ] = cb.z;\n\n\t\t\t\t\tnormals[ i + 3 ] = cb.x;\n\t\t\t\t\tnormals[ i + 4 ] = cb.y;\n\t\t\t\t\tnormals[ i + 5 ] = cb.z;\n\n\t\t\t\t\tnormals[ i + 6 ] = cb.x;\n\t\t\t\t\tnormals[ i + 7 ] = cb.y;\n\t\t\t\t\tnormals[ i + 8 ] = cb.z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.normalizeNormals();\n\n\t\t\tattributes.normal.needsUpdate = true;\n\n\t\t}\n\n\t},\n\n\tmerge: function ( geometry, offset ) {\n\n\t\tif ( geometry instanceof THREE.BufferGeometry === false ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tvar attributes = this.attributes;\n\n\t\tfor ( var key in attributes ) {\n\n\t\t\tif ( geometry.attributes[ key ] === undefined ) continue;\n\n\t\t\tvar attribute1 = attributes[ key ];\n\t\t\tvar attributeArray1 = attribute1.array;\n\n\t\t\tvar attribute2 = geometry.attributes[ key ];\n\t\t\tvar attributeArray2 = attribute2.array;\n\n\t\t\tvar attributeSize = attribute2.itemSize;\n\n\t\t\tfor ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {\n\n\t\t\t\tattributeArray1[ j ] = attributeArray2[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tnormalizeNormals: function () {\n\n\t\tvar normals = this.attributes.normal.array;\n\n\t\tvar x, y, z, n;\n\n\t\tfor ( var i = 0, il = normals.length; i < il; i += 3 ) {\n\n\t\t\tx = normals[ i ];\n\t\t\ty = normals[ i + 1 ];\n\t\t\tz = normals[ i + 2 ];\n\n\t\t\tn = 1.0 / Math.sqrt( x * x + y * y + z * z );\n\n\t\t\tnormals[ i ] *= n;\n\t\t\tnormals[ i + 1 ] *= n;\n\t\t\tnormals[ i + 2 ] *= n;\n\n\t\t}\n\n\t},\n\n\ttoNonIndexed: function () {\n\n\t\tif ( this.index === null ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tvar geometry2 = new THREE.BufferGeometry();\n\n\t\tvar indices = this.index.array;\n\t\tvar attributes = this.attributes;\n\n\t\tfor ( var name in attributes ) {\n\n\t\t\tvar attribute = attributes[ name ];\n\n\t\t\tvar array = attribute.array;\n\t\t\tvar itemSize = attribute.itemSize;\n\n\t\t\tvar array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\tvar index = 0, index2 = 0;\n\n\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\tfor ( var j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgeometry2.addAttribute( name, new THREE.BufferAttribute( array2, itemSize ) );\n\n\t\t}\n\n\t\treturn geometry2;\n\n\t},\n\n\ttoJSON: function () {\n\n\t\tvar data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.4,\n\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard BufferGeometry serialization\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\tif ( this.parameters !== undefined ) {\n\n\t\t\tvar parameters = this.parameters;\n\n\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tdata.data = { attributes: {} };\n\n\t\tvar index = this.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tvar array = Array.prototype.slice.call( index.array );\n\n\t\t\tdata.data.index = {\n\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\tarray: array\n\t\t\t};\n\n\t\t}\n\n\t\tvar attributes = this.attributes;\n\n\t\tfor ( var key in attributes ) {\n\n\t\t\tvar attribute = attributes[ key ];\n\n\t\t\tvar array = Array.prototype.slice.call( attribute.array );\n\n\t\t\tdata.data.attributes[ key ] = {\n\t\t\t\titemSize: attribute.itemSize,\n\t\t\t\ttype: attribute.array.constructor.name,\n\t\t\t\tarray: array,\n\t\t\t\tnormalized: attribute.normalized\n\t\t\t};\n\n\t\t}\n\n\t\tvar groups = this.groups;\n\n\t\tif ( groups.length > 0 ) {\n\n\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\n\n\t\t}\n\n\t\tvar boundingSphere = this.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tdata.data.boundingSphere = {\n\t\t\t\tcenter: boundingSphere.center.toArray(),\n\t\t\t\tradius: boundingSphere.radius\n\t\t\t};\n\n\t\t}\n\n\t\treturn data;\n\n\t},\n\n\tclone: function () {\n\n\t\t/*\n\t\t// Handle primitives\n\n\t\tvar parameters = this.parameters;\n\n\t\tif ( parameters !== undefined ) {\n\n\t\t\tvar values = [];\n\n\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\tvalues.push( parameters[ key ] );\n\n\t\t\t}\n\n\t\t\tvar geometry = Object.create( this.constructor.prototype );\n\t\t\tthis.constructor.apply( geometry, values );\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\treturn new this.constructor().copy( this );\n\t\t*/\n\n\t\treturn new THREE.BufferGeometry().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tvar index = source.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tthis.setIndex( index.clone() );\n\n\t\t}\n\n\t\tvar attributes = source.attributes;\n\n\t\tfor ( var name in attributes ) {\n\n\t\t\tvar attribute = attributes[ name ];\n\t\t\tthis.addAttribute( name, attribute.clone() );\n\n\t\t}\n\n\t\tvar groups = source.groups;\n\n\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tvar group = groups[ i ];\n\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\nTHREE.BufferGeometry.MaxIndex = 65535;\n\n// File:src/core/InstancedBufferGeometry.js\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nTHREE.InstancedBufferGeometry = function () {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'InstancedBufferGeometry';\n\tthis.maxInstancedCount = undefined;\n\n};\n\nTHREE.InstancedBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry;\n\nTHREE.InstancedBufferGeometry.prototype.addGroup = function ( start, count, instances ) {\n\n\tthis.groups.push( {\n\n\t\tstart: start,\n\t\tcount: count,\n\t\tinstances: instances\n\n\t} );\n\n};\n\nTHREE.InstancedBufferGeometry.prototype.copy = function ( source ) {\n\n\tvar index = source.index;\n\n\tif ( index !== null ) {\n\n\t\tthis.setIndex( index.clone() );\n\n\t}\n\n\tvar attributes = source.attributes;\n\n\tfor ( var name in attributes ) {\n\n\t\tvar attribute = attributes[ name ];\n\t\tthis.addAttribute( name, attribute.clone() );\n\n\t}\n\n\tvar groups = source.groups;\n\n\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\tvar group = groups[ i ];\n\t\tthis.addGroup( group.start, group.count, group.instances );\n\n\t}\n\n\treturn this;\n\n};\n\n// File:src/core/Uniform.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Uniform = function ( value ) {\n\n\tif ( typeof value === 'string' ) {\n\n\t\tconsole.warn( 'THREE.Uniform: Type parameter is no longer needed.' );\n\t\tvalue = arguments[ 1 ];\n\n\t}\n\n\tthis.value = value;\n\n\tthis.dynamic = false;\n\n};\n\nTHREE.Uniform.prototype = {\n\n\tconstructor: THREE.Uniform,\n\n\tonUpdate: function ( callback ) {\n\n\t\tthis.dynamic = true;\n\t\tthis.onUpdateCallback = callback;\n\n\t\treturn this;\n\n\t}\n\n};\n\n// File:src/animation/AnimationAction.js\n\n/**\n *\n * Action provided by AnimationMixer for scheduling clip playback on specific\n * objects.\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n *\n */\n\nTHREE.AnimationAction = function() {\n\n\tthrow new Error( \"THREE.AnimationAction: \" +\n\t\t\t\"Use mixer.clipAction for construction.\" );\n\n};\n\nTHREE.AnimationAction._new =\n\t\tfunction AnimationAction( mixer, clip, localRoot ) {\n\n\tthis._mixer = mixer;\n\tthis._clip = clip;\n\tthis._localRoot = localRoot || null;\n\n\tvar tracks = clip.tracks,\n\t\tnTracks = tracks.length,\n\t\tinterpolants = new Array( nTracks );\n\n\tvar interpolantSettings = {\n\t\t\tendingStart: \tTHREE.ZeroCurvatureEnding,\n\t\t\tendingEnd:\t\tTHREE.ZeroCurvatureEnding\n\t};\n\n\tfor ( var i = 0; i !== nTracks; ++ i ) {\n\n\t\tvar interpolant = tracks[ i ].createInterpolant( null );\n\t\tinterpolants[ i ] = interpolant;\n\t\tinterpolant.settings = interpolantSettings;\n\n\t}\n\n\tthis._interpolantSettings = interpolantSettings;\n\n\tthis._interpolants = interpolants;\t// bound by the mixer\n\n\t// inside: PropertyMixer (managed by the mixer)\n\tthis._propertyBindings = new Array( nTracks );\n\n\tthis._cacheIndex = null;\t\t\t// for the memory manager\n\tthis._byClipCacheIndex = null;\t\t// for the memory manager\n\n\tthis._timeScaleInterpolant = null;\n\tthis._weightInterpolant = null;\n\n\tthis.loop = THREE.LoopRepeat;\n\tthis._loopCount = -1;\n\n\t// global mixer time when the action is to be started\n\t// it's set back to 'null' upon start of the action\n\tthis._startTime = null;\n\n\t// scaled local time of the action\n\t// gets clamped or wrapped to 0..clip.duration according to loop\n\tthis.time = 0;\n\n\tthis.timeScale = 1;\n\tthis._effectiveTimeScale = 1;\n\n\tthis.weight = 1;\n\tthis._effectiveWeight = 1;\n\n\tthis.repetitions = Infinity; \t\t// no. of repetitions when looping\n\n\tthis.paused = false;\t\t\t\t// false -> zero effective time scale\n\tthis.enabled = true;\t\t\t\t// true -> zero effective weight\n\n\tthis.clampWhenFinished \t= false;\t// keep feeding the last frame?\n\n\tthis.zeroSlopeAtStart \t= true;\t\t// for smooth interpolation w/o separate\n\tthis.zeroSlopeAtEnd\t\t= true;\t\t// clips for start, loop and end\n\n};\n\nTHREE.AnimationAction._new.prototype = {\n\n\tconstructor: THREE.AnimationAction._new,\n\n\t// State & Scheduling\n\n\tplay: function() {\n\n\t\tthis._mixer._activateAction( this );\n\n\t\treturn this;\n\n\t},\n\n\tstop: function() {\n\n\t\tthis._mixer._deactivateAction( this );\n\n\t\treturn this.reset();\n\n\t},\n\n\treset: function() {\n\n\t\tthis.paused = false;\n\t\tthis.enabled = true;\n\n\t\tthis.time = 0;\t\t\t// restart clip\n\t\tthis._loopCount = -1;\t// forget previous loops\n\t\tthis._startTime = null;\t// forget scheduling\n\n\t\treturn this.stopFading().stopWarping();\n\n\t},\n\n\tisRunning: function() {\n\n\t\tvar start = this._startTime;\n\n\t\treturn this.enabled && ! this.paused && this.timeScale !== 0 &&\n\t\t\t\tthis._startTime === null && this._mixer._isActiveAction( this );\n\n\t},\n\n\t// return true when play has been called\n\tisScheduled: function() {\n\n\t\treturn this._mixer._isActiveAction( this );\n\n\t},\n\n\tstartAt: function( time ) {\n\n\t\tthis._startTime = time;\n\n\t\treturn this;\n\n\t},\n\n\tsetLoop: function( mode, repetitions ) {\n\n\t\tthis.loop = mode;\n\t\tthis.repetitions = repetitions;\n\n\t\treturn this;\n\n\t},\n\n\t// Weight\n\n\t// set the weight stopping any scheduled fading\n\t// although .enabled = false yields an effective weight of zero, this\n\t// method does *not* change .enabled, because it would be confusing\n\tsetEffectiveWeight: function( weight ) {\n\n\t\tthis.weight = weight;\n\n\t\t// note: same logic as when updated at runtime\n\t\tthis._effectiveWeight = this.enabled ? weight : 0;\n\n\t\treturn this.stopFading();\n\n\t},\n\n\t// return the weight considering fading and .enabled\n\tgetEffectiveWeight: function() {\n\n\t\treturn this._effectiveWeight;\n\n\t},\n\n\tfadeIn: function( duration ) {\n\n\t\treturn this._scheduleFading( duration, 0, 1 );\n\n\t},\n\n\tfadeOut: function( duration ) {\n\n\t\treturn this._scheduleFading( duration, 1, 0 );\n\n\t},\n\n\tcrossFadeFrom: function( fadeOutAction, duration, warp ) {\n\n\t\tvar mixer = this._mixer;\n\n\t\tfadeOutAction.fadeOut( duration );\n\t\tthis.fadeIn( duration );\n\n\t\tif( warp ) {\n\n\t\t\tvar fadeInDuration = this._clip.duration,\n\t\t\t\tfadeOutDuration = fadeOutAction._clip.duration,\n\n\t\t\t\tstartEndRatio = fadeOutDuration / fadeInDuration,\n\t\t\t\tendStartRatio = fadeInDuration / fadeOutDuration;\n\n\t\t\tfadeOutAction.warp( 1.0, startEndRatio, duration );\n\t\t\tthis.warp( endStartRatio, 1.0, duration );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcrossFadeTo: function( fadeInAction, duration, warp ) {\n\n\t\treturn fadeInAction.crossFadeFrom( this, duration, warp );\n\n\t},\n\n\tstopFading: function() {\n\n\t\tvar weightInterpolant = this._weightInterpolant;\n\n\t\tif ( weightInterpolant !== null ) {\n\n\t\t\tthis._weightInterpolant = null;\n\t\t\tthis._mixer._takeBackControlInterpolant( weightInterpolant );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// Time Scale Control\n\n\t// set the weight stopping any scheduled warping\n\t// although .paused = true yields an effective time scale of zero, this\n\t// method does *not* change .paused, because it would be confusing\n\tsetEffectiveTimeScale: function( timeScale ) {\n\n\t\tthis.timeScale = timeScale;\n\t\tthis._effectiveTimeScale = this.paused ? 0 :timeScale;\n\n\t\treturn this.stopWarping();\n\n\t},\n\n\t// return the time scale considering warping and .paused\n\tgetEffectiveTimeScale: function() {\n\n\t\treturn this._effectiveTimeScale;\n\n\t},\n\n\tsetDuration: function( duration ) {\n\n\t\tthis.timeScale = this._clip.duration / duration;\n\n\t\treturn this.stopWarping();\n\n\t},\n\n\tsyncWith: function( action ) {\n\n\t\tthis.time = action.time;\n\t\tthis.timeScale = action.timeScale;\n\n\t\treturn this.stopWarping();\n\n\t},\n\n\thalt: function( duration ) {\n\n\t\treturn this.warp( this._effectiveTimeScale, 0, duration );\n\n\t},\n\n\twarp: function( startTimeScale, endTimeScale, duration ) {\n\n\t\tvar mixer = this._mixer, now = mixer.time,\n\t\t\tinterpolant = this._timeScaleInterpolant,\n\n\t\t\ttimeScale = this.timeScale;\n\n\t\tif ( interpolant === null ) {\n\n\t\t\tinterpolant = mixer._lendControlInterpolant(),\n\t\t\tthis._timeScaleInterpolant = interpolant;\n\n\t\t}\n\n\t\tvar times = interpolant.parameterPositions,\n\t\t\tvalues = interpolant.sampleValues;\n\n\t\ttimes[ 0 ] = now;\n\t\ttimes[ 1 ] = now + duration;\n\n\t\tvalues[ 0 ] = startTimeScale / timeScale;\n\t\tvalues[ 1 ] = endTimeScale / timeScale;\n\n\t\treturn this;\n\n\t},\n\n\tstopWarping: function() {\n\n\t\tvar timeScaleInterpolant = this._timeScaleInterpolant;\n\n\t\tif ( timeScaleInterpolant !== null ) {\n\n\t\t\tthis._timeScaleInterpolant = null;\n\t\t\tthis._mixer._takeBackControlInterpolant( timeScaleInterpolant );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// Object Accessors\n\n\tgetMixer: function() {\n\n\t\treturn this._mixer;\n\n\t},\n\n\tgetClip: function() {\n\n\t\treturn this._clip;\n\n\t},\n\n\tgetRoot: function() {\n\n\t\treturn this._localRoot || this._mixer._root;\n\n\t},\n\n\t// Interna\n\n\t_update: function( time, deltaTime, timeDirection, accuIndex ) {\n\t\t// called by the mixer\n\n\t\tvar startTime = this._startTime;\n\n\t\tif ( startTime !== null ) {\n\n\t\t\t// check for scheduled start of action\n\n\t\t\tvar timeRunning = ( time - startTime ) * timeDirection;\n\t\t\tif ( timeRunning < 0 || timeDirection === 0 ) {\n\n\t\t\t\treturn; // yet to come / don't decide when delta = 0\n\n\t\t\t}\n\n\t\t\t// start\n\n\t\t\tthis._startTime = null; // unschedule\n\t\t\tdeltaTime = timeDirection * timeRunning;\n\n\t\t}\n\n\t\t// apply time scale and advance time\n\n\t\tdeltaTime *= this._updateTimeScale( time );\n\t\tvar clipTime = this._updateTime( deltaTime );\n\n\t\t// note: _updateTime may disable the action resulting in\n\t\t// an effective weight of 0\n\n\t\tvar weight = this._updateWeight( time );\n\n\t\tif ( weight > 0 ) {\n\n\t\t\tvar interpolants = this._interpolants;\n\t\t\tvar propertyMixers = this._propertyBindings;\n\n\t\t\tfor ( var j = 0, m = interpolants.length; j !== m; ++ j ) {\n\n\t\t\t\tinterpolants[ j ].evaluate( clipTime );\n\t\t\t\tpropertyMixers[ j ].accumulate( accuIndex, weight );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t_updateWeight: function( time ) {\n\n\t\tvar weight = 0;\n\n\t\tif ( this.enabled ) {\n\n\t\t\tweight = this.weight;\n\t\t\tvar interpolant = this._weightInterpolant;\n\n\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\tweight *= interpolantValue;\n\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\tthis.stopFading();\n\n\t\t\t\t\tif ( interpolantValue === 0 ) {\n\n\t\t\t\t\t\t// faded out, disable\n\t\t\t\t\t\tthis.enabled = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._effectiveWeight = weight;\n\t\treturn weight;\n\n\t},\n\n\t_updateTimeScale: function( time ) {\n\n\t\tvar timeScale = 0;\n\n\t\tif ( ! this.paused ) {\n\n\t\t\ttimeScale = this.timeScale;\n\n\t\t\tvar interpolant = this._timeScaleInterpolant;\n\n\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\ttimeScale *= interpolantValue;\n\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\tthis.stopWarping();\n\n\t\t\t\t\tif ( timeScale === 0 ) {\n\n\t\t\t\t\t\t// motion has halted, pause\n\t\t\t\t\t\tthis.paused = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// warp done - apply final time scale\n\t\t\t\t\t\tthis.timeScale = timeScale;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._effectiveTimeScale = timeScale;\n\t\treturn timeScale;\n\n\t},\n\n\t_updateTime: function( deltaTime ) {\n\n\t\tvar time = this.time + deltaTime;\n\n\t\tif ( deltaTime === 0 ) return time;\n\n\t\tvar duration = this._clip.duration,\n\n\t\t\tloop = this.loop,\n\t\t\tloopCount = this._loopCount;\n\n\t\tif ( loop === THREE.LoopOnce ) {\n\n\t\t\tif ( loopCount === -1 ) {\n\t\t\t\t// just started\n\n\t\t\t\tthis.loopCount = 0;\n\t\t\t\tthis._setEndings( true, true, false );\n\n\t\t\t}\n\n\t\t\thandle_stop: {\n\n\t\t\t\tif ( time >= duration ) {\n\n\t\t\t\t\ttime = duration;\n\n\t\t\t\t} else if ( time < 0 ) {\n\n\t\t\t\t\ttime = 0;\n\n\t\t\t\t} else break handle_stop;\n\n\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\telse this.enabled = false;\n\n\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\tdirection: deltaTime < 0 ? -1 : 1\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} else { // repetitive Repeat or PingPong\n\n\t\t\tvar pingPong = ( loop === THREE.LoopPingPong );\n\n\t\t\tif ( loopCount === -1 ) {\n\t\t\t\t// just started\n\n\t\t\t\tif ( deltaTime >= 0 ) {\n\n\t\t\t\t\tloopCount = 0;\n\n\t\t\t\t\tthis._setEndings(\n\t\t\t\t\t\t\ttrue, this.repetitions === 0, pingPong );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// when looping in reverse direction, the initial\n\t\t\t\t\t// transition through zero counts as a repetition,\n\t\t\t\t\t// so leave loopCount at -1\n\n\t\t\t\t\tthis._setEndings(\n\t\t\t\t\t\t\tthis.repetitions === 0, true, pingPong );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( time >= duration || time < 0 ) {\n\t\t\t\t// wrap around\n\n\t\t\t\tvar loopDelta = Math.floor( time / duration ); // signed\n\t\t\t\ttime -= duration * loopDelta;\n\n\t\t\t\tloopCount += Math.abs( loopDelta );\n\n\t\t\t\tvar pending = this.repetitions - loopCount;\n\n\t\t\t\tif ( pending < 0 ) {\n\t\t\t\t\t// have to stop (switch state, clamp time, fire event)\n\n\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\t\telse this.enabled = false;\n\n\t\t\t\t\ttime = deltaTime > 0 ? duration : 0;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\t\tdirection: deltaTime > 0 ? 1 : -1\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\t\t\t\t\t// keep running\n\n\t\t\t\t\tif ( pending === 0 ) {\n\t\t\t\t\t\t// entering the last round\n\n\t\t\t\t\t\tvar atStart = deltaTime < 0;\n\t\t\t\t\t\tthis._setEndings( atStart, ! atStart, pingPong );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis._setEndings( false, false, pingPong );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._loopCount = loopCount;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'loop', action: this, loopDelta: loopDelta\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( pingPong && ( loopCount & 1 ) === 1 ) {\n\t\t\t\t// invert time for the \"pong round\"\n\n\t\t\t\tthis.time = time;\n\t\t\t\treturn duration - time;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.time = time;\n\t\treturn time;\n\n\t},\n\n\t_setEndings: function( atStart, atEnd, pingPong ) {\n\n\t\tvar settings = this._interpolantSettings;\n\n\t\tif ( pingPong ) {\n\n\t\t\tsettings.endingStart \t= THREE.ZeroSlopeEnding;\n\t\t\tsettings.endingEnd\t\t= THREE.ZeroSlopeEnding;\n\n\t\t} else {\n\n\t\t\t// assuming for LoopOnce atStart == atEnd == true\n\n\t\t\tif ( atStart ) {\n\n\t\t\t\tsettings.endingStart = this.zeroSlopeAtStart ?\n\t\t\t\t\t\tTHREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;\n\n\t\t\t} else {\n\n\t\t\t\tsettings.endingStart = THREE.WrapAroundEnding;\n\n\t\t\t}\n\n\t\t\tif ( atEnd ) {\n\n\t\t\t\tsettings.endingEnd = this.zeroSlopeAtEnd ?\n\t\t\t\t\t\tTHREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;\n\n\t\t\t} else {\n\n\t\t\t\tsettings.endingEnd \t = THREE.WrapAroundEnding;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t_scheduleFading: function( duration, weightNow, weightThen ) {\n\n\t\tvar mixer = this._mixer, now = mixer.time,\n\t\t\tinterpolant = this._weightInterpolant;\n\n\t\tif ( interpolant === null ) {\n\n\t\t\tinterpolant = mixer._lendControlInterpolant(),\n\t\t\tthis._weightInterpolant = interpolant;\n\n\t\t}\n\n\t\tvar times = interpolant.parameterPositions,\n\t\t\tvalues = interpolant.sampleValues;\n\n\t\ttimes[ 0 ] = now; \t\t\t\tvalues[ 0 ] = weightNow;\n\t\ttimes[ 1 ] = now + duration;\tvalues[ 1 ] = weightThen;\n\n\t\treturn this;\n\n\t}\n\n};\n\n\n// File:src/animation/AnimationClip.js\n\n/**\n *\n * Reusable set of Tracks that represent an animation.\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n */\n\nTHREE.AnimationClip = function ( name, duration, tracks ) {\n\n\tthis.name = name;\n\tthis.tracks = tracks;\n\tthis.duration = ( duration !== undefined ) ? duration : -1;\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\t// this means it should figure out its duration by scanning the tracks\n\tif ( this.duration < 0 ) {\n\n\t\tthis.resetDuration();\n\n\t}\n\n\t// maybe only do these on demand, as doing them here could potentially slow down loading\n\t// but leaving these here during development as this ensures a lot of testing of these functions\n\tthis.trim();\n\tthis.optimize();\n\n};\n\nTHREE.AnimationClip.prototype = {\n\n\tconstructor: THREE.AnimationClip,\n\n\tresetDuration: function() {\n\n\t\tvar tracks = this.tracks,\n\t\t\tduration = 0;\n\n\t\tfor ( var i = 0, n = tracks.length; i !== n; ++ i ) {\n\n\t\t\tvar track = this.tracks[ i ];\n\n\t\t\tduration = Math.max(\n\t\t\t\t\tduration, track.times[ track.times.length - 1 ] );\n\n\t\t}\n\n\t\tthis.duration = duration;\n\n\t},\n\n\ttrim: function() {\n\n\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tthis.tracks[ i ].trim( 0, this.duration );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\toptimize: function() {\n\n\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tthis.tracks[ i ].optimize();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n};\n\n// Static methods:\n\nObject.assign( THREE.AnimationClip, {\n\n\tparse: function( json ) {\n\n\t\tvar tracks = [],\n\t\t\tjsonTracks = json.tracks,\n\t\t\tframeTime = 1.0 / ( json.fps || 1.0 );\n\n\t\tfor ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {\n\n\t\t\ttracks.push( THREE.KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );\n\n\t\t}\n\n\t\treturn new THREE.AnimationClip( json.name, json.duration, tracks );\n\n\t},\n\n\n\ttoJSON: function( clip ) {\n\n\t\tvar tracks = [],\n\t\t\tclipTracks = clip.tracks;\n\n\t\tvar json = {\n\n\t\t\t'name': clip.name,\n\t\t\t'duration': clip.duration,\n\t\t\t'tracks': tracks\n\n\t\t};\n\n\t\tfor ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {\n\n\t\t\ttracks.push( THREE.KeyframeTrack.toJSON( clipTracks[ i ] ) );\n\n\t\t}\n\n\t\treturn json;\n\n\t},\n\n\n\tCreateFromMorphTargetSequence: function( name, morphTargetSequence, fps, noLoop ) {\n\n\t\tvar numMorphTargets = morphTargetSequence.length;\n\t\tvar tracks = [];\n\n\t\tfor ( var i = 0; i < numMorphTargets; i ++ ) {\n\n\t\t\tvar times = [];\n\t\t\tvar values = [];\n\n\t\t\ttimes.push(\n\t\t\t\t\t( i + numMorphTargets - 1 ) % numMorphTargets,\n\t\t\t\t\ti,\n\t\t\t\t\t( i + 1 ) % numMorphTargets );\n\n\t\t\tvalues.push( 0, 1, 0 );\n\n\t\t\tvar order = THREE.AnimationUtils.getKeyframeOrder( times );\n\t\t\ttimes = THREE.AnimationUtils.sortedArray( times, 1, order );\n\t\t\tvalues = THREE.AnimationUtils.sortedArray( values, 1, order );\n\n\t\t\t// if there is a key at the first frame, duplicate it as the\n\t\t\t// last frame as well for perfect loop.\n\t\t\tif ( ! noLoop && times[ 0 ] === 0 ) {\n\n\t\t\t\ttimes.push( numMorphTargets );\n\t\t\t\tvalues.push( values[ 0 ] );\n\n\t\t\t}\n\n\t\t\ttracks.push(\n\t\t\t\t\tnew THREE.NumberKeyframeTrack(\n\t\t\t\t\t\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\n\t\t\t\t\t\ttimes, values\n\t\t\t\t\t).scale( 1.0 / fps ) );\n\t\t}\n\n\t\treturn new THREE.AnimationClip( name, -1, tracks );\n\n\t},\n\n\tfindByName: function( objectOrClipArray, name ) {\n\n\t\tvar clipArray = objectOrClipArray;\n\n\t\tif ( ! Array.isArray( objectOrClipArray ) ) {\n\n\t\t\tvar o = objectOrClipArray;\n\t\t\tclipArray = o.geometry && o.geometry.animations || o.animations;\n\n\t\t}\n\n\t\tfor ( var i = 0; i < clipArray.length; i ++ ) {\n\n\t\t\tif ( clipArray[ i ].name === name ) {\n\n\t\t\t\treturn clipArray[ i ];\n\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\n\t},\n\n\tCreateClipsFromMorphTargetSequences: function( morphTargets, fps, noLoop ) {\n\n\t\tvar animationToMorphTargets = {};\n\n\t\t// tested with https://regex101.com/ on trick sequences\n\t\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n\t\tvar pattern = /^([\\w-]*?)([\\d]+)$/;\n\n\t\t// sort morph target names into animation groups based\n\t\t// patterns like Walk_001, Walk_002, Run_001, Run_002\n\t\tfor ( var i = 0, il = morphTargets.length; i < il; i ++ ) {\n\n\t\t\tvar morphTarget = morphTargets[ i ];\n\t\t\tvar parts = morphTarget.name.match( pattern );\n\n\t\t\tif ( parts && parts.length > 1 ) {\n\n\t\t\t\tvar name = parts[ 1 ];\n\n\t\t\t\tvar animationMorphTargets = animationToMorphTargets[ name ];\n\t\t\t\tif ( ! animationMorphTargets ) {\n\n\t\t\t\t\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\n\n\t\t\t\t}\n\n\t\t\t\tanimationMorphTargets.push( morphTarget );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar clips = [];\n\n\t\tfor ( var name in animationToMorphTargets ) {\n\n\t\t\tclips.push( THREE.AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\n\n\t\t}\n\n\t\treturn clips;\n\n\t},\n\n\t// parse the animation.hierarchy format\n\tparseAnimation: function( animation, bones, nodeName ) {\n\n\t\tif ( ! animation ) {\n\n\t\t\tconsole.error( \"  no animation in JSONLoader data\" );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tvar addNonemptyTrack = function(\n\t\t\t\ttrackType, trackName, animationKeys, propertyName, destTracks ) {\n\n\t\t\t// only return track if there are actually keys.\n\t\t\tif ( animationKeys.length !== 0 ) {\n\n\t\t\t\tvar times = [];\n\t\t\t\tvar values = [];\n\n\t\t\t\tTHREE.AnimationUtils.flattenJSON(\n\t\t\t\t\t\tanimationKeys, times, values, propertyName );\n\n\t\t\t\t// empty keys are filtered out, so check again\n\t\t\t\tif ( times.length !== 0 ) {\n\n\t\t\t\t\tdestTracks.push( new trackType( trackName, times, values ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tvar tracks = [];\n\n\t\tvar clipName = animation.name || 'default';\n\t\t// automatic length determination in AnimationClip.\n\t\tvar duration = animation.length || -1;\n\t\tvar fps = animation.fps || 30;\n\n\t\tvar hierarchyTracks = animation.hierarchy || [];\n\n\t\tfor ( var h = 0; h < hierarchyTracks.length; h ++ ) {\n\n\t\t\tvar animationKeys = hierarchyTracks[ h ].keys;\n\n\t\t\t// skip empty tracks\n\t\t\tif ( ! animationKeys || animationKeys.length === 0 ) continue;\n\n\t\t\t// process morph targets in a way exactly compatible\n\t\t\t// with AnimationHandler.init( animation )\n\t\t\tif ( animationKeys[0].morphTargets ) {\n\n\t\t\t\t// figure out all morph targets used in this track\n\t\t\t\tvar morphTargetNames = {};\n\t\t\t\tfor ( var k = 0; k < animationKeys.length; k ++ ) {\n\n\t\t\t\t\tif ( animationKeys[k].morphTargets ) {\n\n\t\t\t\t\t\tfor ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {\n\n\t\t\t\t\t\t\tmorphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// create a track for each morph target with all zero\n\t\t\t\t// morphTargetInfluences except for the keys in which\n\t\t\t\t// the morphTarget is named.\n\t\t\t\tfor ( var morphTargetName in morphTargetNames ) {\n\n\t\t\t\t\tvar times = [];\n\t\t\t\t\tvar values = [];\n\n\t\t\t\t\tfor ( var m = 0;\n\t\t\t\t\t\t\tm !== animationKeys[k].morphTargets.length; ++ m ) {\n\n\t\t\t\t\t\tvar animationKey = animationKeys[k];\n\n\t\t\t\t\t\ttimes.push( animationKey.time );\n\t\t\t\t\t\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttracks.push( new THREE.NumberKeyframeTrack(\n\t\t\t\t\t\t\t'.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\n\n\t\t\t\t}\n\n\t\t\t\tduration = morphTargetNames.length * ( fps || 1.0 );\n\n\t\t\t} else {\n\t\t\t\t// ...assume skeletal animation\n\n\t\t\t\tvar boneName = '.bones[' + bones[ h ].name + ']';\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\tTHREE.VectorKeyframeTrack, boneName + '.position',\n\t\t\t\t\t\tanimationKeys, 'pos', tracks );\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\tTHREE.QuaternionKeyframeTrack, boneName + '.quaternion',\n\t\t\t\t\t\tanimationKeys, 'rot', tracks );\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\tTHREE.VectorKeyframeTrack, boneName + '.scale',\n\t\t\t\t\t\tanimationKeys, 'scl', tracks );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( tracks.length === 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tvar clip = new THREE.AnimationClip( clipName, duration, tracks );\n\n\t\treturn clip;\n\n\t}\n\n} );\n\n// File:src/animation/AnimationMixer.js\n\n/**\n *\n * Player for AnimationClips.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.AnimationMixer = function( root ) {\n\n\tthis._root = root;\n\tthis._initMemoryManager();\n\tthis._accuIndex = 0;\n\n\tthis.time = 0;\n\n\tthis.timeScale = 1.0;\n\n};\n\nObject.assign( THREE.AnimationMixer.prototype, THREE.EventDispatcher.prototype, {\n\n\t// return an action for a clip optionally using a custom root target\n\t// object (this method allocates a lot of dynamic memory in case a\n\t// previously unknown clip/root combination is specified)\n\tclipAction: function( clip, optionalRoot ) {\n\n\t\tvar root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid,\n\n\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\t\tTHREE.AnimationClip.findByName( root, clip ) : clip,\n\n\t\t\tclipUuid = clipObject !== null ? clipObject.uuid : clip,\n\n\t\t\tactionsForClip = this._actionsByClip[ clipUuid ],\n\t\t\tprototypeAction = null;\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\tvar existingAction =\n\t\t\t\t\tactionsForClip.actionByRoot[ rootUuid ];\n\n\t\t\tif ( existingAction !== undefined ) {\n\n\t\t\t\treturn existingAction;\n\n\t\t\t}\n\n\t\t\t// we know the clip, so we don't have to parse all\n\t\t\t// the bindings again but can just copy\n\t\t\tprototypeAction = actionsForClip.knownActions[ 0 ];\n\n\t\t\t// also, take the clip from the prototype action\n\t\t\tif ( clipObject === null )\n\t\t\t\tclipObject = prototypeAction._clip;\n\n\t\t}\n\n\t\t// clip must be known when specified via string\n\t\tif ( clipObject === null ) return null;\n\n\t\t// allocate all resources required to run it\n\t\tvar newAction = new THREE.\n\t\t\t\tAnimationMixer._Action( this, clipObject, optionalRoot );\n\n\t\tthis._bindAction( newAction, prototypeAction );\n\n\t\t// and make the action known to the memory manager\n\t\tthis._addInactiveAction( newAction, clipUuid, rootUuid );\n\n\t\treturn newAction;\n\n\t},\n\n\t// get an existing action\n\texistingAction: function( clip, optionalRoot ) {\n\n\t\tvar root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid,\n\n\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\t\tTHREE.AnimationClip.findByName( root, clip ) : clip,\n\n\t\t\tclipUuid = clipObject ? clipObject.uuid : clip,\n\n\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\n\n\t\t}\n\n\t\treturn null;\n\n\t},\n\n\t// deactivates all previously scheduled actions\n\tstopAllAction: function() {\n\n\t\tvar actions = this._actions,\n\t\t\tnActions = this._nActiveActions,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = this._nActiveBindings;\n\n\t\tthis._nActiveActions = 0;\n\t\tthis._nActiveBindings = 0;\n\n\t\tfor ( var i = 0; i !== nActions; ++ i ) {\n\n\t\t\tactions[ i ].reset();\n\n\t\t}\n\n\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\n\n\t\t\tbindings[ i ].useCount = 0;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// advance the time and update apply the animation\n\tupdate: function( deltaTime ) {\n\n\t\tdeltaTime *= this.timeScale;\n\n\t\tvar actions = this._actions,\n\t\t\tnActions = this._nActiveActions,\n\n\t\t\ttime = this.time += deltaTime,\n\t\t\ttimeDirection = Math.sign( deltaTime ),\n\n\t\t\taccuIndex = this._accuIndex ^= 1;\n\n\t\t// run active actions\n\n\t\tfor ( var i = 0; i !== nActions; ++ i ) {\n\n\t\t\tvar action = actions[ i ];\n\n\t\t\tif ( action.enabled ) {\n\n\t\t\t\taction._update( time, deltaTime, timeDirection, accuIndex );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// update scene graph\n\n\t\tvar bindings = this._bindings,\n\t\t\tnBindings = this._nActiveBindings;\n\n\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\n\n\t\t\tbindings[ i ].apply( accuIndex );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// return this mixer's root target object\n\tgetRoot: function() {\n\n\t\treturn this._root;\n\n\t},\n\n\t// free all resources specific to a particular clip\n\tuncacheClip: function( clip ) {\n\n\t\tvar actions = this._actions,\n\t\t\tclipUuid = clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\t// note: just calling _removeInactiveAction would mess up the\n\t\t\t// iteration state and also require updating the state we can\n\t\t\t// just throw away\n\n\t\t\tvar actionsToRemove = actionsForClip.knownActions;\n\n\t\t\tfor ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\n\n\t\t\t\tvar action = actionsToRemove[ i ];\n\n\t\t\t\tthis._deactivateAction( action );\n\n\t\t\t\tvar cacheIndex = action._cacheIndex,\n\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ];\n\n\t\t\t\taction._cacheIndex = null;\n\t\t\t\taction._byClipCacheIndex = null;\n\n\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\t\tactions.pop();\n\n\t\t\t\tthis._removeInactiveBindingsForAction( action );\n\n\t\t\t}\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t},\n\n\t// free all resources specific to a particular root target object\n\tuncacheRoot: function( root ) {\n\n\t\tvar rootUuid = root.uuid,\n\t\t\tactionsByClip = this._actionsByClip;\n\n\t\tfor ( var clipUuid in actionsByClip ) {\n\n\t\t\tvar actionByRoot = actionsByClip[ clipUuid ].actionByRoot,\n\t\t\t\taction = actionByRoot[ rootUuid ];\n\n\t\t\tif ( action !== undefined ) {\n\n\t\t\t\tthis._deactivateAction( action );\n\t\t\t\tthis._removeInactiveAction( action );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingByName !== undefined ) {\n\n\t\t\tfor ( var trackName in bindingByName ) {\n\n\t\t\t\tvar binding = bindingByName[ trackName ];\n\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t// remove a targeted clip from the cache\n\tuncacheAction: function( clip, optionalRoot ) {\n\n\t\tvar action = this.existingAction( clip, optionalRoot );\n\n\t\tif ( action !== null ) {\n\n\t\t\tthis._deactivateAction( action );\n\t\t\tthis._removeInactiveAction( action );\n\n\t\t}\n\n\t}\n\n} );\n\nTHREE.AnimationMixer._Action = THREE.AnimationAction._new;\n\n// Implementation details:\n\nObject.assign( THREE.AnimationMixer.prototype, {\n\n\t_bindAction: function( action, prototypeAction ) {\n\n\t\tvar root = action._localRoot || this._root,\n\t\t\ttracks = action._clip.tracks,\n\t\t\tnTracks = tracks.length,\n\t\t\tbindings = action._propertyBindings,\n\t\t\tinterpolants = action._interpolants,\n\t\t\trootUuid = root.uuid,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingsByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingsByName === undefined ) {\n\n\t\t\tbindingsByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingsByName;\n\n\t\t}\n\n\t\tfor ( var i = 0; i !== nTracks; ++ i ) {\n\n\t\t\tvar track = tracks[ i ],\n\t\t\t\ttrackName = track.name,\n\t\t\t\tbinding = bindingsByName[ trackName ];\n\n\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t} else {\n\n\t\t\t\tbinding = bindings[ i ];\n\n\t\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\t\t// existing binding, make sure the cache knows\n\n\t\t\t\t\tif ( binding._cacheIndex === null ) {\n\n\t\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tvar path = prototypeAction && prototypeAction.\n\t\t\t\t\t\t_propertyBindings[ i ].binding.parsedPath;\n\n\t\t\t\tbinding = new THREE.PropertyMixer(\n\t\t\t\t\t\tTHREE.PropertyBinding.create( root, trackName, path ),\n\t\t\t\t\t\ttrack.ValueTypeName, track.getValueSize() );\n\n\t\t\t\t++ binding.referenceCount;\n\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t}\n\n\t\t\tinterpolants[ i ].resultBuffer = binding.buffer;\n\n\t\t}\n\n\t},\n\n\t_activateAction: function( action ) {\n\n\t\tif ( ! this._isActiveAction( action ) ) {\n\n\t\t\tif ( action._cacheIndex === null ) {\n\n\t\t\t\t// this action has been forgotten by the cache, but the user\n\t\t\t\t// appears to be still using it -> rebind\n\n\t\t\t\tvar rootUuid = ( action._localRoot || this._root ).uuid,\n\t\t\t\t\tclipUuid = action._clip.uuid,\n\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\t\t\tthis._bindAction( action,\n\t\t\t\t\t\tactionsForClip && actionsForClip.knownActions[ 0 ] );\n\n\t\t\t\tthis._addInactiveAction( action, clipUuid, rootUuid );\n\n\t\t\t}\n\n\t\t\tvar bindings = action._propertyBindings;\n\n\t\t\t// increment reference counts / sort out state\n\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tvar binding = bindings[ i ];\n\n\t\t\t\tif ( binding.useCount ++ === 0 ) {\n\n\t\t\t\t\tthis._lendBinding( binding );\n\t\t\t\t\tbinding.saveOriginalState();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._lendAction( action );\n\n\t\t}\n\n\t},\n\n\t_deactivateAction: function( action ) {\n\n\t\tif ( this._isActiveAction( action ) ) {\n\n\t\t\tvar bindings = action._propertyBindings;\n\n\t\t\t// decrement reference counts / sort out state\n\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tvar binding = bindings[ i ];\n\n\t\t\t\tif ( -- binding.useCount === 0 ) {\n\n\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\tthis._takeBackBinding( binding );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._takeBackAction( action );\n\n\t\t}\n\n\t},\n\n\t// Memory manager\n\n\t_initMemoryManager: function() {\n\n\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\n\t\tthis._nActiveActions = 0;\n\n\t\tthis._actionsByClip = {};\n\t\t// inside:\n\t\t// {\n\t\t// \t\tknownActions: Array< _Action >\t- used as prototypes\n\t\t// \t\tactionByRoot: _Action\t\t\t- lookup\n\t\t// }\n\n\n\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\n\t\tthis._nActiveBindings = 0;\n\n\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\n\n\t\tthis._controlInterpolants = []; // same game as above\n\t\tthis._nActiveControlInterpolants = 0;\n\n\t\tvar scope = this;\n\n\t\tthis.stats = {\n\n\t\t\tactions: {\n\t\t\t\tget total() { return scope._actions.length; },\n\t\t\t\tget inUse() { return scope._nActiveActions; }\n\t\t\t},\n\t\t\tbindings: {\n\t\t\t\tget total() { return scope._bindings.length; },\n\t\t\t\tget inUse() { return scope._nActiveBindings; }\n\t\t\t},\n\t\t\tcontrolInterpolants: {\n\t\t\t\tget total() { return scope._controlInterpolants.length; },\n\t\t\t\tget inUse() { return scope._nActiveControlInterpolants; }\n\t\t\t}\n\n\t\t};\n\n\t},\n\n\t// Memory management for _Action objects\n\n\t_isActiveAction: function( action ) {\n\n\t\tvar index = action._cacheIndex;\n\t\treturn index !== null && index < this._nActiveActions;\n\n\t},\n\n\t_addInactiveAction: function( action, clipUuid, rootUuid ) {\n\n\t\tvar actions = this._actions,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip === undefined ) {\n\n\t\t\tactionsForClip = {\n\n\t\t\t\tknownActions: [ action ],\n\t\t\t\tactionByRoot: {}\n\n\t\t\t};\n\n\t\t\taction._byClipCacheIndex = 0;\n\n\t\t\tactionsByClip[ clipUuid ] = actionsForClip;\n\n\t\t} else {\n\n\t\t\tvar knownActions = actionsForClip.knownActions;\n\n\t\t\taction._byClipCacheIndex = knownActions.length;\n\t\t\tknownActions.push( action );\n\n\t\t}\n\n\t\taction._cacheIndex = actions.length;\n\t\tactions.push( action );\n\n\t\tactionsForClip.actionByRoot[ rootUuid ] = action;\n\n\t},\n\n\t_removeInactiveAction: function( action ) {\n\n\t\tvar actions = this._actions,\n\t\t\tlastInactiveAction = actions[ actions.length - 1 ],\n\t\t\tcacheIndex = action._cacheIndex;\n\n\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\tactions.pop();\n\n\t\taction._cacheIndex = null;\n\n\n\t\tvar clipUuid = action._clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ],\n\t\t\tknownActionsForClip = actionsForClip.knownActions,\n\n\t\t\tlastKnownAction =\n\t\t\t\tknownActionsForClip[ knownActionsForClip.length - 1 ],\n\n\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\n\n\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\n\t\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\n\t\tknownActionsForClip.pop();\n\n\t\taction._byClipCacheIndex = null;\n\n\n\t\tvar actionByRoot = actionsForClip.actionByRoot,\n\t\t\trootUuid = ( actions._localRoot || this._root ).uuid;\n\n\t\tdelete actionByRoot[ rootUuid ];\n\n\t\tif ( knownActionsForClip.length === 0 ) {\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t\tthis._removeInactiveBindingsForAction( action );\n\n\t},\n\n\t_removeInactiveBindingsForAction: function( action ) {\n\n\t\tvar bindings = action._propertyBindings;\n\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tvar binding = bindings[ i ];\n\n\t\t\tif ( -- binding.referenceCount === 0 ) {\n\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t_lendAction: function( action ) {\n\n\t\t// [ active actions |  inactive actions  ]\n\t\t// [  active actions >| inactive actions ]\n\t\t//                 s        a\n\t\t//                  <-swap->\n\t\t//                 a        s\n\n\t\tvar actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveActions ++,\n\n\t\t\tfirstInactiveAction = actions[ lastActiveIndex ];\n\n\t\taction._cacheIndex = lastActiveIndex;\n\t\tactions[ lastActiveIndex ] = action;\n\n\t\tfirstInactiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = firstInactiveAction;\n\n\t},\n\n\t_takeBackAction: function( action ) {\n\n\t\t// [  active actions  | inactive actions ]\n\t\t// [ active actions |< inactive actions  ]\n\t\t//        a        s\n\t\t//         <-swap->\n\t\t//        s        a\n\n\t\tvar actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveActions,\n\n\t\t\tlastActiveAction = actions[ firstInactiveIndex ];\n\n\t\taction._cacheIndex = firstInactiveIndex;\n\t\tactions[ firstInactiveIndex ] = action;\n\n\t\tlastActiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = lastActiveAction;\n\n\t},\n\n\t// Memory management for PropertyMixer objects\n\n\t_addInactiveBinding: function( binding, rootUuid, trackName ) {\n\n\t\tvar bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\n\t\t\tbindings = this._bindings;\n\n\t\tif ( bindingByName === undefined ) {\n\n\t\t\tbindingByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingByName;\n\n\t\t}\n\n\t\tbindingByName[ trackName ] = binding;\n\n\t\tbinding._cacheIndex = bindings.length;\n\t\tbindings.push( binding );\n\n\t},\n\n\t_removeInactiveBinding: function( binding ) {\n\n\t\tvar bindings = this._bindings,\n\t\t\tpropBinding = binding.binding,\n\t\t\trootUuid = propBinding.rootNode.uuid,\n\t\t\ttrackName = propBinding.path,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\n\t\t\tlastInactiveBinding = bindings[ bindings.length - 1 ],\n\t\t\tcacheIndex = binding._cacheIndex;\n\n\t\tlastInactiveBinding._cacheIndex = cacheIndex;\n\t\tbindings[ cacheIndex ] = lastInactiveBinding;\n\t\tbindings.pop();\n\n\t\tdelete bindingByName[ trackName ];\n\n\t\tremove_empty_map: {\n\n\t\t\tfor ( var _ in bindingByName ) break remove_empty_map;\n\n\t\t\tdelete bindingsByRoot[ rootUuid ];\n\n\t\t}\n\n\t},\n\n\t_lendBinding: function( binding ) {\n\n\t\tvar bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveBindings ++,\n\n\t\t\tfirstInactiveBinding = bindings[ lastActiveIndex ];\n\n\t\tbinding._cacheIndex = lastActiveIndex;\n\t\tbindings[ lastActiveIndex ] = binding;\n\n\t\tfirstInactiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = firstInactiveBinding;\n\n\t},\n\n\t_takeBackBinding: function( binding ) {\n\n\t\tvar bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveBindings,\n\n\t\t\tlastActiveBinding = bindings[ firstInactiveIndex ];\n\n\t\tbinding._cacheIndex = firstInactiveIndex;\n\t\tbindings[ firstInactiveIndex ] = binding;\n\n\t\tlastActiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = lastActiveBinding;\n\n\t},\n\n\n\t// Memory management of Interpolants for weight and time scale\n\n\t_lendControlInterpolant: function() {\n\n\t\tvar interpolants = this._controlInterpolants,\n\t\t\tlastActiveIndex = this._nActiveControlInterpolants ++,\n\t\t\tinterpolant = interpolants[ lastActiveIndex ];\n\n\t\tif ( interpolant === undefined ) {\n\n\t\t\tinterpolant = new THREE.LinearInterpolant(\n\t\t\t\t\tnew Float32Array( 2 ), new Float32Array( 2 ),\n\t\t\t\t\t\t1, this._controlInterpolantsResultBuffer );\n\n\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\n\t\t\tinterpolants[ lastActiveIndex ] = interpolant;\n\n\t\t}\n\n\t\treturn interpolant;\n\n\t},\n\n\t_takeBackControlInterpolant: function( interpolant ) {\n\n\t\tvar interpolants = this._controlInterpolants,\n\t\t\tprevIndex = interpolant.__cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\n\n\t\t\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\n\n\t\tinterpolant.__cacheIndex = firstInactiveIndex;\n\t\tinterpolants[ firstInactiveIndex ] = interpolant;\n\n\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\n\t\tinterpolants[ prevIndex ] = lastActiveInterpolant;\n\n\t},\n\n\t_controlInterpolantsResultBuffer: new Float32Array( 1 )\n\n} );\n\n// File:src/animation/AnimationObjectGroup.js\n\n/**\n *\n * A group of objects that receives a shared animation state.\n *\n * Usage:\n *\n * \t-\tAdd objects you would otherwise pass as 'root' to the\n * \t\tconstructor or the .clipAction method of AnimationMixer.\n *\n * \t-\tInstead pass this object as 'root'.\n *\n * \t-\tYou can also add and remove objects later when the mixer\n * \t\tis running.\n *\n * Note:\n *\n *  \tObjects of this class appear as one object to the mixer,\n *  \tso cache control of the individual objects must be done\n *  \ton the group.\n *\n * Limitation:\n *\n * \t- \tThe animated properties must be compatible among the\n * \t\tall objects in the group.\n *\n *  -\tA single property can either be controlled through a\n *  \ttarget group or directly, but not both.\n *\n * @author tschw\n */\n\nTHREE.AnimationObjectGroup = function( var_args ) {\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\t// cached objects followed by the active ones\n\tthis._objects = Array.prototype.slice.call( arguments );\n\n\tthis.nCachedObjects_ = 0;\t\t\t// threshold\n\t// note: read by PropertyBinding.Composite\n\n\tvar indices = {};\n\tthis._indicesByUUID = indices;\t\t// for bookkeeping\n\n\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\tindices[ arguments[ i ].uuid ] = i;\n\n\t}\n\n\tthis._paths = [];\t\t\t\t\t// inside: string\n\tthis._parsedPaths = [];\t\t\t\t// inside: { we don't care, here }\n\tthis._bindings = []; \t\t\t\t// inside: Array< PropertyBinding >\n\tthis._bindingsIndicesByPath = {}; \t// inside: indices in these arrays\n\n\tvar scope = this;\n\n\tthis.stats = {\n\n\t\tobjects: {\n\t\t\tget total() { return scope._objects.length; },\n\t\t\tget inUse() { return this.total - scope.nCachedObjects_;  }\n\t\t},\n\n\t\tget bindingsPerObject() { return scope._bindings.length; }\n\n\t};\n\n};\n\nTHREE.AnimationObjectGroup.prototype = {\n\n\tconstructor: THREE.AnimationObjectGroup,\n\n\tadd: function( var_args ) {\n\n\t\tvar objects = this._objects,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tpaths = this._paths,\n\t\t\tparsedPaths = this._parsedPaths,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tvar object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index === undefined ) {\n\n\t\t\t\t// unknown object -> add it to the ACTIVE region\n\n\t\t\t\tindex = nObjects ++;\n\t\t\t\tindicesByUUID[ uuid ] = index;\n\t\t\t\tobjects.push( object );\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tbindings[ j ].push(\n\t\t\t\t\t\t\tnew THREE.PropertyBinding(\n\t\t\t\t\t\t\t\tobject, paths[ j ], parsedPaths[ j ] ) );\n\n\t\t\t\t}\n\n\t\t\t} else if ( index < nCachedObjects ) {\n\n\t\t\t\tvar knownObject = objects[ index ];\n\n\t\t\t\t// move existing object to the ACTIVE region\n\n\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ];\n\n\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\tindicesByUUID[ uuid ] = firstActiveIndex;\n\t\t\t\tobjects[ firstActiveIndex ] = object;\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\n\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\n\t\t\t\t\tif ( binding === undefined ) {\n\n\t\t\t\t\t\t// since we do not bother to create new bindings\n\t\t\t\t\t\t// for objects that are cached, the binding may\n\t\t\t\t\t\t// or may not exist\n\n\t\t\t\t\t\tbinding = new THREE.PropertyBinding(\n\t\t\t\t\t\t\t\tobject, paths[ j ], parsedPaths[ j ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = binding;\n\n\t\t\t\t}\n\n\t\t\t} else if ( objects[ index ] !== knownObject) {\n\n\t\t\t\tconsole.error( \"Different objects with the same UUID \" +\n\t\t\t\t\t\t\"detected. Clean the caches or recreate your \" +\n\t\t\t\t\t\t\"infrastructure when reloading scenes...\" );\n\n\t\t\t} // else the object is already where we want it to be\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t},\n\n\tremove: function( var_args ) {\n\n\t\tvar objects = this._objects,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tvar object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index !== undefined && index >= nCachedObjects ) {\n\n\t\t\t\t// move existing object into the CACHED region\n\n\t\t\t\tvar lastCachedIndex = nCachedObjects ++,\n\t\t\t\t\tfirstActiveObject = objects[ lastCachedIndex ];\n\n\t\t\t\tindicesByUUID[ firstActiveObject.uuid ] = index;\n\t\t\t\tobjects[ index ] = firstActiveObject;\n\n\t\t\t\tindicesByUUID[ uuid ] = lastCachedIndex;\n\t\t\t\tobjects[ lastCachedIndex ] = object;\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\tfirstActive = bindingsForPath[ lastCachedIndex ],\n\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\n\t\t\t\t\tbindingsForPath[ index ] = firstActive;\n\t\t\t\t\tbindingsForPath[ lastCachedIndex ] = binding;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t},\n\n\t// remove & forget\n\tuncache: function( var_args ) {\n\n\t\tvar objects = this._objects,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tvar object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index !== undefined ) {\n\n\t\t\t\tdelete indicesByUUID[ uuid ];\n\n\t\t\t\tif ( index < nCachedObjects ) {\n\n\t\t\t\t\t// object is cached, shrink the CACHED region\n\n\t\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ],\n\t\t\t\t\t\tlastIndex = -- nObjects,\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\t// last cached object takes this object's place\n\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\t\t// last object goes to the activated slot and pop\n\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = firstActiveIndex;\n\t\t\t\t\tobjects[ firstActiveIndex ] = lastObject;\n\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\t\tlast = bindingsForPath[ lastIndex ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = last;\n\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// object is active, just swap with the last and pop\n\n\t\t\t\t\tvar lastIndex = -- nObjects,\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = lastObject;\n\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = bindingsForPath[ lastIndex ];\n\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t}\n\n\t\t\t\t} // cached or active\n\n\t\t\t} // if object is known\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t},\n\n\t// Internal interface used by befriended PropertyBinding.Composite:\n\n\tsubscribe_: function( path, parsedPath ) {\n\t\t// returns an array of bindings for the given path that is changed\n\t\t// according to the contained objects in the group\n\n\t\tvar indicesByPath = this._bindingsIndicesByPath,\n\t\t\tindex = indicesByPath[ path ],\n\t\t\tbindings = this._bindings;\n\n\t\tif ( index !== undefined ) return bindings[ index ];\n\n\t\tvar paths = this._paths,\n\t\t\tparsedPaths = this._parsedPaths,\n\t\t\tobjects = this._objects,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tbindingsForPath = new Array( nObjects );\n\n\t\tindex = bindings.length;\n\n\t\tindicesByPath[ path ] = index;\n\n\t\tpaths.push( path );\n\t\tparsedPaths.push( parsedPath );\n\t\tbindings.push( bindingsForPath );\n\n\t\tfor ( var i = nCachedObjects,\n\t\t\t\tn = objects.length; i !== n; ++ i ) {\n\n\t\t\tvar object = objects[ i ];\n\n\t\t\tbindingsForPath[ i ] =\n\t\t\t\t\tnew THREE.PropertyBinding( object, path, parsedPath );\n\n\t\t}\n\n\t\treturn bindingsForPath;\n\n\t},\n\n\tunsubscribe_: function( path ) {\n\t\t// tells the group to forget about a property path and no longer\n\t\t// update the array previously obtained with 'subscribe_'\n\n\t\tvar indicesByPath = this._bindingsIndicesByPath,\n\t\t\tindex = indicesByPath[ path ];\n\n\t\tif ( index !== undefined ) {\n\n\t\t\tvar paths = this._paths,\n\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tlastBindingsIndex = bindings.length - 1,\n\t\t\t\tlastBindings = bindings[ lastBindingsIndex ],\n\t\t\t\tlastBindingsPath = path[ lastBindingsIndex ];\n\n\t\t\tindicesByPath[ lastBindingsPath ] = index;\n\n\t\t\tbindings[ index ] = lastBindings;\n\t\t\tbindings.pop();\n\n\t\t\tparsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\n\t\t\tparsedPaths.pop();\n\n\t\t\tpaths[ index ] = paths[ lastBindingsIndex ];\n\t\t\tpaths.pop();\n\n\t\t}\n\n\t}\n\n};\n\n\n// File:src/animation/AnimationUtils.js\n\n/**\n * @author tschw\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n */\n\nTHREE.AnimationUtils = {\n\n\t// same as Array.prototype.slice, but also works on typed arrays\n\tarraySlice: function( array, from, to ) {\n\n\t\tif ( THREE.AnimationUtils.isTypedArray( array ) ) {\n\n\t\t\treturn new array.constructor( array.subarray( from, to ) );\n\n\t\t}\n\n\t\treturn array.slice( from, to );\n\n\t},\n\n\t// converts an array to a specific type\n\tconvertArray: function( array, type, forceClone ) {\n\n\t\tif ( ! array || // let 'undefined' and 'null' pass\n\t\t\t\t! forceClone && array.constructor === type ) return array;\n\n\t\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\n\n\t\t\treturn new type( array ); // create typed array\n\n\t\t}\n\n\t\treturn Array.prototype.slice.call( array ); // create Array\n\n\t},\n\n\tisTypedArray: function( object ) {\n\n\t\treturn ArrayBuffer.isView( object ) &&\n\t\t\t\t! ( object instanceof DataView );\n\n\t},\n\n\t// returns an array by which times and values can be sorted\n\tgetKeyframeOrder: function( times ) {\n\n\t\tfunction compareTime( i, j ) {\n\n\t\t\treturn times[ i ] - times[ j ];\n\n\t\t}\n\n\t\tvar n = times.length;\n\t\tvar result = new Array( n );\n\t\tfor ( var i = 0; i !== n; ++ i ) result[ i ] = i;\n\n\t\tresult.sort( compareTime );\n\n\t\treturn result;\n\n\t},\n\n\t// uses the array previously returned by 'getKeyframeOrder' to sort data\n\tsortedArray: function( values, stride, order ) {\n\n\t\tvar nValues = values.length;\n\t\tvar result = new values.constructor( nValues );\n\n\t\tfor ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\n\n\t\t\tvar srcOffset = order[ i ] * stride;\n\n\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\n\t\t\t\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\t// function for parsing AOS keyframe formats\n\tflattenJSON: function( jsonKeys, times, values, valuePropertyName ) {\n\n\t\tvar i = 1, key = jsonKeys[ 0 ];\n\n\t\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\n\n\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t}\n\n\t\tif ( key === undefined ) return; // no data\n\n\t\tvar value = key[ valuePropertyName ];\n\t\tif ( value === undefined ) return; // no data\n\n\t\tif ( Array.isArray( value ) ) {\n\n\t\t\tdo {\n\n\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\tvalues.push.apply( values, value ); // push all elements\n\n\t\t\t\t}\n\n\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t} while ( key !== undefined );\n\n\t\t} else if ( value.toArray !== undefined ) {\n\t\t\t// ...assume THREE.Math-ish\n\n\t\t\tdo {\n\n\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\tvalue.toArray( values, values.length );\n\n\t\t\t\t}\n\n\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t} while ( key !== undefined );\n\n\t\t} else {\n\t\t\t// otherwise push as-is\n\n\t\t\tdo {\n\n\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\tvalues.push( value );\n\n\t\t\t\t}\n\n\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t} while ( key !== undefined );\n\n\t\t}\n\n\t}\n\n};\n\n// File:src/animation/KeyframeTrack.js\n\n/**\n *\n * A timed sequence of keyframes for a specific property.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.KeyframeTrack = function ( name, times, values, interpolation ) {\n\n\tif( name === undefined ) throw new Error( \"track name is undefined\" );\n\n\tif( times === undefined || times.length === 0 ) {\n\n\t\tthrow new Error( \"no keyframes in track named \" + name );\n\n\t}\n\n\tthis.name = name;\n\n\tthis.times = THREE.AnimationUtils.convertArray( times, this.TimeBufferType );\n\tthis.values = THREE.AnimationUtils.convertArray( values, this.ValueBufferType );\n\n\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\n\n\tthis.validate();\n\tthis.optimize();\n\n};\n\nTHREE.KeyframeTrack.prototype = {\n\n\tconstructor: THREE.KeyframeTrack,\n\n\tTimeBufferType: Float32Array,\n\tValueBufferType: Float32Array,\n\n\tDefaultInterpolation: THREE.InterpolateLinear,\n\n\tInterpolantFactoryMethodDiscrete: function( result ) {\n\n\t\treturn new THREE.DiscreteInterpolant(\n\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\n\t},\n\n\tInterpolantFactoryMethodLinear: function( result ) {\n\n\t\treturn new THREE.LinearInterpolant(\n\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\n\t},\n\n\tInterpolantFactoryMethodSmooth: function( result ) {\n\n\t\treturn new THREE.CubicInterpolant(\n\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\n\t},\n\n\tsetInterpolation: function( interpolation ) {\n\n\t\tvar factoryMethod;\n\n\t\tswitch ( interpolation ) {\n\n\t\t\tcase THREE.InterpolateDiscrete:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\n\n\t\t\t\tbreak;\n\n\t\t\tcase THREE.InterpolateLinear:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodLinear;\n\n\t\t\t\tbreak;\n\n\t\t\tcase THREE.InterpolateSmooth:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tif ( factoryMethod === undefined ) {\n\n\t\t\tvar message = \"unsupported interpolation for \" +\n\t\t\t\t\tthis.ValueTypeName + \" keyframe track named \" + this.name;\n\n\t\t\tif ( this.createInterpolant === undefined ) {\n\n\t\t\t\t// fall back to default, unless the default itself is messed up\n\t\t\t\tif ( interpolation !== this.DefaultInterpolation ) {\n\n\t\t\t\t\tthis.setInterpolation( this.DefaultInterpolation );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( message ); // fatal, in this case\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconsole.warn( message );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.createInterpolant = factoryMethod;\n\n\t},\n\n\tgetInterpolation: function() {\n\n\t\tswitch ( this.createInterpolant ) {\n\n\t\t\tcase this.InterpolantFactoryMethodDiscrete:\n\n\t\t\t\treturn THREE.InterpolateDiscrete;\n\n\t\t\tcase this.InterpolantFactoryMethodLinear:\n\n\t\t\t\treturn THREE.InterpolateLinear;\n\n\t\t\tcase this.InterpolantFactoryMethodSmooth:\n\n\t\t\t\treturn THREE.InterpolateSmooth;\n\n\t\t}\n\n\t},\n\n\tgetValueSize: function() {\n\n\t\treturn this.values.length / this.times.length;\n\n\t},\n\n\t// move all keyframes either forwards or backwards in time\n\tshift: function( timeOffset ) {\n\n\t\tif( timeOffset !== 0.0 ) {\n\n\t\t\tvar times = this.times;\n\n\t\t\tfor( var i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\ttimes[ i ] += timeOffset;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\n\tscale: function( timeScale ) {\n\n\t\tif( timeScale !== 1.0 ) {\n\n\t\t\tvar times = this.times;\n\n\t\t\tfor( var i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\ttimes[ i ] *= timeScale;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\n\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\n\ttrim: function( startTime, endTime ) {\n\n\t\tvar times = this.times,\n\t\t\tnKeys = times.length,\n\t\t\tfrom = 0,\n\t\t\tto = nKeys - 1;\n\n\t\twhile ( from !== nKeys && times[ from ] < startTime ) ++ from;\n\t\twhile ( to !== -1 && times[ to ] > endTime ) -- to;\n\n\t\t++ to; // inclusive -> exclusive bound\n\n\t\tif( from !== 0 || to !== nKeys ) {\n\n\t\t\t// empty tracks are forbidden, so keep at least one keyframe\n\t\t\tif ( from >= to ) to = Math.max( to , 1 ), from = to - 1;\n\n\t\t\tvar stride = this.getValueSize();\n\t\t\tthis.times = THREE.AnimationUtils.arraySlice( times, from, to );\n\t\t\tthis.values = THREE.AnimationUtils.\n\t\t\t\t\tarraySlice( this.values, from * stride, to * stride );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\n\tvalidate: function() {\n\n\t\tvar valid = true;\n\n\t\tvar valueSize = this.getValueSize();\n\t\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\n\n\t\t\tconsole.error( \"invalid value size in track\", this );\n\t\t\tvalid = false;\n\n\t\t}\n\n\t\tvar times = this.times,\n\t\t\tvalues = this.values,\n\n\t\t\tnKeys = times.length;\n\n\t\tif( nKeys === 0 ) {\n\n\t\t\tconsole.error( \"track is empty\", this );\n\t\t\tvalid = false;\n\n\t\t}\n\n\t\tvar prevTime = null;\n\n\t\tfor( var i = 0; i !== nKeys; i ++ ) {\n\n\t\t\tvar currTime = times[ i ];\n\n\t\t\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\n\n\t\t\t\tconsole.error( \"time is not a valid number\", this, i, currTime );\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif( prevTime !== null && prevTime > currTime ) {\n\n\t\t\t\tconsole.error( \"out of order keys\", this, i, currTime, prevTime );\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tprevTime = currTime;\n\n\t\t}\n\n\t\tif ( values !== undefined ) {\n\n\t\t\tif ( THREE.AnimationUtils.isTypedArray( values ) ) {\n\n\t\t\t\tfor ( var i = 0, n = values.length; i !== n; ++ i ) {\n\n\t\t\t\t\tvar value = values[ i ];\n\n\t\t\t\t\tif ( isNaN( value ) ) {\n\n\t\t\t\t\t\tconsole.error( \"value is not a valid number\", this, i, value );\n\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn valid;\n\n\t},\n\n\t// removes equivalent sequential keys as common in morph target sequences\n\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n\toptimize: function() {\n\n\t\tvar times = this.times,\n\t\t\tvalues = this.values,\n\t\t\tstride = this.getValueSize(),\n\n\t\t\twriteIndex = 1;\n\n\t\tfor( var i = 1, n = times.length - 1; i <= n; ++ i ) {\n\n\t\t\tvar keep = false;\n\n\t\t\tvar time = times[ i ];\n\t\t\tvar timeNext = times[ i + 1 ];\n\n\t\t\t// remove adjacent keyframes scheduled at the same time\n\n\t\t\tif ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {\n\n\t\t\t\t// remove unnecessary keyframes same as their neighbors\n\t\t\t\tvar offset = i * stride,\n\t\t\t\t\toffsetP = offset - stride,\n\t\t\t\t\toffsetN = offset + stride;\n\n\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\tvar value = values[ offset + j ];\n\n\t\t\t\t\tif ( value !== values[ offsetP + j ] ||\n\t\t\t\t\t\t\tvalue !== values[ offsetN + j ] ) {\n\n\t\t\t\t\t\tkeep = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// in-place compaction\n\n\t\t\tif ( keep ) {\n\n\t\t\t\tif ( i !== writeIndex ) {\n\n\t\t\t\t\ttimes[ writeIndex ] = times[ i ];\n\n\t\t\t\t\tvar readOffset = i * stride,\n\t\t\t\t\t\twriteOffset = writeIndex * stride;\n\n\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t\t\t}\n\n\n\t\t\t\t}\n\n\t\t\t\t++ writeIndex;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( writeIndex !== times.length ) {\n\n\t\t\tthis.times = THREE.AnimationUtils.arraySlice( times, 0, writeIndex );\n\t\t\tthis.values = THREE.AnimationUtils.arraySlice( values, 0, writeIndex * stride );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n};\n\n// Static methods:\n\nObject.assign( THREE.KeyframeTrack, {\n\n\t// Serialization (in static context, because of constructor invocation\n\t// and automatic invocation of .toJSON):\n\n\tparse: function( json ) {\n\n\t\tif( json.type === undefined ) {\n\n\t\t\tthrow new Error( \"track type undefined, can not parse\" );\n\n\t\t}\n\n\t\tvar trackType = THREE.KeyframeTrack._getTrackTypeForValueTypeName( json.type );\n\n\t\tif ( json.times === undefined ) {\n\n\t\t\tvar times = [], values = [];\n\n\t\t\tTHREE.AnimationUtils.flattenJSON( json.keys, times, values, 'value' );\n\n\t\t\tjson.times = times;\n\t\t\tjson.values = values;\n\n\t\t}\n\n\t\t// derived classes can define a static parse method\n\t\tif ( trackType.parse !== undefined ) {\n\n\t\t\treturn trackType.parse( json );\n\n\t\t} else {\n\n\t\t\t// by default, we asssume a constructor compatible with the base\n\t\t\treturn new trackType(\n\t\t\t\t\tjson.name, json.times, json.values, json.interpolation );\n\n\t\t}\n\n\t},\n\n\ttoJSON: function( track ) {\n\n\t\tvar trackType = track.constructor;\n\n\t\tvar json;\n\n\t\t// derived classes can define a static toJSON method\n\t\tif ( trackType.toJSON !== undefined ) {\n\n\t\t\tjson = trackType.toJSON( track );\n\n\t\t} else {\n\n\t\t\t// by default, we assume the data can be serialized as-is\n\t\t\tjson = {\n\n\t\t\t\t'name': track.name,\n\t\t\t\t'times': THREE.AnimationUtils.convertArray( track.times, Array ),\n\t\t\t\t'values': THREE.AnimationUtils.convertArray( track.values, Array )\n\n\t\t\t};\n\n\t\t\tvar interpolation = track.getInterpolation();\n\n\t\t\tif ( interpolation !== track.DefaultInterpolation ) {\n\n\t\t\t\tjson.interpolation = interpolation;\n\n\t\t\t}\n\n\t\t}\n\n\t\tjson.type = track.ValueTypeName; // mandatory\n\n\t\treturn json;\n\n\t},\n\n\t_getTrackTypeForValueTypeName: function( typeName ) {\n\n\t\tswitch( typeName.toLowerCase() ) {\n\n\t\t\tcase \"scalar\":\n\t\t\tcase \"double\":\n\t\t\tcase \"float\":\n\t\t\tcase \"number\":\n\t\t\tcase \"integer\":\n\n\t\t\t\treturn THREE.NumberKeyframeTrack;\n\n\t\t\tcase \"vector\":\n\t\t\tcase \"vector2\":\n\t\t\tcase \"vector3\":\n\t\t\tcase \"vector4\":\n\n\t\t\t\treturn THREE.VectorKeyframeTrack;\n\n\t\t\tcase \"color\":\n\n\t\t\t\treturn THREE.ColorKeyframeTrack;\n\n\t\t\tcase \"quaternion\":\n\n\t\t\t\treturn THREE.QuaternionKeyframeTrack;\n\n\t\t\tcase \"bool\":\n\t\t\tcase \"boolean\":\n\n\t\t\t\treturn THREE.BooleanKeyframeTrack;\n\n\t\t\tcase \"string\":\n\n\t\t\t\treturn THREE.StringKeyframeTrack;\n\n\t\t}\n\n\t\tthrow new Error( \"Unsupported typeName: \" + typeName );\n\n\t}\n\n} );\n\n// File:src/animation/PropertyBinding.js\n\n/**\n *\n * A reference to a real property in the scene graph.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.PropertyBinding = function ( rootNode, path, parsedPath ) {\n\n\tthis.path = path;\n\tthis.parsedPath = parsedPath ||\n\t\t\tTHREE.PropertyBinding.parseTrackName( path );\n\n\tthis.node = THREE.PropertyBinding.findNode(\n\t\t\trootNode, this.parsedPath.nodeName ) || rootNode;\n\n\tthis.rootNode = rootNode;\n\n};\n\nTHREE.PropertyBinding.prototype = {\n\n\tconstructor: THREE.PropertyBinding,\n\n\tgetValue: function getValue_unbound( targetArray, offset ) {\n\n\t\tthis.bind();\n\t\tthis.getValue( targetArray, offset );\n\n\t\t// Note: This class uses a State pattern on a per-method basis:\n\t\t// 'bind' sets 'this.getValue' / 'setValue' and shadows the\n\t\t// prototype version of these methods with one that represents\n\t\t// the bound state. When the property is not found, the methods\n\t\t// become no-ops.\n\n\t},\n\n\tsetValue: function getValue_unbound( sourceArray, offset ) {\n\n\t\tthis.bind();\n\t\tthis.setValue( sourceArray, offset );\n\n\t},\n\n\t// create getter / setter pair for a property in the scene graph\n\tbind: function() {\n\n\t\tvar targetObject = this.node,\n\t\t\tparsedPath = this.parsedPath,\n\n\t\t\tobjectName = parsedPath.objectName,\n\t\t\tpropertyName = parsedPath.propertyName,\n\t\t\tpropertyIndex = parsedPath.propertyIndex;\n\n\t\tif ( ! targetObject ) {\n\n\t\t\ttargetObject = THREE.PropertyBinding.findNode(\n\t\t\t\t\tthis.rootNode, parsedPath.nodeName ) || this.rootNode;\n\n\t\t\tthis.node = targetObject;\n\n\t\t}\n\n\t\t// set fail state so we can just 'return' on error\n\t\tthis.getValue = this._getValue_unavailable;\n\t\tthis.setValue = this._setValue_unavailable;\n\n \t\t// ensure there is a value node\n\t\tif ( ! targetObject ) {\n\n\t\t\tconsole.error( \"  trying to update node for track: \" + this.path + \" but it wasn't found.\" );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( objectName ) {\n\n\t\t\tvar objectIndex = parsedPath.objectIndex;\n\n\t\t\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\n\t\t\tswitch ( objectName ) {\n\n\t\t\t\tcase 'materials':\n\n\t\t\t\t\tif ( ! targetObject.material ) {\n\n\t\t\t\t\t\tconsole.error( '  can not bind to material as node does not have a material', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! targetObject.material.materials ) {\n\n\t\t\t\t\t\tconsole.error( '  can not bind to material.materials as node.material does not have a materials array', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject.material.materials;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'bones':\n\n\t\t\t\t\tif ( ! targetObject.skeleton ) {\n\n\t\t\t\t\t\tconsole.error( '  can not bind to bones as node does not have a skeleton', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// potential future optimization: skip this if propertyIndex is already an integer\n\t\t\t\t\t// and convert the integer string to a true integer.\n\n\t\t\t\t\ttargetObject = targetObject.skeleton.bones;\n\n\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\tfor ( var i = 0; i < targetObject.length; i ++ ) {\n\n\t\t\t\t\t\tif ( targetObject[ i ].name === objectIndex ) {\n\n\t\t\t\t\t\t\tobjectIndex = i;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tif ( targetObject[ objectName ] === undefined ) {\n\n\t\t\t\t\t\tconsole.error( '  can not bind to objectName of node, undefined', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject[ objectName ];\n\n\t\t\t}\n\n\n\t\t\tif ( objectIndex !== undefined ) {\n\n\t\t\t\tif ( targetObject[ objectIndex ] === undefined ) {\n\n\t\t\t\t\tconsole.error( \"  trying to bind to objectIndex of objectName, but is undefined:\", this, targetObject );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\ttargetObject = targetObject[ objectIndex ];\n\n\t\t\t}\n\n\t\t}\n\n\t\t// resolve property\n\t\tvar nodeProperty = targetObject[ propertyName ];\n\n\t\tif ( nodeProperty === undefined ) {\n\n\t\t\tvar nodeName = parsedPath.nodeName;\n\n\t\t\tconsole.error( \"  trying to update property for track: \" + nodeName +\n\t\t\t\t\t'.' + propertyName + \" but it wasn't found.\", targetObject );\n\t\t\treturn;\n\n\t\t}\n\n\t\t// determine versioning scheme\n\t\tvar versioning = this.Versioning.None;\n\n\t\tif ( targetObject.needsUpdate !== undefined ) { // material\n\n\t\t\tversioning = this.Versioning.NeedsUpdate;\n\t\t\tthis.targetObject = targetObject;\n\n\t\t} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\n\n\t\t\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\n\t\t\tthis.targetObject = targetObject;\n\n\t\t}\n\n\t\t// determine how the property gets bound\n\t\tvar bindingType = this.BindingType.Direct;\n\n\t\tif ( propertyIndex !== undefined ) {\n\t\t\t// access a sub element of the property array (only primitives are supported right now)\n\n\t\t\tif ( propertyName === \"morphTargetInfluences\" ) {\n\t\t\t\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\n\n\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\tif ( ! targetObject.geometry ) {\n\n\t\t\t\t\tconsole.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! targetObject.geometry.morphTargets ) {\n\n\t\t\t\t\tconsole.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {\n\n\t\t\t\t\tif ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {\n\n\t\t\t\t\t\tpropertyIndex = i;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbindingType = this.BindingType.ArrayElement;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\t\t\tthis.propertyIndex = propertyIndex;\n\n\t\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\n\t\t\t// must use copy for Object3D.Euler/Quaternion\n\n\t\t\tbindingType = this.BindingType.HasFromToArray;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t} else if ( nodeProperty.length !== undefined ) {\n\n\t\t\tbindingType = this.BindingType.EntireArray;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t} else {\n\n\t\t\tthis.propertyName = propertyName;\n\n\t\t}\n\n\t\t// select getter / setter\n\t\tthis.getValue = this.GetterByBindingType[ bindingType ];\n\t\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\n\n\t},\n\n\tunbind: function() {\n\n\t\tthis.node = null;\n\n\t\t// back to the prototype version of getValue / setValue\n\t\t// note: avoiding to mutate the shape of 'this' via 'delete'\n\t\tthis.getValue = this._getValue_unbound;\n\t\tthis.setValue = this._setValue_unbound;\n\n\t}\n\n};\n\nObject.assign( THREE.PropertyBinding.prototype, { // prototype, continued\n\n\t// these are used to \"bind\" a nonexistent property\n\t_getValue_unavailable: function() {},\n\t_setValue_unavailable: function() {},\n\n\t// initial state of these methods that calls 'bind'\n\t_getValue_unbound: THREE.PropertyBinding.prototype.getValue,\n\t_setValue_unbound: THREE.PropertyBinding.prototype.setValue,\n\n\tBindingType: {\n\t\tDirect: 0,\n\t\tEntireArray: 1,\n\t\tArrayElement: 2,\n\t\tHasFromToArray: 3\n\t},\n\n\tVersioning: {\n\t\tNone: 0,\n\t\tNeedsUpdate: 1,\n\t\tMatrixWorldNeedsUpdate: 2\n\t},\n\n\tGetterByBindingType: [\n\n\t\tfunction getValue_direct( buffer, offset ) {\n\n\t\t\tbuffer[ offset ] = this.node[ this.propertyName ];\n\n\t\t},\n\n\t\tfunction getValue_array( buffer, offset ) {\n\n\t\t\tvar source = this.resolvedProperty;\n\n\t\t\tfor ( var i = 0, n = source.length; i !== n; ++ i ) {\n\n\t\t\t\tbuffer[ offset ++ ] = source[ i ];\n\n\t\t\t}\n\n\t\t},\n\n\t\tfunction getValue_arrayElement( buffer, offset ) {\n\n\t\t\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\n\n\t\t},\n\n\t\tfunction getValue_toArray( buffer, offset ) {\n\n\t\t\tthis.resolvedProperty.toArray( buffer, offset );\n\n\t\t}\n\n\t],\n\n\tSetterByBindingTypeAndVersioning: [\n\n\t\t[\n\t\t\t// Direct\n\n\t\t\tfunction setValue_direct( buffer, offset ) {\n\n\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\n\t\t\t},\n\n\t\t\tfunction setValue_direct_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t},\n\n\t\t\tfunction setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t], [\n\n\t\t\t// EntireArray\n\n\t\t\tfunction setValue_array( buffer, offset ) {\n\n\t\t\t\tvar dest = this.resolvedProperty;\n\n\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tfunction setValue_array_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tvar dest = this.resolvedProperty;\n\n\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t}\n\n\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t},\n\n\t\t\tfunction setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tvar dest = this.resolvedProperty;\n\n\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t}\n\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t], [\n\n\t\t\t// ArrayElement\n\n\t\t\tfunction setValue_arrayElement( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\n\t\t\t},\n\n\t\t\tfunction setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t},\n\n\t\t\tfunction setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t], [\n\n\t\t\t// HasToFromArray\n\n\t\t\tfunction setValue_fromArray( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\n\t\t\t},\n\n\t\t\tfunction setValue_fromArray_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t},\n\n\t\t\tfunction setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t]\n\n\t]\n\n} );\n\nTHREE.PropertyBinding.Composite =\n\t\tfunction( targetGroup, path, optionalParsedPath ) {\n\n\tvar parsedPath = optionalParsedPath ||\n\t\t\tTHREE.PropertyBinding.parseTrackName( path );\n\n\tthis._targetGroup = targetGroup;\n\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\n\n};\n\nTHREE.PropertyBinding.Composite.prototype = {\n\n\tconstructor: THREE.PropertyBinding.Composite,\n\n\tgetValue: function( array, offset ) {\n\n\t\tthis.bind(); // bind all binding\n\n\t\tvar firstValidIndex = this._targetGroup.nCachedObjects_,\n\t\t\tbinding = this._bindings[ firstValidIndex ];\n\n\t\t// and only call .getValue on the first\n\t\tif ( binding !== undefined ) binding.getValue( array, offset );\n\n\t},\n\n\tsetValue: function( array, offset ) {\n\n\t\tvar bindings = this._bindings;\n\n\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].setValue( array, offset );\n\n\t\t}\n\n\t},\n\n\tbind: function() {\n\n\t\tvar bindings = this._bindings;\n\n\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].bind();\n\n\t\t}\n\n\t},\n\n\tunbind: function() {\n\n\t\tvar bindings = this._bindings;\n\n\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].unbind();\n\n\t\t}\n\n\t}\n\n};\n\nTHREE.PropertyBinding.create = function( root, path, parsedPath ) {\n\n\tif ( ! ( root instanceof THREE.AnimationObjectGroup ) ) {\n\n\t\treturn new THREE.PropertyBinding( root, path, parsedPath );\n\n\t} else {\n\n\t\treturn new THREE.PropertyBinding.Composite( root, path, parsedPath );\n\n\t}\n\n};\n\nTHREE.PropertyBinding.parseTrackName = function( trackName ) {\n\n\t// matches strings in the form of:\n\t//    nodeName.property\n\t//    nodeName.property[accessor]\n\t//    nodeName.material.property[accessor]\n\t//    uuid.property[accessor]\n\t//    uuid.objectName[objectIndex].propertyName[propertyIndex]\n\t//    parentName/nodeName.property\n\t//    parentName/parentName/nodeName.property[index]\n\t//\t  .bone[Armature.DEF_cog].position\n\t// created and tested via https://regex101.com/#javascript\n\n\tvar re = /^(([\\w]+\\/)*)([\\w-\\d]+)?(\\.([\\w]+)(\\[([\\w\\d\\[\\]\\_.:\\- ]+)\\])?)?(\\.([\\w.]+)(\\[([\\w\\d\\[\\]\\_. ]+)\\])?)$/;\n\tvar matches = re.exec( trackName );\n\n\tif ( ! matches ) {\n\n\t\tthrow new Error( \"cannot parse trackName at all: \" + trackName );\n\n\t}\n\n\tif ( matches.index === re.lastIndex ) {\n\n\t\tre.lastIndex++;\n\n\t}\n\n\tvar results = {\n\t\t// directoryName: matches[ 1 ], // (tschw) currently unused\n\t\tnodeName: matches[ 3 ], \t// allowed to be null, specified root node.\n\t\tobjectName: matches[ 5 ],\n\t\tobjectIndex: matches[ 7 ],\n\t\tpropertyName: matches[ 9 ],\n\t\tpropertyIndex: matches[ 11 ]\t// allowed to be null, specifies that the whole property is set.\n\t};\n\n\tif ( results.propertyName === null || results.propertyName.length === 0 ) {\n\n\t\tthrow new Error( \"can not parse propertyName from trackName: \" + trackName );\n\n\t}\n\n\treturn results;\n\n};\n\nTHREE.PropertyBinding.findNode = function( root, nodeName ) {\n\n\tif ( ! nodeName || nodeName === \"\" || nodeName === \"root\" || nodeName === \".\" || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {\n\n\t\treturn root;\n\n\t}\n\n\t// search into skeleton bones.\n\tif ( root.skeleton ) {\n\n\t\tvar searchSkeleton = function( skeleton ) {\n\n\t\t\tfor( var i = 0; i < skeleton.bones.length; i ++ ) {\n\n\t\t\t\tvar bone = skeleton.bones[ i ];\n\n\t\t\t\tif ( bone.name === nodeName ) {\n\n\t\t\t\t\treturn bone;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t};\n\n\t\tvar bone = searchSkeleton( root.skeleton );\n\n\t\tif ( bone ) {\n\n\t\t\treturn bone;\n\n\t\t}\n\t}\n\n\t// search into node subtree.\n\tif ( root.children ) {\n\n\t\tvar searchNodeSubtree = function( children ) {\n\n\t\t\tfor( var i = 0; i < children.length; i ++ ) {\n\n\t\t\t\tvar childNode = children[ i ];\n\n\t\t\t\tif ( childNode.name === nodeName || childNode.uuid === nodeName ) {\n\n\t\t\t\t\treturn childNode;\n\n\t\t\t\t}\n\n\t\t\t\tvar result = searchNodeSubtree( childNode.children );\n\n\t\t\t\tif ( result ) return result;\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t};\n\n\t\tvar subTreeNode = searchNodeSubtree( root.children );\n\n\t\tif ( subTreeNode ) {\n\n\t\t\treturn subTreeNode;\n\n\t\t}\n\n\t}\n\n\treturn null;\n\n};\n\n// File:src/animation/PropertyMixer.js\n\n/**\n *\n * Buffered scene graph property that allows weighted accumulation.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.PropertyMixer = function ( binding, typeName, valueSize ) {\n\n\tthis.binding = binding;\n\tthis.valueSize = valueSize;\n\n\tvar bufferType = Float64Array,\n\t\tmixFunction;\n\n\tswitch ( typeName ) {\n\n\t\tcase 'quaternion':\t\t\tmixFunction = this._slerp;\t\tbreak;\n\n\t\tcase 'string':\n\t\tcase 'bool':\n\n\t\t\tbufferType = Array,\t\tmixFunction = this._select;\t\tbreak;\n\n\t\tdefault:\t\t\t\t\tmixFunction = this._lerp;\n\n\t}\n\n\tthis.buffer = new bufferType( valueSize * 4 );\n\t// layout: [ incoming | accu0 | accu1 | orig ]\n\t//\n\t// interpolators can use .buffer as their .result\n\t// the data then goes to 'incoming'\n\t//\n\t// 'accu0' and 'accu1' are used frame-interleaved for\n\t// the cumulative result and are compared to detect\n\t// changes\n\t//\n\t// 'orig' stores the original state of the property\n\n\tthis._mixBufferRegion = mixFunction;\n\n\tthis.cumulativeWeight = 0;\n\n\tthis.useCount = 0;\n\tthis.referenceCount = 0;\n\n};\n\nTHREE.PropertyMixer.prototype = {\n\n\tconstructor: THREE.PropertyMixer,\n\n\t// accumulate data in the 'incoming' region into 'accu<i>'\n\taccumulate: function( accuIndex, weight ) {\n\n\t\t// note: happily accumulating nothing when weight = 0, the caller knows\n\t\t// the weight and shouldn't have made the call in the first place\n\n\t\tvar buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = accuIndex * stride + stride,\n\n\t\t\tcurrentWeight = this.cumulativeWeight;\n\n\t\tif ( currentWeight === 0 ) {\n\n\t\t\t// accuN := incoming * weight\n\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ offset + i ] = buffer[ i ];\n\n\t\t\t}\n\n\t\t\tcurrentWeight = weight;\n\n\t\t} else {\n\n\t\t\t// accuN := accuN + incoming * weight\n\n\t\t\tcurrentWeight += weight;\n\t\t\tvar mix = weight / currentWeight;\n\t\t\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\n\n\t\t}\n\n\t\tthis.cumulativeWeight = currentWeight;\n\n\t},\n\n\t// apply the state of 'accu<i>' to the binding when accus differ\n\tapply: function( accuIndex ) {\n\n\t\tvar stride = this.valueSize,\n\t\t\tbuffer = this.buffer,\n\t\t\toffset = accuIndex * stride + stride,\n\n\t\t\tweight = this.cumulativeWeight,\n\n\t\t\tbinding = this.binding;\n\n\t\tthis.cumulativeWeight = 0;\n\n\t\tif ( weight < 1 ) {\n\n\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\n\n\t\t\tvar originalValueOffset = stride * 3;\n\n\t\t\tthis._mixBufferRegion(\n\t\t\t\t\tbuffer, offset, originalValueOffset, 1 - weight, stride );\n\n\t\t}\n\n\t\tfor ( var i = stride, e = stride + stride; i !== e; ++ i ) {\n\n\t\t\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\n\n\t\t\t\t// value has changed -> update scene graph\n\n\t\t\t\tbinding.setValue( buffer, offset );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t// remember the state of the bound property and copy it to both accus\n\tsaveOriginalState: function() {\n\n\t\tvar binding = this.binding;\n\n\t\tvar buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\n\t\t\toriginalValueOffset = stride * 3;\n\n\t\tbinding.getValue( buffer, originalValueOffset );\n\n\t\t// accu[0..1] := orig -- initially detect changes against the original\n\t\tfor ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {\n\n\t\t\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\n\n\t\t}\n\n\t\tthis.cumulativeWeight = 0;\n\n\t},\n\n\t// apply the state previously taken via 'saveOriginalState' to the binding\n\trestoreOriginalState: function() {\n\n\t\tvar originalValueOffset = this.valueSize * 3;\n\t\tthis.binding.setValue( this.buffer, originalValueOffset );\n\n\t},\n\n\n\t// mix functions\n\n\t_select: function( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tif ( t >= 0.5 ) {\n\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t_slerp: function( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tTHREE.Quaternion.slerpFlat( buffer, dstOffset,\n\t\t\t\tbuffer, dstOffset, buffer, srcOffset, t );\n\n\t},\n\n\t_lerp: function( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tvar s = 1 - t;\n\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\tvar j = dstOffset + i;\n\n\t\t\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\n\n\t\t}\n\n\t}\n\n};\n\n// File:src/animation/tracks/BooleanKeyframeTrack.js\n\n/**\n *\n * A Track of Boolean keyframe values.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.BooleanKeyframeTrack = function ( name, times, values ) {\n\n\tTHREE.KeyframeTrack.call( this, name, times, values );\n\n};\n\nTHREE.BooleanKeyframeTrack.prototype =\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\n\tconstructor: THREE.BooleanKeyframeTrack,\n\n\tValueTypeName: 'bool',\n\tValueBufferType: Array,\n\n\tDefaultInterpolation: THREE.InterpolateDiscrete,\n\n\tInterpolantFactoryMethodLinear: undefined,\n\tInterpolantFactoryMethodSmooth: undefined\n\n\t// Note: Actually this track could have a optimized / compressed\n\t// representation of a single value and a custom interpolant that\n\t// computes \"firstValue ^ isOdd( index )\".\n\n} );\n\n// File:src/animation/tracks/ColorKeyframeTrack.js\n\n/**\n *\n * A Track of keyframe values that represent color.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.ColorKeyframeTrack = function ( name, times, values, interpolation ) {\n\n\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\n\n};\n\nTHREE.ColorKeyframeTrack.prototype =\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\n\tconstructor: THREE.ColorKeyframeTrack,\n\n\tValueTypeName: 'color'\n\n\t// ValueBufferType is inherited\n\n\t// DefaultInterpolation is inherited\n\n\n\t// Note: Very basic implementation and nothing special yet.\n\t// However, this is the place for color space parameterization.\n\n} );\n\n// File:src/animation/tracks/NumberKeyframeTrack.js\n\n/**\n *\n * A Track of numeric keyframe values.\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.NumberKeyframeTrack = function ( name, times, values, interpolation ) {\n\n\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\n\n};\n\nTHREE.NumberKeyframeTrack.prototype =\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\n\tconstructor: THREE.NumberKeyframeTrack,\n\n\tValueTypeName: 'number',\n\n\t// ValueBufferType is inherited\n\n\t// DefaultInterpolation is inherited\n\n} );\n\n// File:src/animation/tracks/QuaternionKeyframeTrack.js\n\n/**\n *\n * A Track of quaternion keyframe values.\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.QuaternionKeyframeTrack = function ( name, times, values, interpolation ) {\n\n\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\n\n};\n\nTHREE.QuaternionKeyframeTrack.prototype =\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\n\tconstructor: THREE.QuaternionKeyframeTrack,\n\n\tValueTypeName: 'quaternion',\n\n\t// ValueBufferType is inherited\n\n\tDefaultInterpolation: THREE.InterpolateLinear,\n\n\tInterpolantFactoryMethodLinear: function( result ) {\n\n\t\treturn new THREE.QuaternionLinearInterpolant(\n\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\n\t},\n\n\tInterpolantFactoryMethodSmooth: undefined // not yet implemented\n\n} );\n\n// File:src/animation/tracks/StringKeyframeTrack.js\n\n/**\n *\n * A Track that interpolates Strings\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.StringKeyframeTrack = function ( name, times, values, interpolation ) {\n\n\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\n\n};\n\nTHREE.StringKeyframeTrack.prototype =\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\n\tconstructor: THREE.StringKeyframeTrack,\n\n\tValueTypeName: 'string',\n\tValueBufferType: Array,\n\n\tDefaultInterpolation: THREE.InterpolateDiscrete,\n\n\tInterpolantFactoryMethodLinear: undefined,\n\n\tInterpolantFactoryMethodSmooth: undefined\n\n} );\n\n// File:src/animation/tracks/VectorKeyframeTrack.js\n\n/**\n *\n * A Track of vectored keyframe values.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.VectorKeyframeTrack = function ( name, times, values, interpolation ) {\n\n\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\n\n};\n\nTHREE.VectorKeyframeTrack.prototype =\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\n\tconstructor: THREE.VectorKeyframeTrack,\n\n\tValueTypeName: 'vector'\n\n\t// ValueBufferType is inherited\n\n\t// DefaultInterpolation is inherited\n\n} );\n\n// File:src/audio/Audio.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author Reece Aaron Lecrivain / http://reecenotes.com/\n */\n\nTHREE.Audio = function ( listener ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Audio';\n\n\tthis.context = listener.context;\n\tthis.source = this.context.createBufferSource();\n\tthis.source.onended = this.onEnded.bind( this );\n\n\tthis.gain = this.context.createGain();\n\tthis.gain.connect( listener.getInput() );\n\n\tthis.autoplay = false;\n\n\tthis.startTime = 0;\n\tthis.playbackRate = 1;\n\tthis.isPlaying = false;\n\tthis.hasPlaybackControl = true;\n\tthis.sourceType = 'empty';\n\n\tthis.filters = [];\n\n};\n\nTHREE.Audio.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Audio,\n\n\tgetOutput: function () {\n\n\t\treturn this.gain;\n\n\t},\n\n\tsetNodeSource: function ( audioNode ) {\n\n\t\tthis.hasPlaybackControl = false;\n\t\tthis.sourceType = 'audioNode';\n\t\tthis.source = audioNode;\n\t\tthis.connect();\n\n\t\treturn this;\n\n\t},\n\n\tsetBuffer: function ( audioBuffer ) {\n\n\t\tthis.source.buffer = audioBuffer;\n\t\tthis.sourceType = 'buffer';\n\n\t\tif ( this.autoplay ) this.play();\n\n\t\treturn this;\n\n\t},\n\n\tplay: function () {\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: Audio is already playing.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar source = this.context.createBufferSource();\n\n\t\tsource.buffer = this.source.buffer;\n\t\tsource.loop = this.source.loop;\n\t\tsource.onended = this.source.onended;\n\t\tsource.start( 0, this.startTime );\n\t\tsource.playbackRate.value = this.playbackRate;\n\n\t\tthis.isPlaying = true;\n\n\t\tthis.source = source;\n\n\t\treturn this.connect();\n\n\t},\n\n\tpause: function () {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.source.stop();\n\t\tthis.startTime = this.context.currentTime;\n\t\tthis.isPlaying = false;\n\n\t\treturn this;\n\n\t},\n\n\tstop: function () {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.source.stop();\n\t\tthis.startTime = 0;\n\t\tthis.isPlaying = false;\n\n\t\treturn this;\n\n\t},\n\n\tconnect: function () {\n\n\t\tif ( this.filters.length > 0 ) {\n\n\t\t\tthis.source.connect( this.filters[ 0 ] );\n\n\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\n\n\t\t\t\tthis.filters[ i - 1 ].connect( this.filters[ i ] );\n\n\t\t\t}\n\n\t\t\tthis.filters[ this.filters.length - 1 ].connect( this.getOutput() );\n\n\t\t} else {\n\n\t\t\tthis.source.connect( this.getOutput() );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tdisconnect: function () {\n\n\t\tif ( this.filters.length > 0 ) {\n\n\t\t\tthis.source.disconnect( this.filters[ 0 ] );\n\n\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\n\n\t\t\t\tthis.filters[ i - 1 ].disconnect( this.filters[ i ] );\n\n\t\t\t}\n\n\t\t\tthis.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );\n\n\t\t} else {\n\n\t\t\tthis.source.disconnect( this.getOutput() );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tgetFilters: function () {\n\n\t\treturn this.filters;\n\n\t},\n\n\tsetFilters: function ( value ) {\n\n\t\tif ( ! value ) value = [];\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tthis.disconnect();\n\t\t\tthis.filters = value;\n\t\t\tthis.connect();\n\n\t\t} else {\n\n\t\t\tthis.filters = value;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tgetFilter: function () {\n\n\t\treturn this.getFilters()[ 0 ];\n\n\t},\n\n\tsetFilter: function ( filter ) {\n\n\t\treturn this.setFilters( filter ? [ filter ] : [] );\n\n\t},\n\n\tsetPlaybackRate: function ( value ) {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.playbackRate = value;\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tthis.source.playbackRate.value = this.playbackRate;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tgetPlaybackRate: function () {\n\n\t\treturn this.playbackRate;\n\n\t},\n\n\tonEnded: function () {\n\n\t\tthis.isPlaying = false;\n\n\t},\n\n\tgetLoop: function () {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn this.source.loop;\n\n\t},\n\n\tsetLoop: function ( value ) {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.source.loop = value;\n\n\t},\n\n\tgetVolume: function () {\n\n\t\treturn this.gain.gain.value;\n\n\t},\n\n\n\tsetVolume: function ( value ) {\n\n\t\tthis.gain.gain.value = value;\n\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/audio/AudioAnalyser.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.AudioAnalyser = function ( audio, fftSize ) {\n\n\tthis.analyser = audio.context.createAnalyser();\n\tthis.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;\n\n\tthis.data = new Uint8Array( this.analyser.frequencyBinCount );\n\n\taudio.getOutput().connect( this.analyser );\n\n};\n\nObject.assign( THREE.AudioAnalyser.prototype, {\n\n\tgetFrequencyData: function () {\n\n\t\tthis.analyser.getByteFrequencyData( this.data );\n\n\t\treturn this.data;\n\n\t},\n\n\tgetAverageFrequency: function () {\n\n\t\tvar value = 0, data = this.getFrequencyData();\n\n\t\tfor ( var i = 0; i < data.length; i ++ ) {\n\n\t\t\tvalue += data[ i ];\n\n\t\t}\n\n\t\treturn value / data.length;\n\n\t}\n\n} );\n\n// File:src/audio/AudioContext.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nObject.defineProperty( THREE, 'AudioContext', {\n\n\tget: ( function () {\n\n\t\tvar context;\n\n\t\treturn function get() {\n\n\t\t\tif ( context === undefined ) {\n\n\t\t\t\tcontext = new ( window.AudioContext || window.webkitAudioContext )();\n\n\t\t\t}\n\n\t\t\treturn context;\n\n\t\t};\n\n\t} )()\n\n} );\n\n// File:src/audio/PositionalAudio.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.PositionalAudio = function ( listener ) {\n\n\tTHREE.Audio.call( this, listener );\n\n\tthis.panner = this.context.createPanner();\n\tthis.panner.connect( this.gain );\n\n};\n\nTHREE.PositionalAudio.prototype = Object.assign( Object.create( THREE.Audio.prototype ), {\n\n\tconstructor: THREE.PositionalAudio,\n\n\tgetOutput: function () {\n\n\t\treturn this.panner;\n\n\t},\n\n\tgetRefDistance: function () {\n\n\t\treturn this.panner.refDistance;\n\n\t},\n\n\tsetRefDistance: function ( value ) {\n\n\t\tthis.panner.refDistance = value;\n\n\t},\n\n\tgetRolloffFactor: function () {\n\n\t\treturn this.panner.rolloffFactor;\n\n\t},\n\n\tsetRolloffFactor: function ( value ) {\n\n\t\tthis.panner.rolloffFactor = value;\n\n\t},\n\n\tgetDistanceModel: function () {\n\n\t\treturn this.panner.distanceModel;\n\n\t},\n\n\tsetDistanceModel: function ( value ) {\n\n\t\tthis.panner.distanceModel = value;\n\n\t},\n\n\tgetMaxDistance: function () {\n\n\t\treturn this.panner.maxDistance;\n\n\t},\n\n\tsetMaxDistance: function ( value ) {\n\n\t\tthis.panner.maxDistance = value;\n\n\t},\n\n\tupdateMatrixWorld: ( function () {\n\n\t\tvar position = new THREE.Vector3();\n\n\t\treturn function updateMatrixWorld( force ) {\n\n\t\t\tTHREE.Object3D.prototype.updateMatrixWorld.call( this, force );\n\n\t\t\tposition.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\tthis.panner.setPosition( position.x, position.y, position.z );\n\n\t\t};\n\n\t} )()\n\n\n} );\n\n// File:src/audio/AudioListener.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.AudioListener = function () {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'AudioListener';\n\n\tthis.context = THREE.AudioContext;\n\n\tthis.gain = this.context.createGain();\n\tthis.gain.connect( this.context.destination );\n\n\tthis.filter = null;\n\n};\n\nTHREE.AudioListener.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.AudioListener,\n\n\tgetInput: function () {\n\n\t\treturn this.gain;\n\n\t},\n\n\tremoveFilter: function ( ) {\n\n\t\tif ( this.filter !== null ) {\n\n\t\t\tthis.gain.disconnect( this.filter );\n\t\t\tthis.filter.disconnect( this.context.destination );\n\t\t\tthis.gain.connect( this.context.destination );\n\t\t\tthis.filter = null;\n\n\t\t}\n\n\t},\n\n\tgetFilter: function () {\n\n\t\treturn this.filter;\n\n\t},\n\n\tsetFilter: function ( value ) {\n\n\t\tif ( this.filter !== null ) {\n\n\t\t\tthis.gain.disconnect( this.filter );\n\t\t\tthis.filter.disconnect( this.context.destination );\n\n\t\t} else {\n\n\t\t\tthis.gain.disconnect( this.context.destination );\n\n\t\t}\n\n\t\tthis.filter = value;\n\t\tthis.gain.connect( this.filter );\n\t\tthis.filter.connect( this.context.destination );\n\n\t},\n\n\tgetMasterVolume: function () {\n\n\t\treturn this.gain.gain.value;\n\n\t},\n\n\tsetMasterVolume: function ( value ) {\n\n\t\tthis.gain.gain.value = value;\n\n\t},\n\n\tupdateMatrixWorld: ( function () {\n\n\t\tvar position = new THREE.Vector3();\n\t\tvar quaternion = new THREE.Quaternion();\n\t\tvar scale = new THREE.Vector3();\n\n\t\tvar orientation = new THREE.Vector3();\n\n\t\treturn function updateMatrixWorld( force ) {\n\n\t\t\tTHREE.Object3D.prototype.updateMatrixWorld.call( this, force );\n\n\t\t\tvar listener = this.context.listener;\n\t\t\tvar up = this.up;\n\n\t\t\tthis.matrixWorld.decompose( position, quaternion, scale );\n\n\t\t\torientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );\n\n\t\t\tlistener.setPosition( position.x, position.y, position.z );\n\t\t\tlistener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );\n\n\t\t};\n\n\t} )()\n\n} );\n\n// File:src/cameras/Camera.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author mikael emtinger / http://gomo.se/\n * @author WestLangley / http://github.com/WestLangley\n*/\n\nTHREE.Camera = function () {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Camera';\n\n\tthis.matrixWorldInverse = new THREE.Matrix4();\n\tthis.projectionMatrix = new THREE.Matrix4();\n\n};\n\nTHREE.Camera.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.Camera.prototype.constructor = THREE.Camera;\n\nTHREE.Camera.prototype.getWorldDirection = function () {\n\n\tvar quaternion = new THREE.Quaternion();\n\n\treturn function getWorldDirection( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\tthis.getWorldQuaternion( quaternion );\n\n\t\treturn result.set( 0, 0, - 1 ).applyQuaternion( quaternion );\n\n\t};\n\n}();\n\nTHREE.Camera.prototype.lookAt = function () {\n\n\t// This routine does not support cameras with rotated and/or translated parent(s)\n\n\tvar m1 = new THREE.Matrix4();\n\n\treturn function lookAt( vector ) {\n\n\t\tm1.lookAt( this.position, vector, this.up );\n\n\t\tthis.quaternion.setFromRotationMatrix( m1 );\n\n\t};\n\n}();\n\nTHREE.Camera.prototype.clone = function () {\n\n\treturn new this.constructor().copy( this );\n\n};\n\nTHREE.Camera.prototype.copy = function ( source ) {\n\n\tTHREE.Object3D.prototype.copy.call( this, source );\n\n\tthis.matrixWorldInverse.copy( source.matrixWorldInverse );\n\tthis.projectionMatrix.copy( source.projectionMatrix );\n\n\treturn this;\n\n};\n\n// File:src/cameras/CubeCamera.js\n\n/**\n * Camera for rendering cube maps\n *\t- renders scene into axis-aligned cube\n *\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.CubeCamera = function ( near, far, cubeResolution ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'CubeCamera';\n\n\tvar fov = 90, aspect = 1;\n\n\tvar cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraPX.up.set( 0, - 1, 0 );\n\tcameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );\n\tthis.add( cameraPX );\n\n\tvar cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraNX.up.set( 0, - 1, 0 );\n\tcameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );\n\tthis.add( cameraNX );\n\n\tvar cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraPY.up.set( 0, 0, 1 );\n\tcameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );\n\tthis.add( cameraPY );\n\n\tvar cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraNY.up.set( 0, 0, - 1 );\n\tcameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );\n\tthis.add( cameraNY );\n\n\tvar cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraPZ.up.set( 0, - 1, 0 );\n\tcameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );\n\tthis.add( cameraPZ );\n\n\tvar cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraNZ.up.set( 0, - 1, 0 );\n\tcameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );\n\tthis.add( cameraNZ );\n\n\tvar options = { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter };\n\n\tthis.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, options );\n\n\tthis.updateCubeMap = function ( renderer, scene ) {\n\n\t\tif ( this.parent === null ) this.updateMatrixWorld();\n\n\t\tvar renderTarget = this.renderTarget;\n\t\tvar generateMipmaps = renderTarget.texture.generateMipmaps;\n\n\t\trenderTarget.texture.generateMipmaps = false;\n\n\t\trenderTarget.activeCubeFace = 0;\n\t\trenderer.render( scene, cameraPX, renderTarget );\n\n\t\trenderTarget.activeCubeFace = 1;\n\t\trenderer.render( scene, cameraNX, renderTarget );\n\n\t\trenderTarget.activeCubeFace = 2;\n\t\trenderer.render( scene, cameraPY, renderTarget );\n\n\t\trenderTarget.activeCubeFace = 3;\n\t\trenderer.render( scene, cameraNY, renderTarget );\n\n\t\trenderTarget.activeCubeFace = 4;\n\t\trenderer.render( scene, cameraPZ, renderTarget );\n\n\t\trenderTarget.texture.generateMipmaps = generateMipmaps;\n\n\t\trenderTarget.activeCubeFace = 5;\n\t\trenderer.render( scene, cameraNZ, renderTarget );\n\n\t\trenderer.setRenderTarget( null );\n\n\t};\n\n};\n\nTHREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.CubeCamera.prototype.constructor = THREE.CubeCamera;\n\n// File:src/cameras/OrthographicCamera.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author arose / http://github.com/arose\n */\n\nTHREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {\n\n\tTHREE.Camera.call( this );\n\n\tthis.type = 'OrthographicCamera';\n\n\tthis.zoom = 1;\n\tthis.view = null;\n\n\tthis.left = left;\n\tthis.right = right;\n\tthis.top = top;\n\tthis.bottom = bottom;\n\n\tthis.near = ( near !== undefined ) ? near : 0.1;\n\tthis.far = ( far !== undefined ) ? far : 2000;\n\n\tthis.updateProjectionMatrix();\n\n};\n\nTHREE.OrthographicCamera.prototype = Object.assign( Object.create( THREE.Camera.prototype ), {\n\n\tconstructor: THREE.OrthographicCamera,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Camera.prototype.copy.call( this, source );\n\n\t\tthis.left = source.left;\n\t\tthis.right = source.right;\n\t\tthis.top = source.top;\n\t\tthis.bottom = source.bottom;\n\t\tthis.near = source.near;\n\t\tthis.far = source.far;\n\n\t\tthis.zoom = source.zoom;\n\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\treturn this;\n\n\t},\n\n\tsetViewOffset: function( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\tthis.view = {\n\t\t\tfullWidth: fullWidth,\n\t\t\tfullHeight: fullHeight,\n\t\t\toffsetX: x,\n\t\t\toffsetY: y,\n\t\t\twidth: width,\n\t\t\theight: height\n\t\t};\n\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\tclearViewOffset: function() {\n\n\t\tthis.view = null;\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\tupdateProjectionMatrix: function () {\n\n\t\tvar dx = ( this.right - this.left ) / ( 2 * this.zoom );\n\t\tvar dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\n\t\tvar cx = ( this.right + this.left ) / 2;\n\t\tvar cy = ( this.top + this.bottom ) / 2;\n\n\t\tvar left = cx - dx;\n\t\tvar right = cx + dx;\n\t\tvar top = cy + dy;\n\t\tvar bottom = cy - dy;\n\n\t\tif ( this.view !== null ) {\n\n\t\t\tvar zoomW = this.zoom / ( this.view.width / this.view.fullWidth );\n\t\t\tvar zoomH = this.zoom / ( this.view.height / this.view.fullHeight );\n\t\t\tvar scaleW = ( this.right - this.left ) / this.view.width;\n\t\t\tvar scaleH = ( this.top - this.bottom ) / this.view.height;\n\n\t\t\tleft += scaleW * ( this.view.offsetX / zoomW );\n\t\t\tright = left + scaleW * ( this.view.width / zoomW );\n\t\t\ttop -= scaleH * ( this.view.offsetY / zoomH );\n\t\t\tbottom = top - scaleH * ( this.view.height / zoomH );\n\n\t\t}\n\n\t\tthis.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\n\n\t\tdata.object.zoom = this.zoom;\n\t\tdata.object.left = this.left;\n\t\tdata.object.right = this.right;\n\t\tdata.object.top = this.top;\n\t\tdata.object.bottom = this.bottom;\n\t\tdata.object.near = this.near;\n\t\tdata.object.far = this.far;\n\n\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\treturn data;\n\n\t}\n\n} );\n\n// File:src/cameras/PerspectiveCamera.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author greggman / http://games.greggman.com/\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author tschw\n */\n\nTHREE.PerspectiveCamera = function( fov, aspect, near, far ) {\n\n\tTHREE.Camera.call( this );\n\n\tthis.type = 'PerspectiveCamera';\n\n\tthis.fov = fov !== undefined ? fov : 50;\n\tthis.zoom = 1;\n\n\tthis.near = near !== undefined ? near : 0.1;\n\tthis.far = far !== undefined ? far : 2000;\n\tthis.focus = 10;\n\n\tthis.aspect = aspect !== undefined ? aspect : 1;\n\tthis.view = null;\n\n\tthis.filmGauge = 35;\t// width of the film (default in millimeters)\n\tthis.filmOffset = 0;\t// horizontal film offset (same unit as gauge)\n\n\tthis.updateProjectionMatrix();\n\n};\n\nTHREE.PerspectiveCamera.prototype = Object.assign( Object.create( THREE.Camera.prototype ), {\n\n\tconstructor: THREE.PerspectiveCamera,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Camera.prototype.copy.call( this, source );\n\n\t\tthis.fov = source.fov;\n\t\tthis.zoom = source.zoom;\n\n\t\tthis.near = source.near;\n\t\tthis.far = source.far;\n\t\tthis.focus = source.focus;\n\n\t\tthis.aspect = source.aspect;\n\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\tthis.filmGauge = source.filmGauge;\n\t\tthis.filmOffset = source.filmOffset;\n\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Sets the FOV by focal length in respect to the current .filmGauge.\n\t *\n\t * The default film gauge is 35, so that the focal length can be specified for\n\t * a 35mm (full frame) camera.\n\t *\n\t * Values for focal length and film gauge must have the same unit.\n\t */\n\tsetFocalLength: function ( focalLength ) {\n\n\t\t// see http://www.bobatkins.com/photography/technical/field_of_view.html\n\t\tvar vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n\n\t\tthis.fov = THREE.Math.RAD2DEG * 2 * Math.atan( vExtentSlope );\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\t/**\n\t * Calculates the focal length from the current .fov and .filmGauge.\n\t */\n\tgetFocalLength: function () {\n\n\t\tvar vExtentSlope = Math.tan( THREE.Math.DEG2RAD * 0.5 * this.fov );\n\n\t\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\n\n\t},\n\n\tgetEffectiveFOV: function () {\n\n\t\treturn THREE.Math.RAD2DEG * 2 * Math.atan(\n\t\t\t\tMath.tan( THREE.Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );\n\n\t},\n\n\tgetFilmWidth: function () {\n\n\t\t// film not completely covered in portrait format (aspect < 1)\n\t\treturn this.filmGauge * Math.min( this.aspect, 1 );\n\n\t},\n\n\tgetFilmHeight: function () {\n\n\t\t// film not completely covered in landscape format (aspect > 1)\n\t\treturn this.filmGauge / Math.max( this.aspect, 1 );\n\n\t},\n\n\t/**\n\t * Sets an offset in a larger frustum. This is useful for multi-window or\n\t * multi-monitor/multi-machine setups.\n\t *\n\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n\t * the monitors are in grid like this\n\t *\n\t *   +---+---+---+\n\t *   | A | B | C |\n\t *   +---+---+---+\n\t *   | D | E | F |\n\t *   +---+---+---+\n\t *\n\t * then for each monitor you would call it like this\n\t *\n\t *   var w = 1920;\n\t *   var h = 1080;\n\t *   var fullWidth = w * 3;\n\t *   var fullHeight = h * 2;\n\t *\n\t *   --A--\n\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n\t *   --B--\n\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n\t *   --C--\n\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n\t *   --D--\n\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n\t *   --E--\n\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n\t *   --F--\n\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n\t *\n\t *   Note there is no reason monitors have to be the same size or in a grid.\n\t */\n\tsetViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\tthis.aspect = fullWidth / fullHeight;\n\n\t\tthis.view = {\n\t\t\tfullWidth: fullWidth,\n\t\t\tfullHeight: fullHeight,\n\t\t\toffsetX: x,\n\t\t\toffsetY: y,\n\t\t\twidth: width,\n\t\t\theight: height\n\t\t};\n\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\tclearViewOffset: function() {\n\n\t\tthis.view = null;\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\tupdateProjectionMatrix: function () {\n\n\t\tvar near = this.near,\n\t\t\ttop = near * Math.tan(\n\t\t\t\t\tTHREE.Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,\n\t\t\theight = 2 * top,\n\t\t\twidth = this.aspect * height,\n\t\t\tleft = - 0.5 * width,\n\t\t\tview = this.view;\n\n\t\tif ( view !== null ) {\n\n\t\t\tvar fullWidth = view.fullWidth,\n\t\t\t\tfullHeight = view.fullHeight;\n\n\t\t\tleft += view.offsetX * width / fullWidth;\n\t\t\ttop -= view.offsetY * height / fullHeight;\n\t\t\twidth *= view.width / fullWidth;\n\t\t\theight *= view.height / fullHeight;\n\n\t\t}\n\n\t\tvar skew = this.filmOffset;\n\t\tif ( skew !== 0 ) left += near * skew / this.getFilmWidth();\n\n\t\tthis.projectionMatrix.makeFrustum(\n\t\t\t\tleft, left + width, top - height, top, near, this.far );\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\n\n\t\tdata.object.fov = this.fov;\n\t\tdata.object.zoom = this.zoom;\n\n\t\tdata.object.near = this.near;\n\t\tdata.object.far = this.far;\n\t\tdata.object.focus = this.focus;\n\n\t\tdata.object.aspect = this.aspect;\n\n\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\tdata.object.filmGauge = this.filmGauge;\n\t\tdata.object.filmOffset = this.filmOffset;\n\n\t\treturn data;\n\n\t}\n\n} );\n\n// File:src/cameras/StereoCamera.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.StereoCamera = function () {\n\n\tthis.type = 'StereoCamera';\n\n\tthis.aspect = 1;\n\n\tthis.cameraL = new THREE.PerspectiveCamera();\n\tthis.cameraL.layers.enable( 1 );\n\tthis.cameraL.matrixAutoUpdate = false;\n\n\tthis.cameraR = new THREE.PerspectiveCamera();\n\tthis.cameraR.layers.enable( 2 );\n\tthis.cameraR.matrixAutoUpdate = false;\n\n};\n\nObject.assign( THREE.StereoCamera.prototype, {\n\n\tupdate: ( function () {\n\n\t\tvar focus, fov, aspect, near, far;\n\n\t\tvar eyeRight = new THREE.Matrix4();\n\t\tvar eyeLeft = new THREE.Matrix4();\n\n\t\treturn function update( camera ) {\n\n\t\t\tvar needsUpdate = focus !== camera.focus || fov !== camera.fov ||\n\t\t\t\t\t\t\t\t\t\t\t\taspect !== camera.aspect * this.aspect || near !== camera.near ||\n\t\t\t\t\t\t\t\t\t\t\t\tfar !== camera.far;\n\n\t\t\tif ( needsUpdate ) {\n\n\t\t\t\tfocus = camera.focus;\n\t\t\t\tfov = camera.fov;\n\t\t\t\taspect = camera.aspect * this.aspect;\n\t\t\t\tnear = camera.near;\n\t\t\t\tfar = camera.far;\n\n\t\t\t\t// Off-axis stereoscopic effect based on\n\t\t\t\t// http://paulbourke.net/stereographics/stereorender/\n\n\t\t\t\tvar projectionMatrix = camera.projectionMatrix.clone();\n\t\t\t\tvar eyeSep = 0.064 / 2;\n\t\t\t\tvar eyeSepOnProjection = eyeSep * near / focus;\n\t\t\t\tvar ymax = near * Math.tan( THREE.Math.DEG2RAD * fov * 0.5 );\n\t\t\t\tvar xmin, xmax;\n\n\t\t\t\t// translate xOffset\n\n\t\t\t\teyeLeft.elements[ 12 ] = - eyeSep;\n\t\t\t\teyeRight.elements[ 12 ] = eyeSep;\n\n\t\t\t\t// for left eye\n\n\t\t\t\txmin = - ymax * aspect + eyeSepOnProjection;\n\t\t\t\txmax = ymax * aspect + eyeSepOnProjection;\n\n\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\n\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\t\tthis.cameraL.projectionMatrix.copy( projectionMatrix );\n\n\t\t\t\t// for right eye\n\n\t\t\t\txmin = - ymax * aspect - eyeSepOnProjection;\n\t\t\t\txmax = ymax * aspect - eyeSepOnProjection;\n\n\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\n\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\t\tthis.cameraR.projectionMatrix.copy( projectionMatrix );\n\n\t\t\t}\n\n\t\t\tthis.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );\n\t\t\tthis.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );\n\n\t\t};\n\n\t} )()\n\n} );\n\n// File:src/lights/Light.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Light = function ( color, intensity ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Light';\n\n\tthis.color = new THREE.Color( color );\n\tthis.intensity = intensity !== undefined ? intensity : 1;\n\n\tthis.receiveShadow = undefined;\n\n};\n\nTHREE.Light.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Light,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Object3D.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\t\tthis.intensity = source.intensity;\n\n\t\treturn this;\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\n\n\t\tdata.object.color = this.color.getHex();\n\t\tdata.object.intensity = this.intensity;\n\n\t\tif ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();\n\n\t\tif ( this.distance !== undefined ) data.object.distance = this.distance;\n\t\tif ( this.angle !== undefined ) data.object.angle = this.angle;\n\t\tif ( this.decay !== undefined ) data.object.decay = this.decay;\n\t\tif ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;\n\n\t\treturn data;\n\n\t}\n\n} );\n\n// File:src/lights/LightShadow.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.LightShadow = function ( camera ) {\n\n\tthis.camera = camera;\n\n\tthis.bias = 0;\n\tthis.radius = 1;\n\n\tthis.mapSize = new THREE.Vector2( 512, 512 );\n\n\tthis.map = null;\n\tthis.matrix = new THREE.Matrix4();\n\n};\n\nObject.assign( THREE.LightShadow.prototype, {\n\n\tcopy: function ( source ) {\n\n\t\tthis.camera = source.camera.clone();\n\n\t\tthis.bias = source.bias;\n\t\tthis.radius = source.radius;\n\n\t\tthis.mapSize.copy( source.mapSize );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n} );\n\n// File:src/lights/AmbientLight.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.AmbientLight = function ( color, intensity ) {\n\n\tTHREE.Light.call( this, color, intensity );\n\n\tthis.type = 'AmbientLight';\n\n\tthis.castShadow = undefined;\n\n};\n\nTHREE.AmbientLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\n\n\tconstructor: THREE.AmbientLight\n\n} );\n\n// File:src/lights/DirectionalLight.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.DirectionalLight = function ( color, intensity ) {\n\n\tTHREE.Light.call( this, color, intensity );\n\n\tthis.type = 'DirectionalLight';\n\n\tthis.position.set( 0, 1, 0 );\n\tthis.updateMatrix();\n\n\tthis.target = new THREE.Object3D();\n\n\tthis.shadow = new THREE.DirectionalLightShadow();\n\n};\n\nTHREE.DirectionalLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\n\n\tconstructor: THREE.DirectionalLight,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Light.prototype.copy.call( this, source );\n\n\t\tthis.target = source.target.clone();\n\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/lights/DirectionalLightShadow.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.DirectionalLightShadow = function ( light ) {\n\n\tTHREE.LightShadow.call( this, new THREE.OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );\n\n};\n\nTHREE.DirectionalLightShadow.prototype = Object.assign( Object.create( THREE.LightShadow.prototype ), {\n\n\tconstructor: THREE.DirectionalLightShadow\n\n} );\n\n// File:src/lights/HemisphereLight.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {\n\n\tTHREE.Light.call( this, skyColor, intensity );\n\n\tthis.type = 'HemisphereLight';\n\n\tthis.castShadow = undefined;\n\n\tthis.position.set( 0, 1, 0 );\n\tthis.updateMatrix();\n\n\tthis.groundColor = new THREE.Color( groundColor );\n\n};\n\nTHREE.HemisphereLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\n\n\tconstructor: THREE.HemisphereLight,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Light.prototype.copy.call( this, source );\n\n\t\tthis.groundColor.copy( source.groundColor );\n\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/lights/PointLight.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\n\nTHREE.PointLight = function ( color, intensity, distance, decay ) {\n\n\tTHREE.Light.call( this, color, intensity );\n\n\tthis.type = 'PointLight';\n\n\tObject.defineProperty( this, 'power', {\n\t\tget: function () {\n\t\t\t// intensity = power per solid angle.\n\t\t\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\treturn this.intensity * 4 * Math.PI;\n\n\t\t},\n\t\tset: function ( power ) {\n\t\t\t// intensity = power per solid angle.\n\t\t\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\tthis.intensity = power / ( 4 * Math.PI );\n\t\t}\n\t} );\n\n\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\n\n\tthis.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 90, 1, 0.5, 500 ) );\n\n};\n\nTHREE.PointLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\n\n\tconstructor: THREE.PointLight,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Light.prototype.copy.call( this, source );\n\n\t\tthis.distance = source.distance;\n\t\tthis.decay = source.decay;\n\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/lights/SpotLight.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.SpotLight = function ( color, intensity, distance, angle, penumbra, decay ) {\n\n\tTHREE.Light.call( this, color, intensity );\n\n\tthis.type = 'SpotLight';\n\n\tthis.position.set( 0, 1, 0 );\n\tthis.updateMatrix();\n\n\tthis.target = new THREE.Object3D();\n\n\tObject.defineProperty( this, 'power', {\n\t\tget: function () {\n\t\t\t// intensity = power per solid angle.\n\t\t\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\treturn this.intensity * Math.PI;\n\t\t},\n\t\tset: function ( power ) {\n\t\t\t// intensity = power per solid angle.\n\t\t\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\tthis.intensity = power / Math.PI;\n\t\t}\n\t} );\n\n\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\tthis.angle = ( angle !== undefined ) ? angle : Math.PI / 3;\n\tthis.penumbra = ( penumbra !== undefined ) ? penumbra : 0;\n\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\n\n\tthis.shadow = new THREE.SpotLightShadow();\n\n};\n\nTHREE.SpotLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\n\n\tconstructor: THREE.SpotLight,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Light.prototype.copy.call( this, source );\n\n\t\tthis.distance = source.distance;\n\t\tthis.angle = source.angle;\n\t\tthis.penumbra = source.penumbra;\n\t\tthis.decay = source.decay;\n\n\t\tthis.target = source.target.clone();\n\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/lights/SpotLightShadow.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.SpotLightShadow = function () {\n\n\tTHREE.LightShadow.call( this, new THREE.PerspectiveCamera( 50, 1, 0.5, 500 ) );\n\n};\n\nTHREE.SpotLightShadow.prototype = Object.assign( Object.create( THREE.LightShadow.prototype ), {\n\n\tconstructor: THREE.SpotLightShadow,\n\n\tupdate: function ( light ) {\n\n\t\tvar fov = THREE.Math.RAD2DEG * 2 * light.angle;\n\t\tvar aspect = this.mapSize.width / this.mapSize.height;\n\t\tvar far = light.distance || 500;\n\n\t\tvar camera = this.camera;\n\n\t\tif ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {\n\n\t\t\tcamera.fov = fov;\n\t\t\tcamera.aspect = aspect;\n\t\t\tcamera.far = far;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t}\n\n\t}\n\n} );\n\n// File:src/loaders/AudioLoader.js\n\n/**\n * @author Reece Aaron Lecrivain / http://reecenotes.com/\n */\n\nTHREE.AudioLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nObject.assign( THREE.AudioLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.load( url, function ( buffer ) {\n\n\t\t\tvar context = THREE.AudioContext;\n\n\t\t\tcontext.decodeAudioData( buffer, function ( audioBuffer ) {\n\n\t\t\t\tonLoad( audioBuffer );\n\n\t\t\t} );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n} );\n\n// File:src/loaders/Cache.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Cache = {\n\n\tenabled: false,\n\n\tfiles: {},\n\n\tadd: function ( key, file ) {\n\n\t\tif ( this.enabled === false ) return;\n\n\t\t// console.log( 'THREE.Cache', 'Adding key:', key );\n\n\t\tthis.files[ key ] = file;\n\n\t},\n\n\tget: function ( key ) {\n\n\t\tif ( this.enabled === false ) return;\n\n\t\t// console.log( 'THREE.Cache', 'Checking key:', key );\n\n\t\treturn this.files[ key ];\n\n\t},\n\n\tremove: function ( key ) {\n\n\t\tdelete this.files[ key ];\n\n\t},\n\n\tclear: function () {\n\n\t\tthis.files = {};\n\n\t}\n\n};\n\n// File:src/loaders/Loader.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Loader = function () {\n\n\tthis.onLoadStart = function () {};\n\tthis.onLoadProgress = function () {};\n\tthis.onLoadComplete = function () {};\n\n};\n\nTHREE.Loader.prototype = {\n\n\tconstructor: THREE.Loader,\n\n\tcrossOrigin: undefined,\n\n\textractUrlBase: function ( url ) {\n\n\t\tvar parts = url.split( '/' );\n\n\t\tif ( parts.length === 1 ) return './';\n\n\t\tparts.pop();\n\n\t\treturn parts.join( '/' ) + '/';\n\n\t},\n\n\tinitMaterials: function ( materials, texturePath, crossOrigin ) {\n\n\t\tvar array = [];\n\n\t\tfor ( var i = 0; i < materials.length; ++ i ) {\n\n\t\t\tarray[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );\n\n\t\t}\n\n\t\treturn array;\n\n\t},\n\n\tcreateMaterial: ( function () {\n\n\t\tvar color, textureLoader, materialLoader;\n\n\t\treturn function createMaterial( m, texturePath, crossOrigin ) {\n\n\t\t\tif ( color === undefined ) color = new THREE.Color();\n\t\t\tif ( textureLoader === undefined ) textureLoader = new THREE.TextureLoader();\n\t\t\tif ( materialLoader === undefined ) materialLoader = new THREE.MaterialLoader();\n\n\t\t\t// convert from old material format\n\n\t\t\tvar textures = {};\n\n\t\t\tfunction loadTexture( path, repeat, offset, wrap, anisotropy ) {\n\n\t\t\t\tvar fullPath = texturePath + path;\n\t\t\t\tvar loader = THREE.Loader.Handlers.get( fullPath );\n\n\t\t\t\tvar texture;\n\n\t\t\t\tif ( loader !== null ) {\n\n\t\t\t\t\ttexture = loader.load( fullPath );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttextureLoader.setCrossOrigin( crossOrigin );\n\t\t\t\t\ttexture = textureLoader.load( fullPath );\n\n\t\t\t\t}\n\n\t\t\t\tif ( repeat !== undefined ) {\n\n\t\t\t\t\ttexture.repeat.fromArray( repeat );\n\n\t\t\t\t\tif ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\tif ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset !== undefined ) {\n\n\t\t\t\t\ttexture.offset.fromArray( offset );\n\n\t\t\t\t}\n\n\t\t\t\tif ( wrap !== undefined ) {\n\n\t\t\t\t\tif ( wrap[ 0 ] === 'repeat' ) texture.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\tif ( wrap[ 0 ] === 'mirror' ) texture.wrapS = THREE.MirroredRepeatWrapping;\n\n\t\t\t\t\tif ( wrap[ 1 ] === 'repeat' ) texture.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\tif ( wrap[ 1 ] === 'mirror' ) texture.wrapT = THREE.MirroredRepeatWrapping;\n\n\t\t\t\t}\n\n\t\t\t\tif ( anisotropy !== undefined ) {\n\n\t\t\t\t\ttexture.anisotropy = anisotropy;\n\n\t\t\t\t}\n\n\t\t\t\tvar uuid = THREE.Math.generateUUID();\n\n\t\t\t\ttextures[ uuid ] = texture;\n\n\t\t\t\treturn uuid;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar json = {\n\t\t\t\tuuid: THREE.Math.generateUUID(),\n\t\t\t\ttype: 'MeshLambertMaterial'\n\t\t\t};\n\n\t\t\tfor ( var name in m ) {\n\n\t\t\t\tvar value = m[ name ];\n\n\t\t\t\tswitch ( name ) {\n\t\t\t\t\tcase 'DbgColor':\n\t\t\t\t\tcase 'DbgIndex':\n\t\t\t\t\tcase 'opticalDensity':\n\t\t\t\t\tcase 'illumination':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'DbgName':\n\t\t\t\t\t\tjson.name = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'blending':\n\t\t\t\t\t\tjson.blending = THREE[ value ];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'colorAmbient':\n\t\t\t\t\tcase 'mapAmbient':\n\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'colorDiffuse':\n\t\t\t\t\t\tjson.color = color.fromArray( value ).getHex();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'colorSpecular':\n\t\t\t\t\t\tjson.specular = color.fromArray( value ).getHex();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'colorEmissive':\n\t\t\t\t\t\tjson.emissive = color.fromArray( value ).getHex();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'specularCoef':\n\t\t\t\t\t\tjson.shininess = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'shading':\n\t\t\t\t\t\tif ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';\n\t\t\t\t\t\tif ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';\n\t\t\t\t\t\tif ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapDiffuse':\n\t\t\t\t\t\tjson.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapDiffuseRepeat':\n\t\t\t\t\tcase 'mapDiffuseOffset':\n\t\t\t\t\tcase 'mapDiffuseWrap':\n\t\t\t\t\tcase 'mapDiffuseAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapEmissive':\n\t\t\t\t\t\tjson.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapEmissiveRepeat':\n\t\t\t\t\tcase 'mapEmissiveOffset':\n\t\t\t\t\tcase 'mapEmissiveWrap':\n\t\t\t\t\tcase 'mapEmissiveAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapLight':\n\t\t\t\t\t\tjson.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapLightRepeat':\n\t\t\t\t\tcase 'mapLightOffset':\n\t\t\t\t\tcase 'mapLightWrap':\n\t\t\t\t\tcase 'mapLightAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapAO':\n\t\t\t\t\t\tjson.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapAORepeat':\n\t\t\t\t\tcase 'mapAOOffset':\n\t\t\t\t\tcase 'mapAOWrap':\n\t\t\t\t\tcase 'mapAOAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapBump':\n\t\t\t\t\t\tjson.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapBumpScale':\n\t\t\t\t\t\tjson.bumpScale = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapBumpRepeat':\n\t\t\t\t\tcase 'mapBumpOffset':\n\t\t\t\t\tcase 'mapBumpWrap':\n\t\t\t\t\tcase 'mapBumpAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapNormal':\n\t\t\t\t\t\tjson.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapNormalFactor':\n\t\t\t\t\t\tjson.normalScale = [ value, value ];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapNormalRepeat':\n\t\t\t\t\tcase 'mapNormalOffset':\n\t\t\t\t\tcase 'mapNormalWrap':\n\t\t\t\t\tcase 'mapNormalAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapSpecular':\n\t\t\t\t\t\tjson.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapSpecularRepeat':\n\t\t\t\t\tcase 'mapSpecularOffset':\n\t\t\t\t\tcase 'mapSpecularWrap':\n\t\t\t\t\tcase 'mapSpecularAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapMetalness':\n\t\t\t\t\t\tjson.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapMetalnessRepeat':\n\t\t\t\t\tcase 'mapMetalnessOffset':\n\t\t\t\t\tcase 'mapMetalnessWrap':\n\t\t\t\t\tcase 'mapMetalnessAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapRoughness':\n\t\t\t\t\t\tjson.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapRoughnessRepeat':\n\t\t\t\t\tcase 'mapRoughnessOffset':\n\t\t\t\t\tcase 'mapRoughnessWrap':\n\t\t\t\t\tcase 'mapRoughnessAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapAlpha':\n\t\t\t\t\t\tjson.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapAlphaRepeat':\n\t\t\t\t\tcase 'mapAlphaOffset':\n\t\t\t\t\tcase 'mapAlphaWrap':\n\t\t\t\t\tcase 'mapAlphaAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'flipSided':\n\t\t\t\t\t\tjson.side = THREE.BackSide;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'doubleSided':\n\t\t\t\t\t\tjson.side = THREE.DoubleSide;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'transparency':\n\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );\n\t\t\t\t\t\tjson.opacity = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'depthTest':\n\t\t\t\t\tcase 'depthWrite':\n\t\t\t\t\tcase 'colorWrite':\n\t\t\t\t\tcase 'opacity':\n\t\t\t\t\tcase 'reflectivity':\n\t\t\t\t\tcase 'transparent':\n\t\t\t\t\tcase 'visible':\n\t\t\t\t\tcase 'wireframe':\n\t\t\t\t\t\tjson[ name ] = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'vertexColors':\n\t\t\t\t\t\tif ( value === true ) json.vertexColors = THREE.VertexColors;\n\t\t\t\t\t\tif ( value === 'face' ) json.vertexColors = THREE.FaceColors;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'THREE.Loader.createMaterial: Unsupported', name, value );\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( json.type === 'MeshBasicMaterial' ) delete json.emissive;\n\t\t\tif ( json.type !== 'MeshPhongMaterial' ) delete json.specular;\n\n\t\t\tif ( json.opacity < 1 ) json.transparent = true;\n\n\t\t\tmaterialLoader.setTextures( textures );\n\n\t\t\treturn materialLoader.parse( json );\n\n\t\t};\n\n\t} )()\n\n};\n\nTHREE.Loader.Handlers = {\n\n\thandlers: [],\n\n\tadd: function ( regex, loader ) {\n\n\t\tthis.handlers.push( regex, loader );\n\n\t},\n\n\tget: function ( file ) {\n\n\t\tvar handlers = this.handlers;\n\n\t\tfor ( var i = 0, l = handlers.length; i < l; i += 2 ) {\n\n\t\t\tvar regex = handlers[ i ];\n\t\t\tvar loader  = handlers[ i + 1 ];\n\n\t\t\tif ( regex.test( file ) ) {\n\n\t\t\t\treturn loader;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n};\n\n// File:src/loaders/XHRLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.XHRLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nObject.assign( THREE.XHRLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\tvar scope = this;\n\n\t\tvar cached = THREE.Cache.get( url );\n\n\t\tif ( cached !== undefined ) {\n\n\t\t\tif ( onLoad ) {\n\n\t\t\t\tsetTimeout( function () {\n\n\t\t\t\t\tonLoad( cached );\n\n\t\t\t\t}, 0 );\n\n\t\t\t}\n\n\t\t\treturn cached;\n\n\t\t}\n\n\t\tvar request = new XMLHttpRequest();\n\t\trequest.overrideMimeType( 'text/plain' );\n\t\trequest.open( 'GET', url, true );\n\n\t\trequest.addEventListener( 'load', function ( event ) {\n\n\t\t\tvar response = event.target.response;\n\n\t\t\tTHREE.Cache.add( url, response );\n\n\t\t\tif ( this.status === 200 ) {\n\n\t\t\t\tif ( onLoad ) onLoad( response );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t} else if ( this.status === 0 ) {\n\n\t\t\t\t// Some browsers return HTTP Status 0 when using non-http protocol\n\t\t\t\t// e.g. 'file://' or 'data://'. Handle as success.\n\n\t\t\t\tconsole.warn( 'THREE.XHRLoader: HTTP Status 0 received.' );\n\n\t\t\t\tif ( onLoad ) onLoad( response );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t} else {\n\n\t\t\t\tif ( onError ) onError( event );\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, false );\n\n\t\tif ( onProgress !== undefined ) {\n\n\t\t\trequest.addEventListener( 'progress', function ( event ) {\n\n\t\t\t\tonProgress( event );\n\n\t\t\t}, false );\n\n\t\t}\n\n\t\trequest.addEventListener( 'error', function ( event ) {\n\n\t\t\tif ( onError ) onError( event );\n\n\t\t\tscope.manager.itemError( url );\n\n\t\t}, false );\n\n\t\tif ( this.responseType !== undefined ) request.responseType = this.responseType;\n\t\tif ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;\n\n\t\trequest.send( null );\n\n\t\tscope.manager.itemStart( url );\n\n\t\treturn request;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t},\n\n\tsetResponseType: function ( value ) {\n\n\t\tthis.responseType = value;\n\t\treturn this;\n\n\t},\n\n\tsetWithCredentials: function ( value ) {\n\n\t\tthis.withCredentials = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/loaders/FontLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.FontLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nObject.assign( THREE.FontLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tvar json;\n\n\t\t\ttry {\n\n\t\t\t\tjson = JSON.parse( text );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tconsole.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );\n\t\t\t\tjson = JSON.parse( text.substring( 65, text.length - 2 ) );\n\n\t\t\t}\n\n\t\t\tvar font = scope.parse( json );\n\n\t\t\tif ( onLoad ) onLoad( font );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tparse: function ( json ) {\n\n\t\treturn new THREE.Font( json );\n\n\t}\n\n} );\n\n// File:src/loaders/ImageLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.ImageLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nObject.assign( THREE.ImageLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );\n\t\timage.onload = function () {\n\n\t\t\tURL.revokeObjectURL( image.src );\n\t\t\tif ( onLoad ) onLoad( image );\n\n\t\t};\n\n\t\tif ( url.indexOf( 'data:' ) === 0 ) {\n\n\t\t\timage.src = url;\n\n\t\t} else {\n\n\t\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\t\tloader.setPath( this.path );\n\t\t\tloader.setResponseType( 'blob' );\n\t\t\tloader.load( url, function ( blob ) {\n\n\t\t\t\timage.src = URL.createObjectURL( blob );\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\treturn image;\n\n\t},\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\t\treturn this;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/loaders/JSONLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.JSONLoader = function ( manager ) {\n\n\tif ( typeof manager === 'boolean' ) {\n\n\t\tconsole.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );\n\t\tmanager = undefined;\n\n\t}\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n\tthis.withCredentials = false;\n\n};\n\nObject.assign( THREE.JSONLoader.prototype, {\n\n\tload: function( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar texturePath = this.texturePath && ( typeof this.texturePath === \"string\" ) ? this.texturePath : THREE.Loader.prototype.extractUrlBase( url );\n\n\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tvar json = JSON.parse( text );\n\t\t\tvar metadata = json.metadata;\n\n\t\t\tif ( metadata !== undefined ) {\n\n\t\t\t\tvar type = metadata.type;\n\n\t\t\t\tif ( type !== undefined ) {\n\n\t\t\t\t\tif ( type.toLowerCase() === 'object' ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( type.toLowerCase() === 'scene' ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar object = scope.parse( json, texturePath );\n\t\t\tonLoad( object.geometry, object.materials );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tsetTexturePath: function ( value ) {\n\n\t\tthis.texturePath = value;\n\n\t},\n\n\tparse: function ( json, texturePath ) {\n\n\t\tvar geometry = new THREE.Geometry(),\n\t\tscale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;\n\n\t\tparseModel( scale );\n\n\t\tparseSkin();\n\t\tparseMorphing( scale );\n\t\tparseAnimations();\n\n\t\tgeometry.computeFaceNormals();\n\t\tgeometry.computeBoundingSphere();\n\n\t\tfunction parseModel( scale ) {\n\n\t\t\tfunction isBitSet( value, position ) {\n\n\t\t\t\treturn value & ( 1 << position );\n\n\t\t\t}\n\n\t\t\tvar i, j, fi,\n\n\t\t\toffset, zLength,\n\n\t\tcolorIndex, normalIndex, uvIndex, materialIndex,\n\n\t\t\ttype,\n\t\t\tisQuad,\n\t\t\thasMaterial,\n\t\t\thasFaceVertexUv,\n\t\t\thasFaceNormal, hasFaceVertexNormal,\n\t\t\thasFaceColor, hasFaceVertexColor,\n\n\t\tvertex, face, faceA, faceB, hex, normal,\n\n\t\t\tuvLayer, uv, u, v,\n\n\t\t\tfaces = json.faces,\n\t\t\tvertices = json.vertices,\n\t\t\tnormals = json.normals,\n\t\t\tcolors = json.colors,\n\n\t\t\tnUvLayers = 0;\n\n\t\t\tif ( json.uvs !== undefined ) {\n\n\t\t\t\t// disregard empty arrays\n\n\t\t\t\tfor ( i = 0; i < json.uvs.length; i ++ ) {\n\n\t\t\t\t\tif ( json.uvs[ i ].length ) nUvLayers ++;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\n\t\t\t\t\tgeometry.faceVertexUvs[ i ] = [];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\toffset = 0;\n\t\t\tzLength = vertices.length;\n\n\t\t\twhile ( offset < zLength ) {\n\n\t\t\t\tvertex = new THREE.Vector3();\n\n\t\t\t\tvertex.x = vertices[ offset ++ ] * scale;\n\t\t\t\tvertex.y = vertices[ offset ++ ] * scale;\n\t\t\t\tvertex.z = vertices[ offset ++ ] * scale;\n\n\t\t\t\tgeometry.vertices.push( vertex );\n\n\t\t\t}\n\n\t\t\toffset = 0;\n\t\t\tzLength = faces.length;\n\n\t\t\twhile ( offset < zLength ) {\n\n\t\t\t\ttype = faces[ offset ++ ];\n\n\n\t\t\t\tisQuad              = isBitSet( type, 0 );\n\t\t\t\thasMaterial         = isBitSet( type, 1 );\n\t\t\t\thasFaceVertexUv     = isBitSet( type, 3 );\n\t\t\t\thasFaceNormal       = isBitSet( type, 4 );\n\t\t\t\thasFaceVertexNormal = isBitSet( type, 5 );\n\t\t\t\thasFaceColor\t     = isBitSet( type, 6 );\n\t\t\t\thasFaceVertexColor  = isBitSet( type, 7 );\n\n\t\t\t\t// console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\n\n\t\t\t\tif ( isQuad ) {\n\n\t\t\t\t\tfaceA = new THREE.Face3();\n\t\t\t\t\tfaceA.a = faces[ offset ];\n\t\t\t\t\tfaceA.b = faces[ offset + 1 ];\n\t\t\t\t\tfaceA.c = faces[ offset + 3 ];\n\n\t\t\t\t\tfaceB = new THREE.Face3();\n\t\t\t\t\tfaceB.a = faces[ offset + 1 ];\n\t\t\t\t\tfaceB.b = faces[ offset + 2 ];\n\t\t\t\t\tfaceB.c = faces[ offset + 3 ];\n\n\t\t\t\t\toffset += 4;\n\n\t\t\t\t\tif ( hasMaterial ) {\n\n\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\n\t\t\t\t\t\tfaceA.materialIndex = materialIndex;\n\t\t\t\t\t\tfaceB.materialIndex = materialIndex;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// to get face <=> uv index correspondence\n\n\t\t\t\t\tfi = geometry.faces.length;\n\n\t\t\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\n\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\n\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi + 1 ] = [];\n\n\t\t\t\t\t\t\tfor ( j = 0; j < 4; j ++ ) {\n\n\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\n\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\n\t\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\n\n\t\t\t\t\t\t\t\tif ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );\n\t\t\t\t\t\t\t\tif ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\tfaceA.normal.set(\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tfaceB.normal.copy( faceA.normal );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\t\tnormal = new THREE.Vector3(\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t);\n\n\n\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexNormals.push( normal );\n\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexNormals.push( normal );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\thex = colors[ colorIndex ];\n\n\t\t\t\t\t\tfaceA.color.setHex( hex );\n\t\t\t\t\t\tfaceB.color.setHex( hex );\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\thex = colors[ colorIndex ];\n\n\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );\n\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.faces.push( faceA );\n\t\t\t\t\tgeometry.faces.push( faceB );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tface = new THREE.Face3();\n\t\t\t\t\tface.a = faces[ offset ++ ];\n\t\t\t\t\tface.b = faces[ offset ++ ];\n\t\t\t\t\tface.c = faces[ offset ++ ];\n\n\t\t\t\t\tif ( hasMaterial ) {\n\n\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\n\t\t\t\t\t\tface.materialIndex = materialIndex;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// to get face <=> uv index correspondence\n\n\t\t\t\t\tfi = geometry.faces.length;\n\n\t\t\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\n\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\n\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\n\n\t\t\t\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\n\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\n\t\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\n\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ].push( uv );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\tface.normal.set(\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\t\tnormal = new THREE.Vector3(\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tface.vertexNormals.push( normal );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\tface.color.setHex( colors[ colorIndex ] );\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\tface.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.faces.push( face );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseSkin() {\n\n\t\t\tvar influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;\n\n\t\t\tif ( json.skinWeights ) {\n\n\t\t\t\tfor ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {\n\n\t\t\t\t\tvar x =                               json.skinWeights[ i ];\n\t\t\t\t\tvar y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;\n\t\t\t\t\tvar z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;\n\t\t\t\t\tvar w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;\n\n\t\t\t\t\tgeometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( json.skinIndices ) {\n\n\t\t\t\tfor ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {\n\n\t\t\t\t\tvar a =                               json.skinIndices[ i ];\n\t\t\t\t\tvar b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;\n\t\t\t\t\tvar c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;\n\t\t\t\t\tvar d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;\n\n\t\t\t\t\tgeometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgeometry.bones = json.bones;\n\n\t\t\tif ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {\n\n\t\t\t\tconsole.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +\n\t\t\t\t\tgeometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseMorphing( scale ) {\n\n\t\t\tif ( json.morphTargets !== undefined ) {\n\n\t\t\t\tfor ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {\n\n\t\t\t\t\tgeometry.morphTargets[ i ] = {};\n\t\t\t\t\tgeometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\n\t\t\t\t\tgeometry.morphTargets[ i ].vertices = [];\n\n\t\t\t\t\tvar dstVertices = geometry.morphTargets[ i ].vertices;\n\t\t\t\t\tvar srcVertices = json.morphTargets[ i ].vertices;\n\n\t\t\t\t\tfor ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\n\n\t\t\t\t\t\tvar vertex = new THREE.Vector3();\n\t\t\t\t\t\tvertex.x = srcVertices[ v ] * scale;\n\t\t\t\t\t\tvertex.y = srcVertices[ v + 1 ] * scale;\n\t\t\t\t\t\tvertex.z = srcVertices[ v + 2 ] * scale;\n\n\t\t\t\t\t\tdstVertices.push( vertex );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( json.morphColors !== undefined && json.morphColors.length > 0 ) {\n\n\t\t\t\tconsole.warn( 'THREE.JSONLoader: \"morphColors\" no longer supported. Using them as face colors.' );\n\n\t\t\t\tvar faces = geometry.faces;\n\t\t\t\tvar morphColors = json.morphColors[ 0 ].colors;\n\n\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\t\tfaces[ i ].color.fromArray( morphColors, i * 3 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseAnimations() {\n\n\t\t\tvar outputAnimations = [];\n\n\t\t\t// parse old style Bone/Hierarchy animations\n\t\t\tvar animations = [];\n\n\t\t\tif ( json.animation !== undefined ) {\n\n\t\t\t\tanimations.push( json.animation );\n\n\t\t\t}\n\n\t\t\tif ( json.animations !== undefined ) {\n\n\t\t\t\tif ( json.animations.length ) {\n\n\t\t\t\t\tanimations = animations.concat( json.animations );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tanimations.push( json.animations );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i < animations.length; i ++ ) {\n\n\t\t\t\tvar clip = THREE.AnimationClip.parseAnimation( animations[ i ], geometry.bones );\n\t\t\t\tif ( clip ) outputAnimations.push( clip );\n\n\t\t\t}\n\n\t\t\t// parse implicit morph animations\n\t\t\tif ( geometry.morphTargets ) {\n\n\t\t\t\t// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.\n\t\t\t\tvar morphAnimationClips = THREE.AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );\n\t\t\t\toutputAnimations = outputAnimations.concat( morphAnimationClips );\n\n\t\t\t}\n\n\t\t\tif ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;\n\n\t\t}\n\n\t\tif ( json.materials === undefined || json.materials.length === 0 ) {\n\n\t\t\treturn { geometry: geometry };\n\n\t\t} else {\n\n\t\t\tvar materials = THREE.Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );\n\n\t\t\treturn { geometry: geometry, materials: materials };\n\n\t\t}\n\n\t}\n\n} );\n\n// File:src/loaders/LoadingManager.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.LoadingManager = function ( onLoad, onProgress, onError ) {\n\n\tvar scope = this;\n\n\tvar isLoading = false, itemsLoaded = 0, itemsTotal = 0;\n\n\tthis.onStart = undefined;\n\tthis.onLoad = onLoad;\n\tthis.onProgress = onProgress;\n\tthis.onError = onError;\n\n\tthis.itemStart = function ( url ) {\n\n\t\titemsTotal ++;\n\n\t\tif ( isLoading === false ) {\n\n\t\t\tif ( scope.onStart !== undefined ) {\n\n\t\t\t\tscope.onStart( url, itemsLoaded, itemsTotal );\n\n\t\t\t}\n\n\t\t}\n\n\t\tisLoading = true;\n\n\t};\n\n\tthis.itemEnd = function ( url ) {\n\n\t\titemsLoaded ++;\n\n\t\tif ( scope.onProgress !== undefined ) {\n\n\t\t\tscope.onProgress( url, itemsLoaded, itemsTotal );\n\n\t\t}\n\n\t\tif ( itemsLoaded === itemsTotal ) {\n\n\t\t\tisLoading = false;\n\n\t\t\tif ( scope.onLoad !== undefined ) {\n\n\t\t\t\tscope.onLoad();\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tthis.itemError = function ( url ) {\n\n\t\tif ( scope.onError !== undefined ) {\n\n\t\t\tscope.onError( url );\n\n\t\t}\n\n\t};\n\n};\n\nTHREE.DefaultLoadingManager = new THREE.LoadingManager();\n\n// File:src/loaders/BufferGeometryLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.BufferGeometryLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nObject.assign( THREE.BufferGeometryLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.XHRLoader( scope.manager );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tparse: function ( json ) {\n\n\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\tvar index = json.data.index;\n\n\t\tvar TYPED_ARRAYS = {\n\t\t\t'Int8Array': Int8Array,\n\t\t\t'Uint8Array': Uint8Array,\n\t\t\t'Uint8ClampedArray': Uint8ClampedArray,\n\t\t\t'Int16Array': Int16Array,\n\t\t\t'Uint16Array': Uint16Array,\n\t\t\t'Int32Array': Int32Array,\n\t\t\t'Uint32Array': Uint32Array,\n\t\t\t'Float32Array': Float32Array,\n\t\t\t'Float64Array': Float64Array\n\t\t};\n\n\t\tif ( index !== undefined ) {\n\n\t\t\tvar typedArray = new TYPED_ARRAYS[ index.type ]( index.array );\n\t\t\tgeometry.setIndex( new THREE.BufferAttribute( typedArray, 1 ) );\n\n\t\t}\n\n\t\tvar attributes = json.data.attributes;\n\n\t\tfor ( var key in attributes ) {\n\n\t\t\tvar attribute = attributes[ key ];\n\t\t\tvar typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );\n\n\t\t\tgeometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );\n\n\t\t}\n\n\t\tvar groups = json.data.groups || json.data.drawcalls || json.data.offsets;\n\n\t\tif ( groups !== undefined ) {\n\n\t\t\tfor ( var i = 0, n = groups.length; i !== n; ++ i ) {\n\n\t\t\t\tvar group = groups[ i ];\n\n\t\t\t\tgeometry.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar boundingSphere = json.data.boundingSphere;\n\n\t\tif ( boundingSphere !== undefined ) {\n\n\t\t\tvar center = new THREE.Vector3();\n\n\t\t\tif ( boundingSphere.center !== undefined ) {\n\n\t\t\t\tcenter.fromArray( boundingSphere.center );\n\n\t\t\t}\n\n\t\t\tgeometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );\n\n\t\t}\n\n\t\treturn geometry;\n\n\t}\n\n} );\n\n// File:src/loaders/MaterialLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.MaterialLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\tthis.textures = {};\n\n};\n\nObject.assign( THREE.MaterialLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.XHRLoader( scope.manager );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tsetTextures: function ( value ) {\n\n\t\tthis.textures = value;\n\n\t},\n\n\tgetTexture: function ( name ) {\n\n\t\tvar textures = this.textures;\n\n\t\tif ( textures[ name ] === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.MaterialLoader: Undefined texture', name );\n\n\t\t}\n\n\t\treturn textures[ name ];\n\n\t},\n\n\tparse: function ( json ) {\n\n\t\tvar material = new THREE[ json.type ];\n\n\t\tif ( json.uuid !== undefined ) material.uuid = json.uuid;\n\t\tif ( json.name !== undefined ) material.name = json.name;\n\t\tif ( json.color !== undefined ) material.color.setHex( json.color );\n\t\tif ( json.roughness !== undefined ) material.roughness = json.roughness;\n\t\tif ( json.metalness !== undefined ) material.metalness = json.metalness;\n\t\tif ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );\n\t\tif ( json.specular !== undefined ) material.specular.setHex( json.specular );\n\t\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\n\t\tif ( json.uniforms !== undefined ) material.uniforms = json.uniforms;\n\t\tif ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\n\t\tif ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\n\t\tif ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;\n\t\tif ( json.shading !== undefined ) material.shading = json.shading;\n\t\tif ( json.blending !== undefined ) material.blending = json.blending;\n\t\tif ( json.side !== undefined ) material.side = json.side;\n\t\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\n\t\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\n\t\tif ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;\n\t\tif ( json.depthTest !== undefined ) material.depthTest = json.depthTest;\n\t\tif ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;\n\t\tif ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;\n\t\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\n\t\tif ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;\n\n\t\t// for PointsMaterial\n\t\tif ( json.size !== undefined ) material.size = json.size;\n\t\tif ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\n\n\t\t// maps\n\n\t\tif ( json.map !== undefined ) material.map = this.getTexture( json.map );\n\n\t\tif ( json.alphaMap !== undefined ) {\n\n\t\t\tmaterial.alphaMap = this.getTexture( json.alphaMap );\n\t\t\tmaterial.transparent = true;\n\n\t\t}\n\n\t\tif ( json.bumpMap !== undefined ) material.bumpMap = this.getTexture( json.bumpMap );\n\t\tif ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;\n\n\t\tif ( json.normalMap !== undefined ) material.normalMap = this.getTexture( json.normalMap );\n\t\tif ( json.normalScale !== undefined ) {\n\n\t\t\tvar normalScale = json.normalScale;\n\n\t\t\tif ( Array.isArray( normalScale ) === false ) {\n\n\t\t\t\t// Blender exporter used to export a scalar. See #7459\n\n\t\t\t\tnormalScale = [ normalScale, normalScale ];\n\n\t\t\t}\n\n\t\t\tmaterial.normalScale = new THREE.Vector2().fromArray( normalScale );\n\n\t\t}\n\n\t\tif ( json.displacementMap !== undefined ) material.displacementMap = this.getTexture( json.displacementMap );\n\t\tif ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;\n\t\tif ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;\n\n\t\tif ( json.roughnessMap !== undefined ) material.roughnessMap = this.getTexture( json.roughnessMap );\n\t\tif ( json.metalnessMap !== undefined ) material.metalnessMap = this.getTexture( json.metalnessMap );\n\n\t\tif ( json.emissiveMap !== undefined ) material.emissiveMap = this.getTexture( json.emissiveMap );\n\t\tif ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;\n\n\t\tif ( json.specularMap !== undefined ) material.specularMap = this.getTexture( json.specularMap );\n\n\t\tif ( json.envMap !== undefined ) {\n\n\t\t\tmaterial.envMap = this.getTexture( json.envMap );\n\t\t\tmaterial.combine = THREE.MultiplyOperation;\n\n\t\t}\n\n\t\tif ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;\n\n\t\tif ( json.lightMap !== undefined ) material.lightMap = this.getTexture( json.lightMap );\n\t\tif ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;\n\n\t\tif ( json.aoMap !== undefined ) material.aoMap = this.getTexture( json.aoMap );\n\t\tif ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;\n\n\t\t// MultiMaterial\n\n\t\tif ( json.materials !== undefined ) {\n\n\t\t\tfor ( var i = 0, l = json.materials.length; i < l; i ++ ) {\n\n\t\t\t\tmaterial.materials.push( this.parse( json.materials[ i ] ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn material;\n\n\t}\n\n} );\n\n// File:src/loaders/ObjectLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.ObjectLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\tthis.texturePath = '';\n\n};\n\nObject.assign( THREE.ObjectLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tif ( this.texturePath === '' ) {\n\n\t\t\tthis.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );\n\n\t\t}\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.XHRLoader( scope.manager );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tscope.parse( JSON.parse( text ), onLoad );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tsetTexturePath: function ( value ) {\n\n\t\tthis.texturePath = value;\n\n\t},\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\n\t},\n\n\tparse: function ( json, onLoad ) {\n\n\t\tvar geometries = this.parseGeometries( json.geometries );\n\n\t\tvar images = this.parseImages( json.images, function () {\n\n\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\n\t\t} );\n\n\t\tvar textures  = this.parseTextures( json.textures, images );\n\t\tvar materials = this.parseMaterials( json.materials, textures );\n\n\t\tvar object = this.parseObject( json.object, geometries, materials );\n\n\t\tif ( json.animations ) {\n\n\t\t\tobject.animations = this.parseAnimations( json.animations );\n\n\t\t}\n\n\t\tif ( json.images === undefined || json.images.length === 0 ) {\n\n\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\n\t\t}\n\n\t\treturn object;\n\n\t},\n\n\tparseGeometries: function ( json ) {\n\n\t\tvar geometries = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tvar geometryLoader = new THREE.JSONLoader();\n\t\t\tvar bufferGeometryLoader = new THREE.BufferGeometryLoader();\n\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tvar geometry;\n\t\t\t\tvar data = json[ i ];\n\n\t\t\t\tswitch ( data.type ) {\n\n\t\t\t\t\tcase 'PlaneGeometry':\n\t\t\t\t\tcase 'PlaneBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\tdata.heightSegments\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'BoxGeometry':\n\t\t\t\t\tcase 'BoxBufferGeometry':\n\t\t\t\t\tcase 'CubeGeometry': // backwards compatible\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\tdata.depth,\n\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\tdata.depthSegments\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'CircleGeometry':\n\t\t\t\t\tcase 'CircleBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.segments,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'CylinderGeometry':\n\t\t\t\t\tcase 'CylinderBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.radiusTop,\n\t\t\t\t\t\t\tdata.radiusBottom,\n\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\tdata.openEnded,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ConeGeometry':\n\t\t\t\t\tcase 'ConeBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE [ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\tdata.openEnded,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'SphereGeometry':\n\t\t\t\t\tcase 'SphereBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\tdata.phiStart,\n\t\t\t\t\t\t\tdata.phiLength,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'DodecahedronGeometry':\n\t\t\t\t\tcase 'IcosahedronGeometry':\n\t\t\t\t\tcase 'OctahedronGeometry':\n\t\t\t\t\tcase 'TetrahedronGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.detail\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'RingGeometry':\n\t\t\t\t\tcase 'RingBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.innerRadius,\n\t\t\t\t\t\t\tdata.outerRadius,\n\t\t\t\t\t\t\tdata.thetaSegments,\n\t\t\t\t\t\t\tdata.phiSegments,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'TorusGeometry':\n\t\t\t\t\tcase 'TorusBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\tdata.arc\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'TorusKnotGeometry':\n\t\t\t\t\tcase 'TorusKnotBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\tdata.p,\n\t\t\t\t\t\t\tdata.q\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'LatheGeometry':\n\t\t\t\t\tcase 'LatheBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.points,\n\t\t\t\t\t\t\tdata.segments,\n\t\t\t\t\t\t\tdata.phiStart,\n\t\t\t\t\t\t\tdata.phiLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'BufferGeometry':\n\n\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse( data );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Geometry':\n\n\t\t\t\t\t\tgeometry = geometryLoader.parse( data.data, this.texturePath ).geometry;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Unsupported geometry type \"' + data.type + '\"' );\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.uuid = data.uuid;\n\n\t\t\t\tif ( data.name !== undefined ) geometry.name = data.name;\n\n\t\t\t\tgeometries[ data.uuid ] = geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn geometries;\n\n\t},\n\n\tparseMaterials: function ( json, textures ) {\n\n\t\tvar materials = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tvar loader = new THREE.MaterialLoader();\n\t\t\tloader.setTextures( textures );\n\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tvar material = loader.parse( json[ i ] );\n\t\t\t\tmaterials[ material.uuid ] = material;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn materials;\n\n\t},\n\n\tparseAnimations: function ( json ) {\n\n\t\tvar animations = [];\n\n\t\tfor ( var i = 0; i < json.length; i ++ ) {\n\n\t\t\tvar clip = THREE.AnimationClip.parse( json[ i ] );\n\n\t\t\tanimations.push( clip );\n\n\t\t}\n\n\t\treturn animations;\n\n\t},\n\n\tparseImages: function ( json, onLoad ) {\n\n\t\tvar scope = this;\n\t\tvar images = {};\n\n\t\tfunction loadImage( url ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\treturn loader.load( url, function () {\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t} );\n\n\t\t}\n\n\t\tif ( json !== undefined && json.length > 0 ) {\n\n\t\t\tvar manager = new THREE.LoadingManager( onLoad );\n\n\t\t\tvar loader = new THREE.ImageLoader( manager );\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tvar image = json[ i ];\n\t\t\t\tvar path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;\n\n\t\t\t\timages[ image.uuid ] = loadImage( path );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn images;\n\n\t},\n\n\tparseTextures: function ( json, images ) {\n\n\t\tfunction parseConstant( value ) {\n\n\t\t\tif ( typeof( value ) === 'number' ) return value;\n\n\t\t\tconsole.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );\n\n\t\t\treturn THREE[ value ];\n\n\t\t}\n\n\t\tvar textures = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tvar data = json[ i ];\n\n\t\t\t\tif ( data.image === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No \"image\" specified for', data.uuid );\n\n\t\t\t\t}\n\n\t\t\t\tif ( images[ data.image ] === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined image', data.image );\n\n\t\t\t\t}\n\n\t\t\t\tvar texture = new THREE.Texture( images[ data.image ] );\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\ttexture.uuid = data.uuid;\n\n\t\t\t\tif ( data.name !== undefined ) texture.name = data.name;\n\t\t\t\tif ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping );\n\t\t\t\tif ( data.offset !== undefined ) texture.offset = new THREE.Vector2( data.offset[ 0 ], data.offset[ 1 ] );\n\t\t\t\tif ( data.repeat !== undefined ) texture.repeat = new THREE.Vector2( data.repeat[ 0 ], data.repeat[ 1 ] );\n\t\t\t\tif ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter );\n\t\t\t\tif ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter );\n\t\t\t\tif ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\n\t\t\t\tif ( Array.isArray( data.wrap ) ) {\n\n\t\t\t\t\ttexture.wrapS = parseConstant( data.wrap[ 0 ] );\n\t\t\t\t\ttexture.wrapT = parseConstant( data.wrap[ 1 ] );\n\n\t\t\t\t}\n\n\t\t\t\ttextures[ data.uuid ] = texture;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn textures;\n\n\t},\n\n\tparseObject: function () {\n\n\t\tvar matrix = new THREE.Matrix4();\n\n\t\treturn function parseObject( data, geometries, materials ) {\n\n\t\t\tvar object;\n\n\t\t\tfunction getGeometry( name ) {\n\n\t\t\t\tif ( geometries[ name ] === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined geometry', name );\n\n\t\t\t\t}\n\n\t\t\t\treturn geometries[ name ];\n\n\t\t\t}\n\n\t\t\tfunction getMaterial( name ) {\n\n\t\t\t\tif ( name === undefined ) return undefined;\n\n\t\t\t\tif ( materials[ name ] === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', name );\n\n\t\t\t\t}\n\n\t\t\t\treturn materials[ name ];\n\n\t\t\t}\n\n\t\t\tswitch ( data.type ) {\n\n\t\t\t\tcase 'Scene':\n\n\t\t\t\t\tobject = new THREE.Scene();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PerspectiveCamera':\n\n\t\t\t\t\tobject = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\n\n\t\t\t\t\tif ( data.focus !== undefined ) object.focus = data.focus;\n\t\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\n\t\t\t\t\tif ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;\n\t\t\t\t\tif ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;\n\t\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'OrthographicCamera':\n\n\t\t\t\t\tobject = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'AmbientLight':\n\n\t\t\t\t\tobject = new THREE.AmbientLight( data.color, data.intensity );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'DirectionalLight':\n\n\t\t\t\t\tobject = new THREE.DirectionalLight( data.color, data.intensity );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PointLight':\n\n\t\t\t\t\tobject = new THREE.PointLight( data.color, data.intensity, data.distance, data.decay );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SpotLight':\n\n\t\t\t\t\tobject = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'HemisphereLight':\n\n\t\t\t\t\tobject = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Mesh':\n\n\t\t\t\t\tvar geometry = getGeometry( data.geometry );\n\t\t\t\t\tvar material = getMaterial( data.material );\n\n\t\t\t\t\tif ( geometry.bones && geometry.bones.length > 0 ) {\n\n\t\t\t\t\t\tobject = new THREE.SkinnedMesh( geometry, material );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tobject = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'LOD':\n\n\t\t\t\t\tobject = new THREE.LOD();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Line':\n\n\t\t\t\t\tobject = new THREE.Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PointCloud':\n\t\t\t\tcase 'Points':\n\n\t\t\t\t\tobject = new THREE.Points( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Sprite':\n\n\t\t\t\t\tobject = new THREE.Sprite( getMaterial( data.material ) );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Group':\n\n\t\t\t\t\tobject = new THREE.Group();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tobject = new THREE.Object3D();\n\n\t\t\t}\n\n\t\t\tobject.uuid = data.uuid;\n\n\t\t\tif ( data.name !== undefined ) object.name = data.name;\n\t\t\tif ( data.matrix !== undefined ) {\n\n\t\t\t\tmatrix.fromArray( data.matrix );\n\t\t\t\tmatrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t\t} else {\n\n\t\t\t\tif ( data.position !== undefined ) object.position.fromArray( data.position );\n\t\t\t\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\n\t\t\t\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\n\n\t\t\t}\n\n\t\t\tif ( data.castShadow !== undefined ) object.castShadow = data.castShadow;\n\t\t\tif ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;\n\n\t\t\tif ( data.visible !== undefined ) object.visible = data.visible;\n\t\t\tif ( data.userData !== undefined ) object.userData = data.userData;\n\n\t\t\tif ( data.children !== undefined ) {\n\n\t\t\t\tfor ( var child in data.children ) {\n\n\t\t\t\t\tobject.add( this.parseObject( data.children[ child ], geometries, materials ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( data.type === 'LOD' ) {\n\n\t\t\t\tvar levels = data.levels;\n\n\t\t\t\tfor ( var l = 0; l < levels.length; l ++ ) {\n\n\t\t\t\t\tvar level = levels[ l ];\n\t\t\t\t\tvar child = object.getObjectByProperty( 'uuid', level.object );\n\n\t\t\t\t\tif ( child !== undefined ) {\n\n\t\t\t\t\t\tobject.addLevel( child, level.distance );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn object;\n\n\t\t};\n\n\t}()\n\n} );\n\n// File:src/loaders/TextureLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.TextureLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nObject.assign( THREE.TextureLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar texture = new THREE.Texture();\n\n\t\tvar loader = new THREE.ImageLoader( this.manager );\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.setPath( this.path );\n\t\tloader.load( url, function ( image ) {\n\n\t\t\ttexture.image = image;\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad !== undefined ) {\n\n\t\t\t\tonLoad( texture );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t\treturn texture;\n\n\t},\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\t\treturn this;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/loaders/CubeTextureLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.CubeTextureLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nObject.assign( THREE.CubeTextureLoader.prototype, {\n\n\tload: function ( urls, onLoad, onProgress, onError ) {\n\n\t\tvar texture = new THREE.CubeTexture();\n\n\t\tvar loader = new THREE.ImageLoader( this.manager );\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.setPath( this.path );\n\n\t\tvar loaded = 0;\n\n\t\tfunction loadTexture( i ) {\n\n\t\t\tloader.load( urls[ i ], function ( image ) {\n\n\t\t\t\ttexture.images[ i ] = image;\n\n\t\t\t\tloaded ++;\n\n\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}, undefined, onError );\n\n\t\t}\n\n\t\tfor ( var i = 0; i < urls.length; ++ i ) {\n\n\t\t\tloadTexture( i );\n\n\t\t}\n\n\t\treturn texture;\n\n\t},\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\t\treturn this;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/loaders/BinaryTextureLoader.js\n\n/**\n * @author Nikos M. / https://github.com/foo123/\n *\n * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\n */\n\nTHREE.DataTextureLoader = THREE.BinaryTextureLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n\t// override in sub classes\n\tthis._parser = null;\n\n};\n\nObject.assign( THREE.BinaryTextureLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar texture = new THREE.DataTexture();\n\n\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\tloader.load( url, function ( buffer ) {\n\n\t\t\tvar texData = scope._parser( buffer );\n\n\t\t\tif ( ! texData ) return;\n\n\t\t\tif ( undefined !== texData.image ) {\n\n\t\t\t\ttexture.image = texData.image;\n\n\t\t\t} else if ( undefined !== texData.data ) {\n\n\t\t\t\ttexture.image.width = texData.width;\n\t\t\t\ttexture.image.height = texData.height;\n\t\t\t\ttexture.image.data = texData.data;\n\n\t\t\t}\n\n\t\t\ttexture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;\n\t\t\ttexture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;\n\n\t\t\ttexture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;\n\t\t\ttexture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;\n\n\t\t\ttexture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;\n\n\t\t\tif ( undefined !== texData.format ) {\n\n\t\t\t\ttexture.format = texData.format;\n\n\t\t\t}\n\t\t\tif ( undefined !== texData.type ) {\n\n\t\t\t\ttexture.type = texData.type;\n\n\t\t\t}\n\n\t\t\tif ( undefined !== texData.mipmaps ) {\n\n\t\t\t\ttexture.mipmaps = texData.mipmaps;\n\n\t\t\t}\n\n\t\t\tif ( 1 === texData.mipmapCount ) {\n\n\t\t\t\ttexture.minFilter = THREE.LinearFilter;\n\n\t\t\t}\n\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t}, onProgress, onError );\n\n\n\t\treturn texture;\n\n\t}\n\n} );\n\n// File:src/loaders/CompressedTextureLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n *\n * Abstract Base class to block based textures loader (dds, pvr, ...)\n */\n\nTHREE.CompressedTextureLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n\t// override in sub classes\n\tthis._parser = null;\n\n};\n\nObject.assign( THREE.CompressedTextureLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar images = [];\n\n\t\tvar texture = new THREE.CompressedTexture();\n\t\ttexture.image = images;\n\n\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\tfunction loadTexture( i ) {\n\n\t\t\tloader.load( url[ i ], function ( buffer ) {\n\n\t\t\t\tvar texDatas = scope._parser( buffer, true );\n\n\t\t\t\timages[ i ] = {\n\t\t\t\t\twidth: texDatas.width,\n\t\t\t\t\theight: texDatas.height,\n\t\t\t\t\tformat: texDatas.format,\n\t\t\t\t\tmipmaps: texDatas.mipmaps\n\t\t\t\t};\n\n\t\t\t\tloaded += 1;\n\n\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\tif ( texDatas.mipmapCount === 1 )\n\t\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\n\n\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\tif ( Array.isArray( url ) ) {\n\n\t\t\tvar loaded = 0;\n\n\t\t\tfor ( var i = 0, il = url.length; i < il; ++ i ) {\n\n\t\t\t\tloadTexture( i );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// compressed cubemap texture stored in a single DDS file\n\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\tvar texDatas = scope._parser( buffer, true );\n\n\t\t\t\tif ( texDatas.isCubemap ) {\n\n\t\t\t\t\tvar faces = texDatas.mipmaps.length / texDatas.mipmapCount;\n\n\t\t\t\t\tfor ( var f = 0; f < faces; f ++ ) {\n\n\t\t\t\t\t\timages[ f ] = { mipmaps : [] };\n\n\t\t\t\t\t\tfor ( var i = 0; i < texDatas.mipmapCount; i ++ ) {\n\n\t\t\t\t\t\t\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\n\t\t\t\t\t\t\timages[ f ].format = texDatas.format;\n\t\t\t\t\t\t\timages[ f ].width = texDatas.width;\n\t\t\t\t\t\t\timages[ f ].height = texDatas.height;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttexture.image.width = texDatas.width;\n\t\t\t\t\ttexture.image.height = texDatas.height;\n\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\n\n\t\t\t\t}\n\n\t\t\t\tif ( texDatas.mipmapCount === 1 ) {\n\n\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\n\n\t\t\t\t}\n\n\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\treturn texture;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/materials/Material.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Material = function () {\n\n\tObject.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'Material';\n\n\tthis.fog = true;\n\tthis.lights = true;\n\n\tthis.blending = THREE.NormalBlending;\n\tthis.side = THREE.FrontSide;\n\tthis.shading = THREE.SmoothShading; // THREE.FlatShading, THREE.SmoothShading\n\tthis.vertexColors = THREE.NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors\n\n\tthis.opacity = 1;\n\tthis.transparent = false;\n\n\tthis.blendSrc = THREE.SrcAlphaFactor;\n\tthis.blendDst = THREE.OneMinusSrcAlphaFactor;\n\tthis.blendEquation = THREE.AddEquation;\n\tthis.blendSrcAlpha = null;\n\tthis.blendDstAlpha = null;\n\tthis.blendEquationAlpha = null;\n\n\tthis.depthFunc = THREE.LessEqualDepth;\n\tthis.depthTest = true;\n\tthis.depthWrite = true;\n\n\tthis.clippingPlanes = null;\n\tthis.clipShadows = false;\n\n\tthis.colorWrite = true;\n\n\tthis.precision = null; // override the renderer's default precision for this material\n\n\tthis.polygonOffset = false;\n\tthis.polygonOffsetFactor = 0;\n\tthis.polygonOffsetUnits = 0;\n\n\tthis.alphaTest = 0;\n\tthis.premultipliedAlpha = false;\n\n\tthis.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer\n\n\tthis.visible = true;\n\n\tthis._needsUpdate = true;\n\n};\n\nTHREE.Material.prototype = {\n\n\tconstructor: THREE.Material,\n\n\tget needsUpdate() {\n\n\t\treturn this._needsUpdate;\n\n\t},\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.update();\n\t\tthis._needsUpdate = value;\n\n\t},\n\n\tsetValues: function ( values ) {\n\n\t\tif ( values === undefined ) return;\n\n\t\tfor ( var key in values ) {\n\n\t\t\tvar newValue = values[ key ];\n\n\t\t\tif ( newValue === undefined ) {\n\n\t\t\t\tconsole.warn( \"THREE.Material: '\" + key + \"' parameter is undefined.\" );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tvar currentValue = this[ key ];\n\n\t\t\tif ( currentValue === undefined ) {\n\n\t\t\t\tconsole.warn( \"THREE.\" + this.type + \": '\" + key + \"' is not a property of this material.\" );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( currentValue instanceof THREE.Color ) {\n\n\t\t\t\tcurrentValue.set( newValue );\n\n\t\t\t} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {\n\n\t\t\t\tcurrentValue.copy( newValue );\n\n\t\t\t} else if ( key === 'overdraw' ) {\n\n\t\t\t\t// ensure overdraw is backwards-compatible with legacy boolean type\n\t\t\t\tthis[ key ] = Number( newValue );\n\n\t\t\t} else {\n\n\t\t\t\tthis[ key ] = newValue;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar isRoot = meta === undefined;\n\n\t\tif ( isRoot ) {\n\n\t\t\tmeta = {\n\t\t\t\ttextures: {},\n\t\t\t\timages: {}\n\t\t\t};\n\n\t\t}\n\n\t\tvar data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.4,\n\t\t\t\ttype: 'Material',\n\t\t\t\tgenerator: 'Material.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard Material serialization\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\n\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\tif ( this.color instanceof THREE.Color ) data.color = this.color.getHex();\n\n\t\tif ( this.roughness !== undefined ) data.roughness = this.roughness;\n\t\tif ( this.metalness !== undefined ) data.metalness = this.metalness;\n\n\t\tif ( this.emissive instanceof THREE.Color ) data.emissive = this.emissive.getHex();\n\t\tif ( this.specular instanceof THREE.Color ) data.specular = this.specular.getHex();\n\t\tif ( this.shininess !== undefined ) data.shininess = this.shininess;\n\n\t\tif ( this.map instanceof THREE.Texture ) data.map = this.map.toJSON( meta ).uuid;\n\t\tif ( this.alphaMap instanceof THREE.Texture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;\n\t\tif ( this.lightMap instanceof THREE.Texture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;\n\t\tif ( this.bumpMap instanceof THREE.Texture ) {\n\n\t\t\tdata.bumpMap = this.bumpMap.toJSON( meta ).uuid;\n\t\t\tdata.bumpScale = this.bumpScale;\n\n\t\t}\n\t\tif ( this.normalMap instanceof THREE.Texture ) {\n\n\t\t\tdata.normalMap = this.normalMap.toJSON( meta ).uuid;\n\t\t\tdata.normalScale = this.normalScale.toArray();\n\n\t\t}\n\t\tif ( this.displacementMap instanceof THREE.Texture ) {\n\n\t\t\tdata.displacementMap = this.displacementMap.toJSON( meta ).uuid;\n\t\t\tdata.displacementScale = this.displacementScale;\n\t\t\tdata.displacementBias = this.displacementBias;\n\n\t\t}\n\t\tif ( this.roughnessMap instanceof THREE.Texture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;\n\t\tif ( this.metalnessMap instanceof THREE.Texture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;\n\n\t\tif ( this.emissiveMap instanceof THREE.Texture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;\n\t\tif ( this.specularMap instanceof THREE.Texture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;\n\n\t\tif ( this.envMap instanceof THREE.Texture ) {\n\n\t\t\tdata.envMap = this.envMap.toJSON( meta ).uuid;\n\t\t\tdata.reflectivity = this.reflectivity; // Scale behind envMap\n\n\t\t}\n\n\t\tif ( this.size !== undefined ) data.size = this.size;\n\t\tif ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;\n\n\t\tif ( this.blending !== THREE.NormalBlending ) data.blending = this.blending;\n\t\tif ( this.shading !== THREE.SmoothShading ) data.shading = this.shading;\n\t\tif ( this.side !== THREE.FrontSide ) data.side = this.side;\n\t\tif ( this.vertexColors !== THREE.NoColors ) data.vertexColors = this.vertexColors;\n\n\t\tif ( this.opacity < 1 ) data.opacity = this.opacity;\n\t\tif ( this.transparent === true ) data.transparent = this.transparent;\n\t\tif ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;\n\t\tif ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;\n\t\tif ( this.wireframe === true ) data.wireframe = this.wireframe;\n\t\tif ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;\n\n\t\t// TODO: Copied from Object3D.toJSON\n\n\t\tfunction extractFromCache ( cache ) {\n\n\t\t\tvar values = [];\n\n\t\t\tfor ( var key in cache ) {\n\n\t\t\t\tvar data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\n\t\t\treturn values;\n\n\t\t}\n\n\t\tif ( isRoot ) {\n\n\t\t\tvar textures = extractFromCache( meta.textures );\n\t\t\tvar images = extractFromCache( meta.images );\n\n\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\tif ( images.length > 0 ) data.images = images;\n\n\t\t}\n\n\t\treturn data;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.name = source.name;\n\n\t\tthis.fog = source.fog;\n\t\tthis.lights = source.lights;\n\n\t\tthis.blending = source.blending;\n\t\tthis.side = source.side;\n\t\tthis.shading = source.shading;\n\t\tthis.vertexColors = source.vertexColors;\n\n\t\tthis.opacity = source.opacity;\n\t\tthis.transparent = source.transparent;\n\n\t\tthis.blendSrc = source.blendSrc;\n\t\tthis.blendDst = source.blendDst;\n\t\tthis.blendEquation = source.blendEquation;\n\t\tthis.blendSrcAlpha = source.blendSrcAlpha;\n\t\tthis.blendDstAlpha = source.blendDstAlpha;\n\t\tthis.blendEquationAlpha = source.blendEquationAlpha;\n\n\t\tthis.depthFunc = source.depthFunc;\n\t\tthis.depthTest = source.depthTest;\n\t\tthis.depthWrite = source.depthWrite;\n\n\t\tthis.colorWrite = source.colorWrite;\n\n\t\tthis.precision = source.precision;\n\n\t\tthis.polygonOffset = source.polygonOffset;\n\t\tthis.polygonOffsetFactor = source.polygonOffsetFactor;\n\t\tthis.polygonOffsetUnits = source.polygonOffsetUnits;\n\n\t\tthis.alphaTest = source.alphaTest;\n\n\t\tthis.premultipliedAlpha = source.premultipliedAlpha;\n\n\t\tthis.overdraw = source.overdraw;\n\n\t\tthis.visible = source.visible;\n\t\tthis.clipShadows = source.clipShadows;\n\n\t\tvar srcPlanes = source.clippingPlanes,\n\t\t\tdstPlanes = null;\n\n\t\tif ( srcPlanes !== null ) {\n\n\t\t\tvar n = srcPlanes.length;\n\t\t\tdstPlanes = new Array( n );\n\n\t\t\tfor ( var i = 0; i !== n; ++ i )\n\t\t\t\tdstPlanes[ i ] = srcPlanes[ i ].clone();\n\n\t\t}\n\n\t\tthis.clippingPlanes = dstPlanes;\n\n\t\treturn this;\n\n\t},\n\n\tupdate: function () {\n\n\t\tthis.dispatchEvent( { type: 'update' } );\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n};\n\nObject.assign( THREE.Material.prototype, THREE.EventDispatcher.prototype );\n\nTHREE.MaterialIdCount = 0;\n\n// File:src/materials/LineBasicMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  linewidth: <float>,\n *  linecap: \"round\",\n *  linejoin: \"round\"\n * }\n */\n\nTHREE.LineBasicMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'LineBasicMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff );\n\n\tthis.linewidth = 1;\n\tthis.linecap = 'round';\n\tthis.linejoin = 'round';\n\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;\n\nTHREE.LineBasicMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\n\tthis.linewidth = source.linewidth;\n\tthis.linecap = source.linecap;\n\tthis.linejoin = source.linejoin;\n\n\treturn this;\n\n};\n\n// File:src/materials/LineDashedMaterial.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  linewidth: <float>,\n *\n *  scale: <float>,\n *  dashSize: <float>,\n *  gapSize: <float>\n * }\n */\n\nTHREE.LineDashedMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'LineDashedMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff );\n\n\tthis.linewidth = 1;\n\n\tthis.scale = 1;\n\tthis.dashSize = 3;\n\tthis.gapSize = 1;\n\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;\n\nTHREE.LineDashedMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\n\tthis.linewidth = source.linewidth;\n\n\tthis.scale = source.scale;\n\tthis.dashSize = source.dashSize;\n\tthis.gapSize = source.gapSize;\n\n\treturn this;\n\n};\n\n// File:src/materials/MeshBasicMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *  map: new THREE.Texture( <Image> ),\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  shading: THREE.SmoothShading,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>\n * }\n */\n\nTHREE.MeshBasicMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'MeshBasicMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff ); // emissive\n\n\tthis.map = null;\n\n\tthis.aoMap = null;\n\tthis.aoMapIntensity = 1.0;\n\n\tthis.specularMap = null;\n\n\tthis.alphaMap = null;\n\n\tthis.envMap = null;\n\tthis.combine = THREE.MultiplyOperation;\n\tthis.reflectivity = 1;\n\tthis.refractionRatio = 0.98;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;\n\nTHREE.MeshBasicMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\n\tthis.map = source.map;\n\n\tthis.aoMap = source.aoMap;\n\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\tthis.specularMap = source.specularMap;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.envMap = source.envMap;\n\tthis.combine = source.combine;\n\tthis.reflectivity = source.reflectivity;\n\tthis.refractionRatio = source.refractionRatio;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\tthis.wireframeLinecap = source.wireframeLinecap;\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\n\treturn this;\n\n};\n\n// File:src/materials/MeshDepthMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author bhouston / https://clara.io\n * @author WestLangley / http://github.com/WestLangley\n *\n * parameters = {\n *\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>\n * }\n */\n\nTHREE.MeshDepthMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'MeshDepthMaterial';\n\n\tthis.depthPacking = THREE.BasicDepthPacking;\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\n\tthis.map = null;\n\n\tthis.alphaMap = null;\n\n\tthis.displacementMap = null;\n\tthis.displacementScale = 1;\n\tthis.displacementBias = 0;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\n\tthis.fog = false;\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;\n\nTHREE.MeshDepthMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.depthPacking = source.depthPacking;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\n\tthis.map = source.map;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.displacementMap = source.displacementMap;\n\tthis.displacementScale = source.displacementScale;\n\tthis.displacementBias = source.displacementBias;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\treturn this;\n\n};\n\n// File:src/materials/MeshLambertMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  emissive: <hex>,\n *  emissiveIntensity: <float>\n *  emissiveMap: new THREE.Texture( <Image> ),\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nTHREE.MeshLambertMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'MeshLambertMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\n\n\tthis.map = null;\n\n\tthis.lightMap = null;\n\tthis.lightMapIntensity = 1.0;\n\n\tthis.aoMap = null;\n\tthis.aoMapIntensity = 1.0;\n\n\tthis.emissive = new THREE.Color( 0x000000 );\n\tthis.emissiveIntensity = 1.0;\n\tthis.emissiveMap = null;\n\n\tthis.specularMap = null;\n\n\tthis.alphaMap = null;\n\n\tthis.envMap = null;\n\tthis.combine = THREE.MultiplyOperation;\n\tthis.reflectivity = 1;\n\tthis.refractionRatio = 0.98;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\tthis.morphNormals = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;\n\nTHREE.MeshLambertMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\n\tthis.map = source.map;\n\n\tthis.lightMap = source.lightMap;\n\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\tthis.aoMap = source.aoMap;\n\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\tthis.emissive.copy( source.emissive );\n\tthis.emissiveMap = source.emissiveMap;\n\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\tthis.specularMap = source.specularMap;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.envMap = source.envMap;\n\tthis.combine = source.combine;\n\tthis.reflectivity = source.reflectivity;\n\tthis.refractionRatio = source.refractionRatio;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\tthis.wireframeLinecap = source.wireframeLinecap;\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\tthis.morphNormals = source.morphNormals;\n\n\treturn this;\n\n};\n\n// File:src/materials/MeshNormalMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n *\n * parameters = {\n *  opacity: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>\n * }\n */\n\nTHREE.MeshNormalMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this, parameters );\n\n\tthis.type = 'MeshNormalMaterial';\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\n\tthis.fog = false;\n\tthis.lights = false;\n\tthis.morphTargets = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;\n\nTHREE.MeshNormalMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\treturn this;\n\n};\n\n// File:src/materials/MeshPhongMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  specular: <hex>,\n *  shininess: <float>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  emissive: <hex>,\n *  emissiveIntensity: <float>\n *  emissiveMap: new THREE.Texture( <Image> ),\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalScale: <Vector2>,\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nTHREE.MeshPhongMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'MeshPhongMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\n\tthis.specular = new THREE.Color( 0x111111 );\n\tthis.shininess = 30;\n\n\tthis.map = null;\n\n\tthis.lightMap = null;\n\tthis.lightMapIntensity = 1.0;\n\n\tthis.aoMap = null;\n\tthis.aoMapIntensity = 1.0;\n\n\tthis.emissive = new THREE.Color( 0x000000 );\n\tthis.emissiveIntensity = 1.0;\n\tthis.emissiveMap = null;\n\n\tthis.bumpMap = null;\n\tthis.bumpScale = 1;\n\n\tthis.normalMap = null;\n\tthis.normalScale = new THREE.Vector2( 1, 1 );\n\n\tthis.displacementMap = null;\n\tthis.displacementScale = 1;\n\tthis.displacementBias = 0;\n\n\tthis.specularMap = null;\n\n\tthis.alphaMap = null;\n\n\tthis.envMap = null;\n\tthis.combine = THREE.MultiplyOperation;\n\tthis.reflectivity = 1;\n\tthis.refractionRatio = 0.98;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\tthis.morphNormals = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;\n\nTHREE.MeshPhongMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\tthis.specular.copy( source.specular );\n\tthis.shininess = source.shininess;\n\n\tthis.map = source.map;\n\n\tthis.lightMap = source.lightMap;\n\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\tthis.aoMap = source.aoMap;\n\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\tthis.emissive.copy( source.emissive );\n\tthis.emissiveMap = source.emissiveMap;\n\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\tthis.bumpMap = source.bumpMap;\n\tthis.bumpScale = source.bumpScale;\n\n\tthis.normalMap = source.normalMap;\n\tthis.normalScale.copy( source.normalScale );\n\n\tthis.displacementMap = source.displacementMap;\n\tthis.displacementScale = source.displacementScale;\n\tthis.displacementBias = source.displacementBias;\n\n\tthis.specularMap = source.specularMap;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.envMap = source.envMap;\n\tthis.combine = source.combine;\n\tthis.reflectivity = source.reflectivity;\n\tthis.refractionRatio = source.refractionRatio;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\tthis.wireframeLinecap = source.wireframeLinecap;\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\tthis.morphNormals = source.morphNormals;\n\n\treturn this;\n\n};\n\n// File:src/materials/MeshStandardMaterial.js\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n *\n * parameters = {\n *  color: <hex>,\n *  roughness: <float>,\n *  metalness: <float>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  emissive: <hex>,\n *  emissiveIntensity: <float>\n *  emissiveMap: new THREE.Texture( <Image> ),\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalScale: <Vector2>,\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  roughnessMap: new THREE.Texture( <Image> ),\n *\n *  metalnessMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n *  envMapIntensity: <float>\n *\n *  refractionRatio: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nTHREE.MeshStandardMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.defines = { 'STANDARD': '' };\n\n\tthis.type = 'MeshStandardMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\n\tthis.roughness = 0.5;\n\tthis.metalness = 0.5;\n\n\tthis.map = null;\n\n\tthis.lightMap = null;\n\tthis.lightMapIntensity = 1.0;\n\n\tthis.aoMap = null;\n\tthis.aoMapIntensity = 1.0;\n\n\tthis.emissive = new THREE.Color( 0x000000 );\n\tthis.emissiveIntensity = 1.0;\n\tthis.emissiveMap = null;\n\n\tthis.bumpMap = null;\n\tthis.bumpScale = 1;\n\n\tthis.normalMap = null;\n\tthis.normalScale = new THREE.Vector2( 1, 1 );\n\n\tthis.displacementMap = null;\n\tthis.displacementScale = 1;\n\tthis.displacementBias = 0;\n\n\tthis.roughnessMap = null;\n\n\tthis.metalnessMap = null;\n\n\tthis.alphaMap = null;\n\n\tthis.envMap = null;\n\tthis.envMapIntensity = 1.0;\n\n\tthis.refractionRatio = 0.98;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\tthis.morphNormals = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshStandardMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.MeshStandardMaterial.prototype.constructor = THREE.MeshStandardMaterial;\n\nTHREE.MeshStandardMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.defines = { 'STANDARD': '' };\n\n\tthis.color.copy( source.color );\n\tthis.roughness = source.roughness;\n\tthis.metalness = source.metalness;\n\n\tthis.map = source.map;\n\n\tthis.lightMap = source.lightMap;\n\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\tthis.aoMap = source.aoMap;\n\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\tthis.emissive.copy( source.emissive );\n\tthis.emissiveMap = source.emissiveMap;\n\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\tthis.bumpMap = source.bumpMap;\n\tthis.bumpScale = source.bumpScale;\n\n\tthis.normalMap = source.normalMap;\n\tthis.normalScale.copy( source.normalScale );\n\n\tthis.displacementMap = source.displacementMap;\n\tthis.displacementScale = source.displacementScale;\n\tthis.displacementBias = source.displacementBias;\n\n\tthis.roughnessMap = source.roughnessMap;\n\n\tthis.metalnessMap = source.metalnessMap;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.envMap = source.envMap;\n\tthis.envMapIntensity = source.envMapIntensity;\n\n\tthis.refractionRatio = source.refractionRatio;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\tthis.wireframeLinecap = source.wireframeLinecap;\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\tthis.morphNormals = source.morphNormals;\n\n\treturn this;\n\n};\n\n// File:src/materials/MeshPhysicalMaterial.js\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n *\n * parameters = {\n *  reflectivity: <float>\n * }\n */\n\nTHREE.MeshPhysicalMaterial = function ( parameters ) {\n\n\tTHREE.MeshStandardMaterial.call( this );\n\n\tthis.defines = { 'PHYSICAL': '' };\n\n\tthis.type = 'MeshPhysicalMaterial';\n\n\tthis.reflectivity = 0.5; // maps to F0 = 0.04\n\n\tthis.clearCoat = 0.0;\n\tthis.clearCoatRoughness = 0.0;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshPhysicalMaterial.prototype = Object.create( THREE.MeshStandardMaterial.prototype );\nTHREE.MeshPhysicalMaterial.prototype.constructor = THREE.MeshPhysicalMaterial;\n\nTHREE.MeshPhysicalMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.MeshStandardMaterial.prototype.copy.call( this, source );\n\n\tthis.defines = { 'PHYSICAL': '' };\n\n\tthis.reflectivity = source.reflectivity;\n\n\tthis.clearCoat = source.clearCoat;\n\tthis.clearCoatRoughness = source.clearCoatRoughness;\n\n\treturn this;\n\n};\n\n// File:src/materials/MultiMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.MultiMaterial = function ( materials ) {\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.type = 'MultiMaterial';\n\n\tthis.materials = materials instanceof Array ? materials : [];\n\n\tthis.visible = true;\n\n};\n\nTHREE.MultiMaterial.prototype = {\n\n\tconstructor: THREE.MultiMaterial,\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar output = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.2,\n\t\t\t\ttype: 'material',\n\t\t\t\tgenerator: 'MaterialExporter'\n\t\t\t},\n\t\t\tuuid: this.uuid,\n\t\t\ttype: this.type,\n\t\t\tmaterials: []\n\t\t};\n\n\t\tvar materials = this.materials;\n\n\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\tvar material = materials[ i ].toJSON( meta );\n\t\t\tdelete material.metadata;\n\n\t\t\toutput.materials.push( material );\n\n\t\t}\n\n\t\toutput.visible = this.visible;\n\n\t\treturn output;\n\n\t},\n\n\tclone: function () {\n\n\t\tvar material = new this.constructor();\n\n\t\tfor ( var i = 0; i < this.materials.length; i ++ ) {\n\n\t\t\tmaterial.materials.push( this.materials[ i ].clone() );\n\n\t\t}\n\n\t\tmaterial.visible = this.visible;\n\n\t\treturn material;\n\n\t}\n\n};\n\n// File:src/materials/PointsMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *  map: new THREE.Texture( <Image> ),\n *\n *  size: <float>,\n *  sizeAttenuation: <bool>\n * }\n */\n\nTHREE.PointsMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'PointsMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff );\n\n\tthis.map = null;\n\n\tthis.size = 1;\n\tthis.sizeAttenuation = true;\n\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.PointsMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial;\n\nTHREE.PointsMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\n\tthis.map = source.map;\n\n\tthis.size = source.size;\n\tthis.sizeAttenuation = source.sizeAttenuation;\n\n\treturn this;\n\n};\n\n// File:src/materials/ShaderMaterial.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  defines: { \"label\" : \"value\" },\n *  uniforms: { \"parameter1\": { value: 1.0 }, \"parameter2\": { value2: 2 } },\n *\n *  fragmentShader: <string>,\n *  vertexShader: <string>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  lights: <bool>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nTHREE.ShaderMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'ShaderMaterial';\n\n\tthis.defines = {};\n\tthis.uniforms = {};\n\n\tthis.vertexShader = 'void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}';\n\tthis.fragmentShader = 'void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}';\n\n\tthis.linewidth = 1;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\n\tthis.fog = false; // set to use scene fog\n\tthis.lights = false; // set to use scene lights\n\tthis.clipping = false; // set to use user-defined clipping planes\n\n\tthis.skinning = false; // set to use skinning attribute streams\n\tthis.morphTargets = false; // set to use morph targets\n\tthis.morphNormals = false; // set to use morph normals\n\n\tthis.extensions = {\n\t\tderivatives: false, // set to use derivatives\n\t\tfragDepth: false, // set to use fragment depth values\n\t\tdrawBuffers: false, // set to use draw buffers\n\t\tshaderTextureLOD: false // set to use shader texture LOD\n\t};\n\n\t// When rendered geometry doesn't include these attributes but the material does,\n\t// use these default values in WebGL. This avoids errors when buffer data is missing.\n\tthis.defaultAttributeValues = {\n\t\t'color': [ 1, 1, 1 ],\n\t\t'uv': [ 0, 0 ],\n\t\t'uv2': [ 0, 0 ]\n\t};\n\n\tthis.index0AttributeName = undefined;\n\n\tif ( parameters !== undefined ) {\n\n\t\tif ( parameters.attributes !== undefined ) {\n\n\t\t\tconsole.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );\n\n\t\t}\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n};\n\nTHREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;\n\nTHREE.ShaderMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.fragmentShader = source.fragmentShader;\n\tthis.vertexShader = source.vertexShader;\n\n\tthis.uniforms = THREE.UniformsUtils.clone( source.uniforms );\n\n\tthis.defines = source.defines;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\tthis.lights = source.lights;\n\tthis.clipping = source.clipping;\n\n\tthis.skinning = source.skinning;\n\n\tthis.morphTargets = source.morphTargets;\n\tthis.morphNormals = source.morphNormals;\n\n\tthis.extensions = source.extensions;\n\n\treturn this;\n\n};\n\nTHREE.ShaderMaterial.prototype.toJSON = function ( meta ) {\n\n\tvar data = THREE.Material.prototype.toJSON.call( this, meta );\n\n\tdata.uniforms = this.uniforms;\n\tdata.vertexShader = this.vertexShader;\n\tdata.fragmentShader = this.fragmentShader;\n\n\treturn data;\n\n};\n\n// File:src/materials/RawShaderMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.RawShaderMaterial = function ( parameters ) {\n\n\tTHREE.ShaderMaterial.call( this, parameters );\n\n\tthis.type = 'RawShaderMaterial';\n\n};\n\nTHREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );\nTHREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;\n\n// File:src/materials/SpriteMaterial.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *  map: new THREE.Texture( <Image> ),\n *\n *\tuvOffset: new THREE.Vector2(),\n *\tuvScale: new THREE.Vector2()\n * }\n */\n\nTHREE.SpriteMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'SpriteMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff );\n\tthis.map = null;\n\n\tthis.rotation = 0;\n\n\tthis.fog = false;\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;\n\nTHREE.SpriteMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\tthis.map = source.map;\n\n\tthis.rotation = source.rotation;\n\n\treturn this;\n\n};\n\n// File:src/materials/ShadowMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.ShadowMaterial = function () {\n\n\tTHREE.ShaderMaterial.call( this, {\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\t\t\tTHREE.UniformsLib[ \"lights\" ],\n\t\t\t{\n\t\t\t\topacity: { value: 1.0 }\n\t\t\t}\n\t\t] ),\n\t\tvertexShader: THREE.ShaderChunk[ 'shadow_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'shadow_frag' ]\n\t} );\n\n\tthis.lights = true;\n\tthis.transparent = true;\n\n\tObject.defineProperties( this, {\n\t\topacity: {\n\t\t\tenumerable: true,\n\t\t\tget: function () {\n\t\t\t\treturn this.uniforms.opacity.value;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tthis.uniforms.opacity.value = value;\n\t\t\t}\n\t\t}\n\t} );\n\n};\n\nTHREE.ShadowMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );\nTHREE.ShadowMaterial.prototype.constructor = THREE.ShadowMaterial;\n\n// File:src/textures/Texture.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author szimek / https://github.com/szimek/\n */\n\nTHREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\n\tObject.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\tthis.sourceFile = '';\n\n\tthis.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;\n\tthis.mipmaps = [];\n\n\tthis.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;\n\n\tthis.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;\n\tthis.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;\n\n\tthis.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;\n\tthis.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;\n\n\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\n\n\tthis.format = format !== undefined ? format : THREE.RGBAFormat;\n\tthis.type = type !== undefined ? type : THREE.UnsignedByteType;\n\n\tthis.offset = new THREE.Vector2( 0, 0 );\n\tthis.repeat = new THREE.Vector2( 1, 1 );\n\n\tthis.generateMipmaps = true;\n\tthis.premultiplyAlpha = false;\n\tthis.flipY = true;\n\tthis.unpackAlignment = 4;\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\n\n\t// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\n\t//\n\t// Also changing the encoding after already used by a Material will not automatically make the Material\n\t// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.\n\tthis.encoding = encoding !== undefined ? encoding :  THREE.LinearEncoding;\n\n\tthis.version = 0;\n\tthis.onUpdate = null;\n\n};\n\nTHREE.Texture.DEFAULT_IMAGE = undefined;\nTHREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;\n\nTHREE.Texture.prototype = {\n\n\tconstructor: THREE.Texture,\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.image = source.image;\n\t\tthis.mipmaps = source.mipmaps.slice( 0 );\n\n\t\tthis.mapping = source.mapping;\n\n\t\tthis.wrapS = source.wrapS;\n\t\tthis.wrapT = source.wrapT;\n\n\t\tthis.magFilter = source.magFilter;\n\t\tthis.minFilter = source.minFilter;\n\n\t\tthis.anisotropy = source.anisotropy;\n\n\t\tthis.format = source.format;\n\t\tthis.type = source.type;\n\n\t\tthis.offset.copy( source.offset );\n\t\tthis.repeat.copy( source.repeat );\n\n\t\tthis.generateMipmaps = source.generateMipmaps;\n\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\n\t\tthis.flipY = source.flipY;\n\t\tthis.unpackAlignment = source.unpackAlignment;\n\t\tthis.encoding = source.encoding;\n\n\t\treturn this;\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tif ( meta.textures[ this.uuid ] !== undefined ) {\n\n\t\t\treturn meta.textures[ this.uuid ];\n\n\t\t}\n\n\t\tfunction getDataURL( image ) {\n\n\t\t\tvar canvas;\n\n\t\t\tif ( image.toDataURL !== undefined ) {\n\n\t\t\t\tcanvas = image;\n\n\t\t\t} else {\n\n\t\t\t\tcanvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\t\tcanvas.width = image.width;\n\t\t\t\tcanvas.height = image.height;\n\n\t\t\t\tcanvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );\n\n\t\t\t}\n\n\t\t\tif ( canvas.width > 2048 || canvas.height > 2048 ) {\n\n\t\t\t\treturn canvas.toDataURL( 'image/jpeg', 0.6 );\n\n\t\t\t} else {\n\n\t\t\t\treturn canvas.toDataURL( 'image/png' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar output = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.4,\n\t\t\t\ttype: 'Texture',\n\t\t\t\tgenerator: 'Texture.toJSON'\n\t\t\t},\n\n\t\t\tuuid: this.uuid,\n\t\t\tname: this.name,\n\n\t\t\tmapping: this.mapping,\n\n\t\t\trepeat: [ this.repeat.x, this.repeat.y ],\n\t\t\toffset: [ this.offset.x, this.offset.y ],\n\t\t\twrap: [ this.wrapS, this.wrapT ],\n\n\t\t\tminFilter: this.minFilter,\n\t\t\tmagFilter: this.magFilter,\n\t\t\tanisotropy: this.anisotropy\n\t\t};\n\n\t\tif ( this.image !== undefined ) {\n\n\t\t\t// TODO: Move to THREE.Image\n\n\t\t\tvar image = this.image;\n\n\t\t\tif ( image.uuid === undefined ) {\n\n\t\t\t\timage.uuid = THREE.Math.generateUUID(); // UGH\n\n\t\t\t}\n\n\t\t\tif ( meta.images[ image.uuid ] === undefined ) {\n\n\t\t\t\tmeta.images[ image.uuid ] = {\n\t\t\t\t\tuuid: image.uuid,\n\t\t\t\t\turl: getDataURL( image )\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\toutput.image = image.uuid;\n\n\t\t}\n\n\t\tmeta.textures[ this.uuid ] = output;\n\n\t\treturn output;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t},\n\n\ttransformUv: function ( uv ) {\n\n\t\tif ( this.mapping !== THREE.UVMapping )  return;\n\n\t\tuv.multiply( this.repeat );\n\t\tuv.add( this.offset );\n\n\t\tif ( uv.x < 0 || uv.x > 1 ) {\n\n\t\t\tswitch ( this.wrapS ) {\n\n\t\t\t\tcase THREE.RepeatWrapping:\n\n\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.ClampToEdgeWrapping:\n\n\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.MirroredRepeatWrapping:\n\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\tuv.x = Math.ceil( uv.x ) - uv.x;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( uv.y < 0 || uv.y > 1 ) {\n\n\t\t\tswitch ( this.wrapT ) {\n\n\t\t\t\tcase THREE.RepeatWrapping:\n\n\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.ClampToEdgeWrapping:\n\n\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.MirroredRepeatWrapping:\n\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\tuv.y = Math.ceil( uv.y ) - uv.y;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.flipY ) {\n\n\t\t\tuv.y = 1 - uv.y;\n\n\t\t}\n\n\t}\n\n};\n\nObject.assign( THREE.Texture.prototype, THREE.EventDispatcher.prototype );\n\nTHREE.TextureIdCount = 0;\n\n// File:src/textures/DepthTexture.js\n\n/**\n * @author Matt DesLauriers / @mattdesl\n */\n\nTHREE.DepthTexture = function ( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {\n\n  THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, THREE.DepthFormat, type, anisotropy );\n\n  this.image = { width: width, height: height };\n\n  this.type = type !== undefined ? type : THREE.UnsignedShortType;\n\n  this.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;\n  this.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;\n\n  this.flipY = false;\n  this.generateMipmaps  = false;\n\n};\n\nTHREE.DepthTexture.prototype = Object.create( THREE.Texture.prototype );\nTHREE.DepthTexture.prototype.constructor = THREE.DepthTexture;\n\n// File:src/textures/CanvasTexture.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.CanvasTexture = function ( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\tTHREE.Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\tthis.needsUpdate = true;\n\n};\n\nTHREE.CanvasTexture.prototype = Object.create( THREE.Texture.prototype );\nTHREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;\n\n// File:src/textures/CubeTexture.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\n\timages = images !== undefined ? images : [];\n\tmapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;\n\n\tTHREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\tthis.flipY = false;\n\n};\n\nTHREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );\nTHREE.CubeTexture.prototype.constructor = THREE.CubeTexture;\n\nObject.defineProperty( THREE.CubeTexture.prototype, 'images', {\n\n\tget: function () {\n\n\t\treturn this.image;\n\n\t},\n\n\tset: function ( value ) {\n\n\t\tthis.image = value;\n\n\t}\n\n} );\n\n// File:src/textures/CompressedTexture.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\n\n\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\tthis.image = { width: width, height: height };\n\tthis.mipmaps = mipmaps;\n\n\t// no flipping for cube textures\n\t// (also flipping doesn't work for compressed textures )\n\n\tthis.flipY = false;\n\n\t// can't generate mipmaps for compressed textures\n\t// mips must be embedded in DDS files\n\n\tthis.generateMipmaps = false;\n\n};\n\nTHREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );\nTHREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;\n\n// File:src/textures/DataTexture.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\n\n\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\tthis.image = { data: data, width: width, height: height };\n\n\tthis.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;\n\tthis.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;\n\n\tthis.flipY = false;\n\tthis.generateMipmaps  = false;\n\n};\n\nTHREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );\nTHREE.DataTexture.prototype.constructor = THREE.DataTexture;\n\n// File:src/textures/VideoTexture.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\tTHREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\tthis.generateMipmaps = false;\n\n\tvar scope = this;\n\n\tfunction update() {\n\n\t\trequestAnimationFrame( update );\n\n\t\tif ( video.readyState >= video.HAVE_CURRENT_DATA ) {\n\n\t\t\tscope.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\tupdate();\n\n};\n\nTHREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );\nTHREE.VideoTexture.prototype.constructor = THREE.VideoTexture;\n\n// File:src/objects/Group.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Group = function () {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Group';\n\n};\n\nTHREE.Group.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Group\n\n} );\n\n// File:src/objects/Points.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Points = function ( geometry, material ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Points';\n\n\tthis.geometry = geometry !== undefined ? geometry : new THREE.BufferGeometry();\n\tthis.material = material !== undefined ? material : new THREE.PointsMaterial( { color: Math.random() * 0xffffff } );\n\n};\n\nTHREE.Points.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Points,\n\n\traycast: ( function () {\n\n\t\tvar inverseMatrix = new THREE.Matrix4();\n\t\tvar ray = new THREE.Ray();\n\t\tvar sphere = new THREE.Sphere();\n\n\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\tvar object = this;\n\t\t\tvar geometry = this.geometry;\n\t\t\tvar matrixWorld = this.matrixWorld;\n\t\t\tvar threshold = raycaster.params.Points.threshold;\n\n\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\tsphere.applyMatrix4( matrixWorld );\n\n\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\n\t\t\t//\n\n\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\tvar localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\t\tvar localThresholdSq = localThreshold * localThreshold;\n\t\t\tvar position = new THREE.Vector3();\n\n\t\t\tfunction testPoint( point, index ) {\n\n\t\t\t\tvar rayPointDistanceSq = ray.distanceSqToPoint( point );\n\n\t\t\t\tif ( rayPointDistanceSq < localThresholdSq ) {\n\n\t\t\t\t\tvar intersectPoint = ray.closestPointToPoint( point );\n\t\t\t\t\tintersectPoint.applyMatrix4( matrixWorld );\n\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\n\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\n\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\tdistanceToRay: Math.sqrt( rayPointDistanceSq ),\n\t\t\t\t\t\tpoint: intersectPoint.clone(),\n\t\t\t\t\t\tindex: index,\n\t\t\t\t\t\tface: null,\n\t\t\t\t\t\tobject: object\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\tvar index = geometry.index;\n\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\tfor ( var i = 0, il = indices.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tvar a = indices[ i ];\n\n\t\t\t\t\t\tposition.fromArray( positions, a * 3 );\n\n\t\t\t\t\t\ttestPoint( position, a );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( var i = 0, l = positions.length / 3; i < l; i ++ ) {\n\n\t\t\t\t\t\tposition.fromArray( positions, i * 3 );\n\n\t\t\t\t\t\ttestPoint( position, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tvar vertices = geometry.vertices;\n\n\t\t\t\tfor ( var i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\t\t\t\ttestPoint( vertices[ i ], i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}() ),\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t}\n\n} );\n\n// File:src/objects/Line.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Line = function ( geometry, material, mode ) {\n\n\tif ( mode === 1 ) {\n\n\t\tconsole.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );\n\t\treturn new THREE.LineSegments( geometry, material );\n\n\t}\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Line';\n\n\tthis.geometry = geometry !== undefined ? geometry : new THREE.BufferGeometry();\n\tthis.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );\n\n};\n\nTHREE.Line.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Line,\n\n\traycast: ( function () {\n\n\t\tvar inverseMatrix = new THREE.Matrix4();\n\t\tvar ray = new THREE.Ray();\n\t\tvar sphere = new THREE.Sphere();\n\n\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\tvar precision = raycaster.linePrecision;\n\t\t\tvar precisionSq = precision * precision;\n\n\t\t\tvar geometry = this.geometry;\n\t\t\tvar matrixWorld = this.matrixWorld;\n\n\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\tsphere.applyMatrix4( matrixWorld );\n\n\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\n\t\t\t//\n\n\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\tvar vStart = new THREE.Vector3();\n\t\t\tvar vEnd = new THREE.Vector3();\n\t\t\tvar interSegment = new THREE.Vector3();\n\t\t\tvar interRay = new THREE.Vector3();\n\t\t\tvar step = this instanceof THREE.LineSegments ? 2 : 1;\n\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\tvar index = geometry.index;\n\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\tfor ( var i = 0, l = indices.length - 1; i < l; i += step ) {\n\n\t\t\t\t\t\tvar a = indices[ i ];\n\t\t\t\t\t\tvar b = indices[ i + 1 ];\n\n\t\t\t\t\t\tvStart.fromArray( positions, a * 3 );\n\t\t\t\t\t\tvEnd.fromArray( positions, b * 3 );\n\n\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\n\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\n\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {\n\n\t\t\t\t\t\tvStart.fromArray( positions, 3 * i );\n\t\t\t\t\t\tvEnd.fromArray( positions, 3 * i + 3 );\n\n\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\n\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\n\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\tvar nbVertices = vertices.length;\n\n\t\t\t\tfor ( var i = 0; i < nbVertices - 1; i += step ) {\n\n\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\n\n\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\n\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\tface: null,\n\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}() ),\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t}\n\n} );\n\n// File:src/objects/LineSegments.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.LineSegments = function ( geometry, material ) {\n\n\tTHREE.Line.call( this, geometry, material );\n\n\tthis.type = 'LineSegments';\n\n};\n\nTHREE.LineSegments.prototype = Object.assign( Object.create( THREE.Line.prototype ), {\n\n\tconstructor: THREE.LineSegments\n\n} );\n\n// File:src/objects/Mesh.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author mikael emtinger / http://gomo.se/\n * @author jonobr1 / http://jonobr1.com/\n */\n\nTHREE.Mesh = function ( geometry, material ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Mesh';\n\n\tthis.geometry = geometry !== undefined ? geometry : new THREE.BufferGeometry();\n\tthis.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );\n\n\tthis.drawMode = THREE.TrianglesDrawMode;\n\n\tthis.updateMorphTargets();\n\n};\n\nTHREE.Mesh.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Mesh,\n\n\tsetDrawMode: function ( value ) {\n\n\t\tthis.drawMode = value;\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Object3D.prototype.copy.call( this, source );\n\n\t\tthis.drawMode = source.drawMode;\n\n\t\treturn this;\n\n\t},\n\n\tupdateMorphTargets: function () {\n\n\t\tif ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {\n\n\t\t\tthis.morphTargetBase = - 1;\n\t\t\tthis.morphTargetInfluences = [];\n\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\tfor ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {\n\n\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\tthis.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tgetMorphTargetIndexByName: function ( name ) {\n\n\t\tif ( this.morphTargetDictionary[ name ] !== undefined ) {\n\n\t\t\treturn this.morphTargetDictionary[ name ];\n\n\t\t}\n\n\t\tconsole.warn( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );\n\n\t\treturn 0;\n\n\t},\n\n\traycast: ( function () {\n\n\t\tvar inverseMatrix = new THREE.Matrix4();\n\t\tvar ray = new THREE.Ray();\n\t\tvar sphere = new THREE.Sphere();\n\n\t\tvar vA = new THREE.Vector3();\n\t\tvar vB = new THREE.Vector3();\n\t\tvar vC = new THREE.Vector3();\n\n\t\tvar tempA = new THREE.Vector3();\n\t\tvar tempB = new THREE.Vector3();\n\t\tvar tempC = new THREE.Vector3();\n\n\t\tvar uvA = new THREE.Vector2();\n\t\tvar uvB = new THREE.Vector2();\n\t\tvar uvC = new THREE.Vector2();\n\n\t\tvar barycoord = new THREE.Vector3();\n\n\t\tvar intersectionPoint = new THREE.Vector3();\n\t\tvar intersectionPointWorld = new THREE.Vector3();\n\n\t\tfunction uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {\n\n\t\t\tTHREE.Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );\n\n\t\t\tuv1.multiplyScalar( barycoord.x );\n\t\t\tuv2.multiplyScalar( barycoord.y );\n\t\t\tuv3.multiplyScalar( barycoord.z );\n\n\t\t\tuv1.add( uv2 ).add( uv3 );\n\n\t\t\treturn uv1.clone();\n\n\t\t}\n\n\t\tfunction checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {\n\n\t\t\tvar intersect;\n\t\t\tvar material = object.material;\n\n\t\t\tif ( material.side === THREE.BackSide ) {\n\n\t\t\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t\t\t} else {\n\n\t\t\t\tintersect = ray.intersectTriangle( pA, pB, pC, material.side !== THREE.DoubleSide, point );\n\n\t\t\t}\n\n\t\t\tif ( intersect === null ) return null;\n\n\t\t\tintersectionPointWorld.copy( point );\n\t\t\tintersectionPointWorld.applyMatrix4( object.matrixWorld );\n\n\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );\n\n\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\n\n\t\t\treturn {\n\t\t\t\tdistance: distance,\n\t\t\t\tpoint: intersectionPointWorld.clone(),\n\t\t\t\tobject: object\n\t\t\t};\n\n\t\t}\n\n\t\tfunction checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {\n\n\t\t\tvA.fromArray( positions, a * 3 );\n\t\t\tvB.fromArray( positions, b * 3 );\n\t\t\tvC.fromArray( positions, c * 3 );\n\n\t\t\tvar intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );\n\n\t\t\tif ( intersection ) {\n\n\t\t\t\tif ( uvs ) {\n\n\t\t\t\t\tuvA.fromArray( uvs, a * 2 );\n\t\t\t\t\tuvB.fromArray( uvs, b * 2 );\n\t\t\t\t\tuvC.fromArray( uvs, c * 2 );\n\n\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );\n\n\t\t\t\t}\n\n\t\t\t\tintersection.face = new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) );\n\t\t\t\tintersection.faceIndex = a;\n\n\t\t\t}\n\n\t\t\treturn intersection;\n\n\t\t}\n\n\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\tvar geometry = this.geometry;\n\t\t\tvar material = this.material;\n\t\t\tvar matrixWorld = this.matrixWorld;\n\n\t\t\tif ( material === undefined ) return;\n\n\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\tsphere.applyMatrix4( matrixWorld );\n\n\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\n\t\t\t//\n\n\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\t// Check boundingBox before continuing\n\n\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\tif ( ray.intersectsBox( geometry.boundingBox ) === false ) return;\n\n\t\t\t}\n\n\t\t\tvar uvs, intersection;\n\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\tvar a, b, c;\n\t\t\t\tvar index = geometry.index;\n\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\tif ( attributes.uv !== undefined ) {\n\n\t\t\t\t\tuvs = attributes.uv.array;\n\n\t\t\t\t}\n\n\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += 3 ) {\n\n\t\t\t\t\t\ta = indices[ i ];\n\t\t\t\t\t\tb = indices[ i + 1 ];\n\t\t\t\t\t\tc = indices[ i + 2 ];\n\n\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\n\n\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics\n\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\n\t\t\t\t\tfor ( var i = 0, l = positions.length; i < l; i += 9 ) {\n\n\t\t\t\t\t\ta = i / 3;\n\t\t\t\t\t\tb = a + 1;\n\t\t\t\t\t\tc = a + 2;\n\n\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\n\n\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\tintersection.index = a; // triangle number in positions buffer semantics\n\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\tvar fvA, fvB, fvC;\n\t\t\t\tvar isFaceMaterial = material instanceof THREE.MultiMaterial;\n\t\t\t\tvar materials = isFaceMaterial === true ? material.materials : null;\n\n\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\tvar faces = geometry.faces;\n\t\t\t\tvar faceVertexUvs = geometry.faceVertexUvs[ 0 ];\n\t\t\t\tif ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;\n\n\t\t\t\tfor ( var f = 0, fl = faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tvar face = faces[ f ];\n\t\t\t\t\tvar faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;\n\n\t\t\t\t\tif ( faceMaterial === undefined ) continue;\n\n\t\t\t\t\tfvA = vertices[ face.a ];\n\t\t\t\t\tfvB = vertices[ face.b ];\n\t\t\t\t\tfvC = vertices[ face.c ];\n\n\t\t\t\t\tif ( faceMaterial.morphTargets === true ) {\n\n\t\t\t\t\t\tvar morphTargets = geometry.morphTargets;\n\t\t\t\t\t\tvar morphInfluences = this.morphTargetInfluences;\n\n\t\t\t\t\t\tvA.set( 0, 0, 0 );\n\t\t\t\t\t\tvB.set( 0, 0, 0 );\n\t\t\t\t\t\tvC.set( 0, 0, 0 );\n\n\t\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\n\n\t\t\t\t\t\t\tvar influence = morphInfluences[ t ];\n\n\t\t\t\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t\t\t\tvar targets = morphTargets[ t ].vertices;\n\n\t\t\t\t\t\t\tvA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );\n\t\t\t\t\t\t\tvB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );\n\t\t\t\t\t\t\tvC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvA.add( fvA );\n\t\t\t\t\t\tvB.add( fvB );\n\t\t\t\t\t\tvC.add( fvC );\n\n\t\t\t\t\t\tfvA = vA;\n\t\t\t\t\t\tfvB = vB;\n\t\t\t\t\t\tfvC = vC;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tintersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );\n\n\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\tif ( uvs ) {\n\n\t\t\t\t\t\t\tvar uvs_f = uvs[ f ];\n\t\t\t\t\t\t\tuvA.copy( uvs_f[ 0 ] );\n\t\t\t\t\t\t\tuvB.copy( uvs_f[ 1 ] );\n\t\t\t\t\t\t\tuvC.copy( uvs_f[ 2 ] );\n\n\t\t\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tintersection.face = face;\n\t\t\t\t\t\tintersection.faceIndex = f;\n\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}() ),\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t}\n\n} );\n\n// File:src/objects/Bone.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author ikerr / http://verold.com\n */\n\nTHREE.Bone = function ( skin ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Bone';\n\n\tthis.skin = skin;\n\n};\n\nTHREE.Bone.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Bone,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Object3D.prototype.copy.call( this, source );\n\n\t\tthis.skin = source.skin;\n\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/objects/Skeleton.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author michael guerrero / http://realitymeltdown.com\n * @author ikerr / http://verold.com\n */\n\nTHREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {\n\n\tthis.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;\n\n\tthis.identityMatrix = new THREE.Matrix4();\n\n\t// copy the bone array\n\n\tbones = bones || [];\n\n\tthis.bones = bones.slice( 0 );\n\n\t// create a bone texture or an array of floats\n\n\tif ( this.useVertexTexture ) {\n\n\t\t// layout (1 matrix = 4 pixels)\n\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n\t\t//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\n\t\t//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\n\t\t//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\n\t\t//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\n\n\n\t\tvar size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix\n\t\tsize = THREE.Math.nextPowerOfTwo( Math.ceil( size ) );\n\t\tsize = Math.max( size, 4 );\n\n\t\tthis.boneTextureWidth = size;\n\t\tthis.boneTextureHeight = size;\n\n\t\tthis.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel\n\t\tthis.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );\n\n\t} else {\n\n\t\tthis.boneMatrices = new Float32Array( 16 * this.bones.length );\n\n\t}\n\n\t// use the supplied bone inverses or calculate the inverses\n\n\tif ( boneInverses === undefined ) {\n\n\t\tthis.calculateInverses();\n\n\t} else {\n\n\t\tif ( this.bones.length === boneInverses.length ) {\n\n\t\t\tthis.boneInverses = boneInverses.slice( 0 );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.Skeleton bonInverses is the wrong length.' );\n\n\t\t\tthis.boneInverses = [];\n\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\t\tthis.boneInverses.push( new THREE.Matrix4() );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n};\n\nObject.assign( THREE.Skeleton.prototype, {\n\n\tcalculateInverses: function () {\n\n\t\tthis.boneInverses = [];\n\n\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\tvar inverse = new THREE.Matrix4();\n\n\t\t\tif ( this.bones[ b ] ) {\n\n\t\t\t\tinverse.getInverse( this.bones[ b ].matrixWorld );\n\n\t\t\t}\n\n\t\t\tthis.boneInverses.push( inverse );\n\n\t\t}\n\n\t},\n\n\tpose: function () {\n\n\t\tvar bone;\n\n\t\t// recover the bind-time world matrices\n\n\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\tbone = this.bones[ b ];\n\n\t\t\tif ( bone ) {\n\n\t\t\t\tbone.matrixWorld.getInverse( this.boneInverses[ b ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// compute the local matrices, positions, rotations and scales\n\n\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\tbone = this.bones[ b ];\n\n\t\t\tif ( bone ) {\n\n\t\t\t\tif ( bone.parent instanceof THREE.Bone ) {\n\n\t\t\t\t\tbone.matrix.getInverse( bone.parent.matrixWorld );\n\t\t\t\t\tbone.matrix.multiply( bone.matrixWorld );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbone.matrix.copy( bone.matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tupdate: ( function () {\n\n\t\tvar offsetMatrix = new THREE.Matrix4();\n\n\t\treturn function update() {\n\n\t\t\t// flatten bone matrices to array\n\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\t\t// compute the offset between the current and the original transform\n\n\t\t\t\tvar matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;\n\n\t\t\t\toffsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );\n\t\t\t\toffsetMatrix.toArray( this.boneMatrices, b * 16 );\n\n\t\t\t}\n\n\t\t\tif ( this.useVertexTexture ) {\n\n\t\t\t\tthis.boneTexture.needsUpdate = true;\n\n\t\t\t}\n\n\t\t};\n\n\t} )(),\n\n\tclone: function () {\n\n\t\treturn new THREE.Skeleton( this.bones, this.boneInverses, this.useVertexTexture );\n\n\t}\n\n} );\n\n// File:src/objects/SkinnedMesh.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author ikerr / http://verold.com\n */\n\nTHREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {\n\n\tTHREE.Mesh.call( this, geometry, material );\n\n\tthis.type = 'SkinnedMesh';\n\n\tthis.bindMode = \"attached\";\n\tthis.bindMatrix = new THREE.Matrix4();\n\tthis.bindMatrixInverse = new THREE.Matrix4();\n\n\t// init bones\n\n\t// TODO: remove bone creation as there is no reason (other than\n\t// convenience) for THREE.SkinnedMesh to do this.\n\n\tvar bones = [];\n\n\tif ( this.geometry && this.geometry.bones !== undefined ) {\n\n\t\tvar bone, gbone;\n\n\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\n\n\t\t\tgbone = this.geometry.bones[ b ];\n\n\t\t\tbone = new THREE.Bone( this );\n\t\t\tbones.push( bone );\n\n\t\t\tbone.name = gbone.name;\n\t\t\tbone.position.fromArray( gbone.pos );\n\t\t\tbone.quaternion.fromArray( gbone.rotq );\n\t\t\tif ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );\n\n\t\t}\n\n\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\n\n\t\t\tgbone = this.geometry.bones[ b ];\n\n\t\t\tif ( gbone.parent !== - 1 && gbone.parent !== null &&\n\t\t\t\t\tbones[ gbone.parent ] !== undefined ) {\n\n\t\t\t\tbones[ gbone.parent ].add( bones[ b ] );\n\n\t\t\t} else {\n\n\t\t\t\tthis.add( bones[ b ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tthis.normalizeSkinWeights();\n\n\tthis.updateMatrixWorld( true );\n\tthis.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );\n\n};\n\n\nTHREE.SkinnedMesh.prototype = Object.assign( Object.create( THREE.Mesh.prototype ), {\n\n\tconstructor: THREE.SkinnedMesh,\n\n\tbind: function( skeleton, bindMatrix ) {\n\n\t\tthis.skeleton = skeleton;\n\n\t\tif ( bindMatrix === undefined ) {\n\n\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\tthis.skeleton.calculateInverses();\n\n\t\t\tbindMatrix = this.matrixWorld;\n\n\t\t}\n\n\t\tthis.bindMatrix.copy( bindMatrix );\n\t\tthis.bindMatrixInverse.getInverse( bindMatrix );\n\n\t},\n\n\tpose: function () {\n\n\t\tthis.skeleton.pose();\n\n\t},\n\n\tnormalizeSkinWeights: function () {\n\n\t\tif ( this.geometry instanceof THREE.Geometry ) {\n\n\t\t\tfor ( var i = 0; i < this.geometry.skinWeights.length; i ++ ) {\n\n\t\t\t\tvar sw = this.geometry.skinWeights[ i ];\n\n\t\t\t\tvar scale = 1.0 / sw.lengthManhattan();\n\n\t\t\t\tif ( scale !== Infinity ) {\n\n\t\t\t\t\tsw.multiplyScalar( scale );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsw.set( 1, 0, 0, 0 ); // do something reasonable\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( this.geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\tvar vec = new THREE.Vector4();\n\n\t\t\tvar skinWeight = this.geometry.attributes.skinWeight;\n\n\t\t\tfor ( var i = 0; i < skinWeight.count; i ++ ) {\n\n\t\t\t\tvec.x = skinWeight.getX( i );\n\t\t\t\tvec.y = skinWeight.getY( i );\n\t\t\t\tvec.z = skinWeight.getZ( i );\n\t\t\t\tvec.w = skinWeight.getW( i );\n\n\t\t\t\tvar scale = 1.0 / vec.lengthManhattan();\n\n\t\t\t\tif ( scale !== Infinity ) {\n\n\t\t\t\t\tvec.multiplyScalar( scale );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvec.set( 1, 0, 0, 0 ); // do something reasonable\n\n\t\t\t\t}\n\n\t\t\t\tskinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tupdateMatrixWorld: function( force ) {\n\n\t\tTHREE.Mesh.prototype.updateMatrixWorld.call( this, true );\n\n\t\tif ( this.bindMode === \"attached\" ) {\n\n\t\t\tthis.bindMatrixInverse.getInverse( this.matrixWorld );\n\n\t\t} else if ( this.bindMode === \"detached\" ) {\n\n\t\t\tthis.bindMatrixInverse.getInverse( this.bindMatrix );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );\n\n\t\t}\n\n\t},\n\n\tclone: function() {\n\n\t\treturn new this.constructor( this.geometry, this.material, this.skeleton.useVertexTexture ).copy( this );\n\n\t}\n\n} );\n\n// File:src/objects/LOD.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.LOD = function () {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'LOD';\n\n\tObject.defineProperties( this, {\n\t\tlevels: {\n\t\t\tenumerable: true,\n\t\t\tvalue: []\n\t\t}\n\t} );\n\n};\n\n\nTHREE.LOD.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.LOD,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Object3D.prototype.copy.call( this, source, false );\n\n\t\tvar levels = source.levels;\n\n\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\n\n\t\t\tvar level = levels[ i ];\n\n\t\t\tthis.addLevel( level.object.clone(), level.distance );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\taddLevel: function ( object, distance ) {\n\n\t\tif ( distance === undefined ) distance = 0;\n\n\t\tdistance = Math.abs( distance );\n\n\t\tvar levels = this.levels;\n\n\t\tfor ( var l = 0; l < levels.length; l ++ ) {\n\n\t\t\tif ( distance < levels[ l ].distance ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tlevels.splice( l, 0, { distance: distance, object: object } );\n\n\t\tthis.add( object );\n\n\t},\n\n\tgetObjectForDistance: function ( distance ) {\n\n\t\tvar levels = this.levels;\n\n\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\n\n\t\t\tif ( distance < levels[ i ].distance ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn levels[ i - 1 ].object;\n\n\t},\n\n\traycast: ( function () {\n\n\t\tvar matrixPosition = new THREE.Vector3();\n\n\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\tvar distance = raycaster.ray.origin.distanceTo( matrixPosition );\n\n\t\t\tthis.getObjectForDistance( distance ).raycast( raycaster, intersects );\n\n\t\t};\n\n\t}() ),\n\n\tupdate: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\t\tvar v2 = new THREE.Vector3();\n\n\t\treturn function update( camera ) {\n\n\t\t\tvar levels = this.levels;\n\n\t\t\tif ( levels.length > 1 ) {\n\n\t\t\t\tv1.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t\tv2.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\t\tvar distance = v1.distanceTo( v2 );\n\n\t\t\t\tlevels[ 0 ].object.visible = true;\n\n\t\t\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\t\tif ( distance >= levels[ i ].distance ) {\n\n\t\t\t\t\t\tlevels[ i - 1 ].object.visible = false;\n\t\t\t\t\t\tlevels[ i ].object.visible = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( ; i < l; i ++ ) {\n\n\t\t\t\t\tlevels[ i ].object.visible = false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}(),\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\n\n\t\tdata.object.levels = [];\n\n\t\tvar levels = this.levels;\n\n\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\n\n\t\t\tvar level = levels[ i ];\n\n\t\t\tdata.object.levels.push( {\n\t\t\t\tobject: level.object.uuid,\n\t\t\t\tdistance: level.distance\n\t\t\t} );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n} );\n\n// File:src/objects/Sprite.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Sprite = function ( material ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Sprite';\n\n\tthis.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();\n\n};\n\nTHREE.Sprite.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Sprite,\n\n\traycast: ( function () {\n\n\t\tvar matrixPosition = new THREE.Vector3();\n\n\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\tvar distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );\n\t\t\tvar guessSizeSq = this.scale.x * this.scale.y / 4;\n\n\t\t\tif ( distanceSq > guessSizeSq ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tintersects.push( {\n\n\t\t\t\tdistance: Math.sqrt( distanceSq ),\n\t\t\t\tpoint: this.position,\n\t\t\t\tface: null,\n\t\t\t\tobject: this\n\n\t\t\t} );\n\n\t\t};\n\n\t}() ),\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.material ).copy( this );\n\n\t}\n\n} );\n\n// File:src/objects/LensFlare.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.LensFlare = function ( texture, size, distance, blending, color ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.lensFlares = [];\n\n\tthis.positionScreen = new THREE.Vector3();\n\tthis.customUpdateCallback = undefined;\n\n\tif ( texture !== undefined ) {\n\n\t\tthis.add( texture, size, distance, blending, color );\n\n\t}\n\n};\n\nTHREE.LensFlare.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.LensFlare,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Object3D.prototype.copy.call( this, source );\n\n\t\tthis.positionScreen.copy( source.positionScreen );\n\t\tthis.customUpdateCallback = source.customUpdateCallback;\n\n\t\tfor ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {\n\n\t\t\tthis.lensFlares.push( source.lensFlares[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( texture, size, distance, blending, color, opacity ) {\n\n\t\tif ( size === undefined ) size = - 1;\n\t\tif ( distance === undefined ) distance = 0;\n\t\tif ( opacity === undefined ) opacity = 1;\n\t\tif ( color === undefined ) color = new THREE.Color( 0xffffff );\n\t\tif ( blending === undefined ) blending = THREE.NormalBlending;\n\n\t\tdistance = Math.min( distance, Math.max( 0, distance ) );\n\n\t\tthis.lensFlares.push( {\n\t\t\ttexture: texture,\t// THREE.Texture\n\t\t\tsize: size, \t\t// size in pixels (-1 = use texture.width)\n\t\t\tdistance: distance, \t// distance (0-1) from light source (0=at light source)\n\t\t\tx: 0, y: 0, z: 0,\t// screen position (-1 => 1) z = 0 is in front z = 1 is back\n\t\t\tscale: 1, \t\t// scale\n\t\t\trotation: 0, \t\t// rotation\n\t\t\topacity: opacity,\t// opacity\n\t\t\tcolor: color,\t\t// color\n\t\t\tblending: blending\t// blending\n\t\t} );\n\n\t},\n\n\t/*\n\t * Update lens flares update positions on all flares based on the screen position\n\t * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.\n\t */\n\n\tupdateLensFlares: function () {\n\n\t\tvar f, fl = this.lensFlares.length;\n\t\tvar flare;\n\t\tvar vecX = - this.positionScreen.x * 2;\n\t\tvar vecY = - this.positionScreen.y * 2;\n\n\t\tfor ( f = 0; f < fl; f ++ ) {\n\n\t\t\tflare = this.lensFlares[ f ];\n\n\t\t\tflare.x = this.positionScreen.x + vecX * flare.distance;\n\t\t\tflare.y = this.positionScreen.y + vecY * flare.distance;\n\n\t\t\tflare.wantedRotation = flare.x * Math.PI * 0.25;\n\t\t\tflare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;\n\n\t\t}\n\n\t}\n\n} );\n\n// File:src/scenes/Scene.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Scene = function () {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Scene';\n\n\tthis.background = null;\n\tthis.fog = null;\n\tthis.overrideMaterial = null;\n\n\tthis.autoUpdate = true; // checked by the renderer\n\n};\n\nTHREE.Scene.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.Scene.prototype.constructor = THREE.Scene;\n\nTHREE.Scene.prototype.copy = function ( source, recursive ) {\n\n\tTHREE.Object3D.prototype.copy.call( this, source, recursive );\n\n\tif ( source.background !== null ) this.background = source.background.clone();\n\tif ( source.fog !== null ) this.fog = source.fog.clone();\n\tif ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();\n\n\tthis.autoUpdate = source.autoUpdate;\n\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\n\treturn this;\n\n};\n\n// File:src/scenes/Fog.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Fog = function ( color, near, far ) {\n\n\tthis.name = '';\n\n\tthis.color = new THREE.Color( color );\n\n\tthis.near = ( near !== undefined ) ? near : 1;\n\tthis.far = ( far !== undefined ) ? far : 1000;\n\n};\n\nTHREE.Fog.prototype.clone = function () {\n\n\treturn new THREE.Fog( this.color.getHex(), this.near, this.far );\n\n};\n\n// File:src/scenes/FogExp2.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.FogExp2 = function ( color, density ) {\n\n\tthis.name = '';\n\n\tthis.color = new THREE.Color( color );\n\tthis.density = ( density !== undefined ) ? density : 0.00025;\n\n};\n\nTHREE.FogExp2.prototype.clone = function () {\n\n\treturn new THREE.FogExp2( this.color.getHex(), this.density );\n\n};\n\n// File:src/renderers/shaders/ShaderChunk.js\n\nTHREE.ShaderChunk = {};\n\n// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl\n\nTHREE.ShaderChunk[ 'alphamap_fragment' ] = \"#ifdef USE_ALPHAMAP\\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'alphamap_pars_fragment' ] = \"#ifdef USE_ALPHAMAP\\n\tuniform sampler2D alphaMap;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl\n\nTHREE.ShaderChunk[ 'alphatest_fragment' ] = \"#ifdef ALPHATEST\\n\tif ( diffuseColor.a < ALPHATEST ) discard;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/aomap_fragment.glsl\n\nTHREE.ShaderChunk[ 'aomap_fragment' ] = \"#ifdef USE_AOMAP\\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'aomap_pars_fragment' ] = \"#ifdef USE_AOMAP\\n\tuniform sampler2D aoMap;\\n\tuniform float aoMapIntensity;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/begin_vertex.glsl\n\nTHREE.ShaderChunk[ 'begin_vertex' ] = \"\\nvec3 transformed = vec3( position );\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/beginnormal_vertex.glsl\n\nTHREE.ShaderChunk[ 'beginnormal_vertex' ] = \"\\nvec3 objectNormal = vec3( normal );\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/bsdfs.glsl\n\nTHREE.ShaderChunk[ 'bsdfs' ] = \"bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\\n\treturn any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\\n}\\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n\t\tif( decayExponent > 0.0 ) {\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\t\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\t\t\treturn distanceFalloff * maxDistanceCutoffFactor;\\n#else\\n\t\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n#endif\\n\t\t}\\n\t\treturn 1.0;\\n}\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\n}\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\treturn 1.0 / ( gl * gv );\\n}\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\tfloat alpha = pow2( roughness );\\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\tvec3 F = F_Schlick( specularColor, dotLH );\\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\tfloat D = D_GGX( alpha, dotNH );\\n\treturn F * ( G * D );\\n}\\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\tvec4 r = roughness * c0 + c1;\\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\\n\treturn specularColor * AB.x + AB.y;\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\tvec3 F = F_Schlick( specularColor, dotLH );\\n\tfloat G = G_BlinnPhong_Implicit( );\\n\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\treturn F * ( G * D );\\n}\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\n}\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'bumpmap_pars_fragment' ] = \"#ifdef USE_BUMPMAP\\n\tuniform sampler2D bumpMap;\\n\tuniform float bumpScale;\\n\tvec2 dHdxy_fwd() {\\n\t\tvec2 dSTdx = dFdx( vUv );\\n\t\tvec2 dSTdy = dFdy( vUv );\\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\t\treturn vec2( dBx, dBy );\\n\t}\\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n\t\tvec3 vSigmaX = dFdx( surf_pos );\\n\t\tvec3 vSigmaY = dFdy( surf_pos );\\n\t\tvec3 vN = surf_norm;\\n\t\tvec3 R1 = cross( vSigmaY, vN );\\n\t\tvec3 R2 = cross( vN, vSigmaX );\\n\t\tfloat fDet = dot( vSigmaX, R1 );\\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\t}\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/clipping_planes_fragment.glsl\n\nTHREE.ShaderChunk[ 'clipping_planes_fragment' ] = \"#if NUM_CLIPPING_PLANES > 0\\n\tfor ( int i = 0; i < NUM_CLIPPING_PLANES; ++ i ) {\\n\t\tvec4 plane = clippingPlanes[ i ];\\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\\n\t}\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/clipping_planes_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'clipping_planes_pars_fragment' ] = \"#if NUM_CLIPPING_PLANES > 0\\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\\n\t\tvarying vec3 vViewPosition;\\n\t#endif\\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/clipping_planes_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'clipping_planes_pars_vertex' ] = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\tvarying vec3 vViewPosition;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/clipping_planes_vertex.glsl\n\nTHREE.ShaderChunk[ 'clipping_planes_vertex' ] = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\tvViewPosition = - mvPosition.xyz;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl\n\nTHREE.ShaderChunk[ 'color_fragment' ] = \"#ifdef USE_COLOR\\n\tdiffuseColor.rgb *= vColor;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'color_pars_fragment' ] = \"#ifdef USE_COLOR\\n\tvarying vec3 vColor;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'color_pars_vertex' ] = \"#ifdef USE_COLOR\\n\tvarying vec3 vColor;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl\n\nTHREE.ShaderChunk[ 'color_vertex' ] = \"#ifdef USE_COLOR\\n\tvColor.xyz = color.xyz;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/common.glsl\n\nTHREE.ShaderChunk[ 'common' ] = \"#define PI 3.14159265359\\n#define PI2 6.28318530718\\n#define RECIPROCAL_PI 0.31830988618\\n#define RECIPROCAL_PI2 0.15915494\\n#define LOG2 1.442695\\n#define EPSILON 1e-6\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\treturn fract(sin(sn) * c);\\n}\\nstruct IncidentLight {\\n\tvec3 color;\\n\tvec3 direction;\\n\tbool visible;\\n};\\nstruct ReflectedLight {\\n\tvec3 directDiffuse;\\n\tvec3 directSpecular;\\n\tvec3 indirectDiffuse;\\n\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\tvec3 position;\\n\tvec3 normal;\\n\tvec3 viewDir;\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\\n\treturn - distance * planeNormal + point;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/cube_uv_reflection_fragment.glsl\n\nTHREE.ShaderChunk[ 'cube_uv_reflection_fragment' ] = \"#ifdef ENVMAP_TYPE_CUBE_UV\\n#define cubeUV_textureSize (1024.0)\\nint getFaceFromDirection(vec3 direction) {\\n\tvec3 absDirection = abs(direction);\\n\tint face = -1;\\n\tif( absDirection.x > absDirection.z ) {\\n\t\tif(absDirection.x > absDirection.y )\\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\\n\t\telse\\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\\n\t}\\n\telse {\\n\t\tif(absDirection.z > absDirection.y )\\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\\n\t\telse\\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\\n\t}\\n\treturn face;\\n}\\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\\n\tfloat dxRoughness = dFdx(roughness);\\n\tfloat dyRoughness = dFdy(roughness);\\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\\n\tfloat mipLevel = 0.5 * log2(d);\\n\treturn vec2(floor(mipLevel), fract(mipLevel));\\n}\\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\\n\tbool bRes = mipLevel == 0.0;\\n\tscale =  bRes && (scale < a) ? a : scale;\\n\tvec3 r;\\n\tvec2 offset;\\n\tint face = getFaceFromDirection(direction);\\n\tfloat rcpPowScale = 1.0 / powScale;\\n\tif( face == 0) {\\n\t\tr = vec3(direction.x, -direction.z, direction.y);\\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\t}\\n\telse if( face == 1) {\\n\t\tr = vec3(direction.y, direction.x, direction.z);\\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\t}\\n\telse if( face == 2) {\\n\t\tr = vec3(direction.z, direction.x, direction.y);\\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\t}\\n\telse if( face == 3) {\\n\t\tr = vec3(direction.x, direction.z, direction.y);\\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\t}\\n\telse if( face == 4) {\\n\t\tr = vec3(direction.y, direction.x, -direction.z);\\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\t}\\n\telse {\\n\t\tr = vec3(direction.z, -direction.x, direction.y);\\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\t}\\n\tr = normalize(r);\\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\\n\tvec2 base = offset + vec2( texelOffset );\\n\treturn base + s * ( scale - 2.0 * texelOffset );\\n}\\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\\n\tfloat r1 = floor(roughnessVal);\\n\tfloat r2 = r1 + 1.0;\\n\tfloat t = fract(roughnessVal);\\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\\n\tfloat s = mipInfo.y;\\n\tfloat level0 = mipInfo.x;\\n\tfloat level1 = level0 + 1.0;\\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\\n\tvec4 result = mix(color10, color20, t);\\n\treturn vec4(result.rgb, 1.0);\\n}\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl\n\nTHREE.ShaderChunk[ 'defaultnormal_vertex' ] = \"#ifdef FLIP_SIDED\\n\tobjectNormal = -objectNormal;\\n#endif\\nvec3 transformedNormal = normalMatrix * objectNormal;\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/displacementmap_vertex.glsl\n\nTHREE.ShaderChunk[ 'displacementmap_vertex' ] = \"#ifdef USE_DISPLACEMENTMAP\\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/displacementmap_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'displacementmap_pars_vertex' ] = \"#ifdef USE_DISPLACEMENTMAP\\n\tuniform sampler2D displacementMap;\\n\tuniform float displacementScale;\\n\tuniform float displacementBias;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/emissivemap_fragment.glsl\n\nTHREE.ShaderChunk[ 'emissivemap_fragment' ] = \"#ifdef USE_EMISSIVEMAP\\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/emissivemap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'emissivemap_pars_fragment' ] = \"#ifdef USE_EMISSIVEMAP\\n\tuniform sampler2D emissiveMap;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/encodings_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'encodings_pars_fragment' ] = \"\\nvec4 LinearToLinear( in vec4 value ) {\\n  return value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n  float maxComponent = max( max( value.r, value.g ), value.b );\\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n  float maxRGB = max( value.x, max( value.g, value.b ) );\\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n  M            = ceil( M * 255.0 ) / 255.0;\\n  return vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n    float maxRGB = max( value.x, max( value.g, value.b ) );\\n    float D      = max( maxRange / maxRGB, 1.0 );\\n    D            = min( floor( D ) / 255.0, 1.0 );\\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value )  {\\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\\n  vec4 vResult;\\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n  vResult.w = fract(Le);\\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\\n  return vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n  float Le = value.z * 255.0 + value.w;\\n  vec3 Xp_Y_XYZp;\\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\\n  return vec4( max(vRGB, 0.0), 1.0 );\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/encodings_fragment.glsl\n\nTHREE.ShaderChunk[ 'encodings_fragment' ] = \"  gl_FragColor = linearToOutputTexel( gl_FragColor );\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl\n\nTHREE.ShaderChunk[ 'envmap_fragment' ] = \"#ifdef USE_ENVMAP\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\n\t\t#else\\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\n\t\t#endif\\n\t#else\\n\t\tvec3 reflectVec = vReflect;\\n\t#endif\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\t\tvec2 sampleUV;\\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\\n\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\n\t#endif\\n\tenvColor = envMapTexelToLinear( envColor );\\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\t#elif defined( ENVMAP_BLENDING_MIX )\\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\t#elif defined( ENVMAP_BLENDING_ADD )\\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'envmap_pars_fragment' ] = \"#if defined( USE_ENVMAP ) || defined( PHYSICAL )\\n\tuniform float reflectivity;\\n\tuniform float envMapIntenstiy;\\n#endif\\n#ifdef USE_ENVMAP\\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\\n\t\tvarying vec3 vWorldPosition;\\n\t#endif\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tuniform samplerCube envMap;\\n\t#else\\n\t\tuniform sampler2D envMap;\\n\t#endif\\n\tuniform float flipEnvMap;\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\\n\t\tuniform float refractionRatio;\\n\t#else\\n\t\tvarying vec3 vReflect;\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'envmap_pars_vertex' ] = \"#ifdef USE_ENVMAP\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\t\tvarying vec3 vWorldPosition;\\n\t#else\\n\t\tvarying vec3 vReflect;\\n\t\tuniform float refractionRatio;\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl\n\nTHREE.ShaderChunk[ 'envmap_vertex' ] = \"#ifdef USE_ENVMAP\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\t\tvWorldPosition = worldPosition.xyz;\\n\t#else\\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\\n\t\t#else\\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\t\t#endif\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl\n\nTHREE.ShaderChunk[ 'fog_fragment' ] = \"#ifdef USE_FOG\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\\n\t#else\\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\n\t#endif\\n\t#ifdef FOG_EXP2\\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\\n\t#else\\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\\n\t#endif\\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'fog_pars_fragment' ] = \"#ifdef USE_FOG\\n\tuniform vec3 fogColor;\\n\t#ifdef FOG_EXP2\\n\t\tuniform float fogDensity;\\n\t#else\\n\t\tuniform float fogNear;\\n\t\tuniform float fogFar;\\n\t#endif\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl\n\nTHREE.ShaderChunk[ 'lightmap_fragment' ] = \"#ifdef USE_LIGHTMAP\\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'lightmap_pars_fragment' ] = \"#ifdef USE_LIGHTMAP\\n\tuniform sampler2D lightMap;\\n\tuniform float lightMapIntensity;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl\n\nTHREE.ShaderChunk[ 'lights_lambert_vertex' ] = \"vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n\tvLightBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\n#if NUM_POINT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\\n\t\tdotNL = dot( geometry.normal, directLight.direction );\\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\t\t#endif\\n\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\\n\t\tdotNL = dot( geometry.normal, directLight.direction );\\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\t\t#endif\\n\t}\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\\n\t\tdotNL = dot( geometry.normal, directLight.direction );\\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\t\t#endif\\n\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\n\t\t#endif\\n\t}\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/lights_pars.glsl\n\nTHREE.ShaderChunk[ 'lights_pars' ] = \"uniform vec3 ambientLightColor;\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\tvec3 irradiance = ambientLightColor;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\treturn irradiance;\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\tstruct DirectionalLight {\\n\t\tvec3 direction;\\n\t\tvec3 color;\\n\t\tint shadow;\\n\t\tfloat shadowBias;\\n\t\tfloat shadowRadius;\\n\t\tvec2 shadowMapSize;\\n\t};\\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\t\tdirectLight.color = directionalLight.color;\\n\t\tdirectLight.direction = directionalLight.direction;\\n\t\tdirectLight.visible = true;\\n\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\tstruct PointLight {\\n\t\tvec3 position;\\n\t\tvec3 color;\\n\t\tfloat distance;\\n\t\tfloat decay;\\n\t\tint shadow;\\n\t\tfloat shadowBias;\\n\t\tfloat shadowRadius;\\n\t\tvec2 shadowMapSize;\\n\t};\\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\t\tvec3 lVector = pointLight.position - geometry.position;\\n\t\tdirectLight.direction = normalize( lVector );\\n\t\tfloat lightDistance = length( lVector );\\n\t\tif ( testLightInRange( lightDistance, pointLight.distance ) ) {\\n\t\t\tdirectLight.color = pointLight.color;\\n\t\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\n\t\t\tdirectLight.visible = true;\\n\t\t} else {\\n\t\t\tdirectLight.color = vec3( 0.0 );\\n\t\t\tdirectLight.visible = false;\\n\t\t}\\n\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\tstruct SpotLight {\\n\t\tvec3 position;\\n\t\tvec3 direction;\\n\t\tvec3 color;\\n\t\tfloat distance;\\n\t\tfloat decay;\\n\t\tfloat coneCos;\\n\t\tfloat penumbraCos;\\n\t\tint shadow;\\n\t\tfloat shadowBias;\\n\t\tfloat shadowRadius;\\n\t\tvec2 shadowMapSize;\\n\t};\\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\\n\t\tvec3 lVector = spotLight.position - geometry.position;\\n\t\tdirectLight.direction = normalize( lVector );\\n\t\tfloat lightDistance = length( lVector );\\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\n\t\tif ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\t\t\tdirectLight.color = spotLight.color;\\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\n\t\t\tdirectLight.visible = true;\\n\t\t} else {\\n\t\t\tdirectLight.color = vec3( 0.0 );\\n\t\t\tdirectLight.visible = false;\\n\t\t}\\n\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\tstruct HemisphereLight {\\n\t\tvec3 direction;\\n\t\tvec3 skyColor;\\n\t\tvec3 groundColor;\\n\t};\\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\t\tirradiance *= PI;\\n\t\t#endif\\n\t\treturn irradiance;\\n\t}\\n#endif\\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\n\t\t#include <normal_flip>\\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\t\t#ifdef ENVMAP_TYPE_CUBE\\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\\n\t\t#else\\n\t\t\tvec4 envMapColor = vec4( 0.0 );\\n\t\t#endif\\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\\n\t}\\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\n\t}\\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\\n\t\t#else\\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\\n\t\t#endif\\n\t\t#include <normal_flip>\\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\\n\t\t#ifdef ENVMAP_TYPE_CUBE\\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\t\t\tvec2 sampleUV;\\n\t\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\t\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\t\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#endif\\n\t\treturn envMapColor.rgb * envMapIntensity;\\n\t}\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl\n\nTHREE.ShaderChunk[ 'lights_phong_fragment' ] = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'lights_phong_pars_fragment' ] = \"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\nstruct BlinnPhongMaterial {\\n\tvec3\tdiffuseColor;\\n\tvec3\tspecularColor;\\n\tfloat\tspecularShininess;\\n\tfloat\tspecularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\tvec3 irradiance = dotNL * directLight.color;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\t(0)\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/lights_physical_fragment.glsl\n\nTHREE.ShaderChunk[ 'lights_physical_fragment' ] = \"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\\n#ifdef STANDARD\\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\\n#else\\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/lights_physical_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'lights_physical_pars_fragment' ] = \"struct PhysicalMaterial {\\n\tvec3\tdiffuseColor;\\n\tfloat\tspecularRoughness;\\n\tvec3\tspecularColor;\\n\t#ifndef STANDARD\\n\t\tfloat clearCoat;\\n\t\tfloat clearCoatRoughness;\\n\t#endif\\n};\\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\tvec3 irradiance = dotNL * directLight.color;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\t#ifndef STANDARD\\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\t#endif\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectSpecular += radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\\n\t#ifndef STANDARD\\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\t#endif\\n}\\n#define RE_Direct\t\t\t\tRE_Direct_Physical\\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/lights_template.glsl\n\nTHREE.ShaderChunk[ 'lights_template' ] = \"\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = normalize( vViewPosition );\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\tPointLight pointLight;\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tpointLight = pointLights[ i ];\\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\t\t#ifdef USE_SHADOWMAP\\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\t}\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\tSpotLight spotLight;\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tspotLight = spotLights[ i ];\\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\t\t#ifdef USE_SHADOWMAP\\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\t}\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\tDirectionalLight directionalLight;\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tdirectionalLight = directionalLights[ i ];\\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\t\t#ifdef USE_SHADOWMAP\\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\t}\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\t#ifdef USE_LIGHTMAP\\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\t\tlightMapIrradiance *= PI;\\n\t\t#endif\\n\t\tirradiance += lightMapIrradiance;\\n\t#endif\\n\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\t\t}\\n\t#endif\\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\t \tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\\n\t#endif\\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\\n\t#ifndef STANDARD\\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\\n\t#else\\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\\n\t#endif\\n\t\t\\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl\n\nTHREE.ShaderChunk[ 'logdepthbuf_fragment' ] = \"#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'logdepthbuf_pars_fragment' ] = \"#ifdef USE_LOGDEPTHBUF\\n\tuniform float logDepthBufFC;\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tvarying float vFragDepth;\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'logdepthbuf_pars_vertex' ] = \"#ifdef USE_LOGDEPTHBUF\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tvarying float vFragDepth;\\n\t#endif\\n\tuniform float logDepthBufFC;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl\n\nTHREE.ShaderChunk[ 'logdepthbuf_vertex' ] = \"#ifdef USE_LOGDEPTHBUF\\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tvFragDepth = 1.0 + gl_Position.w;\\n\t#else\\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl\n\nTHREE.ShaderChunk[ 'map_fragment' ] = \"#ifdef USE_MAP\\n\tvec4 texelColor = texture2D( map, vUv );\\n\ttexelColor = mapTexelToLinear( texelColor );\\n\tdiffuseColor *= texelColor;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'map_pars_fragment' ] = \"#ifdef USE_MAP\\n\tuniform sampler2D map;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl\n\nTHREE.ShaderChunk[ 'map_particle_fragment' ] = \"#ifdef USE_MAP\\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'map_particle_pars_fragment' ] = \"#ifdef USE_MAP\\n\tuniform vec4 offsetRepeat;\\n\tuniform sampler2D map;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/metalnessmap_fragment.glsl\n\nTHREE.ShaderChunk[ 'metalnessmap_fragment' ] = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\tmetalnessFactor *= texelMetalness.r;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/metalnessmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'metalnessmap_pars_fragment' ] = \"#ifdef USE_METALNESSMAP\\n\tuniform sampler2D metalnessMap;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl\n\nTHREE.ShaderChunk[ 'morphnormal_vertex' ] = \"#ifdef USE_MORPHNORMALS\\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'morphtarget_pars_vertex' ] = \"#ifdef USE_MORPHTARGETS\\n\t#ifndef USE_MORPHNORMALS\\n\tuniform float morphTargetInfluences[ 8 ];\\n\t#else\\n\tuniform float morphTargetInfluences[ 4 ];\\n\t#endif\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl\n\nTHREE.ShaderChunk[ 'morphtarget_vertex' ] = \"#ifdef USE_MORPHTARGETS\\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n\t#ifndef USE_MORPHNORMALS\\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/normal_flip.glsl\n\nTHREE.ShaderChunk[ 'normal_flip' ] = \"#ifdef DOUBLE_SIDED\\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n#else\\n\tfloat flipNormal = 1.0;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/normal_fragment.glsl\n\nTHREE.ShaderChunk[ 'normal_fragment' ] = \"#ifdef FLAT_SHADED\\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\n\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\tvec3 normal = normalize( vNormal ) * flipNormal;\\n#endif\\n#ifdef USE_NORMALMAP\\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\n#elif defined( USE_BUMPMAP )\\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'normalmap_pars_fragment' ] = \"#ifdef USE_NORMALMAP\\n\tuniform sampler2D normalMap;\\n\tuniform vec2 normalScale;\\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\\n\t\tvec2 st0 = dFdx( vUv.st );\\n\t\tvec2 st1 = dFdy( vUv.st );\\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\n\t\tvec3 N = normalize( surf_norm );\\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\t\tmapN.xy = normalScale * mapN.xy;\\n\t\tmat3 tsn = mat3( S, T, N );\\n\t\treturn normalize( tsn * mapN );\\n\t}\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/packing.glsl\n\nTHREE.ShaderChunk[ 'packing' ] = \"vec3 packNormalToRGB( const in vec3 normal ) {\\n  return normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n  return 1.0 - 2.0 * rgb.xyz;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\treturn dot( v, UnpackFactors );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n  return ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\n  return linearClipZ * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/premultiplied_alpha_fragment.glsl\n\nTHREE.ShaderChunk[ 'premultiplied_alpha_fragment' ] = \"#ifdef PREMULTIPLIED_ALPHA\\n\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/project_vertex.glsl\n\nTHREE.ShaderChunk[ 'project_vertex' ] = \"#ifdef USE_SKINNING\\n\tvec4 mvPosition = modelViewMatrix * skinned;\\n#else\\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\n#endif\\ngl_Position = projectionMatrix * mvPosition;\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/roughnessmap_fragment.glsl\n\nTHREE.ShaderChunk[ 'roughnessmap_fragment' ] = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\troughnessFactor *= texelRoughness.r;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/roughnessmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'roughnessmap_pars_fragment' ] = \"#ifdef USE_ROUGHNESSMAP\\n\tuniform sampler2D roughnessMap;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'shadowmap_pars_fragment' ] = \"#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\t#endif\\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\t}\\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\\n\t\tvec2 f = fract( uv * size + 0.5 );\\n\t\tfloat a = mix( lb, lt, f.y );\\n\t\tfloat b = mix( rb, rt, f.y );\\n\t\tfloat c = mix( a, b, f.x );\\n\t\treturn c;\\n\t}\\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\t\tshadowCoord.xyz /= shadowCoord.w;\\n\t\tshadowCoord.z += shadowBias;\\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\t\tbool inFrustum = all( inFrustumVec );\\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\t\tbool frustumTest = all( frustumTestVec );\\n\t\tif ( frustumTest ) {\\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\\n\t\t\treturn (\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\t\t\t) * ( 1.0 / 9.0 );\\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\\n\t\t\treturn (\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\t\t\t) * ( 1.0 / 9.0 );\\n\t\t#else\\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\t\t#endif\\n\t\t}\\n\t\treturn 1.0;\\n\t}\\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\t\tvec3 absV = abs( v );\\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\t\tabsV *= scaleToCube;\\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\t\tvec2 planar = v.xy;\\n\t\tfloat almostATexel = 1.5 * texelSizeY;\\n\t\tfloat almostOne = 1.0 - almostATexel;\\n\t\tif ( absV.z >= almostOne ) {\\n\t\t\tif ( v.z > 0.0 )\\n\t\t\t\tplanar.x = 4.0 - v.x;\\n\t\t} else if ( absV.x >= almostOne ) {\\n\t\t\tfloat signX = sign( v.x );\\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\\n\t\t} else if ( absV.y >= almostOne ) {\\n\t\t\tfloat signY = sign( v.y );\\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\t\t\tplanar.y = v.z * signY - 2.0;\\n\t\t}\\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\t}\\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\t\tvec3 lightToPosition = shadowCoord.xyz;\\n\t\tvec3 bd3D = normalize( lightToPosition );\\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\t\t\treturn (\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\t\t\t) * ( 1.0 / 9.0 );\\n\t\t#else\\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\t\t#endif\\n\t}\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'shadowmap_pars_vertex' ] = \"#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl\n\nTHREE.ShaderChunk[ 'shadowmap_vertex' ] = \"#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\\n\t}\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\\n\t}\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\\n\t}\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/shadowmask_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'shadowmask_pars_fragment' ] = \"float getShadowMask() {\\n\tfloat shadow = 1.0;\\n\t#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\tDirectionalLight directionalLight;\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tdirectionalLight = directionalLights[ i ];\\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\t}\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\tSpotLight spotLight;\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tspotLight = spotLights[ i ];\\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\t}\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\tPointLight pointLight;\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tpointLight = pointLights[ i ];\\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\t}\\n\t#endif\\n\t#endif\\n\treturn shadow;\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl\n\nTHREE.ShaderChunk[ 'skinbase_vertex' ] = \"#ifdef USE_SKINNING\\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'skinning_pars_vertex' ] = \"#ifdef USE_SKINNING\\n\tuniform mat4 bindMatrix;\\n\tuniform mat4 bindMatrixInverse;\\n\t#ifdef BONE_TEXTURE\\n\t\tuniform sampler2D boneTexture;\\n\t\tuniform int boneTextureWidth;\\n\t\tuniform int boneTextureHeight;\\n\t\tmat4 getBoneMatrix( const in float i ) {\\n\t\t\tfloat j = i * 4.0;\\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\\n\t\t\ty = dy * ( y + 0.5 );\\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\t\t\treturn bone;\\n\t\t}\\n\t#else\\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\\n\t\tmat4 getBoneMatrix( const in float i ) {\\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\\n\t\t\treturn bone;\\n\t\t}\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl\n\nTHREE.ShaderChunk[ 'skinning_vertex' ] = \"#ifdef USE_SKINNING\\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\tvec4 skinned = vec4( 0.0 );\\n\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\tskinned  = bindMatrixInverse * skinned;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl\n\nTHREE.ShaderChunk[ 'skinnormal_vertex' ] = \"#ifdef USE_SKINNING\\n\tmat4 skinMatrix = mat4( 0.0 );\\n\tskinMatrix += skinWeight.x * boneMatX;\\n\tskinMatrix += skinWeight.y * boneMatY;\\n\tskinMatrix += skinWeight.z * boneMatZ;\\n\tskinMatrix += skinWeight.w * boneMatW;\\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl\n\nTHREE.ShaderChunk[ 'specularmap_fragment' ] = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\tspecularStrength = texelSpecular.r;\\n#else\\n\tspecularStrength = 1.0;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'specularmap_pars_fragment' ] = \"#ifdef USE_SPECULARMAP\\n\tuniform sampler2D specularMap;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/tonemapping_fragment.glsl\n\nTHREE.ShaderChunk[ 'tonemapping_fragment' ] = \"#if defined( TONE_MAPPING )\\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/tonemapping_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'tonemapping_pars_fragment' ] = \"#define saturate(a) clamp( a, 0.0, 1.0 )\\nuniform float toneMappingExposure;\\nuniform float toneMappingWhitePoint;\\nvec3 LinearToneMapping( vec3 color ) {\\n  return toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  return saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\\nvec3 Uncharted2ToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  color = max( vec3( 0.0 ), color - 0.004 );\\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'uv2_pars_fragment' ] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\tvarying vec2 vUv2;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'uv2_pars_vertex' ] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\tattribute vec2 uv2;\\n\tvarying vec2 vUv2;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/uv2_vertex.glsl\n\nTHREE.ShaderChunk[ 'uv2_vertex' ] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\tvUv2 = uv2;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'uv_pars_fragment' ] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\tvarying vec2 vUv;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'uv_pars_vertex' ] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\tvarying vec2 vUv;\\n\tuniform vec4 offsetRepeat;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/uv_vertex.glsl\n\nTHREE.ShaderChunk[ 'uv_vertex' ] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl\n\nTHREE.ShaderChunk[ 'worldpos_vertex' ] = \"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\\n\t#ifdef USE_SKINNING\\n\t\tvec4 worldPosition = modelMatrix * skinned;\\n\t#else\\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/UniformsUtils.js\n\n/**\n * Uniform Utilities\n */\n\nTHREE.UniformsUtils = {\n\n\tmerge: function ( uniforms ) {\n\n\t\tvar merged = {};\n\n\t\tfor ( var u = 0; u < uniforms.length; u ++ ) {\n\n\t\t\tvar tmp = this.clone( uniforms[ u ] );\n\n\t\t\tfor ( var p in tmp ) {\n\n\t\t\t\tmerged[ p ] = tmp[ p ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn merged;\n\n\t},\n\n\tclone: function ( uniforms_src ) {\n\n\t\tvar uniforms_dst = {};\n\n\t\tfor ( var u in uniforms_src ) {\n\n\t\t\tuniforms_dst[ u ] = {};\n\n\t\t\tfor ( var p in uniforms_src[ u ] ) {\n\n\t\t\t\tvar parameter_src = uniforms_src[ u ][ p ];\n\n\t\t\t\tif ( parameter_src instanceof THREE.Color ||\n\t\t\t\t\t parameter_src instanceof THREE.Vector2 ||\n\t\t\t\t\t parameter_src instanceof THREE.Vector3 ||\n\t\t\t\t\t parameter_src instanceof THREE.Vector4 ||\n\t\t\t\t\t parameter_src instanceof THREE.Matrix3 ||\n\t\t\t\t\t parameter_src instanceof THREE.Matrix4 ||\n\t\t\t\t\t parameter_src instanceof THREE.Texture ) {\n\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.clone();\n\n\t\t\t\t} else if ( Array.isArray( parameter_src ) ) {\n\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.slice();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn uniforms_dst;\n\n\t}\n\n};\n\n// File:src/renderers/shaders/UniformsLib.js\n\n/**\n * Uniforms library for shared webgl shaders\n */\n\nTHREE.UniformsLib = {\n\n\tcommon: {\n\n\t\t\"diffuse\": { value: new THREE.Color( 0xeeeeee ) },\n\t\t\"opacity\": { value: 1.0 },\n\n\t\t\"map\": { value: null },\n\t\t\"offsetRepeat\": { value: new THREE.Vector4( 0, 0, 1, 1 ) },\n\n\t\t\"specularMap\": { value: null },\n\t\t\"alphaMap\": { value: null },\n\n\t\t\"envMap\": { value: null },\n\t\t\"flipEnvMap\": { value: - 1 },\n\t\t\"reflectivity\": { value: 1.0 },\n\t\t\"refractionRatio\": { value: 0.98 }\n\n\t},\n\n\taomap: {\n\n\t\t\"aoMap\": { value: null },\n\t\t\"aoMapIntensity\": { value: 1 }\n\n\t},\n\n\tlightmap: {\n\n\t\t\"lightMap\": { value: null },\n\t\t\"lightMapIntensity\": { value: 1 }\n\n\t},\n\n\temissivemap: {\n\n\t\t\"emissiveMap\": { value: null }\n\n\t},\n\n\tbumpmap: {\n\n\t\t\"bumpMap\": { value: null },\n\t\t\"bumpScale\": { value: 1 }\n\n\t},\n\n\tnormalmap: {\n\n\t\t\"normalMap\": { value: null },\n\t\t\"normalScale\": { value: new THREE.Vector2( 1, 1 ) }\n\n\t},\n\n\tdisplacementmap: {\n\n\t\t\"displacementMap\": { value: null },\n\t\t\"displacementScale\": { value: 1 },\n\t\t\"displacementBias\": { value: 0 }\n\n\t},\n\n\troughnessmap: {\n\n\t\t\"roughnessMap\": { value: null }\n\n\t},\n\n\tmetalnessmap: {\n\n\t\t\"metalnessMap\": { value: null }\n\n\t},\n\n\tfog: {\n\n\t\t\"fogDensity\": { value: 0.00025 },\n\t\t\"fogNear\": { value: 1 },\n\t\t\"fogFar\": { value: 2000 },\n\t\t\"fogColor\": { value: new THREE.Color( 0xffffff ) }\n\n\t},\n\n\tlights: {\n\n\t\t\"ambientLightColor\": { value: [] },\n\n\t\t\"directionalLights\": { value: [], properties: {\n\t\t\t\"direction\": {},\n\t\t\t\"color\": {},\n\n\t\t\t\"shadow\": {},\n\t\t\t\"shadowBias\": {},\n\t\t\t\"shadowRadius\": {},\n\t\t\t\"shadowMapSize\": {}\n\t\t} },\n\n\t\t\"directionalShadowMap\": { value: [] },\n\t\t\"directionalShadowMatrix\": { value: [] },\n\n\t\t\"spotLights\": { value: [], properties: {\n\t\t\t\"color\": {},\n\t\t\t\"position\": {},\n\t\t\t\"direction\": {},\n\t\t\t\"distance\": {},\n\t\t\t\"coneCos\": {},\n\t\t\t\"penumbraCos\": {},\n\t\t\t\"decay\": {},\n\n\t\t\t\"shadow\": {},\n\t\t\t\"shadowBias\": {},\n\t\t\t\"shadowRadius\": {},\n\t\t\t\"shadowMapSize\": {}\n\t\t} },\n\n\t\t\"spotShadowMap\": { value: [] },\n\t\t\"spotShadowMatrix\": { value: [] },\n\n\t\t\"pointLights\": { value: [], properties: {\n\t\t\t\"color\": {},\n\t\t\t\"position\": {},\n\t\t\t\"decay\": {},\n\t\t\t\"distance\": {},\n\n\t\t\t\"shadow\": {},\n\t\t\t\"shadowBias\": {},\n\t\t\t\"shadowRadius\": {},\n\t\t\t\"shadowMapSize\": {}\n\t\t} },\n\n\t\t\"pointShadowMap\": { value: [] },\n\t\t\"pointShadowMatrix\": { value: [] },\n\n\t\t\"hemisphereLights\": { value: [], properties: {\n\t\t\t\"direction\": {},\n\t\t\t\"skyColor\": {},\n\t\t\t\"groundColor\": {}\n\t\t} }\n\n\t},\n\n\tpoints: {\n\n\t\t\"diffuse\": { value: new THREE.Color( 0xeeeeee ) },\n\t\t\"opacity\": { value: 1.0 },\n\t\t\"size\": { value: 1.0 },\n\t\t\"scale\": { value: 1.0 },\n\t\t\"map\": { value: null },\n\t\t\"offsetRepeat\": { value: new THREE.Vector4( 0, 0, 1, 1 ) }\n\n\t}\n\n};\n\n// File:src/renderers/shaders/ShaderLib/cube_frag.glsl\n\nTHREE.ShaderChunk[ 'cube_frag' ] = \"uniform samplerCube tCube;\\nuniform float tFlip;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\\n\t#include <logdepthbuf_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/cube_vert.glsl\n\nTHREE.ShaderChunk[ 'cube_vert' ] = \"varying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\tvWorldPosition = transformDirection( position, modelMatrix );\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/depth_frag.glsl\n\nTHREE.ShaderChunk[ 'depth_frag' ] = \"#if DEPTH_PACKING == 3200\\n\tuniform float opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( 1.0 );\\n\t#if DEPTH_PACKING == 3200\\n\t\tdiffuseColor.a = opacity;\\n\t#endif\\n\t#include <map_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <logdepthbuf_fragment>\\n\t#if DEPTH_PACKING == 3200\\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\\n\t#elif DEPTH_PACKING == 3201\\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\\n\t#endif\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/depth_vert.glsl\n\nTHREE.ShaderChunk[ 'depth_vert' ] = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <begin_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/distanceRGBA_frag.glsl\n\nTHREE.ShaderChunk[ 'distanceRGBA_frag' ] = \"uniform vec3 lightPos;\\nvarying vec4 vWorldPosition;\\n#include <common>\\n#include <packing>\\n#include <clipping_planes_pars_fragment>\\nvoid main () {\\n\t#include <clipping_planes_fragment>\\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/distanceRGBA_vert.glsl\n\nTHREE.ShaderChunk[ 'distanceRGBA_vert' ] = \"varying vec4 vWorldPosition;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <skinbase_vertex>\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvWorldPosition = worldPosition;\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/equirect_frag.glsl\n\nTHREE.ShaderChunk[ 'equirect_frag' ] = \"uniform sampler2D tEquirect;\\nuniform float tFlip;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec3 direction = normalize( vWorldPosition );\\n\tvec2 sampleUV;\\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\\n\t#include <logdepthbuf_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/equirect_vert.glsl\n\nTHREE.ShaderChunk[ 'equirect_vert' ] = \"varying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\tvWorldPosition = transformDirection( position, modelMatrix );\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/linedashed_frag.glsl\n\nTHREE.ShaderChunk[ 'linedashed_frag' ] = \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\t\tdiscard;\\n\t}\\n\tvec3 outgoingLight = vec3( 0.0 );\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <color_fragment>\\n\toutgoingLight = diffuseColor.rgb;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/linedashed_vert.glsl\n\nTHREE.ShaderChunk[ 'linedashed_vert' ] = \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <color_vertex>\\n\tvLineDistance = scale * lineDistance;\\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\tgl_Position = projectionMatrix * mvPosition;\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshbasic_frag.glsl\n\nTHREE.ShaderChunk[ 'meshbasic_frag' ] = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\tReflectedLight reflectedLight;\\n\treflectedLight.directDiffuse = vec3( 0.0 );\\n\treflectedLight.directSpecular = vec3( 0.0 );\\n\treflectedLight.indirectDiffuse = diffuseColor.rgb;\\n\treflectedLight.indirectSpecular = vec3( 0.0 );\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\t#include <normal_flip>\\n\t#include <envmap_fragment>\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshbasic_vert.glsl\n\nTHREE.ShaderChunk[ 'meshbasic_vert' ] = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <skinbase_vertex>\\n\t#ifdef USE_ENVMAP\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n\t#endif\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <envmap_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshlambert_frag.glsl\n\nTHREE.ShaderChunk[ 'meshlambert_frag' ] = \"uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <emissivemap_fragment>\\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\\n\t#include <lightmap_fragment>\\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\n\t#ifdef DOUBLE_SIDED\\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\t#else\\n\t\treflectedLight.directDiffuse = vLightFront;\\n\t#endif\\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\t#include <normal_flip>\\n\t#include <envmap_fragment>\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshlambert_vert.glsl\n\nTHREE.ShaderChunk[ 'meshlambert_vert' ] = \"#define LAMBERT\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <envmap_vertex>\\n\t#include <lights_lambert_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshphong_frag.glsl\n\nTHREE.ShaderChunk[ 'meshphong_frag' ] = \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <normal_flip>\\n\t#include <normal_fragment>\\n\t#include <emissivemap_fragment>\\n\t#include <lights_phong_fragment>\\n\t#include <lights_template>\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\t#include <envmap_fragment>\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshphong_vert.glsl\n\nTHREE.ShaderChunk[ 'meshphong_vert' ] = \"#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\tvNormal = normalize( transformedNormal );\\n#endif\\n\t#include <begin_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvViewPosition = - mvPosition.xyz;\\n\t#include <worldpos_vertex>\\n\t#include <envmap_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshphysical_frag.glsl\n\nTHREE.ShaderChunk[ 'meshphysical_frag' ] = \"#define PHYSICAL\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n#ifndef STANDARD\\n\tuniform float clearCoat;\\n\tuniform float clearCoatRoughness;\\n#endif\\nuniform float envMapIntensity;\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <cube_uv_reflection_fragment>\\n#include <lights_pars>\\n#include <lights_physical_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <roughnessmap_fragment>\\n\t#include <metalnessmap_fragment>\\n\t#include <normal_flip>\\n\t#include <normal_fragment>\\n\t#include <emissivemap_fragment>\\n\t#include <lights_physical_fragment>\\n\t#include <lights_template>\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshphysical_vert.glsl\n\nTHREE.ShaderChunk[ 'meshphysical_vert' ] = \"#define PHYSICAL\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\tvNormal = normalize( transformedNormal );\\n#endif\\n\t#include <begin_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvViewPosition = - mvPosition.xyz;\\n\t#include <worldpos_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/normal_frag.glsl\n\nTHREE.ShaderChunk[ 'normal_frag' ] = \"uniform float opacity;\\nvarying vec3 vNormal;\\n#include <common>\\n#include <packing>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tgl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\\n\t#include <logdepthbuf_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/normal_vert.glsl\n\nTHREE.ShaderChunk[ 'normal_vert' ] = \"varying vec3 vNormal;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\tvNormal = normalize( normalMatrix * normal );\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/points_frag.glsl\n\nTHREE.ShaderChunk[ 'points_frag' ] = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec3 outgoingLight = vec3( 0.0 );\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_particle_fragment>\\n\t#include <color_fragment>\\n\t#include <alphatest_fragment>\\n\toutgoingLight = diffuseColor.rgb;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/points_vert.glsl\n\nTHREE.ShaderChunk[ 'points_vert' ] = \"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <color_vertex>\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\t#ifdef USE_SIZEATTENUATION\\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\\n\t#else\\n\t\tgl_PointSize = size;\\n\t#endif\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/shadow_frag.glsl\n\nTHREE.ShaderChunk[ 'shadow_frag' ] = \"uniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\nvoid main() {\\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/shadow_vert.glsl\n\nTHREE.ShaderChunk[ 'shadow_vert' ] = \"#include <shadowmap_pars_vertex>\\nvoid main() {\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib.js\n\n/**\n * Webgl Shader Library for three.js\n *\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n * @author mikael emtinger / http://gomo.se/\n */\n\n\nTHREE.ShaderLib = {\n\n\t'basic': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\tTHREE.UniformsLib[ 'aomap' ],\n\t\t\tTHREE.UniformsLib[ 'fog' ]\n\n\t\t] ),\n\n\t\tvertexShader: THREE.ShaderChunk[ 'meshbasic_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'meshbasic_frag' ]\n\n\t},\n\n\t'lambert': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\tTHREE.UniformsLib[ 'aomap' ],\n\t\t\tTHREE.UniformsLib[ 'lightmap' ],\n\t\t\tTHREE.UniformsLib[ 'emissivemap' ],\n\t\t\tTHREE.UniformsLib[ 'fog' ],\n\t\t\tTHREE.UniformsLib[ 'lights' ],\n\n\t\t\t{\n\t\t\t\t\"emissive\" : { value: new THREE.Color( 0x000000 ) }\n\t\t\t}\n\n\t\t] ),\n\n\t\tvertexShader: THREE.ShaderChunk[ 'meshlambert_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'meshlambert_frag' ]\n\n\t},\n\n\t'phong': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\tTHREE.UniformsLib[ 'aomap' ],\n\t\t\tTHREE.UniformsLib[ 'lightmap' ],\n\t\t\tTHREE.UniformsLib[ 'emissivemap' ],\n\t\t\tTHREE.UniformsLib[ 'bumpmap' ],\n\t\t\tTHREE.UniformsLib[ 'normalmap' ],\n\t\t\tTHREE.UniformsLib[ 'displacementmap' ],\n\t\t\tTHREE.UniformsLib[ 'fog' ],\n\t\t\tTHREE.UniformsLib[ 'lights' ],\n\n\t\t\t{\n\t\t\t\t\"emissive\" : { value: new THREE.Color( 0x000000 ) },\n\t\t\t\t\"specular\" : { value: new THREE.Color( 0x111111 ) },\n\t\t\t\t\"shininess\": { value: 30 }\n\t\t\t}\n\n\t\t] ),\n\n\t\tvertexShader: THREE.ShaderChunk[ 'meshphong_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'meshphong_frag' ]\n\n\t},\n\n\t'standard': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\tTHREE.UniformsLib[ 'aomap' ],\n\t\t\tTHREE.UniformsLib[ 'lightmap' ],\n\t\t\tTHREE.UniformsLib[ 'emissivemap' ],\n\t\t\tTHREE.UniformsLib[ 'bumpmap' ],\n\t\t\tTHREE.UniformsLib[ 'normalmap' ],\n\t\t\tTHREE.UniformsLib[ 'displacementmap' ],\n\t\t\tTHREE.UniformsLib[ 'roughnessmap' ],\n\t\t\tTHREE.UniformsLib[ 'metalnessmap' ],\n\t\t\tTHREE.UniformsLib[ 'fog' ],\n\t\t\tTHREE.UniformsLib[ 'lights' ],\n\n\t\t\t{\n\t\t\t\t\"emissive\" : { value: new THREE.Color( 0x000000 ) },\n\t\t\t\t\"roughness\": { value: 0.5 },\n\t\t\t\t\"metalness\": { value: 0 },\n\t\t\t\t\"envMapIntensity\" : { value: 1 }, // temporary\n\t\t\t}\n\n\t\t] ),\n\n\t\tvertexShader: THREE.ShaderChunk[ 'meshphysical_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'meshphysical_frag' ]\n\n\t},\n\n\t'points': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ 'points' ],\n\t\t\tTHREE.UniformsLib[ 'fog' ]\n\n\t\t] ),\n\n\t\tvertexShader: THREE.ShaderChunk[ 'points_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'points_frag' ]\n\n\t},\n\n\t'dashed': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\tTHREE.UniformsLib[ 'fog' ],\n\n\t\t\t{\n\t\t\t\t\"scale\"    : { value: 1 },\n\t\t\t\t\"dashSize\" : { value: 1 },\n\t\t\t\t\"totalSize\": { value: 2 }\n\t\t\t}\n\n\t\t] ),\n\n\t\tvertexShader: THREE.ShaderChunk[ 'linedashed_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'linedashed_frag' ]\n\n\t},\n\n\t'depth': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\tTHREE.UniformsLib[ 'displacementmap' ]\n\n\t\t] ),\n\n\t\tvertexShader: THREE.ShaderChunk[ 'depth_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'depth_frag' ]\n\n\t},\n\n\t'normal': {\n\n\t\tuniforms: {\n\n\t\t\t\"opacity\" : { value: 1.0 }\n\n\t\t},\n\n\t\tvertexShader: THREE.ShaderChunk[ 'normal_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'normal_frag' ]\n\n\t},\n\n\t/* -------------------------------------------------------------------------\n\t//\tCube map shader\n\t ------------------------------------------------------------------------- */\n\n\t'cube': {\n\n\t\tuniforms: {\n\t\t\t\"tCube\": { value: null },\n\t\t\t\"tFlip\": { value: - 1 }\n\t\t},\n\n\t\tvertexShader: THREE.ShaderChunk[ 'cube_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'cube_frag' ]\n\n\t},\n\n\t/* -------------------------------------------------------------------------\n\t//\tCube map shader\n\t ------------------------------------------------------------------------- */\n\n\t'equirect': {\n\n\t\tuniforms: {\n\t\t\t\"tEquirect\": { value: null },\n\t\t\t\"tFlip\": { value: - 1 }\n\t\t},\n\n\t\tvertexShader: THREE.ShaderChunk[ 'equirect_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'equirect_frag' ]\n\n\t},\n\n\t'distanceRGBA': {\n\n\t\tuniforms: {\n\n\t\t\t\"lightPos\": { value: new THREE.Vector3() }\n\n\t\t},\n\n\t\tvertexShader: THREE.ShaderChunk[ 'distanceRGBA_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'distanceRGBA_frag' ]\n\n\t}\n\n};\n\nTHREE.ShaderLib[ 'physical' ] = {\n\n\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\tTHREE.ShaderLib[ 'standard' ].uniforms,\n\n\t\t{\n\t\t\t\"clearCoat\": { value: 0 },\n\t\t\t\"clearCoatRoughness\": { value: 0 }\n\t\t}\n\n\t] ),\n\n\tvertexShader: THREE.ShaderChunk[ 'meshphysical_vert' ],\n\tfragmentShader: THREE.ShaderChunk[ 'meshphysical_frag' ]\n\n};\n\n// File:src/renderers/WebGLRenderer.js\n\n/**\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author szimek / https://github.com/szimek/\n * @author tschw\n */\n\nTHREE.WebGLRenderer = function ( parameters ) {\n\n\tconsole.log( 'THREE.WebGLRenderer', THREE.REVISION );\n\n\tparameters = parameters || {};\n\n\tvar _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),\n\t_context = parameters.context !== undefined ? parameters.context : null,\n\n\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\n\t_depth = parameters.depth !== undefined ? parameters.depth : true,\n\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\n\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\n\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\n\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;\n\n\tvar lights = [];\n\n\tvar opaqueObjects = [];\n\tvar opaqueObjectsLastIndex = - 1;\n\tvar transparentObjects = [];\n\tvar transparentObjectsLastIndex = - 1;\n\n\tvar morphInfluences = new Float32Array( 8 );\n\n\tvar sprites = [];\n\tvar lensFlares = [];\n\n\t// public properties\n\n\tthis.domElement = _canvas;\n\tthis.context = null;\n\n\t// clearing\n\n\tthis.autoClear = true;\n\tthis.autoClearColor = true;\n\tthis.autoClearDepth = true;\n\tthis.autoClearStencil = true;\n\n\t// scene graph\n\n\tthis.sortObjects = true;\n\n\t// user-defined clipping\n\n\tthis.clippingPlanes = [];\n\tthis.localClippingEnabled = false;\n\n\t// physically based shading\n\n\tthis.gammaFactor = 2.0;\t// for backwards compatibility\n\tthis.gammaInput = false;\n\tthis.gammaOutput = false;\n\n\t// physical lights\n\n\tthis.physicallyCorrectLights = false;\n\n\t// tone mapping\n\n\tthis.toneMapping = THREE.LinearToneMapping;\n\tthis.toneMappingExposure = 1.0;\n\tthis.toneMappingWhitePoint = 1.0;\n\n\t// morphs\n\n\tthis.maxMorphTargets = 8;\n\tthis.maxMorphNormals = 4;\n\n\t// internal properties\n\n\tvar _this = this,\n\n\t// internal state cache\n\n\t_currentProgram = null,\n\t_currentRenderTarget = null,\n\t_currentFramebuffer = null,\n\t_currentMaterialId = - 1,\n\t_currentGeometryProgram = '',\n\t_currentCamera = null,\n\n\t_currentScissor = new THREE.Vector4(),\n\t_currentScissorTest = null,\n\n\t_currentViewport = new THREE.Vector4(),\n\n\t//\n\n\t_usedTextureUnits = 0,\n\n\t//\n\n\t_clearColor = new THREE.Color( 0x000000 ),\n\t_clearAlpha = 0,\n\n\t_width = _canvas.width,\n\t_height = _canvas.height,\n\n\t_pixelRatio = 1,\n\n\t_scissor = new THREE.Vector4( 0, 0, _width, _height ),\n\t_scissorTest = false,\n\n\t_viewport = new THREE.Vector4( 0, 0, _width, _height ),\n\n\t// frustum\n\n\t_frustum = new THREE.Frustum(),\n\n\t// clipping\n\n\t_clipping = new THREE.WebGLClipping(),\n\t_clippingEnabled = false,\n\t_localClippingEnabled = false,\n\n\t_sphere = new THREE.Sphere(),\n\n\t// camera matrices cache\n\n\t_projScreenMatrix = new THREE.Matrix4(),\n\n\t_vector3 = new THREE.Vector3(),\n\n\t// light arrays cache\n\n\t_lights = {\n\n\t\thash: '',\n\n\t\tambient: [ 0, 0, 0 ],\n\t\tdirectional: [],\n\t\tdirectionalShadowMap: [],\n\t\tdirectionalShadowMatrix: [],\n\t\tspot: [],\n\t\tspotShadowMap: [],\n\t\tspotShadowMatrix: [],\n\t\tpoint: [],\n\t\tpointShadowMap: [],\n\t\tpointShadowMatrix: [],\n\t\themi: [],\n\n\t\tshadows: []\n\n\t},\n\n\t// info\n\n\t_infoRender = {\n\n\t\tcalls: 0,\n\t\tvertices: 0,\n\t\tfaces: 0,\n\t\tpoints: 0\n\n\t};\n\n\tthis.info = {\n\n\t\trender: _infoRender,\n\t\tmemory: {\n\n\t\t\tgeometries: 0,\n\t\t\ttextures: 0\n\n\t\t},\n\t\tprograms: null\n\n\t};\n\n\n\t// initialize\n\n\tvar _gl;\n\n\ttry {\n\n\t\tvar attributes = {\n\t\t\talpha: _alpha,\n\t\t\tdepth: _depth,\n\t\t\tstencil: _stencil,\n\t\t\tantialias: _antialias,\n\t\t\tpremultipliedAlpha: _premultipliedAlpha,\n\t\t\tpreserveDrawingBuffer: _preserveDrawingBuffer\n\t\t};\n\n\t\t_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );\n\n\t\tif ( _gl === null ) {\n\n\t\t\tif ( _canvas.getContext( 'webgl' ) !== null ) {\n\n\t\t\t\tthrow 'Error creating WebGL context with your selected attributes.';\n\n\t\t\t} else {\n\n\t\t\t\tthrow 'Error creating WebGL context.';\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Some experimental-webgl implementations do not have getShaderPrecisionFormat\n\n\t\tif ( _gl.getShaderPrecisionFormat === undefined ) {\n\n\t\t\t_gl.getShaderPrecisionFormat = function () {\n\n\t\t\t\treturn { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };\n\n\t\t\t};\n\n\t\t}\n\n\t\t_canvas.addEventListener( 'webglcontextlost', onContextLost, false );\n\n\t} catch ( error ) {\n\n\t\tconsole.error( 'THREE.WebGLRenderer: ' + error );\n\n\t}\n\n\tvar extensions = new THREE.WebGLExtensions( _gl );\n\n\textensions.get( 'WEBGL_depth_texture' );\n\textensions.get( 'OES_texture_float' );\n\textensions.get( 'OES_texture_float_linear' );\n\textensions.get( 'OES_texture_half_float' );\n\textensions.get( 'OES_texture_half_float_linear' );\n\textensions.get( 'OES_standard_derivatives' );\n\textensions.get( 'ANGLE_instanced_arrays' );\n\n\tif ( extensions.get( 'OES_element_index_uint' ) ) {\n\n\t\tTHREE.BufferGeometry.MaxIndex = 4294967296;\n\n\t}\n\n\tvar capabilities = new THREE.WebGLCapabilities( _gl, extensions, parameters );\n\n\tvar state = new THREE.WebGLState( _gl, extensions, paramThreeToGL );\n\tvar properties = new THREE.WebGLProperties();\n\tvar textures = new THREE.WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, this.info );\n\tvar objects = new THREE.WebGLObjects( _gl, properties, this.info );\n\tvar programCache = new THREE.WebGLPrograms( this, capabilities );\n\tvar lightCache = new THREE.WebGLLights();\n\n\tthis.info.programs = programCache.programs;\n\n\tvar bufferRenderer = new THREE.WebGLBufferRenderer( _gl, extensions, _infoRender );\n\tvar indexedBufferRenderer = new THREE.WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );\n\n\t//\n\n\tvar backgroundCamera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\tvar backgroundCamera2 = new THREE.PerspectiveCamera();\n\tvar backgroundPlaneMesh = new THREE.Mesh(\n\t\tnew THREE.PlaneBufferGeometry( 2, 2 ),\n\t\tnew THREE.MeshBasicMaterial( { depthTest: false, depthWrite: false } )\n\t);\n\tvar backgroundBoxShader = THREE.ShaderLib[ 'cube' ];\n\tvar backgroundBoxMesh = new THREE.Mesh(\n\t\tnew THREE.BoxBufferGeometry( 5, 5, 5 ),\n\t\tnew THREE.ShaderMaterial( {\n\t\t\tuniforms: backgroundBoxShader.uniforms,\n\t\t\tvertexShader: backgroundBoxShader.vertexShader,\n\t\t\tfragmentShader: backgroundBoxShader.fragmentShader,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\tside: THREE.BackSide\n\t\t} )\n\t);\n\tobjects.update( backgroundPlaneMesh );\n\tobjects.update( backgroundBoxMesh );\n\n\t//\n\n\tfunction getTargetPixelRatio() {\n\n\t\treturn _currentRenderTarget === null ? _pixelRatio : 1;\n\n\t}\n\n\tfunction glClearColor( r, g, b, a ) {\n\n\t\tif ( _premultipliedAlpha === true ) {\n\n\t\t\tr *= a; g *= a; b *= a;\n\n\t\t}\n\n\t\tstate.clearColor( r, g, b, a );\n\n\t}\n\n\tfunction setDefaultGLState() {\n\n\t\tstate.init();\n\n\t\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );\n\t\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );\n\n\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t}\n\n\tfunction resetGLState() {\n\n\t\t_currentProgram = null;\n\t\t_currentCamera = null;\n\n\t\t_currentGeometryProgram = '';\n\t\t_currentMaterialId = - 1;\n\n\t\tstate.reset();\n\n\t}\n\n\tsetDefaultGLState();\n\n\tthis.context = _gl;\n\tthis.capabilities = capabilities;\n\tthis.extensions = extensions;\n\tthis.properties = properties;\n\tthis.state = state;\n\n\t// shadow map\n\n\tvar shadowMap = new THREE.WebGLShadowMap( this, _lights, objects );\n\n\tthis.shadowMap = shadowMap;\n\n\n\t// Plugins\n\n\tvar spritePlugin = new THREE.SpritePlugin( this, sprites );\n\tvar lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );\n\n\t// API\n\n\tthis.getContext = function () {\n\n\t\treturn _gl;\n\n\t};\n\n\tthis.getContextAttributes = function () {\n\n\t\treturn _gl.getContextAttributes();\n\n\t};\n\n\tthis.forceContextLoss = function () {\n\n\t\textensions.get( 'WEBGL_lose_context' ).loseContext();\n\n\t};\n\n\tthis.getMaxAnisotropy = function () {\n\n\t\treturn capabilities.getMaxAnisotropy();\n\n\t};\n\n\tthis.getPrecision = function () {\n\n\t\treturn capabilities.precision;\n\n\t};\n\n\tthis.getPixelRatio = function () {\n\n\t\treturn _pixelRatio;\n\n\t};\n\n\tthis.setPixelRatio = function ( value ) {\n\n\t\tif ( value === undefined ) return;\n\n\t\t_pixelRatio = value;\n\n\t\tthis.setSize( _viewport.z, _viewport.w, false );\n\n\t};\n\n\tthis.getSize = function () {\n\n\t\treturn {\n\t\t\twidth: _width,\n\t\t\theight: _height\n\t\t};\n\n\t};\n\n\tthis.setSize = function ( width, height, updateStyle ) {\n\n\t\t_width = width;\n\t\t_height = height;\n\n\t\t_canvas.width = width * _pixelRatio;\n\t\t_canvas.height = height * _pixelRatio;\n\n\t\tif ( updateStyle !== false ) {\n\n\t\t\t_canvas.style.width = width + 'px';\n\t\t\t_canvas.style.height = height + 'px';\n\n\t\t}\n\n\t\tthis.setViewport( 0, 0, width, height );\n\n\t};\n\n\tthis.setViewport = function ( x, y, width, height ) {\n\n\t\tstate.viewport( _viewport.set( x, y, width, height ) );\n\n\t};\n\n\tthis.setScissor = function ( x, y, width, height ) {\n\n\t\tstate.scissor( _scissor.set( x, y, width, height ) );\n\n\t};\n\n\tthis.setScissorTest = function ( boolean ) {\n\n\t\tstate.setScissorTest( _scissorTest = boolean );\n\n\t};\n\n\t// Clearing\n\n\tthis.getClearColor = function () {\n\n\t\treturn _clearColor;\n\n\t};\n\n\tthis.setClearColor = function ( color, alpha ) {\n\n\t\t_clearColor.set( color );\n\n\t\t_clearAlpha = alpha !== undefined ? alpha : 1;\n\n\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t};\n\n\tthis.getClearAlpha = function () {\n\n\t\treturn _clearAlpha;\n\n\t};\n\n\tthis.setClearAlpha = function ( alpha ) {\n\n\t\t_clearAlpha = alpha;\n\n\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t};\n\n\tthis.clear = function ( color, depth, stencil ) {\n\n\t\tvar bits = 0;\n\n\t\tif ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;\n\t\tif ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;\n\t\tif ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\n\n\t\t_gl.clear( bits );\n\n\t};\n\n\tthis.clearColor = function () {\n\n\t\tthis.clear( true, false, false );\n\n\t};\n\n\tthis.clearDepth = function () {\n\n\t\tthis.clear( false, true, false );\n\n\t};\n\n\tthis.clearStencil = function () {\n\n\t\tthis.clear( false, false, true );\n\n\t};\n\n\tthis.clearTarget = function ( renderTarget, color, depth, stencil ) {\n\n\t\tthis.setRenderTarget( renderTarget );\n\t\tthis.clear( color, depth, stencil );\n\n\t};\n\n\t// Reset\n\n\tthis.resetGLState = resetGLState;\n\n\tthis.dispose = function() {\n\n\t\ttransparentObjects = [];\n\t\ttransparentObjectsLastIndex = -1;\n\t\topaqueObjects = [];\n\t\topaqueObjectsLastIndex = -1;\n\n\t\t_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );\n\n\t};\n\n\t// Events\n\n\tfunction onContextLost( event ) {\n\n\t\tevent.preventDefault();\n\n\t\tresetGLState();\n\t\tsetDefaultGLState();\n\n\t\tproperties.clear();\n\n\t}\n\n\tfunction onMaterialDispose( event ) {\n\n\t\tvar material = event.target;\n\n\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\n\n\t\tdeallocateMaterial( material );\n\n\t}\n\n\t// Buffer deallocation\n\n\tfunction deallocateMaterial( material ) {\n\n\t\treleaseMaterialProgramReference( material );\n\n\t\tproperties.delete( material );\n\n\t}\n\n\n\tfunction releaseMaterialProgramReference( material ) {\n\n\t\tvar programInfo = properties.get( material ).program;\n\n\t\tmaterial.program = undefined;\n\n\t\tif ( programInfo !== undefined ) {\n\n\t\t\tprogramCache.releaseProgram( programInfo );\n\n\t\t}\n\n\t}\n\n\t// Buffer rendering\n\n\tthis.renderBufferImmediate = function ( object, program, material ) {\n\n\t\tstate.initAttributes();\n\n\t\tvar buffers = properties.get( object );\n\n\t\tif ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();\n\t\tif ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();\n\t\tif ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();\n\t\tif ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();\n\n\t\tvar attributes = program.getAttributes();\n\n\t\tif ( object.hasPositions ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );\n\n\t\t\tstate.enableAttribute( attributes.position );\n\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.hasNormals ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );\n\n\t\t\tif ( material.type !== 'MeshPhongMaterial' && material.type !== 'MeshStandardMaterial' && material.type !== 'MeshPhysicalMaterial' && material.shading === THREE.FlatShading ) {\n\n\t\t\t\tfor ( var i = 0, l = object.count * 3; i < l; i += 9 ) {\n\n\t\t\t\t\tvar array = object.normalArray;\n\n\t\t\t\t\tvar nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;\n\t\t\t\t\tvar ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;\n\t\t\t\t\tvar nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;\n\n\t\t\t\t\tarray[ i + 0 ] = nx;\n\t\t\t\t\tarray[ i + 1 ] = ny;\n\t\t\t\t\tarray[ i + 2 ] = nz;\n\n\t\t\t\t\tarray[ i + 3 ] = nx;\n\t\t\t\t\tarray[ i + 4 ] = ny;\n\t\t\t\t\tarray[ i + 5 ] = nz;\n\n\t\t\t\t\tarray[ i + 6 ] = nx;\n\t\t\t\t\tarray[ i + 7 ] = ny;\n\t\t\t\t\tarray[ i + 8 ] = nz;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );\n\n\t\t\tstate.enableAttribute( attributes.normal );\n\n\t\t\t_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.hasUvs && material.map ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );\n\n\t\t\tstate.enableAttribute( attributes.uv );\n\n\t\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.hasColors && material.vertexColors !== THREE.NoColors ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );\n\n\t\t\tstate.enableAttribute( attributes.color );\n\n\t\t\t_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t}\n\n\t\tstate.disableUnusedAttributes();\n\n\t\t_gl.drawArrays( _gl.TRIANGLES, 0, object.count );\n\n\t\tobject.count = 0;\n\n\t};\n\n\tthis.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {\n\n\t\tsetMaterial( material );\n\n\t\tvar program = setProgram( camera, fog, material, object );\n\n\t\tvar updateBuffers = false;\n\t\tvar geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;\n\n\t\tif ( geometryProgram !== _currentGeometryProgram ) {\n\n\t\t\t_currentGeometryProgram = geometryProgram;\n\t\t\tupdateBuffers = true;\n\n\t\t}\n\n\t\t// morph targets\n\n\t\tvar morphTargetInfluences = object.morphTargetInfluences;\n\n\t\tif ( morphTargetInfluences !== undefined ) {\n\n\t\t\tvar activeInfluences = [];\n\n\t\t\tfor ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {\n\n\t\t\t\tvar influence = morphTargetInfluences[ i ];\n\t\t\t\tactiveInfluences.push( [ influence, i ] );\n\n\t\t\t}\n\n\t\t\tactiveInfluences.sort( absNumericalSort );\n\n\t\t\tif ( activeInfluences.length > 8 ) {\n\n\t\t\t\tactiveInfluences.length = 8;\n\n\t\t\t}\n\n\t\t\tvar morphAttributes = geometry.morphAttributes;\n\n\t\t\tfor ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {\n\n\t\t\t\tvar influence = activeInfluences[ i ];\n\t\t\t\tmorphInfluences[ i ] = influence[ 0 ];\n\n\t\t\t\tif ( influence[ 0 ] !== 0 ) {\n\n\t\t\t\t\tvar index = influence[ 1 ];\n\n\t\t\t\t\tif ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );\n\t\t\t\t\tif ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );\n\t\t\t\t\tif ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tprogram.getUniforms().setValue(\n\t\t\t\t\t_gl, 'morphTargetInfluences', morphInfluences );\n\n\t\t\tupdateBuffers = true;\n\n\t\t}\n\n\t\t//\n\n\t\tvar index = geometry.index;\n\t\tvar position = geometry.attributes.position;\n\n\t\tif ( material.wireframe === true ) {\n\n\t\t\tindex = objects.getWireframeAttribute( geometry );\n\n\t\t}\n\n\t\tvar renderer;\n\n\t\tif ( index !== null ) {\n\n\t\t\trenderer = indexedBufferRenderer;\n\t\t\trenderer.setIndex( index );\n\n\t\t} else {\n\n\t\t\trenderer = bufferRenderer;\n\n\t\t}\n\n\t\tif ( updateBuffers ) {\n\n\t\t\tsetupVertexAttributes( material, program, geometry );\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tvar dataStart = 0;\n\t\tvar dataCount = Infinity;\n\n\t\tif ( index !== null ) {\n\n\t\t\tdataCount = index.count;\n\n\t\t} else if ( position !== undefined ) {\n\n\t\t\tdataCount = position.count;\n\n\t\t}\n\n\t\tvar rangeStart = geometry.drawRange.start;\n\t\tvar rangeCount = geometry.drawRange.count;\n\n\t\tvar groupStart = group !== null ? group.start : 0;\n\t\tvar groupCount = group !== null ? group.count : Infinity;\n\n\t\tvar drawStart = Math.max( dataStart, rangeStart, groupStart );\n\t\tvar drawEnd = Math.min( dataStart + dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;\n\n\t\tvar drawCount = Math.max( 0, drawEnd - drawStart + 1 );\n\n\t\t//\n\n\t\tif ( object instanceof THREE.Mesh ) {\n\n\t\t\tif ( material.wireframe === true ) {\n\n\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );\n\t\t\t\trenderer.setMode( _gl.LINES );\n\n\t\t\t} else {\n\n\t\t\t\tswitch ( object.drawMode ) {\n\n\t\t\t\t\tcase THREE.TrianglesDrawMode:\n\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLES );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.TriangleStripDrawMode:\n\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_STRIP );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.TriangleFanDrawMode:\n\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_FAN );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t} else if ( object instanceof THREE.Line ) {\n\n\t\t\tvar lineWidth = material.linewidth;\n\n\t\t\tif ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material\n\n\t\t\tstate.setLineWidth( lineWidth * getTargetPixelRatio() );\n\n\t\t\tif ( object instanceof THREE.LineSegments ) {\n\n\t\t\t\trenderer.setMode( _gl.LINES );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.setMode( _gl.LINE_STRIP );\n\n\t\t\t}\n\n\t\t} else if ( object instanceof THREE.Points ) {\n\n\t\t\trenderer.setMode( _gl.POINTS );\n\n\t\t}\n\n\t\tif ( geometry instanceof THREE.InstancedBufferGeometry ) {\n\n\t\t\tif ( geometry.maxInstancedCount > 0 ) {\n\n\t\t\t\trenderer.renderInstances( geometry, drawStart, drawCount );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\trenderer.render( drawStart, drawCount );\n\n\t\t}\n\n\t};\n\n\tfunction setupVertexAttributes( material, program, geometry, startIndex ) {\n\n\t\tvar extension;\n\n\t\tif ( geometry instanceof THREE.InstancedBufferGeometry ) {\n\n\t\t\textension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\tif ( extension === null ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( startIndex === undefined ) startIndex = 0;\n\n\t\tstate.initAttributes();\n\n\t\tvar geometryAttributes = geometry.attributes;\n\n\t\tvar programAttributes = program.getAttributes();\n\n\t\tvar materialDefaultAttributeValues = material.defaultAttributeValues;\n\n\t\tfor ( var name in programAttributes ) {\n\n\t\t\tvar programAttribute = programAttributes[ name ];\n\n\t\t\tif ( programAttribute >= 0 ) {\n\n\t\t\t\tvar geometryAttribute = geometryAttributes[ name ];\n\n\t\t\t\tif ( geometryAttribute !== undefined ) {\n\n\t\t\t\t\tvar type = _gl.FLOAT;\n\t\t\t\t\tvar array = geometryAttribute.array;\n\t\t\t\t\tvar normalized = geometryAttribute.normalized;\n\n\t\t\t\t\tif ( array instanceof Float32Array ) {\n\n\t\t\t\t\t\ttype = _gl.FLOAT;\n\n\t\t\t\t\t} else if ( array instanceof Float64Array ) {\n\n\t\t\t\t\t\tconsole.warn(\"Unsupported data buffer format: Float64Array\");\n\n\t\t\t\t\t} else if ( array instanceof Uint16Array ) {\n\n\t\t\t\t\t\ttype = _gl.UNSIGNED_SHORT;\n\n\t\t\t\t\t} else if ( array instanceof Int16Array ) {\n\n\t\t\t\t\t\ttype = _gl.SHORT;\n\n\t\t\t\t\t} else if ( array instanceof Uint32Array ) {\n\n\t\t\t\t\t\ttype = _gl.UNSIGNED_INT;\n\n\t\t\t\t\t} else if ( array instanceof Int32Array ) {\n\n\t\t\t\t\t\ttype = _gl.INT;\n\n\t\t\t\t\t} else if ( array instanceof Int8Array ) {\n\n\t\t\t\t\t\ttype = _gl.BYTE;\n\n\t\t\t\t\t} else if ( array instanceof Uint8Array ) {\n\n\t\t\t\t\t\ttype = _gl.UNSIGNED_BYTE;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar size = geometryAttribute.itemSize;\n\t\t\t\t\tvar buffer = objects.getAttributeBuffer( geometryAttribute );\n\n\t\t\t\t\tif ( geometryAttribute instanceof THREE.InterleavedBufferAttribute ) {\n\n\t\t\t\t\t\tvar data = geometryAttribute.data;\n\t\t\t\t\t\tvar stride = data.stride;\n\t\t\t\t\t\tvar offset = geometryAttribute.offset;\n\n\t\t\t\t\t\tif ( data instanceof THREE.InstancedInterleavedBuffer ) {\n\n\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );\n\n\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\n\n\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = data.meshPerAttribute * data.count;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\n\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( geometryAttribute instanceof THREE.InstancedBufferAttribute ) {\n\n\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );\n\n\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\n\n\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\n\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * geometryAttribute.array.BYTES_PER_ELEMENT );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( materialDefaultAttributeValues !== undefined ) {\n\n\t\t\t\t\tvar value = materialDefaultAttributeValues[ name ];\n\n\t\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\t\tswitch ( value.length ) {\n\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t_gl.vertexAttrib2fv( programAttribute, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t_gl.vertexAttrib3fv( programAttribute, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t_gl.vertexAttrib4fv( programAttribute, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t_gl.vertexAttrib1fv( programAttribute, value );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.disableUnusedAttributes();\n\n\t}\n\n\t// Sorting\n\n\tfunction absNumericalSort( a, b ) {\n\n\t\treturn Math.abs( b[ 0 ] ) - Math.abs( a[ 0 ] );\n\n\t}\n\n\tfunction painterSortStable ( a, b ) {\n\n\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\n\n\t\t\treturn a.object.renderOrder - b.object.renderOrder;\n\n\t\t} else if ( a.material.id !== b.material.id ) {\n\n\t\t\treturn a.material.id - b.material.id;\n\n\t\t} else if ( a.z !== b.z ) {\n\n\t\t\treturn a.z - b.z;\n\n\t\t} else {\n\n\t\t\treturn a.id - b.id;\n\n\t\t}\n\n\t}\n\n\tfunction reversePainterSortStable ( a, b ) {\n\n\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\n\n\t\t\treturn a.object.renderOrder - b.object.renderOrder;\n\n\t\t} if ( a.z !== b.z ) {\n\n\t\t\treturn b.z - a.z;\n\n\t\t} else {\n\n\t\t\treturn a.id - b.id;\n\n\t\t}\n\n\t}\n\n\t// Rendering\n\n\tthis.render = function ( scene, camera, renderTarget, forceClear ) {\n\n\t\tif ( camera instanceof THREE.Camera === false ) {\n\n\t\t\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar fog = scene.fog;\n\n\t\t// reset caching for this frame\n\n\t\t_currentGeometryProgram = '';\n\t\t_currentMaterialId = - 1;\n\t\t_currentCamera = null;\n\n\t\t// update scene graph\n\n\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\n\n\t\t// update camera matrices and frustum\n\n\t\tif ( camera.parent === null ) camera.updateMatrixWorld();\n\n\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\n\n\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\n\t\tlights.length = 0;\n\n\t\topaqueObjectsLastIndex = - 1;\n\t\ttransparentObjectsLastIndex = - 1;\n\n\t\tsprites.length = 0;\n\t\tlensFlares.length = 0;\n\n\t\t_localClippingEnabled = this.localClippingEnabled;\n\t\t_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );\n\n\t\tprojectObject( scene, camera );\n\n\t\topaqueObjects.length = opaqueObjectsLastIndex + 1;\n\t\ttransparentObjects.length = transparentObjectsLastIndex + 1;\n\n\t\tif ( _this.sortObjects === true ) {\n\n\t\t\topaqueObjects.sort( painterSortStable );\n\t\t\ttransparentObjects.sort( reversePainterSortStable );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( _clippingEnabled ) _clipping.beginShadows();\n\n\t\tsetupShadows( lights );\n\n\t\tshadowMap.render( scene, camera );\n\n\t\tsetupLights( lights, camera );\n\n\t\tif ( _clippingEnabled ) _clipping.endShadows();\n\n\t\t//\n\n\t\t_infoRender.calls = 0;\n\t\t_infoRender.vertices = 0;\n\t\t_infoRender.faces = 0;\n\t\t_infoRender.points = 0;\n\n\t\tif ( renderTarget === undefined ) {\n\n\t\t\trenderTarget = null;\n\n\t\t}\n\n\t\tthis.setRenderTarget( renderTarget );\n\n\t\t//\n\n\t\tvar background = scene.background;\n\n\t\tif ( background === null ) {\n\n\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t\t} else if ( background instanceof THREE.Color ) {\n\n\t\t\tglClearColor( background.r, background.g, background.b, 1 );\n\n\t\t}\n\n\t\tif ( this.autoClear || forceClear ) {\n\n\t\t\tthis.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );\n\n\t\t}\n\n\t\tif ( background instanceof THREE.CubeTexture ) {\n\n\t\t\tbackgroundCamera2.projectionMatrix.copy( camera.projectionMatrix );\n\n\t\t\tbackgroundCamera2.matrixWorld.extractRotation( camera.matrixWorld );\n\t\t\tbackgroundCamera2.matrixWorldInverse.getInverse( backgroundCamera2.matrixWorld );\n\n\t\t\tbackgroundBoxMesh.material.uniforms[ \"tCube\" ].value = background;\n\t\t\tbackgroundBoxMesh.modelViewMatrix.multiplyMatrices( backgroundCamera2.matrixWorldInverse, backgroundBoxMesh.matrixWorld );\n\n\t\t\t_this.renderBufferDirect( backgroundCamera2, null, backgroundBoxMesh.geometry, backgroundBoxMesh.material, backgroundBoxMesh, null );\n\n\t\t} else if ( background instanceof THREE.Texture ) {\n\n\t\t\tbackgroundPlaneMesh.material.map = background;\n\n\t\t\t_this.renderBufferDirect( backgroundCamera, null, backgroundPlaneMesh.geometry, backgroundPlaneMesh.material, backgroundPlaneMesh, null );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( scene.overrideMaterial ) {\n\n\t\t\tvar overrideMaterial = scene.overrideMaterial;\n\n\t\t\trenderObjects( opaqueObjects, camera, fog, overrideMaterial );\n\t\t\trenderObjects( transparentObjects, camera, fog, overrideMaterial );\n\n\t\t} else {\n\n\t\t\t// opaque pass (front-to-back order)\n\n\t\t\tstate.setBlending( THREE.NoBlending );\n\t\t\trenderObjects( opaqueObjects, camera, fog );\n\n\t\t\t// transparent pass (back-to-front order)\n\n\t\t\trenderObjects( transparentObjects, camera, fog );\n\n\t\t}\n\n\t\t// custom render plugins (post pass)\n\n\t\tspritePlugin.render( scene, camera );\n\t\tlensFlarePlugin.render( scene, camera, _currentViewport );\n\n\t\t// Generate mipmap if we're using any kind of mipmap filtering\n\n\t\tif ( renderTarget ) {\n\n\t\t\ttextures.updateRenderTargetMipmap( renderTarget );\n\n\t\t}\n\n\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\n\n\t\tstate.setDepthTest( true );\n\t\tstate.setDepthWrite( true );\n\t\tstate.setColorWrite( true );\n\n\t\t// _gl.finish();\n\n\t};\n\n\tfunction pushRenderItem( object, geometry, material, z, group ) {\n\n\t\tvar array, index;\n\n\t\t// allocate the next position in the appropriate array\n\n\t\tif ( material.transparent ) {\n\n\t\t\tarray = transparentObjects;\n\t\t\tindex = ++ transparentObjectsLastIndex;\n\n\t\t} else {\n\n\t\t\tarray = opaqueObjects;\n\t\t\tindex = ++ opaqueObjectsLastIndex;\n\n\t\t}\n\n\t\t// recycle existing render item or grow the array\n\n\t\tvar renderItem = array[ index ];\n\n\t\tif ( renderItem !== undefined ) {\n\n\t\t\trenderItem.id = object.id;\n\t\t\trenderItem.object = object;\n\t\t\trenderItem.geometry = geometry;\n\t\t\trenderItem.material = material;\n\t\t\trenderItem.z = _vector3.z;\n\t\t\trenderItem.group = group;\n\n\t\t} else {\n\n\t\t\trenderItem = {\n\t\t\t\tid: object.id,\n\t\t\t\tobject: object,\n\t\t\t\tgeometry: geometry,\n\t\t\t\tmaterial: material,\n\t\t\t\tz: _vector3.z,\n\t\t\t\tgroup: group\n\t\t\t};\n\n\t\t\t// assert( index === array.length );\n\t\t\tarray.push( renderItem );\n\n\t\t}\n\n\t}\n\n\t// TODO Duplicated code (Frustum)\n\n\tfunction isObjectViewable( object ) {\n\n\t\tvar geometry = object.geometry;\n\n\t\tif ( geometry.boundingSphere === null )\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t_sphere.copy( geometry.boundingSphere ).\n\t\t\tapplyMatrix4( object.matrixWorld );\n\n\t\treturn isSphereViewable( _sphere );\n\n\t}\n\n\tfunction isSpriteViewable( sprite ) {\n\n\t\t_sphere.center.set( 0, 0, 0 );\n\t\t_sphere.radius = 0.7071067811865476;\n\t\t_sphere.applyMatrix4( sprite.matrixWorld );\n\n\t\treturn isSphereViewable( _sphere );\n\n\t}\n\n\tfunction isSphereViewable( sphere ) {\n\n\t\tif ( ! _frustum.intersectsSphere( sphere ) ) return false;\n\n\t\tvar numPlanes = _clipping.numPlanes;\n\n\t\tif ( numPlanes === 0 ) return true;\n\n\t\tvar planes = _this.clippingPlanes,\n\n\t\t\tcenter = sphere.center,\n\t\t\tnegRad = - sphere.radius,\n\t\t\ti = 0;\n\n\t\tdo {\n\n\t\t\t// out when deeper than radius in the negative halfspace\n\t\t\tif ( planes[ i ].distanceToPoint( center ) < negRad ) return false;\n\n\t\t} while ( ++ i !== numPlanes );\n\n\t\treturn true;\n\n\t}\n\n\tfunction projectObject( object, camera ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tif ( object.layers.test( camera.layers ) ) {\n\n\t\t\tif ( object instanceof THREE.Light ) {\n\n\t\t\t\tlights.push( object );\n\n\t\t\t} else if ( object instanceof THREE.Sprite ) {\n\n\t\t\t\tif ( object.frustumCulled === false || isSpriteViewable( object ) === true ) {\n\n\t\t\t\t\tsprites.push( object );\n\n\t\t\t\t}\n\n\t\t\t} else if ( object instanceof THREE.LensFlare ) {\n\n\t\t\t\tlensFlares.push( object );\n\n\t\t\t} else if ( object instanceof THREE.ImmediateRenderObject ) {\n\n\t\t\t\tif ( _this.sortObjects === true ) {\n\n\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\n\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\n\n\t\t\t\t}\n\n\t\t\t\tpushRenderItem( object, null, object.material, _vector3.z, null );\n\n\t\t\t} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {\n\n\t\t\t\tif ( object instanceof THREE.SkinnedMesh ) {\n\n\t\t\t\t\tobject.skeleton.update();\n\n\t\t\t\t}\n\n\t\t\t\tif ( object.frustumCulled === false || isObjectViewable( object ) === true ) {\n\n\t\t\t\t\tvar material = object.material;\n\n\t\t\t\t\tif ( material.visible === true ) {\n\n\t\t\t\t\t\tif ( _this.sortObjects === true ) {\n\n\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\n\t\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar geometry = objects.update( object );\n\n\t\t\t\t\t\tif ( material instanceof THREE.MultiMaterial ) {\n\n\t\t\t\t\t\t\tvar groups = geometry.groups;\n\t\t\t\t\t\t\tvar materials = material.materials;\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\tvar group = groups[ i ];\n\t\t\t\t\t\t\t\tvar groupMaterial = materials[ group.materialIndex ];\n\n\t\t\t\t\t\t\t\tif ( groupMaterial.visible === true ) {\n\n\t\t\t\t\t\t\t\t\tpushRenderItem( object, geometry, groupMaterial, _vector3.z, group );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tpushRenderItem( object, geometry, material, _vector3.z, null );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar children = object.children;\n\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tprojectObject( children[ i ], camera );\n\n\t\t}\n\n\t}\n\n\tfunction renderObjects( renderList, camera, fog, overrideMaterial ) {\n\n\t\tfor ( var i = 0, l = renderList.length; i < l; i ++ ) {\n\n\t\t\tvar renderItem = renderList[ i ];\n\n\t\t\tvar object = renderItem.object;\n\t\t\tvar geometry = renderItem.geometry;\n\t\t\tvar material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;\n\t\t\tvar group = renderItem.group;\n\n\t\t\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\t\t\tobject.normalMatrix.getNormalMatrix( object.modelViewMatrix );\n\n\t\t\tif ( object instanceof THREE.ImmediateRenderObject ) {\n\n\t\t\t\tsetMaterial( material );\n\n\t\t\t\tvar program = setProgram( camera, fog, material, object );\n\n\t\t\t\t_currentGeometryProgram = '';\n\n\t\t\t\tobject.render( function ( object ) {\n\n\t\t\t\t\t_this.renderBufferImmediate( object, program, material );\n\n\t\t\t\t} );\n\n\t\t\t} else {\n\n\t\t\t\t_this.renderBufferDirect( camera, fog, geometry, material, object, group );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction initMaterial( material, fog, object ) {\n\n\t\tvar materialProperties = properties.get( material );\n\n\t\tvar parameters = programCache.getParameters(\n\t\t\t\tmaterial, _lights, fog, _clipping.numPlanes, object );\n\n\t\tvar code = programCache.getProgramCode( material, parameters );\n\n\t\tvar program = materialProperties.program;\n\t\tvar programChange = true;\n\n\t\tif ( program === undefined ) {\n\n\t\t\t// new material\n\t\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\n\n\t\t} else if ( program.code !== code ) {\n\n\t\t\t// changed glsl or parameters\n\t\t\treleaseMaterialProgramReference( material );\n\n\t\t} else if ( parameters.shaderID !== undefined ) {\n\n\t\t\t// same glsl and uniform list\n\t\t\treturn;\n\n\t\t} else {\n\n\t\t\t// only rebuild uniform list\n\t\t\tprogramChange = false;\n\n\t\t}\n\n\t\tif ( programChange ) {\n\n\t\t\tif ( parameters.shaderID ) {\n\n\t\t\t\tvar shader = THREE.ShaderLib[ parameters.shaderID ];\n\n\t\t\t\tmaterialProperties.__webglShader = {\n\t\t\t\t\tname: material.type,\n\t\t\t\t\tuniforms: THREE.UniformsUtils.clone( shader.uniforms ),\n\t\t\t\t\tvertexShader: shader.vertexShader,\n\t\t\t\t\tfragmentShader: shader.fragmentShader\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tmaterialProperties.__webglShader = {\n\t\t\t\t\tname: material.type,\n\t\t\t\t\tuniforms: material.uniforms,\n\t\t\t\t\tvertexShader: material.vertexShader,\n\t\t\t\t\tfragmentShader: material.fragmentShader\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tmaterial.__webglShader = materialProperties.__webglShader;\n\n\t\t\tprogram = programCache.acquireProgram( material, parameters, code );\n\n\t\t\tmaterialProperties.program = program;\n\t\t\tmaterial.program = program;\n\n\t\t}\n\n\t\tvar attributes = program.getAttributes();\n\n\t\tif ( material.morphTargets ) {\n\n\t\t\tmaterial.numSupportedMorphTargets = 0;\n\n\t\t\tfor ( var i = 0; i < _this.maxMorphTargets; i ++ ) {\n\n\t\t\t\tif ( attributes[ 'morphTarget' + i ] >= 0 ) {\n\n\t\t\t\t\tmaterial.numSupportedMorphTargets ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( material.morphNormals ) {\n\n\t\t\tmaterial.numSupportedMorphNormals = 0;\n\n\t\t\tfor ( var i = 0; i < _this.maxMorphNormals; i ++ ) {\n\n\t\t\t\tif ( attributes[ 'morphNormal' + i ] >= 0 ) {\n\n\t\t\t\t\tmaterial.numSupportedMorphNormals ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar uniforms = materialProperties.__webglShader.uniforms;\n\n\t\tif ( ! ( material instanceof THREE.ShaderMaterial ) &&\n\t\t\t\t! ( material instanceof THREE.RawShaderMaterial ) ||\n\t\t\t\tmaterial.clipping === true ) {\n\n\t\t\tmaterialProperties.numClippingPlanes = _clipping.numPlanes;\n\t\t\tuniforms.clippingPlanes = _clipping.uniform;\n\n\t\t}\n\n\t\tif ( material.lights ) {\n\n\t\t\t// store the light setup it was created for\n\n\t\t\tmaterialProperties.lightsHash = _lights.hash;\n\n\t\t\t// wire up the material to this renderer's lighting state\n\n\t\t\tuniforms.ambientLightColor.value = _lights.ambient;\n\t\t\tuniforms.directionalLights.value = _lights.directional;\n\t\t\tuniforms.spotLights.value = _lights.spot;\n\t\t\tuniforms.pointLights.value = _lights.point;\n\t\t\tuniforms.hemisphereLights.value = _lights.hemi;\n\n\t\t\tuniforms.directionalShadowMap.value = _lights.directionalShadowMap;\n\t\t\tuniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;\n\t\t\tuniforms.spotShadowMap.value = _lights.spotShadowMap;\n\t\t\tuniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;\n\t\t\tuniforms.pointShadowMap.value = _lights.pointShadowMap;\n\t\t\tuniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;\n\n\t\t}\n\n\t\tvar progUniforms = materialProperties.program.getUniforms(),\n\t\t\tuniformsList =\n\t\t\t\t\tTHREE.WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );\n\n\t\tmaterialProperties.uniformsList = uniformsList;\n\t\tmaterialProperties.dynamicUniforms =\n\t\t\t\tTHREE.WebGLUniforms.splitDynamic( uniformsList, uniforms );\n\n\t}\n\n\tfunction setMaterial( material ) {\n\n\t\tif ( material.side !== THREE.DoubleSide )\n\t\t\tstate.enable( _gl.CULL_FACE );\n\t\telse\n\t\t\tstate.disable( _gl.CULL_FACE );\n\n\t\tstate.setFlipSided( material.side === THREE.BackSide );\n\n\t\tif ( material.transparent === true ) {\n\n\t\t\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );\n\n\t\t} else {\n\n\t\t\tstate.setBlending( THREE.NoBlending );\n\n\t\t}\n\n\t\tstate.setDepthFunc( material.depthFunc );\n\t\tstate.setDepthTest( material.depthTest );\n\t\tstate.setDepthWrite( material.depthWrite );\n\t\tstate.setColorWrite( material.colorWrite );\n\t\tstate.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\n\t}\n\n\tfunction setProgram( camera, fog, material, object ) {\n\n\t\t_usedTextureUnits = 0;\n\n\t\tvar materialProperties = properties.get( material );\n\n\t\tif ( _clippingEnabled ) {\n\n\t\t\tif ( _localClippingEnabled || camera !== _currentCamera ) {\n\n\t\t\t\tvar useCache =\n\t\t\t\t\t\tcamera === _currentCamera &&\n\t\t\t\t\t\tmaterial.id === _currentMaterialId;\n\n\t\t\t\t// we might want to call this function with some ClippingGroup\n\t\t\t\t// object instead of the material, once it becomes feasible\n\t\t\t\t// (#8465, #8379)\n\t\t\t\t_clipping.setState(\n\t\t\t\t\t\tmaterial.clippingPlanes, material.clipShadows,\n\t\t\t\t\t\tcamera, materialProperties, useCache );\n\n\t\t\t}\n\n\t\t\tif ( materialProperties.numClippingPlanes !== undefined &&\n\t\t\t\tmaterialProperties.numClippingPlanes !== _clipping.numPlanes ) {\n\n\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialProperties.program === undefined ) {\n\n\t\t\tmaterial.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( materialProperties.lightsHash !== undefined &&\n\t\t\tmaterialProperties.lightsHash !== _lights.hash ) {\n\n\t\t\tmaterial.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( material.needsUpdate ) {\n\n\t\t\tinitMaterial( material, fog, object );\n\t\t\tmaterial.needsUpdate = false;\n\n\t\t}\n\n\t\tvar refreshProgram = false;\n\t\tvar refreshMaterial = false;\n\t\tvar refreshLights = false;\n\n\t\tvar program = materialProperties.program,\n\t\t\tp_uniforms = program.getUniforms(),\n\t\t\tm_uniforms = materialProperties.__webglShader.uniforms;\n\n\t\tif ( program.id !== _currentProgram ) {\n\n\t\t\t_gl.useProgram( program.program );\n\t\t\t_currentProgram = program.id;\n\n\t\t\trefreshProgram = true;\n\t\t\trefreshMaterial = true;\n\t\t\trefreshLights = true;\n\n\t\t}\n\n\t\tif ( material.id !== _currentMaterialId ) {\n\n\t\t\t_currentMaterialId = material.id;\n\n\t\t\trefreshMaterial = true;\n\n\t\t}\n\n\t\tif ( refreshProgram || camera !== _currentCamera ) {\n\n\t\t\tp_uniforms.set( _gl, camera, 'projectionMatrix' );\n\n\t\t\tif ( capabilities.logarithmicDepthBuffer ) {\n\n\t\t\t\tp_uniforms.setValue( _gl, 'logDepthBufFC',\n\t\t\t\t\t\t2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\n\n\t\t\t}\n\n\n\t\t\tif ( camera !== _currentCamera ) {\n\n\t\t\t\t_currentCamera = camera;\n\n\t\t\t\t// lighting uniforms depend on the camera so enforce an update\n\t\t\t\t// now, in case this material supports lights - or later, when\n\t\t\t\t// the next material that does gets activated:\n\n\t\t\t\trefreshMaterial = true;\t\t// set to true on material change\n\t\t\t\trefreshLights = true;\t\t// remains set until update done\n\n\t\t\t}\n\n\t\t\t// load material specific uniforms\n\t\t\t// (shader material also gets them for the sake of genericity)\n\n\t\t\tif ( material instanceof THREE.ShaderMaterial ||\n\t\t\t\t material instanceof THREE.MeshPhongMaterial ||\n\t\t\t\t material instanceof THREE.MeshStandardMaterial ||\n\t\t\t\t material.envMap ) {\n\n\t\t\t\tvar uCamPos = p_uniforms.map.cameraPosition;\n\n\t\t\t\tif ( uCamPos !== undefined ) {\n\n\t\t\t\t\tuCamPos.setValue( _gl,\n\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( camera.matrixWorld ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( material instanceof THREE.MeshPhongMaterial ||\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\n\t\t\t\t material instanceof THREE.MeshBasicMaterial ||\n\t\t\t\t material instanceof THREE.MeshStandardMaterial ||\n\t\t\t\t material instanceof THREE.ShaderMaterial ||\n\t\t\t\t material.skinning ) {\n\n\t\t\t\tp_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );\n\n\t\t\t}\n\n\t\t\tp_uniforms.set( _gl, _this, 'toneMappingExposure' );\n\t\t\tp_uniforms.set( _gl, _this, 'toneMappingWhitePoint' );\n\n\t\t}\n\n\t\t// skinning uniforms must be set even if material didn't change\n\t\t// auto-setting of texture unit for bone texture must go before other textures\n\t\t// not sure why, but otherwise weird things happen\n\n\t\tif ( material.skinning ) {\n\n\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrix' );\n\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );\n\n\t\t\tvar skeleton = object.skeleton;\n\n\t\t\tif ( skeleton ) {\n\n\t\t\t\tif ( capabilities.floatVertexTextures && skeleton.useVertexTexture ) {\n\n\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTexture' );\n\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTextureWidth' );\n\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTextureHeight' );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tp_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( refreshMaterial ) {\n\n\t\t\tif ( material.lights ) {\n\n\t\t\t\t// the current material requires lighting info\n\n\t\t\t\t// note: all lighting uniforms are always set correctly\n\t\t\t\t// they simply reference the renderer's state for their\n\t\t\t\t// values\n\t\t\t\t//\n\t\t\t\t// use the current material's .needsUpdate flags to set\n\t\t\t\t// the GL state when required\n\n\t\t\t\tmarkUniformsLightsNeedsUpdate( m_uniforms, refreshLights );\n\n\t\t\t}\n\n\t\t\t// refresh uniforms common to several materials\n\n\t\t\tif ( fog && material.fog ) {\n\n\t\t\t\trefreshUniformsFog( m_uniforms, fog );\n\n\t\t\t}\n\n\t\t\tif ( material instanceof THREE.MeshBasicMaterial ||\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\n\t\t\t\t material instanceof THREE.MeshPhongMaterial ||\n\t\t\t\t material instanceof THREE.MeshStandardMaterial ||\n\t\t\t\t material instanceof THREE.MeshDepthMaterial ) {\n\n\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\n\t\t\t}\n\n\t\t\t// refresh single material specific uniforms\n\n\t\t\tif ( material instanceof THREE.LineBasicMaterial ) {\n\n\t\t\t\trefreshUniformsLine( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.LineDashedMaterial ) {\n\n\t\t\t\trefreshUniformsLine( m_uniforms, material );\n\t\t\t\trefreshUniformsDash( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.PointsMaterial ) {\n\n\t\t\t\trefreshUniformsPoints( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.MeshLambertMaterial ) {\n\n\t\t\t\trefreshUniformsLambert( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.MeshPhongMaterial ) {\n\n\t\t\t\trefreshUniformsPhong( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.MeshPhysicalMaterial ) {\n\n\t\t\t\trefreshUniformsPhysical( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.MeshStandardMaterial ) {\n\n\t\t\t\trefreshUniformsStandard( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.MeshDepthMaterial ) {\n\n\t\t\t\tif ( material.displacementMap ) {\n\n\t\t\t\t\tm_uniforms.displacementMap.value = material.displacementMap;\n\t\t\t\t\tm_uniforms.displacementScale.value = material.displacementScale;\n\t\t\t\t\tm_uniforms.displacementBias.value = material.displacementBias;\n\n\t\t\t\t}\n\n\t\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\n\n\t\t\t\tm_uniforms.opacity.value = material.opacity;\n\n\t\t\t}\n\n\t\t\tTHREE.WebGLUniforms.upload(\n\t\t\t\t\t_gl, materialProperties.uniformsList, m_uniforms, _this );\n\n\t\t}\n\n\n\t\t// common matrices\n\n\t\tp_uniforms.set( _gl, object, 'modelViewMatrix' );\n\t\tp_uniforms.set( _gl, object, 'normalMatrix' );\n\t\tp_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );\n\n\n\t\t// dynamic uniforms\n\n\t\tvar dynUniforms = materialProperties.dynamicUniforms;\n\n\t\tif ( dynUniforms !== null ) {\n\n\t\t\tTHREE.WebGLUniforms.evalDynamic(\n\t\t\t\t\tdynUniforms, m_uniforms, object, camera );\n\n\t\t\tTHREE.WebGLUniforms.upload( _gl, dynUniforms, m_uniforms, _this );\n\n\t\t}\n\n\t\treturn program;\n\n\t}\n\n\t// Uniforms (refresh uniforms objects)\n\n\tfunction refreshUniformsCommon ( uniforms, material ) {\n\n\t\tuniforms.opacity.value = material.opacity;\n\n\t\tuniforms.diffuse.value = material.color;\n\n\t\tif ( material.emissive ) {\n\n\t\t\tuniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );\n\n\t\t}\n\n\t\tuniforms.map.value = material.map;\n\t\tuniforms.specularMap.value = material.specularMap;\n\t\tuniforms.alphaMap.value = material.alphaMap;\n\n\t\tif ( material.aoMap ) {\n\n\t\t\tuniforms.aoMap.value = material.aoMap;\n\t\t\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\n\n\t\t}\n\n\t\t// uv repeat and offset setting priorities\n\t\t// 1. color map\n\t\t// 2. specular map\n\t\t// 3. normal map\n\t\t// 4. bump map\n\t\t// 5. alpha map\n\t\t// 6. emissive map\n\n\t\tvar uvScaleMap;\n\n\t\tif ( material.map ) {\n\n\t\t\tuvScaleMap = material.map;\n\n\t\t} else if ( material.specularMap ) {\n\n\t\t\tuvScaleMap = material.specularMap;\n\n\t\t} else if ( material.displacementMap ) {\n\n\t\t\tuvScaleMap = material.displacementMap;\n\n\t\t} else if ( material.normalMap ) {\n\n\t\t\tuvScaleMap = material.normalMap;\n\n\t\t} else if ( material.bumpMap ) {\n\n\t\t\tuvScaleMap = material.bumpMap;\n\n\t\t} else if ( material.roughnessMap ) {\n\n\t\t\tuvScaleMap = material.roughnessMap;\n\n\t\t} else if ( material.metalnessMap ) {\n\n\t\t\tuvScaleMap = material.metalnessMap;\n\n\t\t} else if ( material.alphaMap ) {\n\n\t\t\tuvScaleMap = material.alphaMap;\n\n\t\t} else if ( material.emissiveMap ) {\n\n\t\t\tuvScaleMap = material.emissiveMap;\n\n\t\t}\n\n\t\tif ( uvScaleMap !== undefined ) {\n\n\t\t\t// backwards compatibility\n\t\t\tif ( uvScaleMap instanceof THREE.WebGLRenderTarget ) {\n\n\t\t\t\tuvScaleMap = uvScaleMap.texture;\n\n\t\t\t}\n\n\t\t\tvar offset = uvScaleMap.offset;\n\t\t\tvar repeat = uvScaleMap.repeat;\n\n\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\n\n\t\t}\n\n\t\tuniforms.envMap.value = material.envMap;\n\n\t\t// don't flip CubeTexture envMaps, flip everything else:\n\t\t//  WebGLRenderTargetCube will be flipped for backwards compatibility\n\t\t//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture\n\t\t// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future\n\t\tuniforms.flipEnvMap.value = ( ! ( material.envMap instanceof THREE.CubeTexture ) ) ? 1 : - 1;\n\n\t\tuniforms.reflectivity.value = material.reflectivity;\n\t\tuniforms.refractionRatio.value = material.refractionRatio;\n\n\t}\n\n\tfunction refreshUniformsLine ( uniforms, material ) {\n\n\t\tuniforms.diffuse.value = material.color;\n\t\tuniforms.opacity.value = material.opacity;\n\n\t}\n\n\tfunction refreshUniformsDash ( uniforms, material ) {\n\n\t\tuniforms.dashSize.value = material.dashSize;\n\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\n\t\tuniforms.scale.value = material.scale;\n\n\t}\n\n\tfunction refreshUniformsPoints ( uniforms, material ) {\n\n\t\tuniforms.diffuse.value = material.color;\n\t\tuniforms.opacity.value = material.opacity;\n\t\tuniforms.size.value = material.size * _pixelRatio;\n\t\tuniforms.scale.value = _canvas.clientHeight * 0.5;\n\n\t\tuniforms.map.value = material.map;\n\n\t\tif ( material.map !== null ) {\n\n\t\t\tvar offset = material.map.offset;\n\t\t\tvar repeat = material.map.repeat;\n\n\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsFog ( uniforms, fog ) {\n\n\t\tuniforms.fogColor.value = fog.color;\n\n\t\tif ( fog instanceof THREE.Fog ) {\n\n\t\t\tuniforms.fogNear.value = fog.near;\n\t\t\tuniforms.fogFar.value = fog.far;\n\n\t\t} else if ( fog instanceof THREE.FogExp2 ) {\n\n\t\t\tuniforms.fogDensity.value = fog.density;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsLambert ( uniforms, material ) {\n\n\t\tif ( material.lightMap ) {\n\n\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t}\n\n\t\tif ( material.emissiveMap ) {\n\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsPhong ( uniforms, material ) {\n\n\t\tuniforms.specular.value = material.specular;\n\t\tuniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )\n\n\t\tif ( material.lightMap ) {\n\n\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t}\n\n\t\tif ( material.emissiveMap ) {\n\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t}\n\n\t\tif ( material.bumpMap ) {\n\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\n\t\t}\n\n\t\tif ( material.normalMap ) {\n\n\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\n\t\t}\n\n\t\tif ( material.displacementMap ) {\n\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsStandard ( uniforms, material ) {\n\n\t\tuniforms.roughness.value = material.roughness;\n\t\tuniforms.metalness.value = material.metalness;\n\n\t\tif ( material.roughnessMap ) {\n\n\t\t\tuniforms.roughnessMap.value = material.roughnessMap;\n\n\t\t}\n\n\t\tif ( material.metalnessMap ) {\n\n\t\t\tuniforms.metalnessMap.value = material.metalnessMap;\n\n\t\t}\n\n\t\tif ( material.lightMap ) {\n\n\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t}\n\n\t\tif ( material.emissiveMap ) {\n\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t}\n\n\t\tif ( material.bumpMap ) {\n\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\n\t\t}\n\n\t\tif ( material.normalMap ) {\n\n\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\n\t\t}\n\n\t\tif ( material.displacementMap ) {\n\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t}\n\n\t\tif ( material.envMap ) {\n\n\t\t\t//uniforms.envMap.value = material.envMap; // part of uniforms common\n\t\t\tuniforms.envMapIntensity.value = material.envMapIntensity;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsPhysical ( uniforms, material ) {\n\n\t\tuniforms.clearCoat.value = material.clearCoat;\n\t\tuniforms.clearCoatRoughness.value = material.clearCoatRoughness;\n\n\t\trefreshUniformsStandard( uniforms, material );\n\n\t}\n\n\t// If uniforms are marked as clean, they don't need to be loaded to the GPU.\n\n\tfunction markUniformsLightsNeedsUpdate ( uniforms, value ) {\n\n\t\tuniforms.ambientLightColor.needsUpdate = value;\n\n\t\tuniforms.directionalLights.needsUpdate = value;\n\t\tuniforms.pointLights.needsUpdate = value;\n\t\tuniforms.spotLights.needsUpdate = value;\n\t\tuniforms.hemisphereLights.needsUpdate = value;\n\n\t}\n\n\t// Lighting\n\n\tfunction setupShadows ( lights ) {\n\n\t\tvar lightShadowsLength = 0;\n\n\t\tfor ( var i = 0, l = lights.length; i < l; i ++ ) {\n\n\t\t\tvar light = lights[ i ];\n\n\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t_lights.shadows[ lightShadowsLength ++ ] = light;\n\n\t\t\t}\n\n\t\t}\n\n\t\t_lights.shadows.length = lightShadowsLength;\n\n\t}\n\n\tfunction setupLights ( lights, camera ) {\n\n\t\tvar l, ll, light,\n\t\tr = 0, g = 0, b = 0,\n\t\tcolor,\n\t\tintensity,\n\t\tdistance,\n\t\tshadowMap,\n\n\t\tviewMatrix = camera.matrixWorldInverse,\n\n\t\tdirectionalLength = 0,\n\t\tpointLength = 0,\n\t\tspotLength = 0,\n\t\themiLength = 0;\n\n\t\tfor ( l = 0, ll = lights.length; l < ll; l ++ ) {\n\n\t\t\tlight = lights[ l ];\n\n\t\t\tcolor = light.color;\n\t\t\tintensity = light.intensity;\n\t\t\tdistance = light.distance;\n\n\t\t\tshadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;\n\n\t\t\tif ( light instanceof THREE.AmbientLight ) {\n\n\t\t\t\tr += color.r * intensity;\n\t\t\t\tg += color.g * intensity;\n\t\t\t\tb += color.b * intensity;\n\n\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\n\n\t\t\t\tvar uniforms = lightCache.get( light );\n\n\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\tuniforms.direction.sub( _vector3 );\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\tuniforms.shadow = light.castShadow;\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\n\t\t\t\t}\n\n\t\t\t\t_lights.directionalShadowMap[ directionalLength ] = shadowMap;\n\t\t\t\t_lights.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;\n\t\t\t\t_lights.directional[ directionalLength ++ ] = uniforms;\n\n\t\t\t} else if ( light instanceof THREE.SpotLight ) {\n\n\t\t\t\tvar uniforms = lightCache.get( light );\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity );\n\t\t\t\tuniforms.distance = distance;\n\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\tuniforms.direction.sub( _vector3 );\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\tuniforms.coneCos = Math.cos( light.angle );\n\t\t\t\tuniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );\n\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\n\n\t\t\t\tuniforms.shadow = light.castShadow;\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\n\t\t\t\t}\n\n\t\t\t\t_lights.spotShadowMap[ spotLength ] = shadowMap;\n\t\t\t\t_lights.spotShadowMatrix[ spotLength ] = light.shadow.matrix;\n\t\t\t\t_lights.spot[ spotLength ++ ] = uniforms;\n\n\t\t\t} else if ( light instanceof THREE.PointLight ) {\n\n\t\t\t\tvar uniforms = lightCache.get( light );\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\t\t\t\tuniforms.distance = light.distance;\n\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\n\n\t\t\t\tuniforms.shadow = light.castShadow;\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\n\t\t\t\t}\n\n\t\t\t\t_lights.pointShadowMap[ pointLength ] = shadowMap;\n\n\t\t\t\tif ( _lights.pointShadowMatrix[ pointLength ] === undefined ) {\n\n\t\t\t\t\t_lights.pointShadowMatrix[ pointLength ] = new THREE.Matrix4();\n\n\t\t\t\t}\n\n\t\t\t\t// for point lights we set the shadow matrix to be a translation-only matrix\n\t\t\t\t// equal to inverse of the light's position\n\t\t\t\t_vector3.setFromMatrixPosition( light.matrixWorld ).negate();\n\t\t\t\t_lights.pointShadowMatrix[ pointLength ].identity().setPosition( _vector3 );\n\n\t\t\t\t_lights.point[ pointLength ++ ] = uniforms;\n\n\t\t\t} else if ( light instanceof THREE.HemisphereLight ) {\n\n\t\t\t\tvar uniforms = lightCache.get( light );\n\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\t\t\t\tuniforms.direction.normalize();\n\n\t\t\t\tuniforms.skyColor.copy( light.color ).multiplyScalar( intensity );\n\t\t\t\tuniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );\n\n\t\t\t\t_lights.hemi[ hemiLength ++ ] = uniforms;\n\n\t\t\t}\n\n\t\t}\n\n\t\t_lights.ambient[ 0 ] = r;\n\t\t_lights.ambient[ 1 ] = g;\n\t\t_lights.ambient[ 2 ] = b;\n\n\t\t_lights.directional.length = directionalLength;\n\t\t_lights.spot.length = spotLength;\n\t\t_lights.point.length = pointLength;\n\t\t_lights.hemi.length = hemiLength;\n\n\t\t_lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + hemiLength + ',' + _lights.shadows.length;\n\n\t}\n\n\t// GL state setting\n\n\tthis.setFaceCulling = function ( cullFace, frontFaceDirection ) {\n\n\t\tstate.setCullFace( cullFace );\n\t\tstate.setFlipSided( frontFaceDirection === THREE.FrontFaceDirectionCW );\n\n\t};\n\n\t// Textures\n\n\tfunction allocTextureUnit() {\n\n\t\tvar textureUnit = _usedTextureUnits;\n\n\t\tif ( textureUnit >= capabilities.maxTextures ) {\n\n\t\t\tconsole.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );\n\n\t\t}\n\n\t\t_usedTextureUnits += 1;\n\n\t\treturn textureUnit;\n\n\t}\n\n\tthis.allocTextureUnit = allocTextureUnit;\n\n\t// this.setTexture2D = setTexture2D;\n\tthis.setTexture2D = ( function() {\n\n\t\tvar warned = false;\n\n\t\t// backwards compatibility: peel texture.texture\n\t\treturn function setTexture2D( texture, slot ) {\n\n\t\t\tif ( texture instanceof THREE.WebGLRenderTarget ) {\n\n\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.\" );\n\t\t\t\t\twarned = true;\n\n\t\t\t\t}\n\n\t\t\t\ttexture = texture.texture;\n\n\t\t\t}\n\n\t\t\ttextures.setTexture2D( texture, slot );\n\n\t\t};\n\n\t}() );\n\n\tthis.setTexture = ( function() {\n\n\t\tvar warned = false;\n\n\t\treturn function setTexture( texture, slot ) {\n\n\t\t\tif ( ! warned ) {\n\n\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.\" );\n\t\t\t\twarned = true;\n\n\t\t\t}\n\n\t\t\ttextures.setTexture2D( texture, slot );\n\n\t\t};\n\n\t}() );\n\n\tthis.setTextureCube = ( function() {\n\n\t\tvar warned = false;\n\n\t\treturn function setTextureCube( texture, slot ) {\n\n\t\t\t// backwards compatibility: peel texture.texture\n\t\t\tif ( texture instanceof THREE.WebGLRenderTargetCube ) {\n\n\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.\" );\n\t\t\t\t\twarned = true;\n\n\t\t\t\t}\n\n\t\t\t\ttexture = texture.texture;\n\n\t\t\t}\n\n\t\t\t// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture\n\t\t\t// TODO: unify these code paths\n\t\t\tif ( texture instanceof THREE.CubeTexture ||\n\t\t\t\t ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {\n\n\t\t\t\t// CompressedTexture can have Array in image :/\n\n\t\t\t\t// this function alone should take care of cube textures\n\t\t\t\ttextures.setTextureCube( texture, slot );\n\n\t\t\t} else {\n\n\t\t\t\t// assumed: texture property of THREE.WebGLRenderTargetCube\n\n\t\t\t\ttextures.setTextureCubeDynamic( texture, slot );\n\n\t\t\t}\n\n\t\t};\n\n\t}() );\n\n\tthis.getCurrentRenderTarget = function() {\n\n\t\treturn _currentRenderTarget;\n\n\t};\n\n\tthis.setRenderTarget = function ( renderTarget ) {\n\n\t\t_currentRenderTarget = renderTarget;\n\n\t\tif ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {\n\n\t\t\ttextures.setupRenderTarget( renderTarget );\n\n\t\t}\n\n\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\n\t\tvar framebuffer;\n\n\t\tif ( renderTarget ) {\n\n\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\tframebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];\n\n\t\t\t} else {\n\n\t\t\t\tframebuffer = renderTargetProperties.__webglFramebuffer;\n\n\t\t\t}\n\n\t\t\t_currentScissor.copy( renderTarget.scissor );\n\t\t\t_currentScissorTest = renderTarget.scissorTest;\n\n\t\t\t_currentViewport.copy( renderTarget.viewport );\n\n\t\t} else {\n\n\t\t\tframebuffer = null;\n\n\t\t\t_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );\n\t\t\t_currentScissorTest = _scissorTest;\n\n\t\t\t_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );\n\n\t\t}\n\n\t\tif ( _currentFramebuffer !== framebuffer ) {\n\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\t\t_currentFramebuffer = framebuffer;\n\n\t\t}\n\n\t\tstate.scissor( _currentScissor );\n\t\tstate.setScissorTest( _currentScissorTest );\n\n\t\tstate.viewport( _currentViewport );\n\n\t\tif ( isCube ) {\n\n\t\t\tvar textureProperties = properties.get( renderTarget.texture );\n\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );\n\n\t\t}\n\n\t};\n\n\tthis.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {\n\n\t\tif ( renderTarget instanceof THREE.WebGLRenderTarget === false ) {\n\n\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar framebuffer = properties.get( renderTarget ).__webglFramebuffer;\n\n\t\tif ( framebuffer ) {\n\n\t\t\tvar restore = false;\n\n\t\t\tif ( framebuffer !== _currentFramebuffer ) {\n\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\t\t\trestore = true;\n\n\t\t\t}\n\n\t\t\ttry {\n\n\t\t\t\tvar texture = renderTarget.texture;\n\n\t\t\t\tif ( texture.format !== THREE.RGBAFormat && paramThreeToGL( texture.format ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( texture.type !== THREE.UnsignedByteType &&\n\t\t\t\t     paramThreeToGL( texture.type ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) &&\n\t\t\t\t     ! ( texture.type === THREE.FloatType && extensions.get( 'WEBGL_color_buffer_float' ) ) &&\n\t\t\t\t     ! ( texture.type === THREE.HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {\n\n\t\t\t\t\t// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\n\n\t\t\t\t\tif ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {\n\n\t\t\t\t\t\t_gl.readPixels( x, y, width, height, paramThreeToGL( texture.format ), paramThreeToGL( texture.type ), buffer );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );\n\n\t\t\t\t}\n\n\t\t\t} finally {\n\n\t\t\t\tif ( restore ) {\n\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t// Map three.js constants to WebGL constants\n\n\tfunction paramThreeToGL ( p ) {\n\n\t\tvar extension;\n\n\t\tif ( p === THREE.RepeatWrapping ) return _gl.REPEAT;\n\t\tif ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;\n\t\tif ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;\n\n\t\tif ( p === THREE.NearestFilter ) return _gl.NEAREST;\n\t\tif ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;\n\t\tif ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;\n\n\t\tif ( p === THREE.LinearFilter ) return _gl.LINEAR;\n\t\tif ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;\n\t\tif ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;\n\n\t\tif ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;\n\t\tif ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;\n\t\tif ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;\n\t\tif ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;\n\n\t\tif ( p === THREE.ByteType ) return _gl.BYTE;\n\t\tif ( p === THREE.ShortType ) return _gl.SHORT;\n\t\tif ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;\n\t\tif ( p === THREE.IntType ) return _gl.INT;\n\t\tif ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;\n\t\tif ( p === THREE.FloatType ) return _gl.FLOAT;\n\n\t\textension = extensions.get( 'OES_texture_half_float' );\n\n\t\tif ( extension !== null ) {\n\n\t\t\tif ( p === THREE.HalfFloatType ) return extension.HALF_FLOAT_OES;\n\n\t\t}\n\n\t\tif ( p === THREE.AlphaFormat ) return _gl.ALPHA;\n\t\tif ( p === THREE.RGBFormat ) return _gl.RGB;\n\t\tif ( p === THREE.RGBAFormat ) return _gl.RGBA;\n\t\tif ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;\n\t\tif ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;\n\t\tif ( p === THREE.DepthFormat ) return _gl.DEPTH_COMPONENT;\n\n\t\tif ( p === THREE.AddEquation ) return _gl.FUNC_ADD;\n\t\tif ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;\n\t\tif ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;\n\n\t\tif ( p === THREE.ZeroFactor ) return _gl.ZERO;\n\t\tif ( p === THREE.OneFactor ) return _gl.ONE;\n\t\tif ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;\n\t\tif ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;\n\t\tif ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;\n\t\tif ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;\n\t\tif ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;\n\t\tif ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;\n\n\t\tif ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;\n\t\tif ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;\n\t\tif ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;\n\n\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\n\t\tif ( extension !== null ) {\n\n\t\t\tif ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n\n\t\t}\n\n\t\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\n\t\tif ( extension !== null ) {\n\n\t\t\tif ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n\t\t\tif ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n\t\t\tif ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n\t\t\tif ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n\n\t\t}\n\n\t\textension = extensions.get( 'WEBGL_compressed_texture_etc1' );\n\n\t\tif ( extension !== null ) {\n\n\t\t\tif ( p === THREE.RGB_ETC1_Format ) return extension.COMPRESSED_RGB_ETC1_WEBGL;\n\n\t\t}\n\n\t\textension = extensions.get( 'EXT_blend_minmax' );\n\n\t\tif ( extension !== null ) {\n\n\t\t\tif ( p === THREE.MinEquation ) return extension.MIN_EXT;\n\t\t\tif ( p === THREE.MaxEquation ) return extension.MAX_EXT;\n\n\t\t}\n\n\t\treturn 0;\n\n\t}\n\n};\n\n// File:src/renderers/WebGLRenderTarget.js\n\n/**\n * @author szimek / https://github.com/szimek/\n * @author alteredq / http://alteredqualia.com/\n * @author Marius Kintel / https://github.com/kintel\n */\n\n/*\n In options, we can specify:\n * Texture parameters for an auto-generated target texture\n * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\n*/\nTHREE.WebGLRenderTarget = function ( width, height, options ) {\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.width = width;\n\tthis.height = height;\n\n\tthis.scissor = new THREE.Vector4( 0, 0, width, height );\n\tthis.scissorTest = false;\n\n\tthis.viewport = new THREE.Vector4( 0, 0, width, height );\n\n\toptions = options || {};\n\n\tif ( options.minFilter === undefined ) options.minFilter = THREE.LinearFilter;\n\n\tthis.texture = new THREE.Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );\n\n\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\n\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\n\tthis.depthTexture = null;\n\n};\n\nObject.assign( THREE.WebGLRenderTarget.prototype, THREE.EventDispatcher.prototype, {\n\n\tsetSize: function ( width, height ) {\n\n\t\tif ( this.width !== width || this.height !== height ) {\n\n\t\t\tthis.width = width;\n\t\t\tthis.height = height;\n\n\t\t\tthis.dispose();\n\n\t\t}\n\n\t\tthis.viewport.set( 0, 0, width, height );\n\t\tthis.scissor.set( 0, 0, width, height );\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.width = source.width;\n\t\tthis.height = source.height;\n\n\t\tthis.viewport.copy( source.viewport );\n\n\t\tthis.texture = source.texture.clone();\n\n\t\tthis.depthBuffer = source.depthBuffer;\n\t\tthis.stencilBuffer = source.stencilBuffer;\n\t\tthis.depthTexture = source.depthTexture;\n\n\t\treturn this;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\n// File:src/renderers/WebGLRenderTargetCube.js\n\n/**\n * @author alteredq / http://alteredqualia.com\n */\n\nTHREE.WebGLRenderTargetCube = function ( width, height, options ) {\n\n\tTHREE.WebGLRenderTarget.call( this, width, height, options );\n\n\tthis.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\n\tthis.activeMipMapLevel = 0;\n\n};\n\nTHREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );\nTHREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;\n\n// File:src/renderers/webgl/WebGLBufferRenderer.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLBufferRenderer = function ( _gl, extensions, _infoRender ) {\n\n\tvar mode;\n\n\tfunction setMode( value ) {\n\n\t\tmode = value;\n\n\t}\n\n\tfunction render( start, count ) {\n\n\t\t_gl.drawArrays( mode, start, count );\n\n\t\t_infoRender.calls ++;\n\t\t_infoRender.vertices += count;\n\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;\n\n\t}\n\n\tfunction renderInstances( geometry ) {\n\n\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\tif ( extension === null ) {\n\n\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar position = geometry.attributes.position;\n\n\t\tvar count = 0;\n\n\t\tif ( position instanceof THREE.InterleavedBufferAttribute ) {\n\n\t\t\tcount = position.data.count;\n\n\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\n\n\t\t} else {\n\n\t\t\tcount = position.count;\n\n\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\n\n\t\t}\n\n\t\t_infoRender.calls ++;\n\t\t_infoRender.vertices += count * geometry.maxInstancedCount;\n\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += geometry.maxInstancedCount * count / 3;\n\n\t}\n\n\tthis.setMode = setMode;\n\tthis.render = render;\n\tthis.renderInstances = renderInstances;\n\n};\n\n// File:src/renderers/webgl/WebGLClipping.js\n\nTHREE.WebGLClipping = function() {\n\n\tvar scope = this,\n\n\t\tglobalState = null,\n\t\tnumGlobalPlanes = 0,\n\t\tlocalClippingEnabled = false,\n\t\trenderingShadows = false,\n\n\t\tplane = new THREE.Plane(),\n\t\tviewNormalMatrix = new THREE.Matrix3(),\n\n\t\tuniform = { value: null, needsUpdate: false };\n\n\tthis.uniform = uniform;\n\tthis.numPlanes = 0;\n\n\tthis.init = function( planes, enableLocalClipping, camera ) {\n\n\t\tvar enabled =\n\t\t\tplanes.length !== 0 ||\n\t\t\tenableLocalClipping ||\n\t\t\t// enable state of previous frame - the clipping code has to\n\t\t\t// run another frame in order to reset the state:\n\t\t\tnumGlobalPlanes !== 0 ||\n\t\t\tlocalClippingEnabled;\n\n\t\tlocalClippingEnabled = enableLocalClipping;\n\n\t\tglobalState = projectPlanes( planes, camera, 0 );\n\t\tnumGlobalPlanes = planes.length;\n\n\t\treturn enabled;\n\n\t};\n\n\tthis.beginShadows = function() {\n\n\t\trenderingShadows = true;\n\t\tprojectPlanes( null );\n\n\t};\n\n\tthis.endShadows = function() {\n\n\t\trenderingShadows = false;\n\t\tresetGlobalState();\n\n\t};\n\n\tthis.setState = function( planes, clipShadows, camera, cache, fromCache ) {\n\n\t\tif ( ! localClippingEnabled ||\n\t\t\t\tplanes === null || planes.length === 0 ||\n\t\t\t\trenderingShadows && ! clipShadows ) {\n\t\t\t// there's no local clipping\n\n\t\t\tif ( renderingShadows ) {\n\t\t\t\t// there's no global clipping\n\n\t\t\t\tprojectPlanes( null );\n\n\t\t\t} else {\n\n\t\t\t\tresetGlobalState();\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tvar nGlobal = renderingShadows ? 0 : numGlobalPlanes,\n\t\t\t\tlGlobal = nGlobal * 4,\n\n\t\t\t\tdstArray = cache.clippingState || null;\n\n\t\t\tuniform.value = dstArray; // ensure unique state\n\n\t\t\tdstArray = projectPlanes( planes, camera, lGlobal, fromCache );\n\n\t\t\tfor ( var i = 0; i !== lGlobal; ++ i ) {\n\n\t\t\t\tdstArray[ i ] = globalState[ i ];\n\n\t\t\t}\n\n\t\t\tcache.clippingState = dstArray;\n\t\t\tthis.numPlanes += nGlobal;\n\n\t\t}\n\n\n\t};\n\n\tfunction resetGlobalState() {\n\n\t\tif ( uniform.value !== globalState ) {\n\n\t\t\tuniform.value = globalState;\n\t\t\tuniform.needsUpdate = numGlobalPlanes > 0;\n\n\t\t}\n\n\t\tscope.numPlanes = numGlobalPlanes;\n\n\t}\n\n\tfunction projectPlanes( planes, camera, dstOffset, skipTransform ) {\n\n\t\tvar nPlanes = planes !== null ? planes.length : 0,\n\t\t\tdstArray = null;\n\n\t\tif ( nPlanes !== 0 ) {\n\n\t\t\tdstArray = uniform.value;\n\n\t\t\tif ( skipTransform !== true || dstArray === null ) {\n\n\t\t\t\tvar flatSize = dstOffset + nPlanes * 4,\n\t\t\t\t\tviewMatrix = camera.matrixWorldInverse;\n\n\t\t\t\tviewNormalMatrix.getNormalMatrix( viewMatrix );\n\n\t\t\t\tif ( dstArray === null || dstArray.length < flatSize ) {\n\n\t\t\t\t\tdstArray = new Float32Array( flatSize );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0, i4 = dstOffset;\n\t\t\t\t\t\t\t\t\ti !== nPlanes; ++ i, i4 += 4 ) {\n\n\t\t\t\t\tplane.copy( planes[ i ] ).\n\t\t\t\t\t\t\tapplyMatrix4( viewMatrix, viewNormalMatrix );\n\n\t\t\t\t\tplane.normal.toArray( dstArray, i4 );\n\t\t\t\t\tdstArray[ i4 + 3 ] = plane.constant;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tuniform.value = dstArray;\n\t\t\tuniform.needsUpdate = true;\n\n\t\t}\n\n\t\tscope.numPlanes = nPlanes;\n\t\treturn dstArray;\n\n\t}\n\n};\n\n\n// File:src/renderers/webgl/WebGLIndexedBufferRenderer.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLIndexedBufferRenderer = function ( _gl, extensions, _infoRender ) {\n\n\tvar mode;\n\n\tfunction setMode( value ) {\n\n\t\tmode = value;\n\n\t}\n\n\tvar type, size;\n\n\tfunction setIndex( index ) {\n\n\t\tif ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {\n\n\t\t\ttype = _gl.UNSIGNED_INT;\n\t\t\tsize = 4;\n\n\t\t} else {\n\n\t\t\ttype = _gl.UNSIGNED_SHORT;\n\t\t\tsize = 2;\n\n\t\t}\n\n\t}\n\n\tfunction render( start, count ) {\n\n\t\t_gl.drawElements( mode, count, type, start * size );\n\n\t\t_infoRender.calls ++;\n\t\t_infoRender.vertices += count;\n\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;\n\n\t}\n\n\tfunction renderInstances( geometry, start, count ) {\n\n\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\tif ( extension === null ) {\n\n\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\textension.drawElementsInstancedANGLE( mode, count, type, start * size, geometry.maxInstancedCount );\n\n\t\t_infoRender.calls ++;\n\t\t_infoRender.vertices += count * geometry.maxInstancedCount;\n\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += geometry.maxInstancedCount * count / 3;\n\t}\n\n\tthis.setMode = setMode;\n\tthis.setIndex = setIndex;\n\tthis.render = render;\n\tthis.renderInstances = renderInstances;\n\n};\n\n// File:src/renderers/webgl/WebGLExtensions.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLExtensions = function ( gl ) {\n\n\tvar extensions = {};\n\n\tthis.get = function ( name ) {\n\n\t\tif ( extensions[ name ] !== undefined ) {\n\n\t\t\treturn extensions[ name ];\n\n\t\t}\n\n\t\tvar extension;\n\n\t\tswitch ( name ) {\n\n\t\t\tcase 'WEBGL_depth_texture':\n\t\t\t\textension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );\n\t\t\t\tbreak;\n\n\t\t\tcase 'EXT_texture_filter_anisotropic':\n\t\t\t\textension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\n\t\t\t\tbreak;\n\n\t\t\tcase 'WEBGL_compressed_texture_s3tc':\n\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\n\t\t\t\tbreak;\n\n\t\t\tcase 'WEBGL_compressed_texture_pvrtc':\n\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\n\t\t\t\tbreak;\n\n\t\t\tcase 'WEBGL_compressed_texture_etc1':\n\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\textension = gl.getExtension( name );\n\n\t\t}\n\n\t\tif ( extension === null ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\n\n\t\t}\n\n\t\textensions[ name ] = extension;\n\n\t\treturn extension;\n\n\t};\n\n};\n\n// File:src/renderers/webgl/WebGLCapabilities.js\n\nTHREE.WebGLCapabilities = function ( gl, extensions, parameters ) {\n\n\tvar maxAnisotropy;\n\n\tfunction getMaxAnisotropy() {\n\n\t\tif ( maxAnisotropy !== undefined ) return maxAnisotropy;\n\n\t\tvar extension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\n\t\tif ( extension !== null ) {\n\n\t\t\tmaxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\n\n\t\t} else {\n\n\t\t\tmaxAnisotropy = 0;\n\n\t\t}\n\n\t\treturn maxAnisotropy;\n\n\t}\n\n\tfunction getMaxPrecision( precision ) {\n\n\t\tif ( precision === 'highp' ) {\n\n\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&\n\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {\n\n\t\t\t\treturn 'highp';\n\n\t\t\t}\n\n\t\t\tprecision = 'mediump';\n\n\t\t}\n\n\t\tif ( precision === 'mediump' ) {\n\n\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&\n\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {\n\n\t\t\t\treturn 'mediump';\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn 'lowp';\n\n\t}\n\n\tthis.getMaxAnisotropy = getMaxAnisotropy;\n\tthis.getMaxPrecision = getMaxPrecision;\n\n\tthis.precision = parameters.precision !== undefined ? parameters.precision : 'highp';\n\tthis.logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false;\n\n\tthis.maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\n\tthis.maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\n\tthis.maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );\n\tthis.maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );\n\n\tthis.maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\tthis.maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );\n\tthis.maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );\n\tthis.maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );\n\n\tthis.vertexTextures = this.maxVertexTextures > 0;\n\tthis.floatFragmentTextures = !! extensions.get( 'OES_texture_float' );\n\tthis.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;\n\n\tvar _maxPrecision = getMaxPrecision( this.precision );\n\n\tif ( _maxPrecision !== this.precision ) {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer:', this.precision, 'not supported, using', _maxPrecision, 'instead.' );\n\t\tthis.precision = _maxPrecision;\n\n\t}\n\n\tif ( this.logarithmicDepthBuffer ) {\n\n\t\tthis.logarithmicDepthBuffer = !! extensions.get( 'EXT_frag_depth' );\n\n\t}\n\n};\n\n// File:src/renderers/webgl/WebGLGeometries.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLGeometries = function ( gl, properties, info ) {\n\n\tvar geometries = {};\n\n\tfunction get( object ) {\n\n\t\tvar geometry = object.geometry;\n\n\t\tif ( geometries[ geometry.id ] !== undefined ) {\n\n\t\t\treturn geometries[ geometry.id ];\n\n\t\t}\n\n\t\tgeometry.addEventListener( 'dispose', onGeometryDispose );\n\n\t\tvar buffergeometry;\n\n\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\tbuffergeometry = geometry;\n\n\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\n\t\t\tif ( geometry._bufferGeometry === undefined ) {\n\n\t\t\t\tgeometry._bufferGeometry = new THREE.BufferGeometry().setFromObject( object );\n\n\t\t\t}\n\n\t\t\tbuffergeometry = geometry._bufferGeometry;\n\n\t\t}\n\n\t\tgeometries[ geometry.id ] = buffergeometry;\n\n\t\tinfo.memory.geometries ++;\n\n\t\treturn buffergeometry;\n\n\t}\n\n\tfunction onGeometryDispose( event ) {\n\n\t\tvar geometry = event.target;\n\t\tvar buffergeometry = geometries[ geometry.id ];\n\n\t\tif ( buffergeometry.index !== null ) {\n\n\t\t\tdeleteAttribute( buffergeometry.index );\n\n\t\t}\n\n\t\tdeleteAttributes( buffergeometry.attributes );\n\n\t\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\n\n\t\tdelete geometries[ geometry.id ];\n\n\t\t// TODO\n\n\t\tvar property = properties.get( geometry );\n\n\t\tif ( property.wireframe ) {\n\n\t\t\tdeleteAttribute( property.wireframe );\n\n\t\t}\n\n\t\tproperties.delete( geometry );\n\n\t\tvar bufferproperty = properties.get( buffergeometry );\n\n\t\tif ( bufferproperty.wireframe ) {\n\n\t\t\tdeleteAttribute( bufferproperty.wireframe );\n\n\t\t}\n\n\t\tproperties.delete( buffergeometry );\n\n\t\t//\n\n\t\tinfo.memory.geometries --;\n\n\t}\n\n\tfunction getAttributeBuffer( attribute ) {\n\n\t\tif ( attribute instanceof THREE.InterleavedBufferAttribute ) {\n\n\t\t\treturn properties.get( attribute.data ).__webglBuffer;\n\n\t\t}\n\n\t\treturn properties.get( attribute ).__webglBuffer;\n\n\t}\n\n\tfunction deleteAttribute( attribute ) {\n\n\t\tvar buffer = getAttributeBuffer( attribute );\n\n\t\tif ( buffer !== undefined ) {\n\n\t\t\tgl.deleteBuffer( buffer );\n\t\t\tremoveAttributeBuffer( attribute );\n\n\t\t}\n\n\t}\n\n\tfunction deleteAttributes( attributes ) {\n\n\t\tfor ( var name in attributes ) {\n\n\t\t\tdeleteAttribute( attributes[ name ] );\n\n\t\t}\n\n\t}\n\n\tfunction removeAttributeBuffer( attribute ) {\n\n\t\tif ( attribute instanceof THREE.InterleavedBufferAttribute ) {\n\n\t\t\tproperties.delete( attribute.data );\n\n\t\t} else {\n\n\t\t\tproperties.delete( attribute );\n\n\t\t}\n\n\t}\n\n\tthis.get = get;\n\n};\n\n// File:src/renderers/webgl/WebGLLights.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLLights = function () {\n\n\tvar lights = {};\n\n\tthis.get = function ( light ) {\n\n\t\tif ( lights[ light.id ] !== undefined ) {\n\n\t\t\treturn lights[ light.id ];\n\n\t\t}\n\n\t\tvar uniforms;\n\n\t\tswitch ( light.type ) {\n\n\t\t\tcase 'DirectionalLight':\n\t\t\t\tuniforms = {\n\t\t\t\t\tdirection: new THREE.Vector3(),\n\t\t\t\t\tcolor: new THREE.Color(),\n\n\t\t\t\t\tshadow: false,\n\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\tshadowMapSize: new THREE.Vector2()\n\t\t\t\t};\n\t\t\t\tbreak;\n\n\t\t\tcase 'SpotLight':\n\t\t\t\tuniforms = {\n\t\t\t\t\tposition: new THREE.Vector3(),\n\t\t\t\t\tdirection: new THREE.Vector3(),\n\t\t\t\t\tcolor: new THREE.Color(),\n\t\t\t\t\tdistance: 0,\n\t\t\t\t\tconeCos: 0,\n\t\t\t\t\tpenumbraCos: 0,\n\t\t\t\t\tdecay: 0,\n\n\t\t\t\t\tshadow: false,\n\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\tshadowMapSize: new THREE.Vector2()\n\t\t\t\t};\n\t\t\t\tbreak;\n\n\t\t\tcase 'PointLight':\n\t\t\t\tuniforms = {\n\t\t\t\t\tposition: new THREE.Vector3(),\n\t\t\t\t\tcolor: new THREE.Color(),\n\t\t\t\t\tdistance: 0,\n\t\t\t\t\tdecay: 0,\n\n\t\t\t\t\tshadow: false,\n\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\tshadowMapSize: new THREE.Vector2()\n\t\t\t\t};\n\t\t\t\tbreak;\n\n\t\t\tcase 'HemisphereLight':\n\t\t\t\tuniforms = {\n\t\t\t\t\tdirection: new THREE.Vector3(),\n\t\t\t\t\tskyColor: new THREE.Color(),\n\t\t\t\t\tgroundColor: new THREE.Color()\n\t\t\t\t};\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tlights[ light.id ] = uniforms;\n\n\t\treturn uniforms;\n\n\t};\n\n};\n\n// File:src/renderers/webgl/WebGLObjects.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLObjects = function ( gl, properties, info ) {\n\n\tvar geometries = new THREE.WebGLGeometries( gl, properties, info );\n\n\t//\n\n\tfunction update( object ) {\n\n\t\t// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.\n\n\t\tvar geometry = geometries.get( object );\n\n\t\tif ( object.geometry instanceof THREE.Geometry ) {\n\n\t\t\tgeometry.updateFromObject( object );\n\n\t\t}\n\n\t\tvar index = geometry.index;\n\t\tvar attributes = geometry.attributes;\n\n\t\tif ( index !== null ) {\n\n\t\t\tupdateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );\n\n\t\t}\n\n\t\tfor ( var name in attributes ) {\n\n\t\t\tupdateAttribute( attributes[ name ], gl.ARRAY_BUFFER );\n\n\t\t}\n\n\t\t// morph targets\n\n\t\tvar morphAttributes = geometry.morphAttributes;\n\n\t\tfor ( var name in morphAttributes ) {\n\n\t\t\tvar array = morphAttributes[ name ];\n\n\t\t\tfor ( var i = 0, l = array.length; i < l; i ++ ) {\n\n\t\t\t\tupdateAttribute( array[ i ], gl.ARRAY_BUFFER );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn geometry;\n\n\t}\n\n\tfunction updateAttribute( attribute, bufferType ) {\n\n\t\tvar data = ( attribute instanceof THREE.InterleavedBufferAttribute ) ? attribute.data : attribute;\n\n\t\tvar attributeProperties = properties.get( data );\n\n\t\tif ( attributeProperties.__webglBuffer === undefined ) {\n\n\t\t\tcreateBuffer( attributeProperties, data, bufferType );\n\n\t\t} else if ( attributeProperties.version !== data.version ) {\n\n\t\t\tupdateBuffer( attributeProperties, data, bufferType );\n\n\t\t}\n\n\t}\n\n\tfunction createBuffer( attributeProperties, data, bufferType ) {\n\n\t\tattributeProperties.__webglBuffer = gl.createBuffer();\n\t\tgl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\n\n\t\tvar usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;\n\n\t\tgl.bufferData( bufferType, data.array, usage );\n\n\t\tattributeProperties.version = data.version;\n\n\t}\n\n\tfunction updateBuffer( attributeProperties, data, bufferType ) {\n\n\t\tgl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\n\n\t\tif ( data.dynamic === false || data.updateRange.count === - 1 ) {\n\n\t\t\t// Not using update ranges\n\n\t\t\tgl.bufferSubData( bufferType, 0, data.array );\n\n\t\t} else if ( data.updateRange.count === 0 ) {\n\n\t\t\tconsole.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );\n\n\t\t} else {\n\n\t\t\tgl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,\n\t\t\t\t\t\t\t  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );\n\n\t\t\tdata.updateRange.count = 0; // reset range\n\n\t\t}\n\n\t\tattributeProperties.version = data.version;\n\n\t}\n\n\tfunction getAttributeBuffer( attribute ) {\n\n\t\tif ( attribute instanceof THREE.InterleavedBufferAttribute ) {\n\n\t\t\treturn properties.get( attribute.data ).__webglBuffer;\n\n\t\t}\n\n\t\treturn properties.get( attribute ).__webglBuffer;\n\n\t}\n\n\tfunction getWireframeAttribute( geometry ) {\n\n\t\tvar property = properties.get( geometry );\n\n\t\tif ( property.wireframe !== undefined ) {\n\n\t\t\treturn property.wireframe;\n\n\t\t}\n\n\t\tvar indices = [];\n\n\t\tvar index = geometry.index;\n\t\tvar attributes = geometry.attributes;\n\t\tvar position = attributes.position;\n\n\t\t// console.time( 'wireframe' );\n\n\t\tif ( index !== null ) {\n\n\t\t\tvar edges = {};\n\t\t\tvar array = index.array;\n\n\t\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\t\tvar a = array[ i + 0 ];\n\t\t\t\tvar b = array[ i + 1 ];\n\t\t\t\tvar c = array[ i + 2 ];\n\n\t\t\t\tif ( checkEdge( edges, a, b ) ) indices.push( a, b );\n\t\t\t\tif ( checkEdge( edges, b, c ) ) indices.push( b, c );\n\t\t\t\tif ( checkEdge( edges, c, a ) ) indices.push( c, a );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tvar array = attributes.position.array;\n\n\t\t\tfor ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\n\n\t\t\t\tvar a = i + 0;\n\t\t\t\tvar b = i + 1;\n\t\t\t\tvar c = i + 2;\n\n\t\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// console.timeEnd( 'wireframe' );\n\n\t\tvar TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;\n\t\tvar attribute = new THREE.BufferAttribute( new TypeArray( indices ), 1 );\n\n\t\tupdateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );\n\n\t\tproperty.wireframe = attribute;\n\n\t\treturn attribute;\n\n\t}\n\n\tfunction checkEdge( edges, a, b ) {\n\n\t\tif ( a > b ) {\n\n\t\t\tvar tmp = a;\n\t\t\ta = b;\n\t\t\tb = tmp;\n\n\t\t}\n\n\t\tvar list = edges[ a ];\n\n\t\tif ( list === undefined ) {\n\n\t\t\tedges[ a ] = [ b ];\n\t\t\treturn true;\n\n\t\t} else if ( list.indexOf( b ) === -1 ) {\n\n\t\t\tlist.push( b );\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tthis.getAttributeBuffer = getAttributeBuffer;\n\tthis.getWireframeAttribute = getWireframeAttribute;\n\n\tthis.update = update;\n\n};\n\n// File:src/renderers/webgl/WebGLProgram.js\n\nTHREE.WebGLProgram = ( function () {\n\n\tvar programIdCount = 0;\n\n\tfunction getEncodingComponents( encoding ) {\n\n\t\tswitch ( encoding ) {\n\n\t\t\tcase THREE.LinearEncoding:\n\t\t\t\treturn [ 'Linear','( value )' ];\n\t\t\tcase THREE.sRGBEncoding:\n\t\t\t\treturn [ 'sRGB','( value )' ];\n\t\t\tcase THREE.RGBEEncoding:\n\t\t\t\treturn [ 'RGBE','( value )' ];\n\t\t\tcase THREE.RGBM7Encoding:\n\t\t\t\treturn [ 'RGBM','( value, 7.0 )' ];\n\t\t\tcase THREE.RGBM16Encoding:\n\t\t\t\treturn [ 'RGBM','( value, 16.0 )' ];\n\t\t\tcase THREE.RGBDEncoding:\n\t\t\t\treturn [ 'RGBD','( value, 256.0 )' ];\n\t\t\tcase THREE.GammaEncoding:\n\t\t\t\treturn [ 'Gamma','( value, float( GAMMA_FACTOR ) )' ];\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'unsupported encoding: ' + encoding );\n\n\t\t}\n\n\t}\n\n\tfunction getTexelDecodingFunction( functionName, encoding ) {\n\n\t\tvar components = getEncodingComponents( encoding );\n\t\treturn \"vec4 \" + functionName + \"( vec4 value ) { return \" + components[ 0 ] + \"ToLinear\" + components[ 1 ] + \"; }\";\n\n\t}\n\n\tfunction getTexelEncodingFunction( functionName, encoding ) {\n\n\t\tvar components = getEncodingComponents( encoding );\n\t\treturn \"vec4 \" + functionName + \"( vec4 value ) { return LinearTo\" + components[ 0 ] + components[ 1 ] + \"; }\";\n\n\t}\n\n\tfunction getToneMappingFunction( functionName, toneMapping ) {\n\n\t\tvar toneMappingName;\n\n\t\tswitch ( toneMapping ) {\n\n\t\t\tcase THREE.LinearToneMapping:\n\t\t\t\ttoneMappingName = \"Linear\";\n\t\t\t\tbreak;\n\n\t\t\tcase THREE.ReinhardToneMapping:\n\t\t\t\ttoneMappingName = \"Reinhard\";\n\t\t\t\tbreak;\n\n\t\t\tcase THREE.Uncharted2ToneMapping:\n\t\t\t\ttoneMappingName = \"Uncharted2\";\n\t\t\t\tbreak;\n\n\t\t\tcase THREE.CineonToneMapping:\n\t\t\t\ttoneMappingName = \"OptimizedCineon\";\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'unsupported toneMapping: ' + toneMapping );\n\n\t\t}\n\n\t\treturn \"vec3 \" + functionName + \"( vec3 color ) { return \" + toneMappingName + \"ToneMapping( color ); }\";\n\n\t}\n\n\tfunction generateExtensions( extensions, parameters, rendererExtensions ) {\n\n\t\textensions = extensions || {};\n\n\t\tvar chunks = [\n\t\t\t( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',\n\t\t\t( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',\n\t\t\t( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',\n\t\t\t( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : '',\n\t\t];\n\n\t\treturn chunks.filter( filterEmptyLine ).join( '\\n' );\n\n\t}\n\n\tfunction generateDefines( defines ) {\n\n\t\tvar chunks = [];\n\n\t\tfor ( var name in defines ) {\n\n\t\t\tvar value = defines[ name ];\n\n\t\t\tif ( value === false ) continue;\n\n\t\t\tchunks.push( '#define ' + name + ' ' + value );\n\n\t\t}\n\n\t\treturn chunks.join( '\\n' );\n\n\t}\n\n\tfunction fetchAttributeLocations( gl, program, identifiers ) {\n\n\t\tvar attributes = {};\n\n\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );\n\n\t\tfor ( var i = 0; i < n; i ++ ) {\n\n\t\t\tvar info = gl.getActiveAttrib( program, i );\n\t\t\tvar name = info.name;\n\n\t\t\t// console.log(\"THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:\", name, i );\n\n\t\t\tattributes[ name ] = gl.getAttribLocation( program, name );\n\n\t\t}\n\n\t\treturn attributes;\n\n\t}\n\n\tfunction filterEmptyLine( string ) {\n\n\t\treturn string !== '';\n\n\t}\n\n\tfunction replaceLightNums( string, parameters ) {\n\n\t\treturn string\n\t\t\t.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )\n\t\t\t.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )\n\t\t\t.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )\n\t\t\t.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );\n\n\t}\n\n\tfunction parseIncludes( string ) {\n\n\t\tvar pattern = /#include +<([\\w\\d.]+)>/g;\n\n\t\tfunction replace( match, include ) {\n\n\t\t\tvar replace = THREE.ShaderChunk[ include ];\n\n\t\t\tif ( replace === undefined ) {\n\n\t\t\t\tthrow new Error( 'Can not resolve #include <' + include + '>' );\n\n\t\t\t}\n\n\t\t\treturn parseIncludes( replace );\n\n\t\t}\n\n\t\treturn string.replace( pattern, replace );\n\n\t}\n\n\tfunction unrollLoops( string ) {\n\n\t\tvar pattern = /for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g;\n\n\t\tfunction replace( match, start, end, snippet ) {\n\n\t\t\tvar unroll = '';\n\n\t\t\tfor ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {\n\n\t\t\t\tunroll += snippet.replace( /\\[ i \\]/g, '[ ' + i + ' ]' );\n\n\t\t\t}\n\n\t\t\treturn unroll;\n\n\t\t}\n\n\t\treturn string.replace( pattern, replace );\n\n\t}\n\n\treturn function WebGLProgram( renderer, code, material, parameters ) {\n\n\t\tvar gl = renderer.context;\n\n\t\tvar extensions = material.extensions;\n\t\tvar defines = material.defines;\n\n\t\tvar vertexShader = material.__webglShader.vertexShader;\n\t\tvar fragmentShader = material.__webglShader.fragmentShader;\n\n\t\tvar shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\n\n\t\tif ( parameters.shadowMapType === THREE.PCFShadowMap ) {\n\n\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\n\n\t\t} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {\n\n\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\n\n\t\t}\n\n\t\tvar envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\tvar envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\n\t\tvar envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\n\t\tif ( parameters.envMap ) {\n\n\t\t\tswitch ( material.envMap.mapping ) {\n\n\t\t\t\tcase THREE.CubeReflectionMapping:\n\t\t\t\tcase THREE.CubeRefractionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.CubeUVReflectionMapping:\n\t\t\t\tcase THREE.CubeUVRefractionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.EquirectangularReflectionMapping:\n\t\t\t\tcase THREE.EquirectangularRefractionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.SphericalReflectionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_SPHERE';\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tswitch ( material.envMap.mapping ) {\n\n\t\t\t\tcase THREE.CubeRefractionMapping:\n\t\t\t\tcase THREE.EquirectangularRefractionMapping:\n\t\t\t\t\tenvMapModeDefine = 'ENVMAP_MODE_REFRACTION';\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tswitch ( material.combine ) {\n\n\t\t\t\tcase THREE.MultiplyOperation:\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.MixOperation:\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.AddOperation:\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;\n\n\t\t// console.log( 'building new program ' );\n\n\t\t//\n\n\t\tvar customExtensions = generateExtensions( extensions, parameters, renderer.extensions );\n\n\t\tvar customDefines = generateDefines( defines );\n\n\t\t//\n\n\t\tvar program = gl.createProgram();\n\n\t\tvar prefixVertex, prefixFragment;\n\n\t\tif ( material instanceof THREE.RawShaderMaterial ) {\n\n\t\t\tprefixVertex = [\n\n\t\t\t\tcustomDefines\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t\tprefixFragment = [\n\n\t\t\t\tcustomDefines\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t} else {\n\n\t\t\tprefixVertex = [\n\n\t\t\t\t'precision ' + parameters.precision + ' float;',\n\t\t\t\t'precision ' + parameters.precision + ' int;',\n\n\t\t\t\t'#define SHADER_NAME ' + material.__webglShader.name,\n\n\t\t\t\tcustomDefines,\n\n\t\t\t\tparameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',\n\n\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\n\n\t\t\t\t'#define MAX_BONES ' + parameters.maxBones,\n\n\t\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\t\tparameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',\n\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\n\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\n\t\t\t\tparameters.skinning ? '#define USE_SKINNING' : '',\n\t\t\t\tparameters.useVertexTexture ? '#define BONE_TEXTURE' : '',\n\n\t\t\t\tparameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\n\t\t\t\tparameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',\n\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\n\t\t\t\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\n\n\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\n\t\t\t\tparameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\n\n\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\t\tparameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\n\t\t\t\t'uniform mat4 modelMatrix;',\n\t\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t\t'uniform mat3 normalMatrix;',\n\t\t\t\t'uniform vec3 cameraPosition;',\n\n\t\t\t\t'attribute vec3 position;',\n\t\t\t\t'attribute vec3 normal;',\n\t\t\t\t'attribute vec2 uv;',\n\n\t\t\t\t'#ifdef USE_COLOR',\n\n\t\t\t\t'\tattribute vec3 color;',\n\n\t\t\t\t'#endif',\n\n\t\t\t\t'#ifdef USE_MORPHTARGETS',\n\n\t\t\t\t'\tattribute vec3 morphTarget0;',\n\t\t\t\t'\tattribute vec3 morphTarget1;',\n\t\t\t\t'\tattribute vec3 morphTarget2;',\n\t\t\t\t'\tattribute vec3 morphTarget3;',\n\n\t\t\t\t'\t#ifdef USE_MORPHNORMALS',\n\n\t\t\t\t'\t\tattribute vec3 morphNormal0;',\n\t\t\t\t'\t\tattribute vec3 morphNormal1;',\n\t\t\t\t'\t\tattribute vec3 morphNormal2;',\n\t\t\t\t'\t\tattribute vec3 morphNormal3;',\n\n\t\t\t\t'\t#else',\n\n\t\t\t\t'\t\tattribute vec3 morphTarget4;',\n\t\t\t\t'\t\tattribute vec3 morphTarget5;',\n\t\t\t\t'\t\tattribute vec3 morphTarget6;',\n\t\t\t\t'\t\tattribute vec3 morphTarget7;',\n\n\t\t\t\t'\t#endif',\n\n\t\t\t\t'#endif',\n\n\t\t\t\t'#ifdef USE_SKINNING',\n\n\t\t\t\t'\tattribute vec4 skinIndex;',\n\t\t\t\t'\tattribute vec4 skinWeight;',\n\n\t\t\t\t'#endif',\n\n\t\t\t\t'\\n'\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t\tprefixFragment = [\n\n\t\t\t\tcustomExtensions,\n\n\t\t\t\t'precision ' + parameters.precision + ' float;',\n\t\t\t\t'precision ' + parameters.precision + ' int;',\n\n\t\t\t\t'#define SHADER_NAME ' + material.__webglShader.name,\n\n\t\t\t\tcustomDefines,\n\n\t\t\t\tparameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',\n\n\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\n\n\t\t\t\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\n\t\t\t\t( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\n\n\t\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapTypeDefine : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapBlendingDefine : '',\n\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\n\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\n\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\n\t\t\t\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\n\n\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\n\t\t\t\tparameters.premultipliedAlpha ? \"#define PREMULTIPLIED_ALPHA\" : '',\n\n\t\t\t\tparameters.physicallyCorrectLights ? \"#define PHYSICALLY_CORRECT_LIGHTS\" : '',\n\n\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\t\tparameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\n\t\t\t\tparameters.envMap && renderer.extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',\n\n\t\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t\t'uniform vec3 cameraPosition;',\n\n\t\t\t\t( parameters.toneMapping !== THREE.NoToneMapping ) ? \"#define TONE_MAPPING\" : '',\n\t\t\t\t( parameters.toneMapping !== THREE.NoToneMapping ) ? THREE.ShaderChunk[ 'tonemapping_pars_fragment' ] : '',  // this code is required here because it is used by the toneMapping() function defined below\n\t\t\t\t( parameters.toneMapping !== THREE.NoToneMapping ) ? getToneMappingFunction( \"toneMapping\", parameters.toneMapping ) : '',\n\n\t\t\t\t( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? THREE.ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below\n\t\t\t\tparameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',\n\t\t\t\tparameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',\n\t\t\t\tparameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',\n\t\t\t\tparameters.outputEncoding ? getTexelEncodingFunction( \"linearToOutputTexel\", parameters.outputEncoding ) : '',\n\n\t\t\t\tparameters.depthPacking ? \"#define DEPTH_PACKING \" + material.depthPacking : '',\n\n\t\t\t\t'\\n'\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t}\n\n\t\tvertexShader = parseIncludes( vertexShader, parameters );\n\t\tvertexShader = replaceLightNums( vertexShader, parameters );\n\n\t\tfragmentShader = parseIncludes( fragmentShader, parameters );\n\t\tfragmentShader = replaceLightNums( fragmentShader, parameters );\n\n\t\tif ( material instanceof THREE.ShaderMaterial === false ) {\n\n\t\t\tvertexShader = unrollLoops( vertexShader );\n\t\t\tfragmentShader = unrollLoops( fragmentShader );\n\n\t\t}\n\n\t\tvar vertexGlsl = prefixVertex + vertexShader;\n\t\tvar fragmentGlsl = prefixFragment + fragmentShader;\n\n\t\t// console.log( '*VERTEX*', vertexGlsl );\n\t\t// console.log( '*FRAGMENT*', fragmentGlsl );\n\n\t\tvar glVertexShader = THREE.WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );\n\t\tvar glFragmentShader = THREE.WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );\n\n\t\tgl.attachShader( program, glVertexShader );\n\t\tgl.attachShader( program, glFragmentShader );\n\n\t\t// Force a particular attribute to index 0.\n\n\t\tif ( material.index0AttributeName !== undefined ) {\n\n\t\t\tgl.bindAttribLocation( program, 0, material.index0AttributeName );\n\n\t\t} else if ( parameters.morphTargets === true ) {\n\n\t\t\t// programs with morphTargets displace position out of attribute 0\n\t\t\tgl.bindAttribLocation( program, 0, 'position' );\n\n\t\t}\n\n\t\tgl.linkProgram( program );\n\n\t\tvar programLog = gl.getProgramInfoLog( program );\n\t\tvar vertexLog = gl.getShaderInfoLog( glVertexShader );\n\t\tvar fragmentLog = gl.getShaderInfoLog( glFragmentShader );\n\n\t\tvar runnable = true;\n\t\tvar haveDiagnostics = true;\n\n\t\t// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );\n\t\t// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );\n\n\t\tif ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {\n\n\t\t\trunnable = false;\n\n\t\t\tconsole.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );\n\n\t\t} else if ( programLog !== '' ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );\n\n\t\t} else if ( vertexLog === '' || fragmentLog === '' ) {\n\n\t\t\thaveDiagnostics = false;\n\n\t\t}\n\n\t\tif ( haveDiagnostics ) {\n\n\t\t\tthis.diagnostics = {\n\n\t\t\t\trunnable: runnable,\n\t\t\t\tmaterial: material,\n\n\t\t\t\tprogramLog: programLog,\n\n\t\t\t\tvertexShader: {\n\n\t\t\t\t\tlog: vertexLog,\n\t\t\t\t\tprefix: prefixVertex\n\n\t\t\t\t},\n\n\t\t\t\tfragmentShader: {\n\n\t\t\t\t\tlog: fragmentLog,\n\t\t\t\t\tprefix: prefixFragment\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\t// clean up\n\n\t\tgl.deleteShader( glVertexShader );\n\t\tgl.deleteShader( glFragmentShader );\n\n\t\t// set up caching for uniform locations\n\n\t\tvar cachedUniforms;\n\n\t\tthis.getUniforms = function() {\n\n\t\t\tif ( cachedUniforms === undefined ) {\n\n\t\t\t\tcachedUniforms =\n\t\t\t\t\t\tnew THREE.WebGLUniforms( gl, program, renderer );\n\n\t\t\t}\n\n\t\t\treturn cachedUniforms;\n\n\t\t};\n\n\t\t// set up caching for attribute locations\n\n\t\tvar cachedAttributes;\n\n\t\tthis.getAttributes = function() {\n\n\t\t\tif ( cachedAttributes === undefined ) {\n\n\t\t\t\tcachedAttributes = fetchAttributeLocations( gl, program );\n\n\t\t\t}\n\n\t\t\treturn cachedAttributes;\n\n\t\t};\n\n\t\t// free resource\n\n\t\tthis.destroy = function() {\n\n\t\t\tgl.deleteProgram( program );\n\t\t\tthis.program = undefined;\n\n\t\t};\n\n\t\t// DEPRECATED\n\n\t\tObject.defineProperties( this, {\n\n\t\t\tuniforms: {\n\t\t\t\tget: function() {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );\n\t\t\t\t\treturn this.getUniforms();\n\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tattributes: {\n\t\t\t\tget: function() {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );\n\t\t\t\t\treturn this.getAttributes();\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t} );\n\n\n\t\t//\n\n\t\tthis.id = programIdCount ++;\n\t\tthis.code = code;\n\t\tthis.usedTimes = 1;\n\t\tthis.program = program;\n\t\tthis.vertexShader = glVertexShader;\n\t\tthis.fragmentShader = glFragmentShader;\n\n\t\treturn this;\n\n\t};\n\n} )();\n\n// File:src/renderers/webgl/WebGLPrograms.js\n\nTHREE.WebGLPrograms = function ( renderer, capabilities ) {\n\n\tvar programs = [];\n\n\tvar shaderIDs = {\n\t\tMeshDepthMaterial: 'depth',\n\t\tMeshNormalMaterial: 'normal',\n\t\tMeshBasicMaterial: 'basic',\n\t\tMeshLambertMaterial: 'lambert',\n\t\tMeshPhongMaterial: 'phong',\n\t\tMeshStandardMaterial: 'physical',\n\t\tMeshPhysicalMaterial: 'physical',\n\t\tLineBasicMaterial: 'basic',\n\t\tLineDashedMaterial: 'dashed',\n\t\tPointsMaterial: 'points'\n\t};\n\n\tvar parameterNames = [\n\t\t\"precision\", \"supportsVertexTextures\", \"map\", \"mapEncoding\", \"envMap\", \"envMapMode\", \"envMapEncoding\",\n\t\t\"lightMap\", \"aoMap\", \"emissiveMap\", \"emissiveMapEncoding\", \"bumpMap\", \"normalMap\", \"displacementMap\", \"specularMap\",\n\t\t\"roughnessMap\", \"metalnessMap\",\n\t\t\"alphaMap\", \"combine\", \"vertexColors\", \"fog\", \"useFog\", \"fogExp\",\n\t\t\"flatShading\", \"sizeAttenuation\", \"logarithmicDepthBuffer\", \"skinning\",\n\t\t\"maxBones\", \"useVertexTexture\", \"morphTargets\", \"morphNormals\",\n\t\t\"maxMorphTargets\", \"maxMorphNormals\", \"premultipliedAlpha\",\n\t\t\"numDirLights\", \"numPointLights\", \"numSpotLights\", \"numHemiLights\",\n\t\t\"shadowMapEnabled\", \"shadowMapType\", \"toneMapping\", 'physicallyCorrectLights',\n\t\t\"alphaTest\", \"doubleSided\", \"flipSided\", \"numClippingPlanes\", \"depthPacking\"\n\t];\n\n\n\tfunction allocateBones ( object ) {\n\n\t\tif ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {\n\n\t\t\treturn 1024;\n\n\t\t} else {\n\n\t\t\t// default for when object is not specified\n\t\t\t// ( for example when prebuilding shader to be used with multiple objects )\n\t\t\t//\n\t\t\t//  - leave some extra space for other uniforms\n\t\t\t//  - limit here is ANGLE's 254 max uniform vectors\n\t\t\t//    (up to 54 should be safe)\n\n\t\t\tvar nVertexUniforms = capabilities.maxVertexUniforms;\n\t\t\tvar nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\n\n\t\t\tvar maxBones = nVertexMatrices;\n\n\t\t\tif ( object !== undefined && object instanceof THREE.SkinnedMesh ) {\n\n\t\t\t\tmaxBones = Math.min( object.skeleton.bones.length, maxBones );\n\n\t\t\t\tif ( maxBones < object.skeleton.bones.length ) {\n\n\t\t\t\t\tconsole.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn maxBones;\n\n\t\t}\n\n\t}\n\n\tfunction getTextureEncodingFromMap( map, gammaOverrideLinear ) {\n\n\t\tvar encoding;\n\n\t\tif ( ! map ) {\n\n\t\t\tencoding = THREE.LinearEncoding;\n\n\t\t} else if ( map instanceof THREE.Texture ) {\n\n\t\t\tencoding = map.encoding;\n\n\t\t} else if ( map instanceof THREE.WebGLRenderTarget ) {\n\n\t\t\tconsole.warn( \"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.\" );\n\t\t\tencoding = map.texture.encoding;\n\n\t\t}\n\n\t\t// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.\n\t\tif ( encoding === THREE.LinearEncoding && gammaOverrideLinear ) {\n\n\t\t\tencoding = THREE.GammaEncoding;\n\n\t\t}\n\n\t\treturn encoding;\n\n\t}\n\n\tthis.getParameters = function ( material, lights, fog, nClipPlanes, object ) {\n\n\t\tvar shaderID = shaderIDs[ material.type ];\n\n\t\t// heuristics to create shader parameters according to lights in the scene\n\t\t// (not to blow over maxLights budget)\n\n\t\tvar maxBones = allocateBones( object );\n\t\tvar precision = renderer.getPrecision();\n\n\t\tif ( material.precision !== null ) {\n\n\t\t\tprecision = capabilities.getMaxPrecision( material.precision );\n\n\t\t\tif ( precision !== material.precision ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar currentRenderTarget = renderer.getCurrentRenderTarget();\n\n\t\tvar parameters = {\n\n\t\t\tshaderID: shaderID,\n\n\t\t\tprecision: precision,\n\t\t\tsupportsVertexTextures: capabilities.vertexTextures,\n\t\t\toutputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),\n\t\t\tmap: !! material.map,\n\t\t\tmapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),\n\t\t\tenvMap: !! material.envMap,\n\t\t\tenvMapMode: material.envMap && material.envMap.mapping,\n\t\t\tenvMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),\n\t\t\tenvMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === THREE.CubeUVReflectionMapping ) || ( material.envMap.mapping === THREE.CubeUVRefractionMapping ) ),\n\t\t\tlightMap: !! material.lightMap,\n\t\t\taoMap: !! material.aoMap,\n\t\t\temissiveMap: !! material.emissiveMap,\n\t\t\temissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),\n\t\t\tbumpMap: !! material.bumpMap,\n\t\t\tnormalMap: !! material.normalMap,\n\t\t\tdisplacementMap: !! material.displacementMap,\n\t\t\troughnessMap: !! material.roughnessMap,\n\t\t\tmetalnessMap: !! material.metalnessMap,\n\t\t\tspecularMap: !! material.specularMap,\n\t\t\talphaMap: !! material.alphaMap,\n\n\t\t\tcombine: material.combine,\n\n\t\t\tvertexColors: material.vertexColors,\n\n\t\t\tfog: fog,\n\t\t\tuseFog: material.fog,\n\t\t\tfogExp: fog instanceof THREE.FogExp2,\n\n\t\t\tflatShading: material.shading === THREE.FlatShading,\n\n\t\t\tsizeAttenuation: material.sizeAttenuation,\n\t\t\tlogarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,\n\n\t\t\tskinning: material.skinning,\n\t\t\tmaxBones: maxBones,\n\t\t\tuseVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,\n\n\t\t\tmorphTargets: material.morphTargets,\n\t\t\tmorphNormals: material.morphNormals,\n\t\t\tmaxMorphTargets: renderer.maxMorphTargets,\n\t\t\tmaxMorphNormals: renderer.maxMorphNormals,\n\n\t\t\tnumDirLights: lights.directional.length,\n\t\t\tnumPointLights: lights.point.length,\n\t\t\tnumSpotLights: lights.spot.length,\n\t\t\tnumHemiLights: lights.hemi.length,\n\n\t\t\tnumClippingPlanes: nClipPlanes,\n\n\t\t\tshadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,\n\t\t\tshadowMapType: renderer.shadowMap.type,\n\n\t\t\ttoneMapping: renderer.toneMapping,\n\t\t\tphysicallyCorrectLights: renderer.physicallyCorrectLights,\n\n\t\t\tpremultipliedAlpha: material.premultipliedAlpha,\n\n\t\t\talphaTest: material.alphaTest,\n\t\t\tdoubleSided: material.side === THREE.DoubleSide,\n\t\t\tflipSided: material.side === THREE.BackSide,\n\n\t\t\tdepthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false\n\n\t\t};\n\n\t\treturn parameters;\n\n\t};\n\n\tthis.getProgramCode = function ( material, parameters ) {\n\n\t\tvar array = [];\n\n\t\tif ( parameters.shaderID ) {\n\n\t\t\tarray.push( parameters.shaderID );\n\n\t\t} else {\n\n\t\t\tarray.push( material.fragmentShader );\n\t\t\tarray.push( material.vertexShader );\n\n\t\t}\n\n\t\tif ( material.defines !== undefined ) {\n\n\t\t\tfor ( var name in material.defines ) {\n\n\t\t\t\tarray.push( name );\n\t\t\t\tarray.push( material.defines[ name ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( var i = 0; i < parameterNames.length; i ++ ) {\n\n\t\t\tarray.push( parameters[ parameterNames[ i ] ] );\n\n\t\t}\n\n\t\treturn array.join();\n\n\t};\n\n\tthis.acquireProgram = function ( material, parameters, code ) {\n\n\t\tvar program;\n\n\t\t// Check if code has been already compiled\n\t\tfor ( var p = 0, pl = programs.length; p < pl; p ++ ) {\n\n\t\t\tvar programInfo = programs[ p ];\n\n\t\t\tif ( programInfo.code === code ) {\n\n\t\t\t\tprogram = programInfo;\n\t\t\t\t++ program.usedTimes;\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( program === undefined ) {\n\n\t\t\tprogram = new THREE.WebGLProgram( renderer, code, material, parameters );\n\t\t\tprograms.push( program );\n\n\t\t}\n\n\t\treturn program;\n\n\t};\n\n\tthis.releaseProgram = function( program ) {\n\n\t\tif ( -- program.usedTimes === 0 ) {\n\n\t\t\t// Remove from unordered set\n\t\t\tvar i = programs.indexOf( program );\n\t\t\tprograms[ i ] = programs[ programs.length - 1 ];\n\t\t\tprograms.pop();\n\n\t\t\t// Free WebGL resources\n\t\t\tprogram.destroy();\n\n\t\t}\n\n\t};\n\n\t// Exposed for resource monitoring & error feedback via renderer.info:\n\tthis.programs = programs;\n\n};\n\n// File:src/renderers/webgl/WebGLProperties.js\n\n/**\n* @author fordacious / fordacious.github.io\n*/\n\nTHREE.WebGLProperties = function () {\n\n\tvar properties = {};\n\n\tthis.get = function ( object ) {\n\n\t\tvar uuid = object.uuid;\n\t\tvar map = properties[ uuid ];\n\n\t\tif ( map === undefined ) {\n\n\t\t\tmap = {};\n\t\t\tproperties[ uuid ] = map;\n\n\t\t}\n\n\t\treturn map;\n\n\t};\n\n\tthis.delete = function ( object ) {\n\n\t\tdelete properties[ object.uuid ];\n\n\t};\n\n\tthis.clear = function () {\n\n\t\tproperties = {};\n\n\t};\n\n};\n\n// File:src/renderers/webgl/WebGLShader.js\n\nTHREE.WebGLShader = ( function () {\n\n\tfunction addLineNumbers( string ) {\n\n\t\tvar lines = string.split( '\\n' );\n\n\t\tfor ( var i = 0; i < lines.length; i ++ ) {\n\n\t\t\tlines[ i ] = ( i + 1 ) + ': ' + lines[ i ];\n\n\t\t}\n\n\t\treturn lines.join( '\\n' );\n\n\t}\n\n\treturn function WebGLShader( gl, type, string ) {\n\n\t\tvar shader = gl.createShader( type );\n\n\t\tgl.shaderSource( shader, string );\n\t\tgl.compileShader( shader );\n\n\t\tif ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {\n\n\t\t\tconsole.error( 'THREE.WebGLShader: Shader couldn\\'t compile.' );\n\n\t\t}\n\n\t\tif ( gl.getShaderInfoLog( shader ) !== '' ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );\n\n\t\t}\n\n\t\t// --enable-privileged-webgl-extension\n\t\t// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\n\n\t\treturn shader;\n\n\t};\n\n} )();\n\n// File:src/renderers/webgl/WebGLShadowMap.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.WebGLShadowMap = function ( _renderer, _lights, _objects ) {\n\n\tvar _gl = _renderer.context,\n\t_state = _renderer.state,\n\t_frustum = new THREE.Frustum(),\n\t_projScreenMatrix = new THREE.Matrix4(),\n\n\t_lightShadows = _lights.shadows,\n\n\t_shadowMapSize = new THREE.Vector2(),\n\n\t_lookTarget = new THREE.Vector3(),\n\t_lightPositionWorld = new THREE.Vector3(),\n\n\t_renderList = [],\n\n\t_MorphingFlag = 1,\n\t_SkinningFlag = 2,\n\n\t_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,\n\n\t_depthMaterials = new Array( _NumberOfMaterialVariants ),\n\t_distanceMaterials = new Array( _NumberOfMaterialVariants ),\n\n\t_materialCache = {};\n\n\tvar cubeDirections = [\n\t\tnew THREE.Vector3( 1, 0, 0 ), new THREE.Vector3( - 1, 0, 0 ), new THREE.Vector3( 0, 0, 1 ),\n\t\tnew THREE.Vector3( 0, 0, - 1 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, - 1, 0 )\n\t];\n\n\tvar cubeUps = [\n\t\tnew THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ),\n\t\tnew THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 0, 1 ),\tnew THREE.Vector3( 0, 0, - 1 )\n\t];\n\n\tvar cube2DViewPorts = [\n\t\tnew THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(),\n\t\tnew THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4()\n\t];\n\n\t// init\n\n\tvar depthMaterialTemplate = new THREE.MeshDepthMaterial();\n\tdepthMaterialTemplate.depthPacking = THREE.RGBADepthPacking;\n\tdepthMaterialTemplate.clipping = true;\n\n\tvar distanceShader = THREE.ShaderLib[ \"distanceRGBA\" ];\n\tvar distanceUniforms = THREE.UniformsUtils.clone( distanceShader.uniforms );\n\n\tfor ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {\n\n\t\tvar useMorphing = ( i & _MorphingFlag ) !== 0;\n\t\tvar useSkinning = ( i & _SkinningFlag ) !== 0;\n\n\t\tvar depthMaterial = depthMaterialTemplate.clone();\n\t\tdepthMaterial.morphTargets = useMorphing;\n\t\tdepthMaterial.skinning = useSkinning;\n\n\t\t_depthMaterials[ i ] = depthMaterial;\n\n\t\tvar distanceMaterial = new THREE.ShaderMaterial( {\n\t\t\tdefines: {\n\t\t\t\t'USE_SHADOWMAP': ''\n\t\t\t},\n\t\t\tuniforms: distanceUniforms,\n\t\t\tvertexShader: distanceShader.vertexShader,\n\t\t\tfragmentShader: distanceShader.fragmentShader,\n\t\t\tmorphTargets: useMorphing,\n\t\t\tskinning: useSkinning,\n\t\t\tclipping: true\n\t\t} );\n\n\t\t_distanceMaterials[ i ] = distanceMaterial;\n\n\t}\n\n\t//\n\n\tvar scope = this;\n\n\tthis.enabled = false;\n\n\tthis.autoUpdate = true;\n\tthis.needsUpdate = false;\n\n\tthis.type = THREE.PCFShadowMap;\n\n\tthis.renderReverseSided = true;\n\tthis.renderSingleSided = true;\n\n\tthis.render = function ( scene, camera ) {\n\n\t\tif ( scope.enabled === false ) return;\n\t\tif ( scope.autoUpdate === false && scope.needsUpdate === false ) return;\n\n\t\tif ( _lightShadows.length === 0 ) return;\n\n\t\t// Set GL state for depth map.\n\t\t_state.clearColor( 1, 1, 1, 1 );\n\t\t_state.disable( _gl.BLEND );\n\t\t_state.setDepthTest( true );\n\t\t_state.setScissorTest( false );\n\n\t\t// render depth map\n\n\t\tvar faceCount, isPointLight;\n\n\t\tfor ( var i = 0, il = _lightShadows.length; i < il; i ++ ) {\n\n\t\t\tvar light = _lightShadows[ i ];\n\t\t\tvar shadow = light.shadow;\n\n\t\t\tif ( shadow === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tvar shadowCamera = shadow.camera;\n\n\t\t\t_shadowMapSize.copy( shadow.mapSize );\n\n\t\t\tif ( light instanceof THREE.PointLight ) {\n\n\t\t\t\tfaceCount = 6;\n\t\t\t\tisPointLight = true;\n\n\t\t\t\tvar vpWidth = _shadowMapSize.x;\n\t\t\t\tvar vpHeight = _shadowMapSize.y;\n\n\t\t\t\t// These viewports map a cube-map onto a 2D texture with the\n\t\t\t\t// following orientation:\n\t\t\t\t//\n\t\t\t\t//  xzXZ\n\t\t\t\t//   y Y\n\t\t\t\t//\n\t\t\t\t// X - Positive x direction\n\t\t\t\t// x - Negative x direction\n\t\t\t\t// Y - Positive y direction\n\t\t\t\t// y - Negative y direction\n\t\t\t\t// Z - Positive z direction\n\t\t\t\t// z - Negative z direction\n\n\t\t\t\t// positive X\n\t\t\t\tcube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );\n\t\t\t\t// negative X\n\t\t\t\tcube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );\n\t\t\t\t// positive Z\n\t\t\t\tcube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );\n\t\t\t\t// negative Z\n\t\t\t\tcube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );\n\t\t\t\t// positive Y\n\t\t\t\tcube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );\n\t\t\t\t// negative Y\n\t\t\t\tcube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );\n\n\t\t\t\t_shadowMapSize.x *= 4.0;\n\t\t\t\t_shadowMapSize.y *= 2.0;\n\n\t\t\t} else {\n\n\t\t\t\tfaceCount = 1;\n\t\t\t\tisPointLight = false;\n\n\t\t\t}\n\n\t\t\tif ( shadow.map === null ) {\n\n\t\t\t\tvar pars = { minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat };\n\n\t\t\t\tshadow.map = new THREE.WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\n\n\t\t\t\tshadowCamera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\tif ( shadow instanceof THREE.SpotLightShadow ) {\n\n\t\t\t\tshadow.update( light );\n\n\t\t\t}\n\n\t\t\tvar shadowMap = shadow.map;\n\t\t\tvar shadowMatrix = shadow.matrix;\n\n\t\t\t_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );\n\t\t\tshadowCamera.position.copy( _lightPositionWorld );\n\n\t\t\t_renderer.setRenderTarget( shadowMap );\n\t\t\t_renderer.clear();\n\n\t\t\t// render shadow map for each cube face (if omni-directional) or\n\t\t\t// run a single pass if not\n\n\t\t\tfor ( var face = 0; face < faceCount; face ++ ) {\n\n\t\t\t\tif ( isPointLight ) {\n\n\t\t\t\t\t_lookTarget.copy( shadowCamera.position );\n\t\t\t\t\t_lookTarget.add( cubeDirections[ face ] );\n\t\t\t\t\tshadowCamera.up.copy( cubeUps[ face ] );\n\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\n\n\t\t\t\t\tvar vpDimensions = cube2DViewPorts[ face ];\n\t\t\t\t\t_state.viewport( vpDimensions );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_lookTarget.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\n\n\t\t\t\t}\n\n\t\t\t\tshadowCamera.updateMatrixWorld();\n\t\t\t\tshadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );\n\n\t\t\t\t// compute shadow matrix\n\n\t\t\t\tshadowMatrix.set(\n\t\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t\t);\n\n\t\t\t\tshadowMatrix.multiply( shadowCamera.projectionMatrix );\n\t\t\t\tshadowMatrix.multiply( shadowCamera.matrixWorldInverse );\n\n\t\t\t\t// update camera matrices and frustum\n\n\t\t\t\t_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\n\t\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\n\t\t\t\t// set object matrices & frustum culling\n\n\t\t\t\t_renderList.length = 0;\n\n\t\t\t\tprojectObject( scene, camera, shadowCamera );\n\n\t\t\t\t// render shadow map\n\t\t\t\t// render regular objects\n\n\t\t\t\tfor ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {\n\n\t\t\t\t\tvar object = _renderList[ j ];\n\t\t\t\t\tvar geometry = _objects.update( object );\n\t\t\t\t\tvar material = object.material;\n\n\t\t\t\t\tif ( material instanceof THREE.MultiMaterial ) {\n\n\t\t\t\t\t\tvar groups = geometry.groups;\n\t\t\t\t\t\tvar materials = material.materials;\n\n\t\t\t\t\t\tfor ( var k = 0, kl = groups.length; k < kl; k ++ ) {\n\n\t\t\t\t\t\t\tvar group = groups[ k ];\n\t\t\t\t\t\t\tvar groupMaterial = materials[ group.materialIndex ];\n\n\t\t\t\t\t\t\tif ( groupMaterial.visible === true ) {\n\n\t\t\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );\n\t\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );\n\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Restore GL state.\n\t\tvar clearColor = _renderer.getClearColor(),\n\t\tclearAlpha = _renderer.getClearAlpha();\n\t\t_renderer.setClearColor( clearColor, clearAlpha );\n\n\t\tscope.needsUpdate = false;\n\n\t};\n\n\tfunction getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {\n\n\t\tvar geometry = object.geometry;\n\n\t\tvar result = null;\n\n\t\tvar materialVariants = _depthMaterials;\n\t\tvar customMaterial = object.customDepthMaterial;\n\n\t\tif ( isPointLight ) {\n\n\t\t\tmaterialVariants = _distanceMaterials;\n\t\t\tcustomMaterial = object.customDistanceMaterial;\n\n\t\t}\n\n\t\tif ( ! customMaterial ) {\n\n\t\t\tvar useMorphing = geometry.morphTargets !== undefined &&\n\t\t\t\t\tgeometry.morphTargets.length > 0 && material.morphTargets;\n\n\t\t\tvar useSkinning = object instanceof THREE.SkinnedMesh && material.skinning;\n\n\t\t\tvar variantIndex = 0;\n\n\t\t\tif ( useMorphing ) variantIndex |= _MorphingFlag;\n\t\t\tif ( useSkinning ) variantIndex |= _SkinningFlag;\n\n\t\t\tresult = materialVariants[ variantIndex ];\n\n\t\t} else {\n\n\t\t\tresult = customMaterial;\n\n\t\t}\n\n\t\tif ( _renderer.localClippingEnabled &&\n\t\t\t material.clipShadows === true &&\n\t\t\t\tmaterial.clippingPlanes.length !== 0 ) {\n\n\t\t\t// in this case we need a unique material instance reflecting the\n\t\t\t// appropriate state\n\n\t\t\tvar keyA = result.uuid, keyB = material.uuid;\n\n\t\t\tvar materialsForVariant = _materialCache[ keyA ];\n\n\t\t\tif ( materialsForVariant === undefined ) {\n\n\t\t\t\tmaterialsForVariant = {};\n\t\t\t\t_materialCache[ keyA ] = materialsForVariant;\n\n\t\t\t}\n\n\t\t\tvar cachedMaterial = materialsForVariant[ keyB ];\n\n\t\t\tif ( cachedMaterial === undefined ) {\n\n\t\t\t\tcachedMaterial = result.clone();\n\t\t\t\tmaterialsForVariant[ keyB ] = cachedMaterial;\n\n\t\t\t}\n\n\t\t\tresult = cachedMaterial;\n\n\t\t}\n\n\t\tresult.visible = material.visible;\n\t\tresult.wireframe = material.wireframe;\n\n\t\tvar side = material.side;\n\n\t\tif ( scope.renderSingleSided && side == THREE.DoubleSide ) {\n\n\t\t\tside = THREE.FrontSide;\n\n\t\t}\n\n\t\tif ( scope.renderReverseSided ) {\n\n\t\t\tif ( side === THREE.FrontSide ) side = THREE.BackSide;\n\t\t\telse if ( side === THREE.BackSide ) side = THREE.FrontSide;\n\n\t\t}\n\n\t\tresult.side = side;\n\n\t\tresult.clipShadows = material.clipShadows;\n\t\tresult.clippingPlanes = material.clippingPlanes;\n\n\t\tresult.wireframeLinewidth = material.wireframeLinewidth;\n\t\tresult.linewidth = material.linewidth;\n\n\t\tif ( isPointLight && result.uniforms.lightPos !== undefined ) {\n\n\t\t\tresult.uniforms.lightPos.value.copy( lightPositionWorld );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tfunction projectObject( object, camera, shadowCamera ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tif ( object.layers.test( camera.layers ) && ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) ) {\n\n\t\t\tif ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {\n\n\t\t\t\tvar material = object.material;\n\n\t\t\t\tif ( material.visible === true ) {\n\n\t\t\t\t\tobject.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\n\t\t\t\t\t_renderList.push( object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar children = object.children;\n\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tprojectObject( children[ i ], camera, shadowCamera );\n\n\t\t}\n\n\t}\n\n};\n\n// File:src/renderers/webgl/WebGLState.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLState = function ( gl, extensions, paramThreeToGL ) {\n\n\tvar _this = this;\n\n\tthis.buffers = {\n\t\tcolor: new THREE.WebGLColorBuffer( gl, this ),\n\t\tdepth: new THREE.WebGLDepthBuffer( gl, this ),\n\t\tstencil: new THREE.WebGLStencilBuffer( gl, this )\n\t};\n\n\tvar maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\tvar newAttributes = new Uint8Array( maxVertexAttributes );\n\tvar enabledAttributes = new Uint8Array( maxVertexAttributes );\n\tvar attributeDivisors = new Uint8Array( maxVertexAttributes );\n\n\tvar capabilities = {};\n\n\tvar compressedTextureFormats = null;\n\n\tvar currentBlending = null;\n\tvar currentBlendEquation = null;\n\tvar currentBlendSrc = null;\n\tvar currentBlendDst = null;\n\tvar currentBlendEquationAlpha = null;\n\tvar currentBlendSrcAlpha = null;\n\tvar currentBlendDstAlpha = null;\n\tvar currentPremultipledAlpha = false;\n\n\tvar currentFlipSided = null;\n\tvar currentCullFace = null;\n\n\tvar currentLineWidth = null;\n\n\tvar currentPolygonOffsetFactor = null;\n\tvar currentPolygonOffsetUnits = null;\n\n\tvar currentScissorTest = null;\n\n\tvar maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\n\n\tvar currentTextureSlot = null;\n\tvar currentBoundTextures = {};\n\n\tvar currentScissor = new THREE.Vector4();\n\tvar currentViewport = new THREE.Vector4();\n\n\tfunction createTexture( type, target, count ) {\n\n\t\tvar data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.\n\t\tvar texture = gl.createTexture();\n\n\t\tgl.bindTexture( type, texture );\n\t\tgl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\t\tgl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\n\t\tfor ( var i = 0; i < count; i ++ ) {\n\n\t\t\tgl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\tvar emptyTextures = {};\n\temptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );\n\temptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );\n\n\t//\n\n\tthis.init = function () {\n\n\t\tthis.clearColor( 0, 0, 0, 1 );\n\t\tthis.clearDepth( 1 );\n\t\tthis.clearStencil( 0 );\n\n\t\tthis.enable( gl.DEPTH_TEST );\n\t\tthis.setDepthFunc( THREE.LessEqualDepth );\n\n\t\tthis.setFlipSided( false );\n\t\tthis.setCullFace( THREE.CullFaceBack );\n\t\tthis.enable( gl.CULL_FACE );\n\n\t\tthis.enable( gl.BLEND );\n\t\tthis.setBlending( THREE.NormalBlending );\n\n\t};\n\n\tthis.initAttributes = function () {\n\n\t\tfor ( var i = 0, l = newAttributes.length; i < l; i ++ ) {\n\n\t\t\tnewAttributes[ i ] = 0;\n\n\t\t}\n\n\t};\n\n\tthis.enableAttribute = function ( attribute ) {\n\n\t\tnewAttributes[ attribute ] = 1;\n\n\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\n\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\tenabledAttributes[ attribute ] = 1;\n\n\t\t}\n\n\t\tif ( attributeDivisors[ attribute ] !== 0 ) {\n\n\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\textension.vertexAttribDivisorANGLE( attribute, 0 );\n\t\t\tattributeDivisors[ attribute ] = 0;\n\n\t\t}\n\n\t};\n\n\tthis.enableAttributeAndDivisor = function ( attribute, meshPerAttribute, extension ) {\n\n\t\tnewAttributes[ attribute ] = 1;\n\n\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\n\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\tenabledAttributes[ attribute ] = 1;\n\n\t\t}\n\n\t\tif ( attributeDivisors[ attribute ] !== meshPerAttribute ) {\n\n\t\t\textension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );\n\t\t\tattributeDivisors[ attribute ] = meshPerAttribute;\n\n\t\t}\n\n\t};\n\n\tthis.disableUnusedAttributes = function () {\n\n\t\tfor ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {\n\n\t\t\tif ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\n\n\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\tenabledAttributes[ i ] = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tthis.enable = function ( id ) {\n\n\t\tif ( capabilities[ id ] !== true ) {\n\n\t\t\tgl.enable( id );\n\t\t\tcapabilities[ id ] = true;\n\n\t\t}\n\n\t};\n\n\tthis.disable = function ( id ) {\n\n\t\tif ( capabilities[ id ] !== false ) {\n\n\t\t\tgl.disable( id );\n\t\t\tcapabilities[ id ] = false;\n\n\t\t}\n\n\t};\n\n\tthis.getCompressedTextureFormats = function () {\n\n\t\tif ( compressedTextureFormats === null ) {\n\n\t\t\tcompressedTextureFormats = [];\n\n\t\t\tif ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||\n\t\t\t     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||\n\t\t\t     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {\n\n\t\t\t\tvar formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );\n\n\t\t\t\tfor ( var i = 0; i < formats.length; i ++ ) {\n\n\t\t\t\t\tcompressedTextureFormats.push( formats[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn compressedTextureFormats;\n\n\t};\n\n\tthis.setBlending = function ( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {\n\n\t\tif ( blending !== THREE.NoBlending ) {\n\n\t\t\tthis.enable( gl.BLEND );\n\n\t\t} else {\n\n\t\t\tthis.disable( gl.BLEND );\n\t\t\tcurrentBlending = blending; // no blending, that is\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {\n\n\t\t\tif ( blending === THREE.AdditiveBlending ) {\n\n\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE );\n\n\t\t\t\t}\n\n\t\t\t} else if ( blending === THREE.SubtractiveBlending ) {\n\n\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );\n\n\t\t\t\t}\n\n\t\t\t} else if ( blending === THREE.MultiplyBlending ) {\n\n\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.SRC_COLOR );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tcurrentBlending = blending;\n\t\t\tcurrentPremultipledAlpha = premultipliedAlpha;\n\n\t\t}\n\n\t\tif ( blending === THREE.CustomBlending ) {\n\n\t\t\tblendEquationAlpha = blendEquationAlpha || blendEquation;\n\t\t\tblendSrcAlpha = blendSrcAlpha || blendSrc;\n\t\t\tblendDstAlpha = blendDstAlpha || blendDst;\n\n\t\t\tif ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {\n\n\t\t\t\tgl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );\n\n\t\t\t\tcurrentBlendEquation = blendEquation;\n\t\t\t\tcurrentBlendEquationAlpha = blendEquationAlpha;\n\n\t\t\t}\n\n\t\t\tif ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {\n\n\t\t\t\tgl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );\n\n\t\t\t\tcurrentBlendSrc = blendSrc;\n\t\t\t\tcurrentBlendDst = blendDst;\n\t\t\t\tcurrentBlendSrcAlpha = blendSrcAlpha;\n\t\t\t\tcurrentBlendDstAlpha = blendDstAlpha;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tcurrentBlendEquation = null;\n\t\t\tcurrentBlendSrc = null;\n\t\t\tcurrentBlendDst = null;\n\t\t\tcurrentBlendEquationAlpha = null;\n\t\t\tcurrentBlendSrcAlpha = null;\n\t\t\tcurrentBlendDstAlpha = null;\n\n\t\t}\n\n\t};\n\n\t// TODO Deprecate\n\n\tthis.setColorWrite = function ( colorWrite ) {\n\n\t\tthis.buffers.color.setMask( colorWrite );\n\n\t};\n\n\tthis.setDepthTest = function ( depthTest ) {\n\n\t\tthis.buffers.depth.setTest( depthTest );\n\n\t};\n\n\tthis.setDepthWrite = function ( depthWrite ) {\n\n\t\tthis.buffers.depth.setMask( depthWrite );\n\n\t};\n\n\tthis.setDepthFunc = function ( depthFunc ) {\n\n\t\tthis.buffers.depth.setFunc( depthFunc );\n\n\t};\n\n\tthis.setStencilTest = function ( stencilTest ) {\n\n\t\tthis.buffers.stencil.setTest( stencilTest );\n\n\t};\n\n\tthis.setStencilWrite = function ( stencilWrite ) {\n\n\t\tthis.buffers.stencil.setMask( stencilWrite );\n\n\t};\n\n\tthis.setStencilFunc = function ( stencilFunc, stencilRef, stencilMask ) {\n\n\t\tthis.buffers.stencil.setFunc( stencilFunc, stencilRef, stencilMask );\n\n\t};\n\n\tthis.setStencilOp = function ( stencilFail, stencilZFail, stencilZPass ) {\n\n\t\tthis.buffers.stencil.setOp( stencilFail, stencilZFail, stencilZPass );\n\n\t};\n\n\t//\n\n\tthis.setFlipSided = function ( flipSided ) {\n\n\t\tif ( currentFlipSided !== flipSided ) {\n\n\t\t\tif ( flipSided ) {\n\n\t\t\t\tgl.frontFace( gl.CW );\n\n\t\t\t} else {\n\n\t\t\t\tgl.frontFace( gl.CCW );\n\n\t\t\t}\n\n\t\t\tcurrentFlipSided = flipSided;\n\n\t\t}\n\n\t};\n\n\tthis.setCullFace = function ( cullFace ) {\n\n\t\tif ( cullFace !== THREE.CullFaceNone ) {\n\n\t\t\tthis.enable( gl.CULL_FACE );\n\n\t\t\tif ( cullFace !== currentCullFace ) {\n\n\t\t\t\tif ( cullFace === THREE.CullFaceBack ) {\n\n\t\t\t\t\tgl.cullFace( gl.BACK );\n\n\t\t\t\t} else if ( cullFace === THREE.CullFaceFront ) {\n\n\t\t\t\t\tgl.cullFace( gl.FRONT );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.cullFace( gl.FRONT_AND_BACK );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.disable( gl.CULL_FACE );\n\n\t\t}\n\n\t\tcurrentCullFace = cullFace;\n\n\t};\n\n\tthis.setLineWidth = function ( width ) {\n\n\t\tif ( width !== currentLineWidth ) {\n\n\t\t\tgl.lineWidth( width );\n\n\t\t\tcurrentLineWidth = width;\n\n\t\t}\n\n\t};\n\n\tthis.setPolygonOffset = function ( polygonOffset, factor, units ) {\n\n\t\tif ( polygonOffset ) {\n\n\t\t\tthis.enable( gl.POLYGON_OFFSET_FILL );\n\n\t\t\tif ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {\n\n\t\t\t\tgl.polygonOffset( factor, units );\n\n\t\t\t\tcurrentPolygonOffsetFactor = factor;\n\t\t\t\tcurrentPolygonOffsetUnits = units;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.disable( gl.POLYGON_OFFSET_FILL );\n\n\t\t}\n\n\t};\n\n\tthis.getScissorTest = function () {\n\n\t\treturn currentScissorTest;\n\n\t};\n\n\tthis.setScissorTest = function ( scissorTest ) {\n\n\t\tcurrentScissorTest = scissorTest;\n\n\t\tif ( scissorTest ) {\n\n\t\t\tthis.enable( gl.SCISSOR_TEST );\n\n\t\t} else {\n\n\t\t\tthis.disable( gl.SCISSOR_TEST );\n\n\t\t}\n\n\t};\n\n\t// texture\n\n\tthis.activeTexture = function ( webglSlot ) {\n\n\t\tif ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;\n\n\t\tif ( currentTextureSlot !== webglSlot ) {\n\n\t\t\tgl.activeTexture( webglSlot );\n\t\t\tcurrentTextureSlot = webglSlot;\n\n\t\t}\n\n\t};\n\n\tthis.bindTexture = function ( webglType, webglTexture ) {\n\n\t\tif ( currentTextureSlot === null ) {\n\n\t\t\t_this.activeTexture();\n\n\t\t}\n\n\t\tvar boundTexture = currentBoundTextures[ currentTextureSlot ];\n\n\t\tif ( boundTexture === undefined ) {\n\n\t\t\tboundTexture = { type: undefined, texture: undefined };\n\t\t\tcurrentBoundTextures[ currentTextureSlot ] = boundTexture;\n\n\t\t}\n\n\t\tif ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\n\n\t\t\tgl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );\n\n\t\t\tboundTexture.type = webglType;\n\t\t\tboundTexture.texture = webglTexture;\n\n\t\t}\n\n\t};\n\n\tthis.compressedTexImage2D = function () {\n\n\t\ttry {\n\n\t\t\tgl.compressedTexImage2D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( error );\n\n\t\t}\n\n\t};\n\n\tthis.texImage2D = function () {\n\n\t\ttry {\n\n\t\t\tgl.texImage2D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( error );\n\n\t\t}\n\n\t};\n\n\t// TODO Deprecate\n\n\tthis.clearColor = function ( r, g, b, a ) {\n\n\t\tthis.buffers.color.setClear( r, g, b, a );\n\n\t};\n\n\tthis.clearDepth = function ( depth ) {\n\n\t\tthis.buffers.depth.setClear( depth );\n\n\t};\n\n\tthis.clearStencil = function ( stencil ) {\n\n\t\tthis.buffers.stencil.setClear( stencil );\n\n\t};\n\n\t//\n\n\tthis.scissor = function ( scissor ) {\n\n\t\tif ( currentScissor.equals( scissor ) === false ) {\n\n\t\t\tgl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );\n\t\t\tcurrentScissor.copy( scissor );\n\n\t\t}\n\n\t};\n\n\tthis.viewport = function ( viewport ) {\n\n\t\tif ( currentViewport.equals( viewport ) === false ) {\n\n\t\t\tgl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );\n\t\t\tcurrentViewport.copy( viewport );\n\n\t\t}\n\n\t};\n\n\t//\n\n\tthis.reset = function () {\n\n\t\tfor ( var i = 0; i < enabledAttributes.length; i ++ ) {\n\n\t\t\tif ( enabledAttributes[ i ] === 1 ) {\n\n\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\tenabledAttributes[ i ] = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tcapabilities = {};\n\n\t\tcompressedTextureFormats = null;\n\n\t\tcurrentTextureSlot = null;\n\t\tcurrentBoundTextures = {};\n\n\t\tcurrentBlending = null;\n\n\t\tcurrentFlipSided = null;\n\t\tcurrentCullFace = null;\n\n\t\tthis.buffers.color.reset();\n\t\tthis.buffers.depth.reset();\n\t\tthis.buffers.stencil.reset();\n\n\t};\n\n};\n\nTHREE.WebGLColorBuffer = function ( gl, state ) {\n\n\tvar locked = false;\n\n\tvar color = new THREE.Vector4();\n\tvar currentColorMask = null;\n\tvar currentColorClear = new THREE.Vector4();\n\n\tthis.setMask = function ( colorMask ) {\n\n\t\tif ( currentColorMask !== colorMask && ! locked ) {\n\n\t\t\tgl.colorMask( colorMask, colorMask, colorMask, colorMask );\n\t\t\tcurrentColorMask = colorMask;\n\n\t\t}\n\n\t};\n\n\tthis.setLocked = function ( lock ) {\n\n\t\tlocked = lock;\n\n\t};\n\n\tthis.setClear = function ( r, g, b, a ) {\n\n\t\tcolor.set( r, g, b, a );\n\n\t\tif ( currentColorClear.equals( color ) === false ) {\n\n\t\t\tgl.clearColor( r, g, b, a );\n\t\t\tcurrentColorClear.copy( color );\n\n\t\t}\n\n\t};\n\n\tthis.reset = function () {\n\n\t\tlocked = false;\n\n\t\tcurrentColorMask = null;\n\t\tcurrentColorClear = new THREE.Vector4();\n\n\t};\n\n};\n\nTHREE.WebGLDepthBuffer = function( gl, state ) {\n\n\tvar locked = false;\n\n\tvar currentDepthMask = null;\n\tvar currentDepthFunc = null;\n\tvar currentDepthClear = null;\n\n\tthis.setTest = function ( depthTest ) {\n\n\t\tif ( depthTest ) {\n\n\t\t\tstate.enable( gl.DEPTH_TEST );\n\n\t\t} else {\n\n\t\t\tstate.disable( gl.DEPTH_TEST );\n\n\t\t}\n\n\t};\n\n\tthis.setMask = function( depthMask ){\n\n\t\tif ( currentDepthMask !== depthMask && ! locked ) {\n\n\t\t\tgl.depthMask( depthMask );\n\t\t\tcurrentDepthMask = depthMask;\n\n\t\t}\n\n\t};\n\n\tthis.setFunc = function ( depthFunc ) {\n\n\t\tif ( currentDepthFunc !== depthFunc ) {\n\n\t\t\tif ( depthFunc ) {\n\n\t\t\t\tswitch ( depthFunc ) {\n\n\t\t\t\t\tcase THREE.NeverDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.NEVER );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.AlwaysDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.ALWAYS );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.LessDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.LESS );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.LessEqualDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.EqualDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.EQUAL );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.GreaterEqualDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.GEQUAL );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.GreaterDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.GREATER );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.NotEqualDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.NOTEQUAL );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\n\t\t\t}\n\n\t\t\tcurrentDepthFunc = depthFunc;\n\n\t\t}\n\n\t};\n\n\tthis.setLocked = function ( lock ) {\n\n\t\tlocked = lock;\n\n\t};\n\n\tthis.setClear = function ( depth ) {\n\n\t\tif ( currentDepthClear !== depth ) {\n\n\t\t\tgl.clearDepth( depth );\n\t\t\tcurrentDepthClear = depth;\n\n\t\t}\n\n\t};\n\n\tthis.reset = function () {\n\n\t\tlocked = false;\n\n\t\tcurrentDepthMask = null;\n\t\tcurrentDepthFunc = null;\n\t\tcurrentDepthClear = null;\n\n\t};\n\n};\n\nTHREE.WebGLStencilBuffer = function ( gl, state ) {\n\n\tvar locked = false;\n\n\tvar currentStencilMask = null;\n\tvar currentStencilFunc = null;\n\tvar currentStencilRef = null;\n\tvar currentStencilFuncMask = null;\n\tvar currentStencilFail  = null;\n\tvar currentStencilZFail = null;\n\tvar currentStencilZPass = null;\n\tvar currentStencilClear = null;\n\n\tthis.setTest = function ( stencilTest ) {\n\n\t\tif ( stencilTest ) {\n\n\t\t\tstate.enable( gl.STENCIL_TEST );\n\n\t\t} else {\n\n\t\t\tstate.disable( gl.STENCIL_TEST );\n\n\t\t}\n\n\t};\n\n\tthis.setMask = function ( stencilMask ) {\n\n\t\tif ( currentStencilMask !== stencilMask && ! locked ) {\n\n\t\t\tgl.stencilMask( stencilMask );\n\t\t\tcurrentStencilMask = stencilMask;\n\n\t\t}\n\n\t};\n\n\tthis.setFunc = function ( stencilFunc, stencilRef, stencilMask ) {\n\n\t\tif ( currentStencilFunc !== stencilFunc ||\n\t\t     currentStencilRef \t!== stencilRef \t||\n\t\t     currentStencilFuncMask !== stencilMask ) {\n\n\t\t\tgl.stencilFunc( stencilFunc,  stencilRef, stencilMask );\n\n\t\t\tcurrentStencilFunc = stencilFunc;\n\t\t\tcurrentStencilRef  = stencilRef;\n\t\t\tcurrentStencilFuncMask = stencilMask;\n\n\t\t}\n\n\t};\n\n\tthis.setOp\t = function ( stencilFail, stencilZFail, stencilZPass ) {\n\n\t\tif ( currentStencilFail\t !== stencilFail \t||\n\t\t     currentStencilZFail !== stencilZFail ||\n\t\t     currentStencilZPass !== stencilZPass ) {\n\n\t\t\tgl.stencilOp( stencilFail,  stencilZFail, stencilZPass );\n\n\t\t\tcurrentStencilFail  = stencilFail;\n\t\t\tcurrentStencilZFail = stencilZFail;\n\t\t\tcurrentStencilZPass = stencilZPass;\n\n\t\t}\n\n\t};\n\n\tthis.setLocked = function ( lock ) {\n\n\t\tlocked = lock;\n\n\t};\n\n\tthis.setClear = function ( stencil ) {\n\n\t\tif ( currentStencilClear !== stencil ) {\n\n\t\t\tgl.clearStencil( stencil );\n\t\t\tcurrentStencilClear = stencil;\n\n\t\t}\n\n\t};\n\n\tthis.reset = function () {\n\n\t\tlocked = false;\n\n\t\tcurrentStencilMask = null;\n\t\tcurrentStencilFunc = null;\n\t\tcurrentStencilRef = null;\n\t\tcurrentStencilFuncMask = null;\n\t\tcurrentStencilFail = null;\n\t\tcurrentStencilZFail = null;\n\t\tcurrentStencilZPass = null;\n\t\tcurrentStencilClear = null;\n\n\t};\n\n};\n\n// File:src/renderers/webgl/WebGLTextures.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLTextures = function ( _gl, extensions, state, properties, capabilities, paramThreeToGL, info ) {\n\n\tvar _infoMemory = info.memory;\n\tvar _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext );\n\n\t//\n\n\tfunction clampToMaxSize ( image, maxSize ) {\n\n\t\tif ( image.width > maxSize || image.height > maxSize ) {\n\n\t\t\t// Warning: Scaling through the canvas will only work with images that use\n\t\t\t// premultiplied alpha.\n\n\t\t\tvar scale = maxSize / Math.max( image.width, image.height );\n\n\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\tcanvas.width = Math.floor( image.width * scale );\n\t\t\tcanvas.height = Math.floor( image.height * scale );\n\n\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\n\n\t\t\treturn canvas;\n\n\t\t}\n\n\t\treturn image;\n\n\t}\n\n\tfunction isPowerOfTwo( image ) {\n\n\t\treturn THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height );\n\n\t}\n\n\tfunction makePowerOfTwo( image ) {\n\n\t\tif ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {\n\n\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\tcanvas.width = THREE.Math.nearestPowerOfTwo( image.width );\n\t\t\tcanvas.height = THREE.Math.nearestPowerOfTwo( image.height );\n\n\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\tcontext.drawImage( image, 0, 0, canvas.width, canvas.height );\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\n\n\t\t\treturn canvas;\n\n\t\t}\n\n\t\treturn image;\n\n\t}\n\n\tfunction textureNeedsPowerOfTwo( texture ) {\n\n\t\tif ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) return true;\n\t\tif ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) return true;\n\n\t\treturn false;\n\n\t}\n\n\t// Fallback filters for non-power-of-2 textures\n\n\tfunction filterFallback ( f ) {\n\n\t\tif ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {\n\n\t\t\treturn _gl.NEAREST;\n\n\t\t}\n\n\t\treturn _gl.LINEAR;\n\n\t}\n\n\t//\n\n\tfunction onTextureDispose( event ) {\n\n\t\tvar texture = event.target;\n\n\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\n\t\tdeallocateTexture( texture );\n\n\t\t_infoMemory.textures --;\n\n\n\t}\n\n\tfunction onRenderTargetDispose( event ) {\n\n\t\tvar renderTarget = event.target;\n\n\t\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\n\n\t\tdeallocateRenderTarget( renderTarget );\n\n\t\t_infoMemory.textures --;\n\n\t}\n\n\t//\n\n\tfunction deallocateTexture( texture ) {\n\n\t\tvar textureProperties = properties.get( texture );\n\n\t\tif ( texture.image && textureProperties.__image__webglTextureCube ) {\n\n\t\t\t// cube texture\n\n\t\t\t_gl.deleteTexture( textureProperties.__image__webglTextureCube );\n\n\t\t} else {\n\n\t\t\t// 2D texture\n\n\t\t\tif ( textureProperties.__webglInit === undefined ) return;\n\n\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\n\t\t}\n\n\t\t// remove all webgl properties\n\t\tproperties.delete( texture );\n\n\t}\n\n\tfunction deallocateRenderTarget( renderTarget ) {\n\n\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\tvar textureProperties = properties.get( renderTarget.texture );\n\n\t\tif ( ! renderTarget ) return;\n\n\t\tif ( textureProperties.__webglTexture !== undefined ) {\n\n\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\n\t\t}\n\n\t\tif ( renderTarget.depthTexture ) {\n\n\t\t\trenderTarget.depthTexture.dispose();\n\n\t\t}\n\n\t\tif ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );\n\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );\n\n\t\t}\n\n\t\tproperties.delete( renderTarget.texture );\n\t\tproperties.delete( renderTarget );\n\n\t}\n\n\t//\n\n\n\n\tfunction setTexture2D( texture, slot ) {\n\n\t\tvar textureProperties = properties.get( texture );\n\n\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\tvar image = texture.image;\n\n\t\t\tif ( image === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );\n\n\t\t\t} else if ( image.complete === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );\n\n\t\t\t} else {\n\n\t\t\t\tuploadTexture( textureProperties, texture, slot );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\n\t}\n\n\tfunction setTextureCube ( texture, slot ) {\n\n\t\tvar textureProperties = properties.get( texture );\n\n\t\tif ( texture.image.length === 6 ) {\n\n\t\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\t\tif ( ! textureProperties.__image__webglTextureCube ) {\n\n\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\t\t\ttextureProperties.__image__webglTextureCube = _gl.createTexture();\n\n\t\t\t\t\t_infoMemory.textures ++;\n\n\t\t\t\t}\n\n\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\n\n\t\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\n\t\t\t\tvar isCompressed = texture instanceof THREE.CompressedTexture;\n\t\t\t\tvar isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;\n\n\t\t\t\tvar cubeImage = [];\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tif ( ! isCompressed && ! isDataTexture ) {\n\n\t\t\t\t\t\tcubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tcubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar image = cubeImage[ 0 ],\n\t\t\t\tisPowerOfTwoImage = isPowerOfTwo( image ),\n\t\t\t\tglFormat = paramThreeToGL( texture.format ),\n\t\t\t\tglType = paramThreeToGL( texture.type );\n\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tif ( ! isCompressed ) {\n\n\t\t\t\t\t\tif ( isDataTexture ) {\n\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvar mipmap, mipmaps = cubeImage[ i ].mipmaps;\n\n\t\t\t\t\t\tfor ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tmipmap = mipmaps[ j ];\n\n\t\t\t\t\t\t\tif ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {\n\n\t\t\t\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\n\n\t\t\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()\" );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( texture.generateMipmaps && isPowerOfTwoImage ) {\n\n\t\t\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\n\t\t\t\t}\n\n\t\t\t\ttextureProperties.__version = texture.version;\n\n\t\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t\t\t} else {\n\n\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction setTextureCubeDynamic ( texture, slot ) {\n\n\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );\n\n\t}\n\n\tfunction setTextureParameters ( textureType, texture, isPowerOfTwoImage ) {\n\n\t\tvar extension;\n\n\t\tif ( isPowerOfTwoImage ) {\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );\n\n\t\t} else {\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\n\n\t\t\tif ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );\n\n\t\t\t}\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\n\n\t\t\tif ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );\n\n\t\t\t}\n\n\t\t}\n\n\t\textension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\n\t\tif ( extension ) {\n\n\t\t\tif ( texture.type === THREE.FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;\n\t\t\tif ( texture.type === THREE.HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;\n\n\t\t\tif ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {\n\n\t\t\t\t_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );\n\t\t\t\tproperties.get( texture ).__currentAnisotropy = texture.anisotropy;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction uploadTexture( textureProperties, texture, slot ) {\n\n\t\tif ( textureProperties.__webglInit === undefined ) {\n\n\t\t\ttextureProperties.__webglInit = true;\n\n\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\n\t\t\t_infoMemory.textures ++;\n\n\t\t}\n\n\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\n\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\n\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\n\n\t\tvar image = clampToMaxSize( texture.image, capabilities.maxTextureSize );\n\n\t\tif ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {\n\n\t\t\timage = makePowerOfTwo( image );\n\n\t\t}\n\n\t\tvar isPowerOfTwoImage = isPowerOfTwo( image ),\n\t\tglFormat = paramThreeToGL( texture.format ),\n\t\tglType = paramThreeToGL( texture.type );\n\n\t\tsetTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );\n\n\t\tvar mipmap, mipmaps = texture.mipmaps;\n\n\t\tif ( texture instanceof THREE.DepthTexture ) {\n\n\t\t\t// populate depth texture with dummy data\n\n\t\t\tvar internalFormat = _gl.DEPTH_COMPONENT;\n\n\t\t\tif ( texture.type === THREE.FloatType ) {\n\n\t\t\t\tif ( !_isWebGL2 ) throw new Error('Float Depth Texture only supported in WebGL2.0');\n\t\t\t\tinternalFormat = _gl.DEPTH_COMPONENT32F;\n\n\t\t\t} else if ( _isWebGL2 ) {\n\n\t\t\t\t// WebGL 2.0 requires signed internalformat for glTexImage2D\n\t\t\t\tinternalFormat = _gl.DEPTH_COMPONENT16;\n\n\t\t\t}\n\n\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );\n\n\t\t} else if ( texture instanceof THREE.DataTexture ) {\n\n\t\t\t// use manually created mipmaps if available\n\t\t\t// if there are no manual mipmaps\n\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\n\n\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t}\n\n\t\t\t\ttexture.generateMipmaps = false;\n\n\t\t\t} else {\n\n\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );\n\n\t\t\t}\n\n\t\t} else if ( texture instanceof THREE.CompressedTexture ) {\n\n\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\tmipmap = mipmaps[ i ];\n\n\t\t\t\tif ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {\n\n\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\n\n\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()\" );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// regular Texture (image, video, canvas)\n\n\t\t\t// use manually created mipmaps if available\n\t\t\t// if there are no manual mipmaps\n\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\n\n\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );\n\n\t\t\t\t}\n\n\t\t\t\ttexture.generateMipmaps = false;\n\n\t\t\t} else {\n\n\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( texture.generateMipmaps && isPowerOfTwoImage ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\n\t\ttextureProperties.__version = texture.version;\n\n\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t}\n\n\t// Render targets\n\n\t// Setup storage for target texture and bind it to correct framebuffer\n\tfunction setupFrameBufferTexture ( framebuffer, renderTarget, attachment, textureTarget ) {\n\n\t\tvar glFormat = paramThreeToGL( renderTarget.texture.format );\n\t\tvar glType = paramThreeToGL( renderTarget.texture.type );\n\t\tstate.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\n\t}\n\n\t// Setup storage for internal depth/stencil buffers and bind to correct framebuffer\n\tfunction setupRenderBufferStorage ( renderbuffer, renderTarget ) {\n\n\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\n\n\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\n\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\n\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\n\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\n\t\t} else {\n\n\t\t\t// FIXME: We don't support !depth !stencil\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );\n\n\t\t}\n\n\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\n\n\t}\n\n\t// Setup resources for a Depth Texture for a FBO (needs an extension)\n\tfunction setupDepthTexture ( framebuffer, renderTarget ) {\n\n\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\n\t\tif ( isCube ) throw new Error('Depth Texture with cube render targets is not supported!');\n\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\tif ( !( renderTarget.depthTexture instanceof THREE.DepthTexture ) ) {\n\n\t\t\tthrow new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');\n\n\t\t}\n\n\t\t// upload an empty depth texture with framebuffer size\n\t\tif ( !properties.get( renderTarget.depthTexture ).__webglTexture ||\n\t\t\t\trenderTarget.depthTexture.image.width !== renderTarget.width ||\n\t\t\t\trenderTarget.depthTexture.image.height !== renderTarget.height ) {\n\t\t\trenderTarget.depthTexture.image.width = renderTarget.width;\n\t\t\trenderTarget.depthTexture.image.height = renderTarget.height;\n\t\t\trenderTarget.depthTexture.needsUpdate = true;\n\t\t}\n\n\t\tsetTexture2D( renderTarget.depthTexture, 0 );\n\n\t\tvar webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;\n\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\n\n\t}\n\n\t// Setup GL resources for a non-texture depth buffer\n\tfunction setupDepthRenderbuffer( renderTarget ) {\n\n\t\tvar renderTargetProperties = properties.get( renderTarget );\n\n\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\n\n\t\tif ( renderTarget.depthTexture ) {\n\n\t\t\tif ( isCube ) throw new Error('target.depthTexture not supported in Cube render targets');\n\n\t\t\tsetupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );\n\n\t\t} else {\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\trenderTargetProperties.__webglDepthbuffer = [];\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\t\trenderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();\n\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\n\t\t\t\trenderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\n\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );\n\n\t\t\t}\n\n\t\t}\n\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\n\t}\n\n\t// Set up GL resources for the render target\n\tfunction setupRenderTarget( renderTarget ) {\n\n\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\tvar textureProperties = properties.get( renderTarget.texture );\n\n\t\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\n\n\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\n\t\t_infoMemory.textures ++;\n\n\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\n\t\tvar isTargetPowerOfTwo = isPowerOfTwo( renderTarget );\n\n\t\t// Setup framebuffer\n\n\t\tif ( isCube ) {\n\n\t\t\trenderTargetProperties.__webglFramebuffer = [];\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\trenderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\trenderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\n\n\t\t}\n\n\t\t// Setup color buffer\n\n\t\tif ( isCube ) {\n\n\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );\n\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\n\n\t\t\t}\n\n\t\t\tif ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\n\n\t\t} else {\n\n\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\t\t\tsetTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );\n\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );\n\n\t\t\tif ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\t\t\tstate.bindTexture( _gl.TEXTURE_2D, null );\n\n\t\t}\n\n\t\t// Setup depth and stencil buffers\n\n\t\tif ( renderTarget.depthBuffer ) {\n\n\t\t\tsetupDepthRenderbuffer( renderTarget );\n\n\t\t}\n\n\t}\n\n\tfunction updateRenderTargetMipmap( renderTarget ) {\n\n\t\tvar texture = renderTarget.texture;\n\n\t\tif ( texture.generateMipmaps && isPowerOfTwo( renderTarget ) &&\n\t\t\t\ttexture.minFilter !== THREE.NearestFilter &&\n\t\t\t\ttexture.minFilter !== THREE.LinearFilter ) {\n\n\t\t\tvar target = renderTarget instanceof THREE.WebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;\n\t\t\tvar webglTexture = properties.get( texture ).__webglTexture;\n\n\t\t\tstate.bindTexture( target, webglTexture );\n\t\t\t_gl.generateMipmap( target );\n\t\t\tstate.bindTexture( target, null );\n\n\t\t}\n\n\t}\n\n\tthis.setTexture2D = setTexture2D;\n\tthis.setTextureCube = setTextureCube;\n\tthis.setTextureCubeDynamic = setTextureCubeDynamic;\n\tthis.setupRenderTarget = setupRenderTarget;\n\tthis.updateRenderTargetMipmap = updateRenderTargetMipmap;\n\n};\n\n// File:src/renderers/webgl/WebGLUniforms.js\n\n/**\n *\n * Uniforms of a program.\n * Those form a tree structure with a special top-level container for the root,\n * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.\n *\n *\n * Properties of inner nodes including the top-level container:\n *\n * .seq - array of nested uniforms\n * .map - nested uniforms by name\n *\n *\n * Methods of all nodes except the top-level container:\n *\n * .setValue( gl, value, [renderer] )\n *\n * \t\tuploads a uniform value(s)\n *  \tthe 'renderer' parameter is needed for sampler uniforms\n *\n *\n * Static methods of the top-level container (renderer factorizations):\n *\n * .upload( gl, seq, values, renderer )\n *\n * \t\tsets uniforms in 'seq' to 'values[id].value'\n *\n * .seqWithValue( seq, values ) : filteredSeq\n *\n * \t\tfilters 'seq' entries with corresponding entry in values\n *\n * .splitDynamic( seq, values ) : filteredSeq\n *\n * \t\tfilters 'seq' entries with dynamic entry and removes them from 'seq'\n *\n *\n * Methods of the top-level container (renderer factorizations):\n *\n * .setValue( gl, name, value )\n *\n * \t\tsets uniform with  name 'name' to 'value'\n *\n * .set( gl, obj, prop )\n *\n * \t\tsets uniform from object and property with same name than uniform\n *\n * .setOptional( gl, obj, prop )\n *\n * \t\tlike .set for an optional property of the object\n *\n *\n * @author tschw\n *\n */\n\nTHREE.WebGLUniforms = ( function() { // scope\n\n\tvar emptyTexture = new THREE.Texture();\n\tvar emptyCubeTexture = new THREE.CubeTexture();\n\n\t// --- Base for inner nodes (including the root) ---\n\n\tvar UniformContainer = function() {\n\n\t\t\tthis.seq = [];\n\t\t\tthis.map = {};\n\n\t\t},\n\n\t// --- Utilities ---\n\n\t// Array Caches (provide typed arrays for temporary by size)\n\n\t\tarrayCacheF32 = [],\n\t\tarrayCacheI32 = [],\n\n\t\tuncacheTemporaryArrays = function() {\n\n\t\t\tarrayCacheF32.length = 0;\n\t\t\tarrayCacheI32.length = 0;\n\n\t\t},\n\n\t// Flattening for arrays of vectors and matrices\n\n\t\tflatten = function( array, nBlocks, blockSize ) {\n\n\t\t\tvar firstElem = array[ 0 ];\n\n\t\t\tif ( firstElem <= 0 || firstElem > 0 ) return array;\n\t\t\t// unoptimized: ! isNaN( firstElem )\n\t\t\t// see http://jacksondunstan.com/articles/983\n\n\t\t\tvar n = nBlocks * blockSize,\n\t\t\t\tr = arrayCacheF32[ n ];\n\n\t\t\tif ( r === undefined ) {\n\n\t\t\t\tr = new Float32Array( n );\n\t\t\t\tarrayCacheF32[ n ] = r;\n\n\t\t\t}\n\n\t\t\tif ( nBlocks !== 0 ) {\n\n\t\t\t\tfirstElem.toArray( r, 0 );\n\n\t\t\t\tfor ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {\n\n\t\t\t\t\toffset += blockSize;\n\t\t\t\t\tarray[ i ].toArray( r, offset );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn r;\n\n\t\t},\n\n\t// Texture unit allocation\n\n\t\tallocTexUnits = function( renderer, n ) {\n\n\t\t\tvar r = arrayCacheI32[ n ];\n\n\t\t\tif ( r === undefined ) {\n\n\t\t\t\tr = new Int32Array( n );\n\t\t\t\tarrayCacheI32[ n ] = r;\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i !== n; ++ i )\n\t\t\t\tr[ i ] = renderer.allocTextureUnit();\n\n\t\t\treturn r;\n\n\t\t},\n\n\t// --- Setters ---\n\n\t// Note: Defining these methods externally, because they come in a bunch\n\t// and this way their names minify.\n\n\t\t// Single scalar\n\n\t\tsetValue1f = function( gl, v ) { gl.uniform1f( this.addr, v ); },\n\t\tsetValue1i = function( gl, v ) { gl.uniform1i( this.addr, v ); },\n\n\t\t// Single float vector (from flat array or THREE.VectorN)\n\n\t\tsetValue2fv = function( gl, v ) {\n\n\t\t\tif ( v.x === undefined ) gl.uniform2fv( this.addr, v );\n\t\t\telse gl.uniform2f( this.addr, v.x, v.y );\n\n\t\t},\n\n\t\tsetValue3fv = function( gl, v ) {\n\n\t\t\tif ( v.x !== undefined )\n\t\t\t\tgl.uniform3f( this.addr, v.x, v.y, v.z );\n\t\t\telse if ( v.r !== undefined )\n\t\t\t\tgl.uniform3f( this.addr, v.r, v.g, v.b );\n\t\t\telse\n\t\t\t\tgl.uniform3fv( this.addr, v );\n\n\t\t},\n\n\t\tsetValue4fv = function( gl, v ) {\n\n\t\t\tif ( v.x === undefined ) gl.uniform4fv( this.addr, v );\n\t\t\telse gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );\n\n\t\t},\n\n\t\t// Single matrix (from flat array or MatrixN)\n\n\t\tsetValue2fm = function( gl, v ) {\n\n\t\t\tgl.uniformMatrix2fv( this.addr, false, v.elements || v );\n\n\t\t},\n\n\t\tsetValue3fm = function( gl, v ) {\n\n\t\t\tgl.uniformMatrix3fv( this.addr, false, v.elements || v );\n\n\t\t},\n\n\t\tsetValue4fm = function( gl, v ) {\n\n\t\t\tgl.uniformMatrix4fv( this.addr, false, v.elements || v );\n\n\t\t},\n\n\t\t// Single texture (2D / Cube)\n\n\t\tsetValueT1 = function( gl, v, renderer ) {\n\n\t\t\tvar unit = renderer.allocTextureUnit();\n\t\t\tgl.uniform1i( this.addr, unit );\n\t\t\trenderer.setTexture2D( v || emptyTexture, unit );\n\n\t\t},\n\n\t\tsetValueT6 = function( gl, v, renderer ) {\n\n\t\t\tvar unit = renderer.allocTextureUnit();\n\t\t\tgl.uniform1i( this.addr, unit );\n\t\t\trenderer.setTextureCube( v || emptyCubeTexture, unit );\n\n\t\t},\n\n\t\t// Integer / Boolean vectors or arrays thereof (always flat arrays)\n\n\t\tsetValue2iv = function( gl, v ) { gl.uniform2iv( this.addr, v ); },\n\t\tsetValue3iv = function( gl, v ) { gl.uniform3iv( this.addr, v ); },\n\t\tsetValue4iv = function( gl, v ) { gl.uniform4iv( this.addr, v ); },\n\n\t\t// Helper to pick the right setter for the singular case\n\n\t\tgetSingularSetter = function( type ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 0x1406: return setValue1f; // FLOAT\n\t\t\t\tcase 0x8b50: return setValue2fv; // _VEC2\n\t\t\t\tcase 0x8b51: return setValue3fv; // _VEC3\n\t\t\t\tcase 0x8b52: return setValue4fv; // _VEC4\n\n\t\t\t\tcase 0x8b5a: return setValue2fm; // _MAT2\n\t\t\t\tcase 0x8b5b: return setValue3fm; // _MAT3\n\t\t\t\tcase 0x8b5c: return setValue4fm; // _MAT4\n\n\t\t\t\tcase 0x8b5e: return setValueT1; // SAMPLER_2D\n\t\t\t\tcase 0x8b60: return setValueT6; // SAMPLER_CUBE\n\n\t\t\t\tcase 0x1404: case 0x8b56: return setValue1i; // INT, BOOL\n\t\t\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\n\t\t\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\n\t\t\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\n\n\t\t\t}\n\n\t\t},\n\n\t\t// Array of scalars\n\n\t\tsetValue1fv = function( gl, v ) { gl.uniform1fv( this.addr, v ); },\n\t\tsetValue1iv = function( gl, v ) { gl.uniform1iv( this.addr, v ); },\n\n\t\t// Array of vectors (flat or from THREE classes)\n\n\t\tsetValueV2a = function( gl, v ) {\n\n\t\t\tgl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );\n\n\t\t},\n\n\t\tsetValueV3a = function( gl, v ) {\n\n\t\t\tgl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );\n\n\t\t},\n\n\t\tsetValueV4a = function( gl, v ) {\n\n\t\t\tgl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );\n\n\t\t},\n\n\t\t// Array of matrices (flat or from THREE clases)\n\n\t\tsetValueM2a = function( gl, v ) {\n\n\t\t\tgl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );\n\n\t\t},\n\n\t\tsetValueM3a = function( gl, v ) {\n\n\t\t\tgl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );\n\n\t\t},\n\n\t\tsetValueM4a = function( gl, v ) {\n\n\t\t\tgl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );\n\n\t\t},\n\n\t\t// Array of textures (2D / Cube)\n\n\t\tsetValueT1a = function( gl, v, renderer ) {\n\n\t\t\tvar n = v.length,\n\t\t\t\tunits = allocTexUnits( renderer, n );\n\n\t\t\tgl.uniform1iv( this.addr, units );\n\n\t\t\tfor ( var i = 0; i !== n; ++ i ) {\n\n\t\t\t\trenderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );\n\n\t\t\t}\n\n\t\t},\n\n\t\tsetValueT6a = function( gl, v, renderer ) {\n\n\t\t\tvar n = v.length,\n\t\t\t\tunits = allocTexUnits( renderer, n );\n\n\t\t\tgl.uniform1iv( this.addr, units );\n\n\t\t\tfor ( var i = 0; i !== n; ++ i ) {\n\n\t\t\t\trenderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );\n\n\t\t\t}\n\n\t\t},\n\n\n\t\t// Helper to pick the right setter for a pure (bottom-level) array\n\n\t\tgetPureArraySetter = function( type ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 0x1406: return setValue1fv; // FLOAT\n\t\t\t\tcase 0x8b50: return setValueV2a; // _VEC2\n\t\t\t\tcase 0x8b51: return setValueV3a; // _VEC3\n\t\t\t\tcase 0x8b52: return setValueV4a; // _VEC4\n\n\t\t\t\tcase 0x8b5a: return setValueM2a; // _MAT2\n\t\t\t\tcase 0x8b5b: return setValueM3a; // _MAT3\n\t\t\t\tcase 0x8b5c: return setValueM4a; // _MAT4\n\n\t\t\t\tcase 0x8b5e: return setValueT1a; // SAMPLER_2D\n\t\t\t\tcase 0x8b60: return setValueT6a; // SAMPLER_CUBE\n\n\t\t\t\tcase 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL\n\t\t\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\n\t\t\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\n\t\t\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\n\n\t\t\t}\n\n\t\t},\n\n\t// --- Uniform Classes ---\n\n\t\tSingleUniform = function SingleUniform( id, activeInfo, addr ) {\n\n\t\t\tthis.id = id;\n\t\t\tthis.addr = addr;\n\t\t\tthis.setValue = getSingularSetter( activeInfo.type );\n\n\t\t\t// this.path = activeInfo.name; // DEBUG\n\n\t\t},\n\n\t\tPureArrayUniform = function( id, activeInfo, addr ) {\n\n\t\t\tthis.id = id;\n\t\t\tthis.addr = addr;\n\t\t\tthis.size = activeInfo.size;\n\t\t\tthis.setValue = getPureArraySetter( activeInfo.type );\n\n\t\t\t// this.path = activeInfo.name; // DEBUG\n\n\t\t},\n\n\t\tStructuredUniform = function( id ) {\n\n\t\t\tthis.id = id;\n\n\t\t\tUniformContainer.call( this ); // mix-in\n\n\t\t};\n\n\tStructuredUniform.prototype.setValue = function( gl, value ) {\n\n\t\t// Note: Don't need an extra 'renderer' parameter, since samplers\n\t\t// are not allowed in structured uniforms.\n\n\t\tvar seq = this.seq;\n\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tvar u = seq[ i ];\n\t\t\tu.setValue( gl, value[ u.id ] );\n\n\t\t}\n\n\t};\n\n\t// --- Top-level ---\n\n\t// Parser - builds up the property tree from the path strings\n\n\tvar RePathPart = /([\\w\\d_]+)(\\])?(\\[|\\.)?/g,\n\t\t// extracts\n\t\t// \t- the identifier (member name or array index)\n\t\t//  - followed by an optional right bracket (found when array index)\n\t\t//  - followed by an optional left bracket or dot (type of subscript)\n\t\t//\n\t\t// Note: These portions can be read in a non-overlapping fashion and\n\t\t// allow straightforward parsing of the hierarchy that WebGL encodes\n\t\t// in the uniform names.\n\n\t\taddUniform = function( container, uniformObject ) {\n\n\t\t\tcontainer.seq.push( uniformObject );\n\t\t\tcontainer.map[ uniformObject.id ] = uniformObject;\n\n\t\t},\n\n\t\tparseUniform = function( activeInfo, addr, container ) {\n\n\t\t\tvar path = activeInfo.name,\n\t\t\t\tpathLength = path.length;\n\n\t\t\t// reset RegExp object, because of the early exit of a previous run\n\t\t\tRePathPart.lastIndex = 0;\n\n\t\t\tfor (; ;) {\n\n\t\t\t\tvar match = RePathPart.exec( path ),\n\t\t\t\t\tmatchEnd = RePathPart.lastIndex,\n\n\t\t\t\t\tid = match[ 1 ],\n\t\t\t\t\tidIsIndex = match[ 2 ] === ']',\n\t\t\t\t\tsubscript = match[ 3 ];\n\n\t\t\t\tif ( idIsIndex ) id = id | 0; // convert to integer\n\n\t\t\t\tif ( subscript === undefined ||\n\t\t\t\t\t\tsubscript === '[' && matchEnd + 2 === pathLength ) {\n\t\t\t\t\t// bare name or \"pure\" bottom-level array \"[0]\" suffix\n\n\t\t\t\t\taddUniform( container, subscript === undefined ?\n\t\t\t\t\t\t\tnew SingleUniform( id, activeInfo, addr ) :\n\t\t\t\t\t\t\tnew PureArrayUniform( id, activeInfo, addr ) );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else {\n\t\t\t\t\t// step into inner node / create it in case it doesn't exist\n\n\t\t\t\t\tvar map = container.map,\n\t\t\t\t\t\tnext = map[ id ];\n\n\t\t\t\t\tif ( next === undefined ) {\n\n\t\t\t\t\t\tnext = new StructuredUniform( id );\n\t\t\t\t\t\taddUniform( container, next );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcontainer = next;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t// Root Container\n\n\t\tWebGLUniforms = function WebGLUniforms( gl, program, renderer ) {\n\n\t\t\tUniformContainer.call( this );\n\n\t\t\tthis.renderer = renderer;\n\n\t\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );\n\n\t\t\tfor ( var i = 0; i !== n; ++ i ) {\n\n\t\t\t\tvar info = gl.getActiveUniform( program, i ),\n\t\t\t\t\tpath = info.name,\n\t\t\t\t\taddr = gl.getUniformLocation( program, path );\n\n\t\t\t\tparseUniform( info, addr, this );\n\n\t\t\t}\n\n\t\t};\n\n\n\tWebGLUniforms.prototype.setValue = function( gl, name, value ) {\n\n\t\tvar u = this.map[ name ];\n\n\t\tif ( u !== undefined ) u.setValue( gl, value, this.renderer );\n\n\t};\n\n\tWebGLUniforms.prototype.set = function( gl, object, name ) {\n\n\t\tvar u = this.map[ name ];\n\n\t\tif ( u !== undefined ) u.setValue( gl, object[ name ], this.renderer );\n\n\t};\n\n\tWebGLUniforms.prototype.setOptional = function( gl, object, name ) {\n\n\t\tvar v = object[ name ];\n\n\t\tif ( v !== undefined ) this.setValue( gl, name, v );\n\n\t};\n\n\n\t// Static interface\n\n\tWebGLUniforms.upload = function( gl, seq, values, renderer ) {\n\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tvar u = seq[ i ],\n\t\t\t\tv = values[ u.id ];\n\n\t\t\tif ( v.needsUpdate !== false ) {\n\t\t\t\t// note: always updating when .needsUpdate is undefined\n\n\t\t\t\tu.setValue( gl, v.value, renderer );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tWebGLUniforms.seqWithValue = function( seq, values ) {\n\n\t\tvar r = [];\n\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tvar u = seq[ i ];\n\t\t\tif ( u.id in values ) r.push( u );\n\n\t\t}\n\n\t\treturn r;\n\n\t};\n\n\tWebGLUniforms.splitDynamic = function( seq, values ) {\n\n\t\tvar r = null,\n\t\t\tn = seq.length,\n\t\t\tw = 0;\n\n\t\tfor ( var i = 0; i !== n; ++ i ) {\n\n\t\t\tvar u = seq[ i ],\n\t\t\t\tv = values[ u.id ];\n\n\t\t\tif ( v && v.dynamic === true ) {\n\n\t\t\t\tif ( r === null ) r = [];\n\t\t\t\tr.push( u );\n\n\t\t\t} else {\n\n\t\t\t\t// in-place compact 'seq', removing the matches\n\t\t\t\tif ( w < i ) seq[ w ] = u;\n\t\t\t\t++ w;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( w < n ) seq.length = w;\n\n\t\treturn r;\n\n\t};\n\n\tWebGLUniforms.evalDynamic = function( seq, values, object, camera ) {\n\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tvar v = values[ seq[ i ].id ],\n\t\t\t\tf = v.onUpdateCallback;\n\n\t\t\tif ( f !== undefined ) f.call( v, object, camera );\n\n\t\t}\n\n\t};\n\n\treturn WebGLUniforms;\n\n} )();\n\n// File:src/renderers/webgl/plugins/LensFlarePlugin.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.LensFlarePlugin = function ( renderer, flares ) {\n\n\tvar gl = renderer.context;\n\tvar state = renderer.state;\n\n\tvar vertexBuffer, elementBuffer;\n\tvar shader, program, attributes, uniforms;\n\n\tvar tempTexture, occlusionTexture;\n\n\tfunction init() {\n\n\t\tvar vertices = new Float32Array( [\n\t\t\t- 1, - 1,  0, 0,\n\t\t\t 1, - 1,  1, 0,\n\t\t\t 1,  1,  1, 1,\n\t\t\t- 1,  1,  0, 1\n\t\t] );\n\n\t\tvar faces = new Uint16Array( [\n\t\t\t0, 1, 2,\n\t\t\t0, 2, 3\n\t\t] );\n\n\t\t// buffers\n\n\t\tvertexBuffer     = gl.createBuffer();\n\t\telementBuffer    = gl.createBuffer();\n\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\n\n\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\n\n\t\t// textures\n\n\t\ttempTexture      = gl.createTexture();\n\t\tocclusionTexture = gl.createTexture();\n\n\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\n\t\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\n\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\n\t\tshader = {\n\n\t\t\tvertexShader: [\n\n\t\t\t\t\"uniform lowp int renderType;\",\n\n\t\t\t\t\"uniform vec3 screenPosition;\",\n\t\t\t\t\"uniform vec2 scale;\",\n\t\t\t\t\"uniform float rotation;\",\n\n\t\t\t\t\"uniform sampler2D occlusionMap;\",\n\n\t\t\t\t\"attribute vec2 position;\",\n\t\t\t\t\"attribute vec2 uv;\",\n\n\t\t\t\t\"varying vec2 vUV;\",\n\t\t\t\t\"varying float vVisibility;\",\n\n\t\t\t\t\"void main() {\",\n\n\t\t\t\t\t\"vUV = uv;\",\n\n\t\t\t\t\t\"vec2 pos = position;\",\n\n\t\t\t\t\t\"if ( renderType == 2 ) {\",\n\n\t\t\t\t\t\t\"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\",\n\n\t\t\t\t\t\t\"vVisibility =        visibility.r / 9.0;\",\n\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.g / 9.0;\",\n\t\t\t\t\t\t\"vVisibility *=       visibility.b / 9.0;\",\n\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.a / 9.0;\",\n\n\t\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\n\t\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\n\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\n\n\t\t\t\t\"}\"\n\n\t\t\t].join( \"\\n\" ),\n\n\t\t\tfragmentShader: [\n\n\t\t\t\t\"uniform lowp int renderType;\",\n\n\t\t\t\t\"uniform sampler2D map;\",\n\t\t\t\t\"uniform float opacity;\",\n\t\t\t\t\"uniform vec3 color;\",\n\n\t\t\t\t\"varying vec2 vUV;\",\n\t\t\t\t\"varying float vVisibility;\",\n\n\t\t\t\t\"void main() {\",\n\n\t\t\t\t\t// pink square\n\n\t\t\t\t\t\"if ( renderType == 0 ) {\",\n\n\t\t\t\t\t\t\"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\",\n\n\t\t\t\t\t// restore\n\n\t\t\t\t\t\"} else if ( renderType == 1 ) {\",\n\n\t\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\n\n\t\t\t\t\t// flare\n\n\t\t\t\t\t\"} else {\",\n\n\t\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\n\t\t\t\t\t\t\"texture.a *= opacity * vVisibility;\",\n\t\t\t\t\t\t\"gl_FragColor = texture;\",\n\t\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\n\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\"}\"\n\n\t\t\t].join( \"\\n\" )\n\n\t\t};\n\n\t\tprogram = createProgram( shader );\n\n\t\tattributes = {\n\t\t\tvertex: gl.getAttribLocation ( program, \"position\" ),\n\t\t\tuv:     gl.getAttribLocation ( program, \"uv\" )\n\t\t};\n\n\t\tuniforms = {\n\t\t\trenderType:     gl.getUniformLocation( program, \"renderType\" ),\n\t\t\tmap:            gl.getUniformLocation( program, \"map\" ),\n\t\t\tocclusionMap:   gl.getUniformLocation( program, \"occlusionMap\" ),\n\t\t\topacity:        gl.getUniformLocation( program, \"opacity\" ),\n\t\t\tcolor:          gl.getUniformLocation( program, \"color\" ),\n\t\t\tscale:          gl.getUniformLocation( program, \"scale\" ),\n\t\t\trotation:       gl.getUniformLocation( program, \"rotation\" ),\n\t\t\tscreenPosition: gl.getUniformLocation( program, \"screenPosition\" )\n\t\t};\n\n\t}\n\n\t/*\n\t * Render lens flares\n\t * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,\n\t *         reads these back and calculates occlusion.\n\t */\n\n\tthis.render = function ( scene, camera, viewport ) {\n\n\t\tif ( flares.length === 0 ) return;\n\n\t\tvar tempPosition = new THREE.Vector3();\n\n\t\tvar invAspect = viewport.w / viewport.z,\n\t\t\thalfViewportWidth = viewport.z * 0.5,\n\t\t\thalfViewportHeight = viewport.w * 0.5;\n\n\t\tvar size = 16 / viewport.w,\n\t\t\tscale = new THREE.Vector2( size * invAspect, size );\n\n\t\tvar screenPosition = new THREE.Vector3( 1, 1, 0 ),\n\t\t\tscreenPositionPixels = new THREE.Vector2( 1, 1 );\n\n\t\tvar validArea = new THREE.Box2();\n\n\t\tvalidArea.min.set( 0, 0 );\n\t\tvalidArea.max.set( viewport.z - 16, viewport.w - 16 );\n\n\t\tif ( program === undefined ) {\n\n\t\t\tinit();\n\n\t\t}\n\n\t\tgl.useProgram( program );\n\n\t\tstate.initAttributes();\n\t\tstate.enableAttribute( attributes.vertex );\n\t\tstate.enableAttribute( attributes.uv );\n\t\tstate.disableUnusedAttributes();\n\n\t\t// loop through all lens flares to update their occlusion and positions\n\t\t// setup gl and common used attribs/uniforms\n\n\t\tgl.uniform1i( uniforms.occlusionMap, 0 );\n\t\tgl.uniform1i( uniforms.map, 1 );\n\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\tgl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );\n\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\n\n\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\n\t\tstate.disable( gl.CULL_FACE );\n\t\tstate.setDepthWrite( false );\n\n\t\tfor ( var i = 0, l = flares.length; i < l; i ++ ) {\n\n\t\t\tsize = 16 / viewport.w;\n\t\t\tscale.set( size * invAspect, size );\n\n\t\t\t// calc object screen position\n\n\t\t\tvar flare = flares[ i ];\n\n\t\t\ttempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );\n\n\t\t\ttempPosition.applyMatrix4( camera.matrixWorldInverse );\n\t\t\ttempPosition.applyProjection( camera.projectionMatrix );\n\n\t\t\t// setup arrays for gl programs\n\n\t\t\tscreenPosition.copy( tempPosition );\n\n\t\t\t// horizontal and vertical coordinate of the lower left corner of the pixels to copy\n\n\t\t\tscreenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;\n\t\t\tscreenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;\n\n\t\t\t// screen cull\n\n\t\t\tif ( validArea.containsPoint( screenPositionPixels ) === true ) {\n\n\t\t\t\t// save current RGB to temp texture\n\n\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, null );\n\t\t\t\tstate.activeTexture( gl.TEXTURE1 );\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\n\n\n\t\t\t\t// render pink quad\n\n\t\t\t\tgl.uniform1i( uniforms.renderType, 0 );\n\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\n\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\n\n\t\t\t\tstate.disable( gl.BLEND );\n\t\t\t\tstate.enable( gl.DEPTH_TEST );\n\n\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\n\t\t\t\t// copy result to occlusionMap\n\n\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\n\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\n\n\n\t\t\t\t// restore graphics\n\n\t\t\t\tgl.uniform1i( uniforms.renderType, 1 );\n\t\t\t\tstate.disable( gl.DEPTH_TEST );\n\n\t\t\t\tstate.activeTexture( gl.TEXTURE1 );\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\n\t\t\t\t// update object positions\n\n\t\t\t\tflare.positionScreen.copy( screenPosition );\n\n\t\t\t\tif ( flare.customUpdateCallback ) {\n\n\t\t\t\t\tflare.customUpdateCallback( flare );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tflare.updateLensFlares();\n\n\t\t\t\t}\n\n\t\t\t\t// render flares\n\n\t\t\t\tgl.uniform1i( uniforms.renderType, 2 );\n\t\t\t\tstate.enable( gl.BLEND );\n\n\t\t\t\tfor ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {\n\n\t\t\t\t\tvar sprite = flare.lensFlares[ j ];\n\n\t\t\t\t\tif ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {\n\n\t\t\t\t\t\tscreenPosition.x = sprite.x;\n\t\t\t\t\t\tscreenPosition.y = sprite.y;\n\t\t\t\t\t\tscreenPosition.z = sprite.z;\n\n\t\t\t\t\t\tsize = sprite.size * sprite.scale / viewport.w;\n\n\t\t\t\t\t\tscale.x = size * invAspect;\n\t\t\t\t\t\tscale.y = size;\n\n\t\t\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\n\t\t\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\n\t\t\t\t\t\tgl.uniform1f( uniforms.rotation, sprite.rotation );\n\n\t\t\t\t\t\tgl.uniform1f( uniforms.opacity, sprite.opacity );\n\t\t\t\t\t\tgl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );\n\n\t\t\t\t\t\tstate.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );\n\t\t\t\t\t\trenderer.setTexture2D( sprite.texture, 1 );\n\n\t\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// restore gl\n\n\t\tstate.enable( gl.CULL_FACE );\n\t\tstate.enable( gl.DEPTH_TEST );\n\t\tstate.setDepthWrite( true );\n\n\t\trenderer.resetGLState();\n\n\t};\n\n\tfunction createProgram ( shader ) {\n\n\t\tvar program = gl.createProgram();\n\n\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\n\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\n\n\t\tvar prefix = \"precision \" + renderer.getPrecision() + \" float;\\n\";\n\n\t\tgl.shaderSource( fragmentShader, prefix + shader.fragmentShader );\n\t\tgl.shaderSource( vertexShader, prefix + shader.vertexShader );\n\n\t\tgl.compileShader( fragmentShader );\n\t\tgl.compileShader( vertexShader );\n\n\t\tgl.attachShader( program, fragmentShader );\n\t\tgl.attachShader( program, vertexShader );\n\n\t\tgl.linkProgram( program );\n\n\t\treturn program;\n\n\t}\n\n};\n\n// File:src/renderers/webgl/plugins/SpritePlugin.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.SpritePlugin = function ( renderer, sprites ) {\n\n\tvar gl = renderer.context;\n\tvar state = renderer.state;\n\n\tvar vertexBuffer, elementBuffer;\n\tvar program, attributes, uniforms;\n\n\tvar texture;\n\n\t// decompose matrixWorld\n\n\tvar spritePosition = new THREE.Vector3();\n\tvar spriteRotation = new THREE.Quaternion();\n\tvar spriteScale = new THREE.Vector3();\n\n\tfunction init() {\n\n\t\tvar vertices = new Float32Array( [\n\t\t\t- 0.5, - 0.5,  0, 0,\n\t\t\t  0.5, - 0.5,  1, 0,\n\t\t\t  0.5,   0.5,  1, 1,\n\t\t\t- 0.5,   0.5,  0, 1\n\t\t] );\n\n\t\tvar faces = new Uint16Array( [\n\t\t\t0, 1, 2,\n\t\t\t0, 2, 3\n\t\t] );\n\n\t\tvertexBuffer  = gl.createBuffer();\n\t\telementBuffer = gl.createBuffer();\n\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\n\n\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\n\n\t\tprogram = createProgram();\n\n\t\tattributes = {\n\t\t\tposition:\t\t\tgl.getAttribLocation ( program, 'position' ),\n\t\t\tuv:\t\t\t\t\tgl.getAttribLocation ( program, 'uv' )\n\t\t};\n\n\t\tuniforms = {\n\t\t\tuvOffset:\t\t\tgl.getUniformLocation( program, 'uvOffset' ),\n\t\t\tuvScale:\t\t\tgl.getUniformLocation( program, 'uvScale' ),\n\n\t\t\trotation:\t\t\tgl.getUniformLocation( program, 'rotation' ),\n\t\t\tscale:\t\t\t\tgl.getUniformLocation( program, 'scale' ),\n\n\t\t\tcolor:\t\t\t\tgl.getUniformLocation( program, 'color' ),\n\t\t\tmap:\t\t\t\tgl.getUniformLocation( program, 'map' ),\n\t\t\topacity:\t\t\tgl.getUniformLocation( program, 'opacity' ),\n\n\t\t\tmodelViewMatrix: \tgl.getUniformLocation( program, 'modelViewMatrix' ),\n\t\t\tprojectionMatrix:\tgl.getUniformLocation( program, 'projectionMatrix' ),\n\n\t\t\tfogType:\t\t\tgl.getUniformLocation( program, 'fogType' ),\n\t\t\tfogDensity:\t\t\tgl.getUniformLocation( program, 'fogDensity' ),\n\t\t\tfogNear:\t\t\tgl.getUniformLocation( program, 'fogNear' ),\n\t\t\tfogFar:\t\t\t\tgl.getUniformLocation( program, 'fogFar' ),\n\t\t\tfogColor:\t\t\tgl.getUniformLocation( program, 'fogColor' ),\n\n\t\t\talphaTest:\t\t\tgl.getUniformLocation( program, 'alphaTest' )\n\t\t};\n\n\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\tcanvas.width = 8;\n\t\tcanvas.height = 8;\n\n\t\tvar context = canvas.getContext( '2d' );\n\t\tcontext.fillStyle = 'white';\n\t\tcontext.fillRect( 0, 0, 8, 8 );\n\n\t\ttexture = new THREE.Texture( canvas );\n\t\ttexture.needsUpdate = true;\n\n\t}\n\n\tthis.render = function ( scene, camera ) {\n\n\t\tif ( sprites.length === 0 ) return;\n\n\t\t// setup gl\n\n\t\tif ( program === undefined ) {\n\n\t\t\tinit();\n\n\t\t}\n\n\t\tgl.useProgram( program );\n\n\t\tstate.initAttributes();\n\t\tstate.enableAttribute( attributes.position );\n\t\tstate.enableAttribute( attributes.uv );\n\t\tstate.disableUnusedAttributes();\n\n\t\tstate.disable( gl.CULL_FACE );\n\t\tstate.enable( gl.BLEND );\n\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\tgl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );\n\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\n\n\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\n\t\tgl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\n\n\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\tgl.uniform1i( uniforms.map, 0 );\n\n\t\tvar oldFogType = 0;\n\t\tvar sceneFogType = 0;\n\t\tvar fog = scene.fog;\n\n\t\tif ( fog ) {\n\n\t\t\tgl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );\n\n\t\t\tif ( fog instanceof THREE.Fog ) {\n\n\t\t\t\tgl.uniform1f( uniforms.fogNear, fog.near );\n\t\t\t\tgl.uniform1f( uniforms.fogFar, fog.far );\n\n\t\t\t\tgl.uniform1i( uniforms.fogType, 1 );\n\t\t\t\toldFogType = 1;\n\t\t\t\tsceneFogType = 1;\n\n\t\t\t} else if ( fog instanceof THREE.FogExp2 ) {\n\n\t\t\t\tgl.uniform1f( uniforms.fogDensity, fog.density );\n\n\t\t\t\tgl.uniform1i( uniforms.fogType, 2 );\n\t\t\t\toldFogType = 2;\n\t\t\t\tsceneFogType = 2;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tgl.uniform1i( uniforms.fogType, 0 );\n\t\t\toldFogType = 0;\n\t\t\tsceneFogType = 0;\n\n\t\t}\n\n\n\t\t// update positions and sort\n\n\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\n\n\t\t\tvar sprite = sprites[ i ];\n\n\t\t\tsprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );\n\t\t\tsprite.z = - sprite.modelViewMatrix.elements[ 14 ];\n\n\t\t}\n\n\t\tsprites.sort( painterSortStable );\n\n\t\t// render all sprites\n\n\t\tvar scale = [];\n\n\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\n\n\t\t\tvar sprite = sprites[ i ];\n\t\t\tvar material = sprite.material;\n\n\t\t\tgl.uniform1f( uniforms.alphaTest, material.alphaTest );\n\t\t\tgl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );\n\n\t\t\tsprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );\n\n\t\t\tscale[ 0 ] = spriteScale.x;\n\t\t\tscale[ 1 ] = spriteScale.y;\n\n\t\t\tvar fogType = 0;\n\n\t\t\tif ( scene.fog && material.fog ) {\n\n\t\t\t\tfogType = sceneFogType;\n\n\t\t\t}\n\n\t\t\tif ( oldFogType !== fogType ) {\n\n\t\t\t\tgl.uniform1i( uniforms.fogType, fogType );\n\t\t\t\toldFogType = fogType;\n\n\t\t\t}\n\n\t\t\tif ( material.map !== null ) {\n\n\t\t\t\tgl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );\n\t\t\t\tgl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );\n\n\t\t\t} else {\n\n\t\t\t\tgl.uniform2f( uniforms.uvOffset, 0, 0 );\n\t\t\t\tgl.uniform2f( uniforms.uvScale, 1, 1 );\n\n\t\t\t}\n\n\t\t\tgl.uniform1f( uniforms.opacity, material.opacity );\n\t\t\tgl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );\n\n\t\t\tgl.uniform1f( uniforms.rotation, material.rotation );\n\t\t\tgl.uniform2fv( uniforms.scale, scale );\n\n\t\t\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\n\t\t\tstate.setDepthTest( material.depthTest );\n\t\t\tstate.setDepthWrite( material.depthWrite );\n\n\t\t\tif ( material.map ) {\n\n\t\t\t\trenderer.setTexture2D( material.map, 0 );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.setTexture2D( texture, 0 );\n\n\t\t\t}\n\n\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\t\t}\n\n\t\t// restore gl\n\n\t\tstate.enable( gl.CULL_FACE );\n\n\t\trenderer.resetGLState();\n\n\t};\n\n\tfunction createProgram () {\n\n\t\tvar program = gl.createProgram();\n\n\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\n\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\n\n\t\tgl.shaderSource( vertexShader, [\n\n\t\t\t'precision ' + renderer.getPrecision() + ' float;',\n\n\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t'uniform float rotation;',\n\t\t\t'uniform vec2 scale;',\n\t\t\t'uniform vec2 uvOffset;',\n\t\t\t'uniform vec2 uvScale;',\n\n\t\t\t'attribute vec2 position;',\n\t\t\t'attribute vec2 uv;',\n\n\t\t\t'varying vec2 vUV;',\n\n\t\t\t'void main() {',\n\n\t\t\t\t'vUV = uvOffset + uv * uvScale;',\n\n\t\t\t\t'vec2 alignedPosition = position * scale;',\n\n\t\t\t\t'vec2 rotatedPosition;',\n\t\t\t\t'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',\n\t\t\t\t'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',\n\n\t\t\t\t'vec4 finalPosition;',\n\n\t\t\t\t'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',\n\t\t\t\t'finalPosition.xy += rotatedPosition;',\n\t\t\t\t'finalPosition = projectionMatrix * finalPosition;',\n\n\t\t\t\t'gl_Position = finalPosition;',\n\n\t\t\t'}'\n\n\t\t].join( '\\n' ) );\n\n\t\tgl.shaderSource( fragmentShader, [\n\n\t\t\t'precision ' + renderer.getPrecision() + ' float;',\n\n\t\t\t'uniform vec3 color;',\n\t\t\t'uniform sampler2D map;',\n\t\t\t'uniform float opacity;',\n\n\t\t\t'uniform int fogType;',\n\t\t\t'uniform vec3 fogColor;',\n\t\t\t'uniform float fogDensity;',\n\t\t\t'uniform float fogNear;',\n\t\t\t'uniform float fogFar;',\n\t\t\t'uniform float alphaTest;',\n\n\t\t\t'varying vec2 vUV;',\n\n\t\t\t'void main() {',\n\n\t\t\t\t'vec4 texture = texture2D( map, vUV );',\n\n\t\t\t\t'if ( texture.a < alphaTest ) discard;',\n\n\t\t\t\t'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',\n\n\t\t\t\t'if ( fogType > 0 ) {',\n\n\t\t\t\t\t'float depth = gl_FragCoord.z / gl_FragCoord.w;',\n\t\t\t\t\t'float fogFactor = 0.0;',\n\n\t\t\t\t\t'if ( fogType == 1 ) {',\n\n\t\t\t\t\t\t'fogFactor = smoothstep( fogNear, fogFar, depth );',\n\n\t\t\t\t\t'} else {',\n\n\t\t\t\t\t\t'const float LOG2 = 1.442695;',\n\t\t\t\t\t\t'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',\n\t\t\t\t\t\t'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',\n\n\t\t\t\t\t'}',\n\n\t\t\t\t\t'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',\n\n\t\t\t\t'}',\n\n\t\t\t'}'\n\n\t\t].join( '\\n' ) );\n\n\t\tgl.compileShader( vertexShader );\n\t\tgl.compileShader( fragmentShader );\n\n\t\tgl.attachShader( program, vertexShader );\n\t\tgl.attachShader( program, fragmentShader );\n\n\t\tgl.linkProgram( program );\n\n\t\treturn program;\n\n\t}\n\n\tfunction painterSortStable ( a, b ) {\n\t\t\n\t\tif ( a.renderOrder !== b.renderOrder ) {\n\n\t\t\treturn a.renderOrder - b.renderOrder;\n\n\t\t} else if ( a.z !== b.z ) {\n\n\t\t\treturn b.z - a.z;\n\n\t\t} else {\n\n\t\t\treturn b.id - a.id;\n\n\t\t}\n\n\t}\n\n};\n\n// File:src/Three.Legacy.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nObject.assign( THREE, {\n\tFace4: function ( a, b, c, d, normal, color, materialIndex ) {\n\t\tconsole.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );\n\t\treturn new THREE.Face3( a, b, c, normal, color, materialIndex );\n\t},\n\tLineStrip: 0,\n\tLinePieces: 1,\n\tMeshFaceMaterial: THREE.MultiMaterial,\n\tPointCloud: function ( geometry, material ) {\n\t\tconsole.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );\n\t\treturn new THREE.Points( geometry, material );\n\t},\n\tParticle: THREE.Sprite,\n\tParticleSystem: function ( geometry, material ) {\n\t\tconsole.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );\n\t\treturn new THREE.Points( geometry, material );\n\t},\n\tPointCloudMaterial: function ( parameters ) {\n\t\tconsole.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );\n\t\treturn new THREE.PointsMaterial( parameters );\n\t},\n\tParticleBasicMaterial: function ( parameters ) {\n\t\tconsole.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );\n\t\treturn new THREE.PointsMaterial( parameters );\n\t},\n\tParticleSystemMaterial: function ( parameters ) {\n\t\tconsole.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );\n\t\treturn new THREE.PointsMaterial( parameters );\n\t},\n\tVertex: function ( x, y, z ) {\n\t\tconsole.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );\n\t\treturn new THREE.Vector3( x, y, z );\n\t}\n} );\n\n//\n\nObject.assign( THREE.Box2.prototype, {\n\tempty: function () {\n\t\tconsole.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );\n\t\treturn this.isEmpty();\n\t},\n\tisIntersectionBox: function ( box ) {\n\t\tconsole.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\treturn this.intersectsBox( box );\n\t}\n} );\n\nObject.assign( THREE.Box3.prototype, {\n\tempty: function () {\n\t\tconsole.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );\n\t\treturn this.isEmpty();\n\t},\n\tisIntersectionBox: function ( box ) {\n\t\tconsole.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\treturn this.intersectsBox( box );\n\t},\n\tisIntersectionSphere: function ( sphere ) {\n\t\tconsole.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n\t\treturn this.intersectsSphere( sphere );\n\t}\n} );\n\nObject.assign( THREE.Matrix3.prototype, {\n\tmultiplyVector3: function ( vector ) {\n\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\n\t\treturn vector.applyMatrix3( this );\n\t},\n\tmultiplyVector3Array: function ( a ) {\n\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\n\t\treturn this.applyToVector3Array( a );\n\t}\n} );\n\nObject.assign( THREE.Matrix4.prototype, {\n\textractPosition: function ( m ) {\n\t\tconsole.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );\n\t\treturn this.copyPosition( m );\n\t},\n\tsetRotationFromQuaternion: function ( q ) {\n\t\tconsole.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );\n\t\treturn this.makeRotationFromQuaternion( q );\n\t},\n\tmultiplyVector3: function ( vector ) {\n\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );\n\t\treturn vector.applyProjection( this );\n\t},\n\tmultiplyVector4: function ( vector ) {\n\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\treturn vector.applyMatrix4( this );\n\t},\n\tmultiplyVector3Array: function ( a ) {\n\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\n\t\treturn this.applyToVector3Array( a );\n\t},\n\trotateAxis: function ( v ) {\n\t\tconsole.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );\n\t\tv.transformDirection( this );\n\t},\n\tcrossVector: function ( vector ) {\n\t\tconsole.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\treturn vector.applyMatrix4( this );\n\t},\n\ttranslate: function ( v ) {\n\t\tconsole.error( 'THREE.Matrix4: .translate() has been removed.' );\n\t},\n\trotateX: function ( angle ) {\n\t\tconsole.error( 'THREE.Matrix4: .rotateX() has been removed.' );\n\t},\n\trotateY: function ( angle ) {\n\t\tconsole.error( 'THREE.Matrix4: .rotateY() has been removed.' );\n\t},\n\trotateZ: function ( angle ) {\n\t\tconsole.error( 'THREE.Matrix4: .rotateZ() has been removed.' );\n\t},\n\trotateByAxis: function ( axis, angle ) {\n\t\tconsole.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );\n\t}\n} );\n\nObject.assign( THREE.Plane.prototype, {\n\tisIntersectionLine: function ( line ) {\n\t\tconsole.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );\n\t\treturn this.intersectsLine( line );\n\t}\n} );\n\nObject.assign( THREE.Quaternion.prototype, {\n\tmultiplyVector3: function ( vector ) {\n\t\tconsole.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\n\t\treturn vector.applyQuaternion( this );\n\t}\n} );\n\nObject.assign( THREE.Ray.prototype, {\n\tisIntersectionBox: function ( box ) {\n\t\tconsole.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\treturn this.intersectsBox( box );\n\t},\n\tisIntersectionPlane: function ( plane ) {\n\t\tconsole.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );\n\t\treturn this.intersectsPlane( plane );\n\t},\n\tisIntersectionSphere: function ( sphere ) {\n\t\tconsole.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n\t\treturn this.intersectsSphere( sphere );\n\t}\n} );\n\nObject.assign( THREE.Vector3.prototype, {\n\tsetEulerFromRotationMatrix: function () {\n\t\tconsole.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );\n\t},\n\tsetEulerFromQuaternion: function () {\n\t\tconsole.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );\n\t},\n\tgetPositionFromMatrix: function ( m ) {\n\t\tconsole.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );\n\t\treturn this.setFromMatrixPosition( m );\n\t},\n\tgetScaleFromMatrix: function ( m ) {\n\t\tconsole.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );\n\t\treturn this.setFromMatrixScale( m );\n\t},\n\tgetColumnFromMatrix: function ( index, matrix ) {\n\t\tconsole.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );\n\t\treturn this.setFromMatrixColumn( matrix, index );\n\t}\n} );\n\n//\n\nObject.assign( THREE.Object3D.prototype, {\n\tgetChildByName: function ( name ) {\n\t\tconsole.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );\n\t\treturn this.getObjectByName( name );\n\t},\n\trenderDepth: function ( value ) {\n\t\tconsole.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );\n\t},\n\ttranslate: function ( distance, axis ) {\n\t\tconsole.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );\n\t\treturn this.translateOnAxis( axis, distance );\n\t}\n} );\n\nObject.defineProperties( THREE.Object3D.prototype, {\n\teulerOrder: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n\t\t\treturn this.rotation.order;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n\t\t\tthis.rotation.order = value;\n\t\t}\n\t},\n\tuseQuaternion: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\t\t}\n\t}\n} );\n\nObject.defineProperties( THREE.LOD.prototype, {\n\tobjects: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.LOD: .objects has been renamed to .levels.' );\n\t\t\treturn this.levels;\n\t\t}\n\t}\n} );\n\n//\n\nTHREE.PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {\n\n\tconsole.warn( \"THREE.PerspectiveCamera.setLens is deprecated. \" +\n\t\t\t\"Use .setFocalLength and .filmGauge for a photographic setup.\" );\n\n\tif ( filmGauge !== undefined ) this.filmGauge = filmGauge;\n\tthis.setFocalLength( focalLength );\n\n};\n\n//\n\nObject.defineProperties( THREE.Light.prototype, {\n\tonlyShadow: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .onlyShadow has been removed.' );\n\t\t}\n\t},\n\tshadowCameraFov: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );\n\t\t\tthis.shadow.camera.fov = value;\n\t\t}\n\t},\n\tshadowCameraLeft: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );\n\t\t\tthis.shadow.camera.left = value;\n\t\t}\n\t},\n\tshadowCameraRight: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );\n\t\t\tthis.shadow.camera.right = value;\n\t\t}\n\t},\n\tshadowCameraTop: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );\n\t\t\tthis.shadow.camera.top = value;\n\t\t}\n\t},\n\tshadowCameraBottom: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );\n\t\t\tthis.shadow.camera.bottom = value;\n\t\t}\n\t},\n\tshadowCameraNear: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );\n\t\t\tthis.shadow.camera.near = value;\n\t\t}\n\t},\n\tshadowCameraFar: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );\n\t\t\tthis.shadow.camera.far = value;\n\t\t}\n\t},\n\tshadowCameraVisible: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );\n\t\t}\n\t},\n\tshadowBias: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );\n\t\t\tthis.shadow.bias = value;\n\t\t}\n\t},\n\tshadowDarkness: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowDarkness has been removed.' );\n\t\t}\n\t},\n\tshadowMapWidth: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );\n\t\t\tthis.shadow.mapSize.width = value;\n\t\t}\n\t},\n\tshadowMapHeight: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );\n\t\t\tthis.shadow.mapSize.height = value;\n\t\t}\n\t}\n} );\n\n//\n\nObject.defineProperties( THREE.BufferAttribute.prototype, {\n\tlength: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );\n\t\t\treturn this.array.length;\n\t\t}\n\t}\n} );\n\nObject.assign( THREE.BufferGeometry.prototype, {\n\taddIndex: function ( index ) {\n\t\tconsole.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );\n\t\tthis.setIndex( index );\n\t},\n\taddDrawCall: function ( start, count, indexOffset ) {\n\t\tif ( indexOffset !== undefined ) {\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );\n\t\t}\n\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );\n\t\tthis.addGroup( start, count );\n\t},\n\tclearDrawCalls: function () {\n\t\tconsole.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );\n\t\tthis.clearGroups();\n\t},\n\tcomputeTangents: function () {\n\t\tconsole.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );\n\t},\n\tcomputeOffsets: function () {\n\t\tconsole.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );\n\t}\n} );\n\nObject.defineProperties( THREE.BufferGeometry.prototype, {\n\tdrawcalls: {\n\t\tget: function () {\n\t\t\tconsole.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );\n\t\t\treturn this.groups;\n\t\t}\n\t},\n\toffsets: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );\n\t\t\treturn this.groups;\n\t\t}\n\t}\n} );\n\n//\n\nObject.defineProperties( THREE.Material.prototype, {\n\twrapAround: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\n\t\t}\n\t},\n\twrapRGB: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );\n\t\t\treturn new THREE.Color();\n\t\t}\n\t}\n} );\n\nObject.defineProperties( THREE.MeshPhongMaterial.prototype, {\n\tmetal: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );\n\t\t\treturn false;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );\n\t\t}\n\t}\n} );\n\nObject.defineProperties( THREE.ShaderMaterial.prototype, {\n\tderivatives: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n\t\t\treturn this.extensions.derivatives;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n\t\t\tthis.extensions.derivatives = value;\n\t\t}\n\t}\n} );\n\n//\n\nTHREE.EventDispatcher.prototype = Object.assign( Object.create( {\n\n\t// Note: Extra base ensures these properties are not 'assign'ed.\n\n\tconstructor: THREE.EventDispatcher,\n\n\tapply: function ( target ) {\n\n\t\tconsole.warn( \"THREE.EventDispatcher: .apply is deprecated, \" +\n\t\t\t\t\"just inherit or Object.assign the prototype to mix-in.\" );\n\n\t\tObject.assign( target, this );\n\n\t}\n\n} ), THREE.EventDispatcher.prototype );\n\n//\n\nObject.assign( THREE.WebGLRenderer.prototype, {\n\tsupportsFloatTextures: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \\'OES_texture_float\\' ).' );\n\t\treturn this.extensions.get( 'OES_texture_float' );\n\t},\n\tsupportsHalfFloatTextures: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \\'OES_texture_half_float\\' ).' );\n\t\treturn this.extensions.get( 'OES_texture_half_float' );\n\t},\n\tsupportsStandardDerivatives: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \\'OES_standard_derivatives\\' ).' );\n\t\treturn this.extensions.get( 'OES_standard_derivatives' );\n\t},\n\tsupportsCompressedTextureS3TC: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \\'WEBGL_compressed_texture_s3tc\\' ).' );\n\t\treturn this.extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\t},\n\tsupportsCompressedTexturePVRTC: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \\'WEBGL_compressed_texture_pvrtc\\' ).' );\n\t\treturn this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\t},\n\tsupportsBlendMinMax: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \\'EXT_blend_minmax\\' ).' );\n\t\treturn this.extensions.get( 'EXT_blend_minmax' );\n\t},\n\tsupportsVertexTextures: function () {\n\t\treturn this.capabilities.vertexTextures;\n\t},\n\tsupportsInstancedArrays: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \\'ANGLE_instanced_arrays\\' ).' );\n\t\treturn this.extensions.get( 'ANGLE_instanced_arrays' );\n\t},\n\tenableScissorTest: function ( boolean ) {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );\n\t\tthis.setScissorTest( boolean );\n\t},\n\tinitMaterial: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );\n\t},\n\taddPrePlugin: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );\n\t},\n\taddPostPlugin: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );\n\t},\n\tupdateShadowMap: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );\n\t}\n} );\n\nObject.defineProperties( THREE.WebGLRenderer.prototype, {\n\tshadowMapEnabled: {\n\t\tget: function () {\n\t\t\treturn this.shadowMap.enabled;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );\n\t\t\tthis.shadowMap.enabled = value;\n\t\t}\n\t},\n\tshadowMapType: {\n\t\tget: function () {\n\t\t\treturn this.shadowMap.type;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );\n\t\t\tthis.shadowMap.type = value;\n\t\t}\n\t},\n\tshadowMapCullFace: {\n\t\tget: function () {\n\t\t\treturn this.shadowMap.cullFace;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );\n\t\t\tthis.shadowMap.cullFace = value;\n\t\t}\n\t}\n} );\n\nObject.defineProperties( THREE.WebGLShadowMap.prototype, {\n\tcullFace: {\n\t\tget: function () {\n\t\t\treturn this.renderReverseSided ? THREE.CullFaceFront : THREE.CullFaceBack;\n\t\t},\n\t\tset: function ( cullFace ) {\n\t\t\tvar value = ( cullFace !== THREE.CullFaceBack );\n\t\t\tconsole.warn( \"WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to \" + value + \".\" );\n\t\t\tthis.renderReverseSided = value;\n\t\t}\n\t}\n} );\n\n//\n\nObject.defineProperties( THREE.WebGLRenderTarget.prototype, {\n\twrapS: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n\t\t\treturn this.texture.wrapS;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n\t\t\tthis.texture.wrapS = value;\n\t\t}\n\t},\n\twrapT: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n\t\t\treturn this.texture.wrapT;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n\t\t\tthis.texture.wrapT = value;\n\t\t}\n\t},\n\tmagFilter: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n\t\t\treturn this.texture.magFilter;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n\t\t\tthis.texture.magFilter = value;\n\t\t}\n\t},\n\tminFilter: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n\t\t\treturn this.texture.minFilter;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n\t\t\tthis.texture.minFilter = value;\n\t\t}\n\t},\n\tanisotropy: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n\t\t\treturn this.texture.anisotropy;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n\t\t\tthis.texture.anisotropy = value;\n\t\t}\n\t},\n\toffset: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n\t\t\treturn this.texture.offset;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n\t\t\tthis.texture.offset = value;\n\t\t}\n\t},\n\trepeat: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n\t\t\treturn this.texture.repeat;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n\t\t\tthis.texture.repeat = value;\n\t\t}\n\t},\n\tformat: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n\t\t\treturn this.texture.format;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n\t\t\tthis.texture.format = value;\n\t\t}\n\t},\n\ttype: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n\t\t\treturn this.texture.type;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n\t\t\tthis.texture.type = value;\n\t\t}\n\t},\n\tgenerateMipmaps: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n\t\t\treturn this.texture.generateMipmaps;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n\t\t\tthis.texture.generateMipmaps = value;\n\t\t}\n\t}\n} );\n\n//\n\nObject.assign( THREE.Audio.prototype, {\n\tload: function ( file ) {\n\t\tconsole.warn( 'THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader.' );\n\t\tvar scope = this;\n\t\tvar audioLoader = new THREE.AudioLoader();\n\t\taudioLoader.load( file, function ( buffer ) {\n\t\t\tscope.setBuffer( buffer );\n\t\t} );\n\t\treturn this;\n\t}\n} );\n\nObject.assign( THREE.AudioAnalyser.prototype, {\n\tgetData: function ( file ) {\n\t\tconsole.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );\n\t\treturn this.getFrequencyData();\n\t}\n} );\n\n//\n\nTHREE.GeometryUtils = {\n\n\tmerge: function ( geometry1, geometry2, materialIndexOffset ) {\n\n\t\tconsole.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );\n\n\t\tvar matrix;\n\n\t\tif ( geometry2 instanceof THREE.Mesh ) {\n\n\t\t\tgeometry2.matrixAutoUpdate && geometry2.updateMatrix();\n\n\t\t\tmatrix = geometry2.matrix;\n\t\t\tgeometry2 = geometry2.geometry;\n\n\t\t}\n\n\t\tgeometry1.merge( geometry2, matrix, materialIndexOffset );\n\n\t},\n\n\tcenter: function ( geometry ) {\n\n\t\tconsole.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );\n\t\treturn geometry.center();\n\n\t}\n\n};\n\nTHREE.ImageUtils = {\n\n\tcrossOrigin: undefined,\n\n\tloadTexture: function ( url, mapping, onLoad, onError ) {\n\n\t\tconsole.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );\n\n\t\tvar loader = new THREE.TextureLoader();\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\tvar texture = loader.load( url, onLoad, undefined, onError );\n\n\t\tif ( mapping ) texture.mapping = mapping;\n\n\t\treturn texture;\n\n\t},\n\n\tloadTextureCube: function ( urls, mapping, onLoad, onError ) {\n\n\t\tconsole.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );\n\n\t\tvar loader = new THREE.CubeTextureLoader();\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\tvar texture = loader.load( urls, onLoad, undefined, onError );\n\n\t\tif ( mapping ) texture.mapping = mapping;\n\n\t\treturn texture;\n\n\t},\n\n\tloadCompressedTexture: function () {\n\n\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );\n\n\t},\n\n\tloadCompressedTextureCube: function () {\n\n\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );\n\n\t}\n\n};\n\n//\n\nTHREE.Projector = function () {\n\n\tconsole.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );\n\n\tthis.projectVector = function ( vector, camera ) {\n\n\t\tconsole.warn( 'THREE.Projector: .projectVector() is now vector.project().' );\n\t\tvector.project( camera );\n\n\t};\n\n\tthis.unprojectVector = function ( vector, camera ) {\n\n\t\tconsole.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );\n\t\tvector.unproject( camera );\n\n\t};\n\n\tthis.pickingRay = function ( vector, camera ) {\n\n\t\tconsole.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );\n\n\t};\n\n};\n\n//\n\nTHREE.CanvasRenderer = function () {\n\n\tconsole.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );\n\n\tthis.domElement = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\tthis.clear = function () {};\n\tthis.render = function () {};\n\tthis.setClearColor = function () {};\n\tthis.setSize = function () {};\n\n};\n\n// File:src/extras/CurveUtils.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n */\n\nTHREE.CurveUtils = {\n\n\ttangentQuadraticBezier: function ( t, p0, p1, p2 ) {\n\n\t\treturn 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );\n\n\t},\n\n\t// Puay Bing, thanks for helping with this derivative!\n\n\ttangentCubicBezier: function ( t, p0, p1, p2, p3 ) {\n\n\t\treturn - 3 * p0 * ( 1 - t ) * ( 1 - t )  +\n\t\t\t3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +\n\t\t\t6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +\n\t\t\t3 * t * t * p3;\n\n\t},\n\n\ttangentSpline: function ( t, p0, p1, p2, p3 ) {\n\n\t\t// To check if my formulas are correct\n\n\t\tvar h00 = 6 * t * t - 6 * t; \t// derived from 2t^3 − 3t^2 + 1\n\t\tvar h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t\n\t\tvar h01 = - 6 * t * t + 6 * t; \t// − 2t3 + 3t2\n\t\tvar h11 = 3 * t * t - 2 * t;\t// t3 − t2\n\n\t\treturn h00 + h10 + h01 + h11;\n\n\t},\n\n\t// Catmull-Rom\n\n\tinterpolate: function( p0, p1, p2, p3, t ) {\n\n\t\tvar v0 = ( p2 - p0 ) * 0.5;\n\t\tvar v1 = ( p3 - p1 ) * 0.5;\n\t\tvar t2 = t * t;\n\t\tvar t3 = t * t2;\n\t\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n\t}\n\n};\n\n// File:src/extras/SceneUtils.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.SceneUtils = {\n\n\tcreateMultiMaterialObject: function ( geometry, materials ) {\n\n\t\tvar group = new THREE.Group();\n\n\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\tgroup.add( new THREE.Mesh( geometry, materials[ i ] ) );\n\n\t\t}\n\n\t\treturn group;\n\n\t},\n\n\tdetach: function ( child, parent, scene ) {\n\n\t\tchild.applyMatrix( parent.matrixWorld );\n\t\tparent.remove( child );\n\t\tscene.add( child );\n\n\t},\n\n\tattach: function ( child, scene, parent ) {\n\n\t\tvar matrixWorldInverse = new THREE.Matrix4();\n\t\tmatrixWorldInverse.getInverse( parent.matrixWorld );\n\t\tchild.applyMatrix( matrixWorldInverse );\n\n\t\tscene.remove( child );\n\t\tparent.add( child );\n\n\t}\n\n};\n\n// File:src/extras/ShapeUtils.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n */\n\nTHREE.ShapeUtils = {\n\n\t// calculate area of the contour polygon\n\n\tarea: function ( contour ) {\n\n\t\tvar n = contour.length;\n\t\tvar a = 0.0;\n\n\t\tfor ( var p = n - 1, q = 0; q < n; p = q ++ ) {\n\n\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\n\n\t\t}\n\n\t\treturn a * 0.5;\n\n\t},\n\n\ttriangulate: ( function () {\n\n\t\t/**\n\t\t * This code is a quick port of code written in C++ which was submitted to\n\t\t * flipcode.com by John W. Ratcliff  // July 22, 2000\n\t\t * See original code and more information here:\n\t\t * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml\n\t\t *\n\t\t * ported to actionscript by Zevan Rosser\n\t\t * www.actionsnippet.com\n\t\t *\n\t\t * ported to javascript by Joshua Koo\n\t\t * http://www.lab4games.net/zz85/blog\n\t\t *\n\t\t */\n\n\t\tfunction snip( contour, u, v, w, n, verts ) {\n\n\t\t\tvar p;\n\t\t\tvar ax, ay, bx, by;\n\t\t\tvar cx, cy, px, py;\n\n\t\t\tax = contour[ verts[ u ] ].x;\n\t\t\tay = contour[ verts[ u ] ].y;\n\n\t\t\tbx = contour[ verts[ v ] ].x;\n\t\t\tby = contour[ verts[ v ] ].y;\n\n\t\t\tcx = contour[ verts[ w ] ].x;\n\t\t\tcy = contour[ verts[ w ] ].y;\n\n\t\t\tif ( Number.EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;\n\n\t\t\tvar aX, aY, bX, bY, cX, cY;\n\t\t\tvar apx, apy, bpx, bpy, cpx, cpy;\n\t\t\tvar cCROSSap, bCROSScp, aCROSSbp;\n\n\t\t\taX = cx - bx;  aY = cy - by;\n\t\t\tbX = ax - cx;  bY = ay - cy;\n\t\t\tcX = bx - ax;  cY = by - ay;\n\n\t\t\tfor ( p = 0; p < n; p ++ ) {\n\n\t\t\t\tpx = contour[ verts[ p ] ].x;\n\t\t\t\tpy = contour[ verts[ p ] ].y;\n\n\t\t\t\tif ( ( ( px === ax ) && ( py === ay ) ) ||\n\t\t\t\t\t ( ( px === bx ) && ( py === by ) ) ||\n\t\t\t\t\t ( ( px === cx ) && ( py === cy ) ) )\tcontinue;\n\n\t\t\t\tapx = px - ax;  apy = py - ay;\n\t\t\t\tbpx = px - bx;  bpy = py - by;\n\t\t\t\tcpx = px - cx;  cpy = py - cy;\n\n\t\t\t\t// see if p is inside triangle abc\n\n\t\t\t\taCROSSbp = aX * bpy - aY * bpx;\n\t\t\t\tcCROSSap = cX * apy - cY * apx;\n\t\t\t\tbCROSScp = bX * cpy - bY * cpx;\n\n\t\t\t\tif ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\t// takes in an contour array and returns\n\n\t\treturn function triangulate( contour, indices ) {\n\n\t\t\tvar n = contour.length;\n\n\t\t\tif ( n < 3 ) return null;\n\n\t\t\tvar result = [],\n\t\t\t\tverts = [],\n\t\t\t\tvertIndices = [];\n\n\t\t\t/* we want a counter-clockwise polygon in verts */\n\n\t\t\tvar u, v, w;\n\n\t\t\tif ( THREE.ShapeUtils.area( contour ) > 0.0 ) {\n\n\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = v;\n\n\t\t\t} else {\n\n\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;\n\n\t\t\t}\n\n\t\t\tvar nv = n;\n\n\t\t\t/*  remove nv - 2 vertices, creating 1 triangle every time */\n\n\t\t\tvar count = 2 * nv;   /* error detection */\n\n\t\t\tfor ( v = nv - 1; nv > 2; ) {\n\n\t\t\t\t/* if we loop, it is probably a non-simple polygon */\n\n\t\t\t\tif ( ( count -- ) <= 0 ) {\n\n\t\t\t\t\t//** Triangulate: ERROR - probable bad polygon!\n\n\t\t\t\t\t//throw ( \"Warning, unable to triangulate polygon!\" );\n\t\t\t\t\t//return null;\n\t\t\t\t\t// Sometimes warning is fine, especially polygons are triangulated in reverse.\n\t\t\t\t\tconsole.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );\n\n\t\t\t\t\tif ( indices ) return vertIndices;\n\t\t\t\t\treturn result;\n\n\t\t\t\t}\n\n\t\t\t\t/* three consecutive vertices in current polygon, <u,v,w> */\n\n\t\t\t\tu = v; \t \tif ( nv <= u ) u = 0;     /* previous */\n\t\t\t\tv = u + 1;  if ( nv <= v ) v = 0;     /* new v    */\n\t\t\t\tw = v + 1;  if ( nv <= w ) w = 0;     /* next     */\n\n\t\t\t\tif ( snip( contour, u, v, w, nv, verts ) ) {\n\n\t\t\t\t\tvar a, b, c, s, t;\n\n\t\t\t\t\t/* true names of the vertices */\n\n\t\t\t\t\ta = verts[ u ];\n\t\t\t\t\tb = verts[ v ];\n\t\t\t\t\tc = verts[ w ];\n\n\t\t\t\t\t/* output Triangle */\n\n\t\t\t\t\tresult.push( [ contour[ a ],\n\t\t\t\t\t\tcontour[ b ],\n\t\t\t\t\t\tcontour[ c ] ] );\n\n\n\t\t\t\t\tvertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );\n\n\t\t\t\t\t/* remove v from the remaining polygon */\n\n\t\t\t\t\tfor ( s = v, t = v + 1; t < nv; s ++, t ++ ) {\n\n\t\t\t\t\t\tverts[ s ] = verts[ t ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tnv --;\n\n\t\t\t\t\t/* reset error detection counter */\n\n\t\t\t\t\tcount = 2 * nv;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( indices ) return vertIndices;\n\t\t\treturn result;\n\n\t\t}\n\n\t} )(),\n\n\ttriangulateShape: function ( contour, holes ) {\n\n\t\tfunction point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {\n\n\t\t\t// inOtherPt needs to be collinear to the inSegment\n\t\t\tif ( inSegPt1.x !== inSegPt2.x ) {\n\n\t\t\t\tif ( inSegPt1.x < inSegPt2.x ) {\n\n\t\t\t\t\treturn\t( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn\t( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( inSegPt1.y < inSegPt2.y ) {\n\n\t\t\t\t\treturn\t( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn\t( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {\n\n\t\t\tvar seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;\n\t\t\tvar seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;\n\n\t\t\tvar seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;\n\t\t\tvar seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;\n\n\t\t\tvar limit\t\t= seg1dy * seg2dx - seg1dx * seg2dy;\n\t\t\tvar perpSeg1\t= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;\n\n\t\t\tif ( Math.abs( limit ) > Number.EPSILON ) {\n\n\t\t\t\t// not parallel\n\n\t\t\t\tvar perpSeg2;\n\t\t\t\tif ( limit > 0 ) {\n\n\t\t\t\t\tif ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) \t\treturn [];\n\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\n\t\t\t\t\tif ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) \t\treturn [];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) \t\treturn [];\n\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\n\t\t\t\t\tif ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) \t\treturn [];\n\n\t\t\t\t}\n\n\t\t\t\t// i.e. to reduce rounding errors\n\t\t\t\t// intersection at endpoint of segment#1?\n\t\t\t\tif ( perpSeg2 === 0 ) {\n\n\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\n\t\t\t\t\t\t ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )\t\treturn [];\n\t\t\t\t\treturn [ inSeg1Pt1 ];\n\n\t\t\t\t}\n\t\t\t\tif ( perpSeg2 === limit ) {\n\n\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\n\t\t\t\t\t\t ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )\t\treturn [];\n\t\t\t\t\treturn [ inSeg1Pt2 ];\n\n\t\t\t\t}\n\t\t\t\t// intersection at endpoint of segment#2?\n\t\t\t\tif ( perpSeg1 === 0 )\t\treturn [ inSeg2Pt1 ];\n\t\t\t\tif ( perpSeg1 === limit )\treturn [ inSeg2Pt2 ];\n\n\t\t\t\t// return real intersection point\n\t\t\t\tvar factorSeg1 = perpSeg2 / limit;\n\t\t\t\treturn\t[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,\n\t\t\t\t\t\t\ty: inSeg1Pt1.y + factorSeg1 * seg1dy } ];\n\n\t\t\t} else {\n\n\t\t\t\t// parallel or collinear\n\t\t\t\tif ( ( perpSeg1 !== 0 ) ||\n\t\t\t\t\t ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) \t\t\treturn [];\n\n\t\t\t\t// they are collinear or degenerate\n\t\t\t\tvar seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );\t// segment1 is just a point?\n\t\t\t\tvar seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );\t// segment2 is just a point?\n\t\t\t\t// both segments are points\n\t\t\t\tif ( seg1Pt && seg2Pt ) {\n\n\t\t\t\t\tif ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||\n\t\t\t\t\t\t ( inSeg1Pt1.y !== inSeg2Pt1.y ) )\t\treturn [];\t// they are distinct  points\n\t\t\t\t\treturn [ inSeg1Pt1 ];                 \t\t\t\t\t\t// they are the same point\n\n\t\t\t\t}\n\t\t\t\t// segment#1  is a single point\n\t\t\t\tif ( seg1Pt ) {\n\n\t\t\t\t\tif ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )\t\treturn [];\t\t// but not in segment#2\n\t\t\t\t\treturn [ inSeg1Pt1 ];\n\n\t\t\t\t}\n\t\t\t\t// segment#2  is a single point\n\t\t\t\tif ( seg2Pt ) {\n\n\t\t\t\t\tif ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )\t\treturn [];\t\t// but not in segment#1\n\t\t\t\t\treturn [ inSeg2Pt1 ];\n\n\t\t\t\t}\n\n\t\t\t\t// they are collinear segments, which might overlap\n\t\t\t\tvar seg1min, seg1max, seg1minVal, seg1maxVal;\n\t\t\t\tvar seg2min, seg2max, seg2minVal, seg2maxVal;\n\t\t\t\tif ( seg1dx !== 0 ) {\n\n\t\t\t\t\t// the segments are NOT on a vertical line\n\t\t\t\t\tif ( inSeg1Pt1.x < inSeg1Pt2.x ) {\n\n\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;\n\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;\n\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( inSeg2Pt1.x < inSeg2Pt2.x ) {\n\n\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;\n\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;\n\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// the segments are on a vertical line\n\t\t\t\t\tif ( inSeg1Pt1.y < inSeg1Pt2.y ) {\n\n\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;\n\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;\n\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( inSeg2Pt1.y < inSeg2Pt2.y ) {\n\n\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;\n\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;\n\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tif ( seg1minVal <= seg2minVal ) {\n\n\t\t\t\t\tif ( seg1maxVal <  seg2minVal )\treturn [];\n\t\t\t\t\tif ( seg1maxVal === seg2minVal )\t{\n\n\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\n\t\t\t\t\t\treturn [ seg2min ];\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg2min, seg1max ];\n\t\t\t\t\treturn\t[ seg2min, seg2max ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( seg1minVal >  seg2maxVal )\treturn [];\n\t\t\t\t\tif ( seg1minVal === seg2maxVal )\t{\n\n\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\n\t\t\t\t\t\treturn [ seg1min ];\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg1min, seg1max ];\n\t\t\t\t\treturn\t[ seg1min, seg2max ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {\n\n\t\t\t// The order of legs is important\n\n\t\t\t// translation of all points, so that Vertex is at (0,0)\n\t\t\tvar legFromPtX\t= inLegFromPt.x - inVertex.x,  legFromPtY\t= inLegFromPt.y - inVertex.y;\n\t\t\tvar legToPtX\t= inLegToPt.x\t- inVertex.x,  legToPtY\t\t= inLegToPt.y\t- inVertex.y;\n\t\t\tvar otherPtX\t= inOtherPt.x\t- inVertex.x,  otherPtY\t\t= inOtherPt.y\t- inVertex.y;\n\n\t\t\t// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.\n\t\t\tvar from2toAngle\t= legFromPtX * legToPtY - legFromPtY * legToPtX;\n\t\t\tvar from2otherAngle\t= legFromPtX * otherPtY - legFromPtY * otherPtX;\n\n\t\t\tif ( Math.abs( from2toAngle ) > Number.EPSILON ) {\n\n\t\t\t\t// angle != 180 deg.\n\n\t\t\t\tvar other2toAngle\t\t= otherPtX * legToPtY - otherPtY * legToPtX;\n\t\t\t\t// console.log( \"from2to: \" + from2toAngle + \", from2other: \" + from2otherAngle + \", other2to: \" + other2toAngle );\n\n\t\t\t\tif ( from2toAngle > 0 ) {\n\n\t\t\t\t\t// main angle < 180 deg.\n\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// main angle > 180 deg.\n\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// angle == 180 deg.\n\t\t\t\t// console.log( \"from2to: 180 deg., from2other: \" + from2otherAngle  );\n\t\t\t\treturn\t( from2otherAngle > 0 );\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tfunction removeHoles( contour, holes ) {\n\n\t\t\tvar shape = contour.concat(); // work on this shape\n\t\t\tvar hole;\n\n\t\t\tfunction isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {\n\n\t\t\t\t// Check if hole point lies within angle around shape point\n\t\t\t\tvar lastShapeIdx = shape.length - 1;\n\n\t\t\t\tvar prevShapeIdx = inShapeIdx - 1;\n\t\t\t\tif ( prevShapeIdx < 0 )\t\t\tprevShapeIdx = lastShapeIdx;\n\n\t\t\t\tvar nextShapeIdx = inShapeIdx + 1;\n\t\t\t\tif ( nextShapeIdx > lastShapeIdx )\tnextShapeIdx = 0;\n\n\t\t\t\tvar insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );\n\t\t\t\tif ( ! insideAngle ) {\n\n\t\t\t\t\t// console.log( \"Vertex (Shape): \" + inShapeIdx + \", Point: \" + hole[inHoleIdx].x + \"/\" + hole[inHoleIdx].y );\n\t\t\t\t\treturn\tfalse;\n\n\t\t\t\t}\n\n\t\t\t\t// Check if shape point lies within angle around hole point\n\t\t\t\tvar lastHoleIdx = hole.length - 1;\n\n\t\t\t\tvar prevHoleIdx = inHoleIdx - 1;\n\t\t\t\tif ( prevHoleIdx < 0 )\t\t\tprevHoleIdx = lastHoleIdx;\n\n\t\t\t\tvar nextHoleIdx = inHoleIdx + 1;\n\t\t\t\tif ( nextHoleIdx > lastHoleIdx )\tnextHoleIdx = 0;\n\n\t\t\t\tinsideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );\n\t\t\t\tif ( ! insideAngle ) {\n\n\t\t\t\t\t// console.log( \"Vertex (Hole): \" + inHoleIdx + \", Point: \" + shape[inShapeIdx].x + \"/\" + shape[inShapeIdx].y );\n\t\t\t\t\treturn\tfalse;\n\n\t\t\t\t}\n\n\t\t\t\treturn\ttrue;\n\n\t\t\t}\n\n\t\t\tfunction intersectsShapeEdge( inShapePt, inHolePt ) {\n\n\t\t\t\t// checks for intersections with shape edges\n\t\t\t\tvar sIdx, nextIdx, intersection;\n\t\t\t\tfor ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {\n\n\t\t\t\t\tnextIdx = sIdx + 1; nextIdx %= shape.length;\n\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );\n\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\n\n\t\t\t\t}\n\n\t\t\t\treturn\tfalse;\n\n\t\t\t}\n\n\t\t\tvar indepHoles = [];\n\n\t\t\tfunction intersectsHoleEdge( inShapePt, inHolePt ) {\n\n\t\t\t\t// checks for intersections with hole edges\n\t\t\t\tvar ihIdx, chkHole,\n\t\t\t\t\thIdx, nextIdx, intersection;\n\t\t\t\tfor ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {\n\n\t\t\t\t\tchkHole = holes[ indepHoles[ ihIdx ]];\n\t\t\t\t\tfor ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {\n\n\t\t\t\t\t\tnextIdx = hIdx + 1; nextIdx %= chkHole.length;\n\t\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );\n\t\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\treturn\tfalse;\n\n\t\t\t}\n\n\t\t\tvar holeIndex, shapeIndex,\n\t\t\t\tshapePt, holePt,\n\t\t\t\tholeIdx, cutKey, failedCuts = [],\n\t\t\t\ttmpShape1, tmpShape2,\n\t\t\t\ttmpHole1, tmpHole2;\n\n\t\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tindepHoles.push( h );\n\n\t\t\t}\n\n\t\t\tvar minShapeIndex = 0;\n\t\t\tvar counter = indepHoles.length * 2;\n\t\t\twhile ( indepHoles.length > 0 ) {\n\n\t\t\t\tcounter --;\n\t\t\t\tif ( counter < 0 ) {\n\n\t\t\t\t\tconsole.log( \"Infinite Loop! Holes left:\" + indepHoles.length + \", Probably Hole outside Shape!\" );\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\t// search for shape-vertex and hole-vertex,\n\t\t\t\t// which can be connected without intersections\n\t\t\t\tfor ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {\n\n\t\t\t\t\tshapePt = shape[ shapeIndex ];\n\t\t\t\t\tholeIndex\t= - 1;\n\n\t\t\t\t\t// search for hole which can be reached without intersections\n\t\t\t\t\tfor ( var h = 0; h < indepHoles.length; h ++ ) {\n\n\t\t\t\t\t\tholeIdx = indepHoles[ h ];\n\n\t\t\t\t\t\t// prevent multiple checks\n\t\t\t\t\t\tcutKey = shapePt.x + \":\" + shapePt.y + \":\" + holeIdx;\n\t\t\t\t\t\tif ( failedCuts[ cutKey ] !== undefined )\t\t\tcontinue;\n\n\t\t\t\t\t\thole = holes[ holeIdx ];\n\t\t\t\t\t\tfor ( var h2 = 0; h2 < hole.length; h2 ++ ) {\n\n\t\t\t\t\t\t\tholePt = hole[ h2 ];\n\t\t\t\t\t\t\tif ( ! isCutLineInsideAngles( shapeIndex, h2 ) )\t\tcontinue;\n\t\t\t\t\t\t\tif ( intersectsShapeEdge( shapePt, holePt ) )\t\tcontinue;\n\t\t\t\t\t\t\tif ( intersectsHoleEdge( shapePt, holePt ) )\t\tcontinue;\n\n\t\t\t\t\t\t\tholeIndex = h2;\n\t\t\t\t\t\t\tindepHoles.splice( h, 1 );\n\n\t\t\t\t\t\t\ttmpShape1 = shape.slice( 0, shapeIndex + 1 );\n\t\t\t\t\t\t\ttmpShape2 = shape.slice( shapeIndex );\n\t\t\t\t\t\t\ttmpHole1 = hole.slice( holeIndex );\n\t\t\t\t\t\t\ttmpHole2 = hole.slice( 0, holeIndex + 1 );\n\n\t\t\t\t\t\t\tshape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );\n\n\t\t\t\t\t\t\tminShapeIndex = shapeIndex;\n\n\t\t\t\t\t\t\t// Debug only, to show the selected cuts\n\t\t\t\t\t\t\t// glob_CutLines.push( [ shapePt, holePt ] );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\n\n\t\t\t\t\t\tfailedCuts[ cutKey ] = true;\t\t\t// remember failure\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn shape; \t\t\t/* shape with no holes */\n\n\t\t}\n\n\n\t\tvar i, il, f, face,\n\t\t\tkey, index,\n\t\t\tallPointsMap = {};\n\n\t\t// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.\n\n\t\tvar allpoints = contour.concat();\n\n\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tArray.prototype.push.apply( allpoints, holes[ h ] );\n\n\t\t}\n\n\t\t//console.log( \"allpoints\",allpoints, allpoints.length );\n\n\t\t// prepare all points map\n\n\t\tfor ( i = 0, il = allpoints.length; i < il; i ++ ) {\n\n\t\t\tkey = allpoints[ i ].x + \":\" + allpoints[ i ].y;\n\n\t\t\tif ( allPointsMap[ key ] !== undefined ) {\n\n\t\t\t\tconsole.warn( \"THREE.Shape: Duplicate point\", key );\n\n\t\t\t}\n\n\t\t\tallPointsMap[ key ] = i;\n\n\t\t}\n\n\t\t// remove holes by cutting paths to holes and adding them to the shape\n\t\tvar shapeWithoutHoles = removeHoles( contour, holes );\n\n\t\tvar triangles = THREE.ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape\n\t\t//console.log( \"triangles\",triangles, triangles.length );\n\n\t\t// check all face vertices against all points map\n\n\t\tfor ( i = 0, il = triangles.length; i < il; i ++ ) {\n\n\t\t\tface = triangles[ i ];\n\n\t\t\tfor ( f = 0; f < 3; f ++ ) {\n\n\t\t\t\tkey = face[ f ].x + \":\" + face[ f ].y;\n\n\t\t\t\tindex = allPointsMap[ key ];\n\n\t\t\t\tif ( index !== undefined ) {\n\n\t\t\t\t\tface[ f ] = index;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn triangles.concat();\n\n\t},\n\n\tisClockWise: function ( pts ) {\n\n\t\treturn THREE.ShapeUtils.area( pts ) < 0;\n\n\t},\n\n\t// Bezier Curves formulas obtained from\n\t// http://en.wikipedia.org/wiki/B%C3%A9zier_curve\n\n\t// Quad Bezier Functions\n\n\tb2: ( function () {\n\n\t\tfunction b2p0( t, p ) {\n\n\t\t\tvar k = 1 - t;\n\t\t\treturn k * k * p;\n\n\t\t}\n\n\t\tfunction b2p1( t, p ) {\n\n\t\t\treturn 2 * ( 1 - t ) * t * p;\n\n\t\t}\n\n\t\tfunction b2p2( t, p ) {\n\n\t\t\treturn t * t * p;\n\n\t\t}\n\n\t\treturn function b2( t, p0, p1, p2 ) {\n\n\t\t\treturn b2p0( t, p0 ) + b2p1( t, p1 ) + b2p2( t, p2 );\n\n\t\t};\n\n\t} )(),\n\n\t// Cubic Bezier Functions\n\n\tb3: ( function () {\n\n\t\tfunction b3p0( t, p ) {\n\n\t\t\tvar k = 1 - t;\n\t\t\treturn k * k * k * p;\n\n\t\t}\n\n\t\tfunction b3p1( t, p ) {\n\n\t\t\tvar k = 1 - t;\n\t\t\treturn 3 * k * k * t * p;\n\n\t\t}\n\n\t\tfunction b3p2( t, p ) {\n\n\t\t\tvar k = 1 - t;\n\t\t\treturn 3 * k * t * t * p;\n\n\t\t}\n\n\t\tfunction b3p3( t, p ) {\n\n\t\t\treturn t * t * t * p;\n\n\t\t}\n\n\t\treturn function b3( t, p0, p1, p2, p3 ) {\n\n\t\t\treturn b3p0( t, p0 ) + b3p1( t, p1 ) + b3p2( t, p2 ) + b3p3( t, p3 );\n\n\t\t};\n\n\t} )()\n\n};\n\n// File:src/extras/core/Curve.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * Extensible curve object\n *\n * Some common of Curve methods\n * .getPoint(t), getTangent(t)\n * .getPointAt(u), getTagentAt(u)\n * .getPoints(), .getSpacedPoints()\n * .getLength()\n * .updateArcLengths()\n *\n * This following classes subclasses THREE.Curve:\n *\n * -- 2d classes --\n * THREE.LineCurve\n * THREE.QuadraticBezierCurve\n * THREE.CubicBezierCurve\n * THREE.SplineCurve\n * THREE.ArcCurve\n * THREE.EllipseCurve\n *\n * -- 3d classes --\n * THREE.LineCurve3\n * THREE.QuadraticBezierCurve3\n * THREE.CubicBezierCurve3\n * THREE.SplineCurve3\n *\n * A series of curves can be represented as a THREE.CurvePath\n *\n **/\n\n/**************************************************************\n *\tAbstract Curve base class\n **************************************************************/\n\nTHREE.Curve = function () {\n\n};\n\nTHREE.Curve.prototype = {\n\n\tconstructor: THREE.Curve,\n\n\t// Virtual base class method to overwrite and implement in subclasses\n\t//\t- t [0 .. 1]\n\n\tgetPoint: function ( t ) {\n\n\t\tconsole.warn( \"THREE.Curve: Warning, getPoint() not implemented!\" );\n\t\treturn null;\n\n\t},\n\n\t// Get point at relative position in curve according to arc length\n\t// - u [0 .. 1]\n\n\tgetPointAt: function ( u ) {\n\n\t\tvar t = this.getUtoTmapping( u );\n\t\treturn this.getPoint( t );\n\n\t},\n\n\t// Get sequence of points using getPoint( t )\n\n\tgetPoints: function ( divisions ) {\n\n\t\tif ( ! divisions ) divisions = 5;\n\n\t\tvar d, pts = [];\n\n\t\tfor ( d = 0; d <= divisions; d ++ ) {\n\n\t\t\tpts.push( this.getPoint( d / divisions ) );\n\n\t\t}\n\n\t\treturn pts;\n\n\t},\n\n\t// Get sequence of points using getPointAt( u )\n\n\tgetSpacedPoints: function ( divisions ) {\n\n\t\tif ( ! divisions ) divisions = 5;\n\n\t\tvar d, pts = [];\n\n\t\tfor ( d = 0; d <= divisions; d ++ ) {\n\n\t\t\tpts.push( this.getPointAt( d / divisions ) );\n\n\t\t}\n\n\t\treturn pts;\n\n\t},\n\n\t// Get total curve arc length\n\n\tgetLength: function () {\n\n\t\tvar lengths = this.getLengths();\n\t\treturn lengths[ lengths.length - 1 ];\n\n\t},\n\n\t// Get list of cumulative segment lengths\n\n\tgetLengths: function ( divisions ) {\n\n\t\tif ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;\n\n\t\tif ( this.cacheArcLengths\n\t\t\t&& ( this.cacheArcLengths.length === divisions + 1 )\n\t\t\t&& ! this.needsUpdate ) {\n\n\t\t\t//console.log( \"cached\", this.cacheArcLengths );\n\t\t\treturn this.cacheArcLengths;\n\n\t\t}\n\n\t\tthis.needsUpdate = false;\n\n\t\tvar cache = [];\n\t\tvar current, last = this.getPoint( 0 );\n\t\tvar p, sum = 0;\n\n\t\tcache.push( 0 );\n\n\t\tfor ( p = 1; p <= divisions; p ++ ) {\n\n\t\t\tcurrent = this.getPoint ( p / divisions );\n\t\t\tsum += current.distanceTo( last );\n\t\t\tcache.push( sum );\n\t\t\tlast = current;\n\n\t\t}\n\n\t\tthis.cacheArcLengths = cache;\n\n\t\treturn cache; // { sums: cache, sum:sum }; Sum is in the last element.\n\n\t},\n\n\tupdateArcLengths: function() {\n\n\t\tthis.needsUpdate = true;\n\t\tthis.getLengths();\n\n\t},\n\n\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\n\tgetUtoTmapping: function ( u, distance ) {\n\n\t\tvar arcLengths = this.getLengths();\n\n\t\tvar i = 0, il = arcLengths.length;\n\n\t\tvar targetArcLength; // The targeted u distance value to get\n\n\t\tif ( distance ) {\n\n\t\t\ttargetArcLength = distance;\n\n\t\t} else {\n\n\t\t\ttargetArcLength = u * arcLengths[ il - 1 ];\n\n\t\t}\n\n\t\t//var time = Date.now();\n\n\t\t// binary search for the index with largest value smaller than target u distance\n\n\t\tvar low = 0, high = il - 1, comparison;\n\n\t\twhile ( low <= high ) {\n\n\t\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n\t\t\tcomparison = arcLengths[ i ] - targetArcLength;\n\n\t\t\tif ( comparison < 0 ) {\n\n\t\t\t\tlow = i + 1;\n\n\t\t\t} else if ( comparison > 0 ) {\n\n\t\t\t\thigh = i - 1;\n\n\t\t\t} else {\n\n\t\t\t\thigh = i;\n\t\t\t\tbreak;\n\n\t\t\t\t// DONE\n\n\t\t\t}\n\n\t\t}\n\n\t\ti = high;\n\n\t\t//console.log('b' , i, low, high, Date.now()- time);\n\n\t\tif ( arcLengths[ i ] === targetArcLength ) {\n\n\t\t\tvar t = i / ( il - 1 );\n\t\t\treturn t;\n\n\t\t}\n\n\t\t// we could get finer grain at lengths, or use simple interpolation between two points\n\n\t\tvar lengthBefore = arcLengths[ i ];\n\t\tvar lengthAfter = arcLengths[ i + 1 ];\n\n\t\tvar segmentLength = lengthAfter - lengthBefore;\n\n\t\t// determine where we are between the 'before' and 'after' points\n\n\t\tvar segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\n\n\t\t// add that fractional amount to t\n\n\t\tvar t = ( i + segmentFraction ) / ( il - 1 );\n\n\t\treturn t;\n\n\t},\n\n\t// Returns a unit vector tangent at t\n\t// In case any sub curve does not implement its tangent derivation,\n\t// 2 points a small delta apart will be used to find its gradient\n\t// which seems to give a reasonable approximation\n\n\tgetTangent: function( t ) {\n\n\t\tvar delta = 0.0001;\n\t\tvar t1 = t - delta;\n\t\tvar t2 = t + delta;\n\n\t\t// Capping in case of danger\n\n\t\tif ( t1 < 0 ) t1 = 0;\n\t\tif ( t2 > 1 ) t2 = 1;\n\n\t\tvar pt1 = this.getPoint( t1 );\n\t\tvar pt2 = this.getPoint( t2 );\n\n\t\tvar vec = pt2.clone().sub( pt1 );\n\t\treturn vec.normalize();\n\n\t},\n\n\tgetTangentAt: function ( u ) {\n\n\t\tvar t = this.getUtoTmapping( u );\n\t\treturn this.getTangent( t );\n\n\t}\n\n};\n\n// TODO: Transformation for Curves?\n\n/**************************************************************\n *\t3D Curves\n **************************************************************/\n\n// A Factory method for creating new curve subclasses\n\nTHREE.Curve.create = function ( constructor, getPointFunc ) {\n\n\tconstructor.prototype = Object.create( THREE.Curve.prototype );\n\tconstructor.prototype.constructor = constructor;\n\tconstructor.prototype.getPoint = getPointFunc;\n\n\treturn constructor;\n\n};\n\n// File:src/extras/core/CurvePath.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n *\n **/\n\n/**************************************************************\n *\tCurved Path - a curve path is simply a array of connected\n *  curves, but retains the api of a curve\n **************************************************************/\n\nTHREE.CurvePath = function () {\n\n\tthis.curves = [];\n\n\tthis.autoClose = false; // Automatically closes the path\n\n};\n\nTHREE.CurvePath.prototype = Object.assign( Object.create( THREE.Curve.prototype ), {\n\n\tconstructor: THREE.CurvePath,\n\n\tadd: function ( curve ) {\n\n\t\tthis.curves.push( curve );\n\n\t},\n\n\tclosePath: function () {\n\n\t\t// TODO Test\n\t\t// and verify for vector3 (needs to implement equals)\n\t\t// Add a line curve if start and end of lines are not connected\n\t\tvar startPoint = this.curves[ 0 ].getPoint( 0 );\n\t\tvar endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\n\n\t\tif ( ! startPoint.equals( endPoint ) ) {\n\n\t\t\tthis.curves.push( new THREE.LineCurve( endPoint, startPoint ) );\n\n\t\t}\n\n\t},\n\n\t// To get accurate point with reference to\n\t// entire path distance at time t,\n\t// following has to be done:\n\n\t// 1. Length of each sub path have to be known\n\t// 2. Locate and identify type of curve\n\t// 3. Get t for the curve\n\t// 4. Return curve.getPointAt(t')\n\n\tgetPoint: function ( t ) {\n\n\t\tvar d = t * this.getLength();\n\t\tvar curveLengths = this.getCurveLengths();\n\t\tvar i = 0;\n\n\t\t// To think about boundaries points.\n\n\t\twhile ( i < curveLengths.length ) {\n\n\t\t\tif ( curveLengths[ i ] >= d ) {\n\n\t\t\t\tvar diff = curveLengths[ i ] - d;\n\t\t\t\tvar curve = this.curves[ i ];\n\n\t\t\t\tvar u = 1 - diff / curve.getLength();\n\n\t\t\t\treturn curve.getPointAt( u );\n\n\t\t\t}\n\n\t\t\ti ++;\n\n\t\t}\n\n\t\treturn null;\n\n\t\t// loop where sum != 0, sum > d , sum+1 <d\n\n\t},\n\n\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\n\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n\t// getPoint() depends on getLength\n\n\tgetLength: function () {\n\n\t\tvar lens = this.getCurveLengths();\n\t\treturn lens[ lens.length - 1 ];\n\n\t},\n\n\t// cacheLengths must be recalculated.\n\tupdateArcLengths: function () {\n\n\t\tthis.needsUpdate = true;\n\t\tthis.cacheLengths = null;\n\t\tthis.getLengths();\n\n\t},\n\n\t// Compute lengths and cache them\n\t// We cannot overwrite getLengths() because UtoT mapping uses it.\n\n\tgetCurveLengths: function () {\n\n\t\t// We use cache values if curves and cache array are same length\n\n\t\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\n\n\t\t\treturn this.cacheLengths;\n\n\t\t}\n\n\t\t// Get length of sub-curve\n\t\t// Push sums into cached array\n\n\t\tvar lengths = [], sums = 0;\n\n\t\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\n\n\t\t\tsums += this.curves[ i ].getLength();\n\t\t\tlengths.push( sums );\n\n\t\t}\n\n\t\tthis.cacheLengths = lengths;\n\n\t\treturn lengths;\n\n\t},\n\n\t/**************************************************************\n\t *\tCreate Geometries Helpers\n\t **************************************************************/\n\n\t/// Generate geometry from path points (for Line or Points objects)\n\n\tcreatePointsGeometry: function ( divisions ) {\n\n\t\tvar pts = this.getPoints( divisions );\n\t\treturn this.createGeometry( pts );\n\n\t},\n\n\t// Generate geometry from equidistant sampling along the path\n\n\tcreateSpacedPointsGeometry: function ( divisions ) {\n\n\t\tvar pts = this.getSpacedPoints( divisions );\n\t\treturn this.createGeometry( pts );\n\n\t},\n\n\tcreateGeometry: function ( points ) {\n\n\t\tvar geometry = new THREE.Geometry();\n\n\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tvar point = points[ i ];\n\t\t\tgeometry.vertices.push( new THREE.Vector3( point.x, point.y, point.z || 0 ) );\n\n\t\t}\n\n\t\treturn geometry;\n\n\t}\n\n} );\n\n// File:src/extras/core/Font.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Font = function ( data ) {\n\n\tthis.data = data;\n\n};\n\nObject.assign( THREE.Font.prototype, {\n\n\tgenerateShapes: function ( text, size, divisions ) {\n\n\t\tfunction createPaths( text ) {\n\n\t\t\tvar chars = String( text ).split( '' );\n\t\t\tvar scale = size / data.resolution;\n\t\t\tvar offset = 0;\n\n\t\t\tvar paths = [];\n\n\t\t\tfor ( var i = 0; i < chars.length; i ++ ) {\n\n\t\t\t\tvar ret = createPath( chars[ i ], scale, offset );\n\t\t\t\toffset += ret.offset;\n\n\t\t\t\tpaths.push( ret.path );\n\n\t\t\t}\n\n\t\t\treturn paths;\n\n\t\t}\n\n\t\tfunction createPath( c, scale, offset ) {\n\n\t\t\tvar glyph = data.glyphs[ c ] || data.glyphs[ '?' ];\n\n\t\t\tif ( ! glyph ) return;\n\n\t\t\tvar path = new THREE.Path();\n\n\t\t\tvar pts = [], b2 = THREE.ShapeUtils.b2, b3 = THREE.ShapeUtils.b3;\n\t\t\tvar x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;\n\n\t\t\tif ( glyph.o ) {\n\n\t\t\t\tvar outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\n\n\t\t\t\tfor ( var i = 0, l = outline.length; i < l; ) {\n\n\t\t\t\t\tvar action = outline[ i ++ ];\n\n\t\t\t\t\tswitch ( action ) {\n\n\t\t\t\t\t\tcase 'm': // moveTo\n\n\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\ty = outline[ i ++ ] * scale;\n\n\t\t\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'l': // lineTo\n\n\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\ty = outline[ i ++ ] * scale;\n\n\t\t\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'q': // quadraticCurveTo\n\n\t\t\t\t\t\t\tcpx  = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\tcpy  = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale;\n\n\t\t\t\t\t\t\tpath.quadraticCurveTo( cpx1, cpy1, cpx, cpy );\n\n\t\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\n\n\t\t\t\t\t\t\tif ( laste ) {\n\n\t\t\t\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\t\t\t\tcpy0 = laste.y;\n\n\t\t\t\t\t\t\t\tfor ( var i2 = 1; i2 <= divisions; i2 ++ ) {\n\n\t\t\t\t\t\t\t\t\tvar t = i2 / divisions;\n\t\t\t\t\t\t\t\t\tb2( t, cpx0, cpx1, cpx );\n\t\t\t\t\t\t\t\t\tb2( t, cpy0, cpy1, cpy );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'b': // bezierCurveTo\n\n\t\t\t\t\t\t\tcpx  = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\tcpy  = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\tcpx2 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\tcpy2 = outline[ i ++ ] * scale;\n\n\t\t\t\t\t\t\tpath.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );\n\n\t\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\n\n\t\t\t\t\t\t\tif ( laste ) {\n\n\t\t\t\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\t\t\t\tcpy0 = laste.y;\n\n\t\t\t\t\t\t\t\tfor ( var i2 = 1; i2 <= divisions; i2 ++ ) {\n\n\t\t\t\t\t\t\t\t\tvar t = i2 / divisions;\n\t\t\t\t\t\t\t\t\tb3( t, cpx0, cpx1, cpx2, cpx );\n\t\t\t\t\t\t\t\t\tb3( t, cpy0, cpy1, cpy2, cpy );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn { offset: glyph.ha * scale, path: path };\n\n\t\t}\n\n\t\t//\n\n\t\tif ( size === undefined ) size = 100;\n\t\tif ( divisions === undefined ) divisions = 4;\n\n\t\tvar data = this.data;\n\n\t\tvar paths = createPaths( text );\n\t\tvar shapes = [];\n\n\t\tfor ( var p = 0, pl = paths.length; p < pl; p ++ ) {\n\n\t\t\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\n\n\t\t}\n\n\t\treturn shapes;\n\n\t}\n\n} );\n\n// File:src/extras/core/Path.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * Creates free form 2d path using series of points, lines or curves.\n *\n **/\n\nTHREE.Path = function ( points ) {\n\n\tTHREE.CurvePath.call( this );\n\n\tthis.actions = [];\n\n\tif ( points ) {\n\n\t\tthis.fromPoints( points );\n\n\t}\n\n};\n\nTHREE.Path.prototype = Object.assign( Object.create( THREE.CurvePath.prototype ), {\n\n\tconstructor: THREE.Path,\n\n\t// TODO Clean up PATH API\n\n\t// Create path using straight lines to connect all points\n\t// - vectors: array of Vector2\n\n\tfromPoints: function ( vectors ) {\n\n\t\tthis.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );\n\n\t\tfor ( var i = 1, l = vectors.length; i < l; i ++ ) {\n\n\t\t\tthis.lineTo( vectors[ i ].x, vectors[ i ].y );\n\n\t\t}\n\n\t},\n\n\tmoveTo: function ( x, y ) {\n\n\t\tthis.actions.push( { action: 'moveTo', args: [ x, y ] } );\n\n\t},\n\n\tlineTo: function ( x, y ) {\n\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\t\tvar curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );\n\t\tthis.curves.push( curve );\n\n\t\tthis.actions.push( { action: 'lineTo', args: [ x, y ] } );\n\n\t},\n\n\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\n\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\t\tvar curve = new THREE.QuadraticBezierCurve(\n\t\t\tnew THREE.Vector2( x0, y0 ),\n\t\t\tnew THREE.Vector2( aCPx, aCPy ),\n\t\t\tnew THREE.Vector2( aX, aY )\n\t\t);\n\n\t\tthis.curves.push( curve );\n\n\t\tthis.actions.push( { action: 'quadraticCurveTo', args: [ aCPx, aCPy, aX, aY ] } );\n\n\t},\n\n\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\t\tvar curve = new THREE.CubicBezierCurve(\n\t\t\tnew THREE.Vector2( x0, y0 ),\n\t\t\tnew THREE.Vector2( aCP1x, aCP1y ),\n\t\t\tnew THREE.Vector2( aCP2x, aCP2y ),\n\t\t\tnew THREE.Vector2( aX, aY )\n\t\t);\n\n\t\tthis.curves.push( curve );\n\n\t\tthis.actions.push( { action: 'bezierCurveTo', args: [ aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ] } );\n\n\t},\n\n\tsplineThru: function ( pts /*Array of Vector*/ ) {\n\n\t\tvar args = Array.prototype.slice.call( arguments );\n\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\t\tvar npts = [ new THREE.Vector2( x0, y0 ) ];\n\t\tArray.prototype.push.apply( npts, pts );\n\n\t\tvar curve = new THREE.SplineCurve( npts );\n\t\tthis.curves.push( curve );\n\n\t\tvar lastPoint = pts[ pts.length - 1 ];\n\t\targs.push( lastPoint.x );\n\t\targs.push( lastPoint.y );\n\n\t\tthis.actions.push( { action: 'splineThru', args: args } );\n\n\t},\n\n\tarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\t\tthis.absarc( aX + x0, aY + y0, aRadius,\n\t\t\taStartAngle, aEndAngle, aClockwise );\n\n\t},\n\n\tabsarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tthis.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n\t},\n\n\tellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\t\tthis.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n\t},\n\n\tabsellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\tvar args = [\n\t\t\taX, aY,\n\t\t\txRadius, yRadius,\n\t\t\taStartAngle, aEndAngle,\n\t\t\taClockwise,\n\t\t\taRotation || 0 // aRotation is optional.\n\t\t];\n\n\t\tvar curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\t\tthis.curves.push( curve );\n\n\t\tvar lastPoint = curve.getPoint( 1 );\n\t\targs.push( lastPoint.x );\n\t\targs.push( lastPoint.y );\n\n\t\tthis.actions.push( { action: 'ellipse', args: args } );\n\n\t},\n\n\tgetSpacedPoints: function ( divisions ) {\n\n\t\tif ( ! divisions ) divisions = 40;\n\n\t\tvar points = [];\n\n\t\tfor ( var i = 0; i < divisions; i ++ ) {\n\n\t\t\tpoints.push( this.getPoint( i / divisions ) );\n\n\t\t\t//if ( !this.getPoint( i / divisions ) ) throw \"DIE\";\n\n\t\t}\n\n\t\tif ( this.autoClose ) {\n\n\t\t\tpoints.push( points[ 0 ] );\n\n\t\t}\n\n\t\treturn points;\n\n\t},\n\n\tgetPoints: function ( divisions ) {\n\n\t\tdivisions = divisions || 12;\n\n\t\tvar b2 = THREE.ShapeUtils.b2;\n\t\tvar b3 = THREE.ShapeUtils.b3;\n\n\t\tvar points = [];\n\n\t\tvar cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,\n\t\t\tlaste, tx, ty;\n\n\t\tfor ( var i = 0, l = this.actions.length; i < l; i ++ ) {\n\n\t\t\tvar item = this.actions[ i ];\n\n\t\t\tvar action = item.action;\n\t\t\tvar args = item.args;\n\n\t\t\tswitch ( action ) {\n\n\t\t\tcase 'moveTo':\n\n\t\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'lineTo':\n\n\t\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'quadraticCurveTo':\n\n\t\t\t\tcpx  = args[ 2 ];\n\t\t\t\tcpy  = args[ 3 ];\n\n\t\t\t\tcpx1 = args[ 0 ];\n\t\t\t\tcpy1 = args[ 1 ];\n\n\t\t\t\tif ( points.length > 0 ) {\n\n\t\t\t\t\tlaste = points[ points.length - 1 ];\n\n\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\tcpy0 = laste.y;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlaste = this.actions[ i - 1 ].args;\n\n\t\t\t\t\tcpx0 = laste[ laste.length - 2 ];\n\t\t\t\t\tcpy0 = laste[ laste.length - 1 ];\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var j = 1; j <= divisions; j ++ ) {\n\n\t\t\t\t\tvar t = j / divisions;\n\n\t\t\t\t\ttx = b2( t, cpx0, cpx1, cpx );\n\t\t\t\t\tty = b2( t, cpy0, cpy1, cpy );\n\n\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'bezierCurveTo':\n\n\t\t\t\tcpx  = args[ 4 ];\n\t\t\t\tcpy  = args[ 5 ];\n\n\t\t\t\tcpx1 = args[ 0 ];\n\t\t\t\tcpy1 = args[ 1 ];\n\n\t\t\t\tcpx2 = args[ 2 ];\n\t\t\t\tcpy2 = args[ 3 ];\n\n\t\t\t\tif ( points.length > 0 ) {\n\n\t\t\t\t\tlaste = points[ points.length - 1 ];\n\n\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\tcpy0 = laste.y;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlaste = this.actions[ i - 1 ].args;\n\n\t\t\t\t\tcpx0 = laste[ laste.length - 2 ];\n\t\t\t\t\tcpy0 = laste[ laste.length - 1 ];\n\n\t\t\t\t}\n\n\n\t\t\t\tfor ( var j = 1; j <= divisions; j ++ ) {\n\n\t\t\t\t\tvar t = j / divisions;\n\n\t\t\t\t\ttx = b3( t, cpx0, cpx1, cpx2, cpx );\n\t\t\t\t\tty = b3( t, cpy0, cpy1, cpy2, cpy );\n\n\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'splineThru':\n\n\t\t\t\tlaste = this.actions[ i - 1 ].args;\n\n\t\t\t\tvar last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );\n\t\t\t\tvar spts = [ last ];\n\n\t\t\t\tvar n = divisions * args[ 0 ].length;\n\n\t\t\t\tspts = spts.concat( args[ 0 ] );\n\n\t\t\t\tvar spline = new THREE.SplineCurve( spts );\n\n\t\t\t\tfor ( var j = 1; j <= n; j ++ ) {\n\n\t\t\t\t\tpoints.push( spline.getPointAt( j / n ) );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'arc':\n\n\t\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\n\t\t\t\t\taRadius = args[ 2 ],\n\t\t\t\t\taStartAngle = args[ 3 ], aEndAngle = args[ 4 ],\n\t\t\t\t\taClockwise = !! args[ 5 ];\n\n\t\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\n\t\t\t\tvar angle;\n\t\t\t\tvar tdivisions = divisions * 2;\n\n\t\t\t\tfor ( var j = 1; j <= tdivisions; j ++ ) {\n\n\t\t\t\t\tvar t = j / tdivisions;\n\n\t\t\t\t\tif ( ! aClockwise ) {\n\n\t\t\t\t\t\tt = 1 - t;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tangle = aStartAngle + t * deltaAngle;\n\n\t\t\t\t\ttx = aX + aRadius * Math.cos( angle );\n\t\t\t\t\tty = aY + aRadius * Math.sin( angle );\n\n\t\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\n\n\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\n\n\t\t\t\t}\n\n\t\t\t\t//console.log(points);\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'ellipse':\n\n\t\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\n\t\t\t\t\txRadius = args[ 2 ],\n\t\t\t\t\tyRadius = args[ 3 ],\n\t\t\t\t\taStartAngle = args[ 4 ], aEndAngle = args[ 5 ],\n\t\t\t\t\taClockwise = !! args[ 6 ],\n\t\t\t\t\taRotation = args[ 7 ];\n\n\n\t\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\n\t\t\t\tvar angle;\n\t\t\t\tvar tdivisions = divisions * 2;\n\n\t\t\t\tvar cos, sin;\n\t\t\t\tif ( aRotation !== 0 ) {\n\n\t\t\t\t\tcos = Math.cos( aRotation );\n\t\t\t\t\tsin = Math.sin( aRotation );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var j = 1; j <= tdivisions; j ++ ) {\n\n\t\t\t\t\tvar t = j / tdivisions;\n\n\t\t\t\t\tif ( ! aClockwise ) {\n\n\t\t\t\t\t\tt = 1 - t;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tangle = aStartAngle + t * deltaAngle;\n\n\t\t\t\t\ttx = aX + xRadius * Math.cos( angle );\n\t\t\t\t\tty = aY + yRadius * Math.sin( angle );\n\n\t\t\t\t\tif ( aRotation !== 0 ) {\n\n\t\t\t\t\t\tvar x = tx, y = ty;\n\n\t\t\t\t\t\t// Rotate the point about the center of the ellipse.\n\t\t\t\t\t\ttx = ( x - aX ) * cos - ( y - aY ) * sin + aX;\n\t\t\t\t\t\tty = ( x - aX ) * sin + ( y - aY ) * cos + aY;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\n\n\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\n\n\t\t\t\t}\n\n\t\t\t\t//console.log(points);\n\n\t\t\t\tbreak;\n\n\t\t\t} // end switch\n\n\t\t}\n\n\n\n\t\t// Normalize to remove the closing point by default.\n\t\tvar lastPoint = points[ points.length - 1 ];\n\t\tif ( Math.abs( lastPoint.x - points[ 0 ].x ) < Number.EPSILON &&\n\t\t\t\t Math.abs( lastPoint.y - points[ 0 ].y ) < Number.EPSILON )\n\t\t\tpoints.splice( points.length - 1, 1 );\n\n\t\tif ( this.autoClose ) {\n\n\t\t\tpoints.push( points[ 0 ] );\n\n\t\t}\n\n\t\treturn points;\n\n\t},\n\n\ttoShapes: function ( isCCW, noHoles ) {\n\n\t\tfunction extractSubpaths( inActions ) {\n\n\t\t\tvar subPaths = [], lastPath = new THREE.Path();\n\n\t\t\tfor ( var i = 0, l = inActions.length; i < l; i ++ ) {\n\n\t\t\t\tvar item = inActions[ i ];\n\n\t\t\t\tvar args = item.args;\n\t\t\t\tvar action = item.action;\n\n\t\t\t\tif ( action === 'moveTo' ) {\n\n\t\t\t\t\tif ( lastPath.actions.length !== 0 ) {\n\n\t\t\t\t\t\tsubPaths.push( lastPath );\n\t\t\t\t\t\tlastPath = new THREE.Path();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tlastPath[ action ].apply( lastPath, args );\n\n\t\t\t}\n\n\t\t\tif ( lastPath.actions.length !== 0 ) {\n\n\t\t\t\tsubPaths.push( lastPath );\n\n\t\t\t}\n\n\t\t\t// console.log(subPaths);\n\n\t\t\treturn\tsubPaths;\n\n\t\t}\n\n\t\tfunction toShapesNoHoles( inSubpaths ) {\n\n\t\t\tvar shapes = [];\n\n\t\t\tfor ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {\n\n\t\t\t\tvar tmpPath = inSubpaths[ i ];\n\n\t\t\t\tvar tmpShape = new THREE.Shape();\n\t\t\t\ttmpShape.actions = tmpPath.actions;\n\t\t\t\ttmpShape.curves = tmpPath.curves;\n\n\t\t\t\tshapes.push( tmpShape );\n\n\t\t\t}\n\n\t\t\t//console.log(\"shape\", shapes);\n\n\t\t\treturn shapes;\n\n\t\t}\n\n\t\tfunction isPointInsidePolygon( inPt, inPolygon ) {\n\n\t\t\tvar polyLen = inPolygon.length;\n\n\t\t\t// inPt on polygon contour => immediate success    or\n\t\t\t// toggling of inside/outside at every single! intersection point of an edge\n\t\t\t//  with the horizontal line through inPt, left of inPt\n\t\t\t//  not counting lowerY endpoints of edges and whole edges on that line\n\t\t\tvar inside = false;\n\t\t\tfor ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\n\n\t\t\t\tvar edgeLowPt  = inPolygon[ p ];\n\t\t\t\tvar edgeHighPt = inPolygon[ q ];\n\n\t\t\t\tvar edgeDx = edgeHighPt.x - edgeLowPt.x;\n\t\t\t\tvar edgeDy = edgeHighPt.y - edgeLowPt.y;\n\n\t\t\t\tif ( Math.abs( edgeDy ) > Number.EPSILON ) {\n\n\t\t\t\t\t// not parallel\n\t\t\t\t\tif ( edgeDy < 0 ) {\n\n\t\t\t\t\t\tedgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;\n\t\t\t\t\t\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \t\tcontinue;\n\n\t\t\t\t\tif ( inPt.y === edgeLowPt.y ) {\n\n\t\t\t\t\t\tif ( inPt.x === edgeLowPt.x )\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvar perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\n\t\t\t\t\t\tif ( perpEdge === 0 )\t\t\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\tif ( perpEdge < 0 ) \t\t\t\tcontinue;\n\t\t\t\t\t\tinside = ! inside;\t\t// true intersection left of inPt\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// parallel or collinear\n\t\t\t\t\tif ( inPt.y !== edgeLowPt.y ) \t\tcontinue;\t\t\t// parallel\n\t\t\t\t\t// edge lies on the same horizontal line as inPt\n\t\t\t\t\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\n\t\t\t\t\t\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\t\treturn\ttrue;\t// inPt: Point on contour !\n\t\t\t\t\t// continue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn\tinside;\n\n\t\t}\n\n\t\tvar isClockWise = THREE.ShapeUtils.isClockWise;\n\n\t\tvar subPaths = extractSubpaths( this.actions );\n\t\tif ( subPaths.length === 0 ) return [];\n\n\t\tif ( noHoles === true )\treturn\ttoShapesNoHoles( subPaths );\n\n\n\t\tvar solid, tmpPath, tmpShape, shapes = [];\n\n\t\tif ( subPaths.length === 1 ) {\n\n\t\t\ttmpPath = subPaths[ 0 ];\n\t\t\ttmpShape = new THREE.Shape();\n\t\t\ttmpShape.actions = tmpPath.actions;\n\t\t\ttmpShape.curves = tmpPath.curves;\n\t\t\tshapes.push( tmpShape );\n\t\t\treturn shapes;\n\n\t\t}\n\n\t\tvar holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\n\t\tholesFirst = isCCW ? ! holesFirst : holesFirst;\n\n\t\t// console.log(\"Holes first\", holesFirst);\n\n\t\tvar betterShapeHoles = [];\n\t\tvar newShapes = [];\n\t\tvar newShapeHoles = [];\n\t\tvar mainIdx = 0;\n\t\tvar tmpPoints;\n\n\t\tnewShapes[ mainIdx ] = undefined;\n\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\tfor ( var i = 0, l = subPaths.length; i < l; i ++ ) {\n\n\t\t\ttmpPath = subPaths[ i ];\n\t\t\ttmpPoints = tmpPath.getPoints();\n\t\t\tsolid = isClockWise( tmpPoints );\n\t\t\tsolid = isCCW ? ! solid : solid;\n\n\t\t\tif ( solid ) {\n\n\t\t\t\tif ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )\tmainIdx ++;\n\n\t\t\t\tnewShapes[ mainIdx ] = { s: new THREE.Shape(), p: tmpPoints };\n\t\t\t\tnewShapes[ mainIdx ].s.actions = tmpPath.actions;\n\t\t\t\tnewShapes[ mainIdx ].s.curves = tmpPath.curves;\n\n\t\t\t\tif ( holesFirst )\tmainIdx ++;\n\t\t\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\t\t\t//console.log('cw', i);\n\n\t\t\t} else {\n\n\t\t\t\tnewShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\n\n\t\t\t\t//console.log('ccw', i);\n\n\t\t\t}\n\n\t\t}\n\n\t\t// only Holes? -> probably all Shapes with wrong orientation\n\t\tif ( ! newShapes[ 0 ] )\treturn\ttoShapesNoHoles( subPaths );\n\n\n\t\tif ( newShapes.length > 1 ) {\n\n\t\t\tvar ambiguous = false;\n\t\t\tvar toChange = [];\n\n\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\tbetterShapeHoles[ sIdx ] = [];\n\n\t\t\t}\n\n\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\tvar sho = newShapeHoles[ sIdx ];\n\n\t\t\t\tfor ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {\n\n\t\t\t\t\tvar ho = sho[ hIdx ];\n\t\t\t\t\tvar hole_unassigned = true;\n\n\t\t\t\t\tfor ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\n\n\t\t\t\t\t\tif ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\n\n\t\t\t\t\t\t\tif ( sIdx !== s2Idx )\ttoChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );\n\t\t\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\t\t\thole_unassigned = false;\n\t\t\t\t\t\t\t\tbetterShapeHoles[ s2Idx ].push( ho );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tambiguous = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\tbetterShapeHoles[ sIdx ].push( ho );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// console.log(\"ambiguous: \", ambiguous);\n\t\t\tif ( toChange.length > 0 ) {\n\n\t\t\t\t// console.log(\"to change: \", toChange);\n\t\t\t\tif ( ! ambiguous )\tnewShapeHoles = betterShapeHoles;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar tmpHoles;\n\n\t\tfor ( var i = 0, il = newShapes.length; i < il; i ++ ) {\n\n\t\t\ttmpShape = newShapes[ i ].s;\n\t\t\tshapes.push( tmpShape );\n\t\t\ttmpHoles = newShapeHoles[ i ];\n\n\t\t\tfor ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\n\n\t\t\t\ttmpShape.holes.push( tmpHoles[ j ].h );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//console.log(\"shape\", shapes);\n\n\t\treturn shapes;\n\n\t}\n\n} );\n\n// File:src/extras/core/Shape.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * Defines a 2d shape plane using paths.\n **/\n\n// STEP 1 Create a path.\n// STEP 2 Turn path into shape.\n// STEP 3 ExtrudeGeometry takes in Shape/Shapes\n// STEP 3a - Extract points from each shape, turn to vertices\n// STEP 3b - Triangulate each shape, add faces.\n\nTHREE.Shape = function () {\n\n\tTHREE.Path.apply( this, arguments );\n\n\tthis.holes = [];\n\n};\n\nTHREE.Shape.prototype = Object.assign( Object.create( THREE.Path.prototype ), {\n\n\tconstructor: THREE.Shape,\n\n\t// Convenience method to return ExtrudeGeometry\n\n\textrude: function ( options ) {\n\n\t\treturn new THREE.ExtrudeGeometry( this, options );\n\n\t},\n\n\t// Convenience method to return ShapeGeometry\n\n\tmakeGeometry: function ( options ) {\n\n\t\treturn new THREE.ShapeGeometry( this, options );\n\n\t},\n\n\tgetPointsHoles: function ( divisions ) {\n\n\t\tvar holesPts = [];\n\n\t\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\n\n\t\t\tholesPts[ i ] = this.holes[ i ].getPoints( divisions );\n\n\t\t}\n\n\t\treturn holesPts;\n\n\t},\n\n\t// Get points of shape and holes (keypoints based on segments parameter)\n\n\textractAllPoints: function ( divisions ) {\n\n\t\treturn {\n\n\t\t\tshape: this.getPoints( divisions ),\n\t\t\tholes: this.getPointsHoles( divisions )\n\n\t\t};\n\n\t},\n\n\textractPoints: function ( divisions ) {\n\n\t\treturn this.extractAllPoints( divisions );\n\n\t}\n\n} );\n\n// File:src/extras/curves/LineCurve.js\n\n/**************************************************************\n *\tLine\n **************************************************************/\n\nTHREE.LineCurve = function ( v1, v2 ) {\n\n\tthis.v1 = v1;\n\tthis.v2 = v2;\n\n};\n\nTHREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );\nTHREE.LineCurve.prototype.constructor = THREE.LineCurve;\n\nTHREE.LineCurve.prototype.getPoint = function ( t ) {\n\n\tvar point = this.v2.clone().sub( this.v1 );\n\tpoint.multiplyScalar( t ).add( this.v1 );\n\n\treturn point;\n\n};\n\n// Line curve is linear, so we can overwrite default getPointAt\n\nTHREE.LineCurve.prototype.getPointAt = function ( u ) {\n\n\treturn this.getPoint( u );\n\n};\n\nTHREE.LineCurve.prototype.getTangent = function( t ) {\n\n\tvar tangent = this.v2.clone().sub( this.v1 );\n\n\treturn tangent.normalize();\n\n};\n\n// File:src/extras/curves/QuadraticBezierCurve.js\n\n/**************************************************************\n *\tQuadratic Bezier curve\n **************************************************************/\n\n\nTHREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {\n\n\tthis.v0 = v0;\n\tthis.v1 = v1;\n\tthis.v2 = v2;\n\n};\n\nTHREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );\nTHREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;\n\n\nTHREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {\n\n\tvar b2 = THREE.ShapeUtils.b2;\n\n\treturn new THREE.Vector2(\n\t\tb2( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\tb2( t, this.v0.y, this.v1.y, this.v2.y )\n\t);\n\n};\n\n\nTHREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {\n\n\tvar tangentQuadraticBezier = THREE.CurveUtils.tangentQuadraticBezier;\n\n\treturn new THREE.Vector2(\n\t\ttangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\ttangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y )\n\t).normalize();\n\n};\n\n// File:src/extras/curves/CubicBezierCurve.js\n\n/**************************************************************\n *\tCubic Bezier curve\n **************************************************************/\n\nTHREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {\n\n\tthis.v0 = v0;\n\tthis.v1 = v1;\n\tthis.v2 = v2;\n\tthis.v3 = v3;\n\n};\n\nTHREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );\nTHREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;\n\nTHREE.CubicBezierCurve.prototype.getPoint = function ( t ) {\n\n\tvar b3 = THREE.ShapeUtils.b3;\n\n\treturn new THREE.Vector2( \n\t\tb3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\tb3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\n\t);\n\n};\n\nTHREE.CubicBezierCurve.prototype.getTangent = function( t ) {\n\n\tvar tangentCubicBezier = THREE.CurveUtils.tangentCubicBezier;\n\n\treturn new THREE.Vector2( \n\t\ttangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\ttangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\n\t).normalize();\n\n};\n\n// File:src/extras/curves/SplineCurve.js\n\n/**************************************************************\n *\tSpline curve\n **************************************************************/\n\nTHREE.SplineCurve = function ( points /* array of Vector2 */ ) {\n\n\tthis.points = ( points == undefined ) ? [] : points;\n\n};\n\nTHREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );\nTHREE.SplineCurve.prototype.constructor = THREE.SplineCurve;\n\nTHREE.SplineCurve.prototype.getPoint = function ( t ) {\n\n\tvar points = this.points;\n\tvar point = ( points.length - 1 ) * t;\n\n\tvar intPoint = Math.floor( point );\n\tvar weight = point - intPoint;\n\n\tvar point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\n\tvar point1 = points[ intPoint ];\n\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\n\tvar interpolate = THREE.CurveUtils.interpolate;\n\n\treturn new THREE.Vector2(\n\t\tinterpolate( point0.x, point1.x, point2.x, point3.x, weight ),\n\t\tinterpolate( point0.y, point1.y, point2.y, point3.y, weight )\n\t);\n\n};\n\n// File:src/extras/curves/EllipseCurve.js\n\n/**************************************************************\n *\tEllipse curve\n **************************************************************/\n\nTHREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\tthis.aX = aX;\n\tthis.aY = aY;\n\n\tthis.xRadius = xRadius;\n\tthis.yRadius = yRadius;\n\n\tthis.aStartAngle = aStartAngle;\n\tthis.aEndAngle = aEndAngle;\n\n\tthis.aClockwise = aClockwise;\n\t\n\tthis.aRotation = aRotation || 0;\n\n};\n\nTHREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );\nTHREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;\n\nTHREE.EllipseCurve.prototype.getPoint = function ( t ) {\n\n\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\n\n\tif ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;\n\tif ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;\n\n\tvar angle;\n\n\tif ( this.aClockwise === true ) {\n\n\t\tangle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );\n\n\t} else {\n\n\t\tangle = this.aStartAngle + t * deltaAngle;\n\n\t}\n\t\n\tvar x = this.aX + this.xRadius * Math.cos( angle );\n\tvar y = this.aY + this.yRadius * Math.sin( angle );\n\n\tif ( this.aRotation !== 0 ) {\n\n\t\tvar cos = Math.cos( this.aRotation );\n\t\tvar sin = Math.sin( this.aRotation );\n\n\t\tvar tx = x, ty = y;\n\n\t\t// Rotate the point about the center of the ellipse.\n\t\tx = ( tx - this.aX ) * cos - ( ty - this.aY ) * sin + this.aX;\n\t\ty = ( tx - this.aX ) * sin + ( ty - this.aY ) * cos + this.aY;\n\n\t}\n\n\treturn new THREE.Vector2( x, y );\n\n};\n\n// File:src/extras/curves/ArcCurve.js\n\n/**************************************************************\n *\tArc curve\n **************************************************************/\n\nTHREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\tTHREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n};\n\nTHREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );\nTHREE.ArcCurve.prototype.constructor = THREE.ArcCurve;\n\n// File:src/extras/curves/LineCurve3.js\n\n/**************************************************************\n *\tLine3D\n **************************************************************/\n\nTHREE.LineCurve3 = THREE.Curve.create(\n\n\tfunction ( v1, v2 ) {\n\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t},\n\n\tfunction ( t ) {\n\n\t\tvar vector = new THREE.Vector3();\n\n\t\tvector.subVectors( this.v2, this.v1 ); // diff\n\t\tvector.multiplyScalar( t );\n\t\tvector.add( this.v1 );\n\n\t\treturn vector;\n\n\t}\n\n);\n\n// File:src/extras/curves/QuadraticBezierCurve3.js\n\n/**************************************************************\n *\tQuadratic Bezier 3D curve\n **************************************************************/\n\nTHREE.QuadraticBezierCurve3 = THREE.Curve.create(\n\n\tfunction ( v0, v1, v2 ) {\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t},\n\n\tfunction ( t ) {\n\n\t\tvar b2 = THREE.ShapeUtils.b2;\t\t\n\n\t\treturn new THREE.Vector3(\n\t\t\tb2( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\t\tb2( t, this.v0.y, this.v1.y, this.v2.y ),\n\t\t\tb2( t, this.v0.z, this.v1.z, this.v2.z )\n\t\t);\n\n\t}\n\n);\n\n// File:src/extras/curves/CubicBezierCurve3.js\n\n/**************************************************************\n *\tCubic Bezier 3D curve\n **************************************************************/\n\nTHREE.CubicBezierCurve3 = THREE.Curve.create(\n\n\tfunction ( v0, v1, v2, v3 ) {\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\tthis.v3 = v3;\n\n\t},\n\n\tfunction ( t ) {\n\n\t\tvar b3 = THREE.ShapeUtils.b3;\n\n\t\treturn new THREE.Vector3(\n\t\t\tb3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\t\tb3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y ),\n\t\t\tb3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z )\n\t\t);\n\n\t}\n\n);\n\n// File:src/extras/curves/SplineCurve3.js\n\n/**************************************************************\n *\tSpline 3D curve\n **************************************************************/\n\n\nTHREE.SplineCurve3 = THREE.Curve.create(\n\n\tfunction ( points /* array of Vector3 */ ) {\n\n\t\tconsole.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );\n\t\tthis.points = ( points == undefined ) ? [] : points;\n\n\t},\n\n\tfunction ( t ) {\n\n\t\tvar points = this.points;\n\t\tvar point = ( points.length - 1 ) * t;\n\n\t\tvar intPoint = Math.floor( point );\n\t\tvar weight = point - intPoint;\n\n\t\tvar point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];\n\t\tvar point1 = points[ intPoint ];\n\t\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n\t\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\n\t\tvar interpolate = THREE.CurveUtils.interpolate;\n\n\t\treturn new THREE.Vector3(\n\t\t\tinterpolate( point0.x, point1.x, point2.x, point3.x, weight ),\n\t\t\tinterpolate( point0.y, point1.y, point2.y, point3.y, weight ),\n\t\t\tinterpolate( point0.z, point1.z, point2.z, point3.z, weight )\n\t\t);\n\n\t}\n\n);\n\n// File:src/extras/curves/CatmullRomCurve3.js\n\n/**\n * @author zz85 https://github.com/zz85\n *\n * Centripetal CatmullRom Curve - which is useful for avoiding\n * cusps and self-intersections in non-uniform catmull rom curves.\n * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\n *\n * curve.type accepts centripetal(default), chordal and catmullrom\n * curve.tension is used for catmullrom which defaults to 0.5\n */\n\nTHREE.CatmullRomCurve3 = ( function() {\n\n\tvar\n\t\ttmp = new THREE.Vector3(),\n\t\tpx = new CubicPoly(),\n\t\tpy = new CubicPoly(),\n\t\tpz = new CubicPoly();\n\n\t/*\n\tBased on an optimized c++ solution in\n\t - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\n\t - http://ideone.com/NoEbVM\n\n\tThis CubicPoly class could be used for reusing some variables and calculations,\n\tbut for three.js curve use, it could be possible inlined and flatten into a single function call\n\twhich can be placed in CurveUtils.\n\t*/\n\n\tfunction CubicPoly() {\n\n\t}\n\n\t/*\n\t * Compute coefficients for a cubic polynomial\n\t *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\n\t * such that\n\t *   p(0) = x0, p(1) = x1\n\t *  and\n\t *   p'(0) = t0, p'(1) = t1.\n\t */\n\tCubicPoly.prototype.init = function( x0, x1, t0, t1 ) {\n\n\t\tthis.c0 = x0;\n\t\tthis.c1 = t0;\n\t\tthis.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\n\t\tthis.c3 = 2 * x0 - 2 * x1 + t0 + t1;\n\n\t};\n\n\tCubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {\n\n\t\t// compute tangents when parameterized in [t1,t2]\n\t\tvar t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\n\t\tvar t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\n\n\t\t// rescale tangents for parametrization in [0,1]\n\t\tt1 *= dt1;\n\t\tt2 *= dt1;\n\n\t\t// initCubicPoly\n\t\tthis.init( x1, x2, t1, t2 );\n\n\t};\n\n\t// standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4\n\tCubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {\n\n\t\tthis.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\n\n\t};\n\n\tCubicPoly.prototype.calc = function( t ) {\n\n\t\tvar t2 = t * t;\n\t\tvar t3 = t2 * t;\n\t\treturn this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;\n\n\t};\n\n\t// Subclass Three.js curve\n\treturn THREE.Curve.create(\n\n\t\tfunction ( p /* array of Vector3 */ ) {\n\n\t\t\tthis.points = p || [];\n\t\t\tthis.closed = false;\n\n\t\t},\n\n\t\tfunction ( t ) {\n\n\t\t\tvar points = this.points,\n\t\t\t\tpoint, intPoint, weight, l;\n\n\t\t\tl = points.length;\n\n\t\t\tif ( l < 2 ) console.log( 'duh, you need at least 2 points' );\n\n\t\t\tpoint = ( l - ( this.closed ? 0 : 1 ) ) * t;\n\t\t\tintPoint = Math.floor( point );\n\t\t\tweight = point - intPoint;\n\n\t\t\tif ( this.closed ) {\n\n\t\t\t\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;\n\n\t\t\t} else if ( weight === 0 && intPoint === l - 1 ) {\n\n\t\t\t\tintPoint = l - 2;\n\t\t\t\tweight = 1;\n\n\t\t\t}\n\n\t\t\tvar p0, p1, p2, p3; // 4 points\n\n\t\t\tif ( this.closed || intPoint > 0 ) {\n\n\t\t\t\tp0 = points[ ( intPoint - 1 ) % l ];\n\n\t\t\t} else {\n\n\t\t\t\t// extrapolate first point\n\t\t\t\ttmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\n\t\t\t\tp0 = tmp;\n\n\t\t\t}\n\n\t\t\tp1 = points[ intPoint % l ];\n\t\t\tp2 = points[ ( intPoint + 1 ) % l ];\n\n\t\t\tif ( this.closed || intPoint + 2 < l ) {\n\n\t\t\t\tp3 = points[ ( intPoint + 2 ) % l ];\n\n\t\t\t} else {\n\n\t\t\t\t// extrapolate last point\n\t\t\t\ttmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\n\t\t\t\tp3 = tmp;\n\n\t\t\t}\n\n\t\t\tif ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {\n\n\t\t\t\t// init Centripetal / Chordal Catmull-Rom\n\t\t\t\tvar pow = this.type === 'chordal' ? 0.5 : 0.25;\n\t\t\t\tvar dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\n\t\t\t\tvar dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\n\t\t\t\tvar dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\n\n\t\t\t\t// safety check for repeated points\n\t\t\t\tif ( dt1 < 1e-4 ) dt1 = 1.0;\n\t\t\t\tif ( dt0 < 1e-4 ) dt0 = dt1;\n\t\t\t\tif ( dt2 < 1e-4 ) dt2 = dt1;\n\n\t\t\t\tpx.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\n\t\t\t\tpy.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\n\t\t\t\tpz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\n\n\t\t\t} else if ( this.type === 'catmullrom' ) {\n\n\t\t\t\tvar tension = this.tension !== undefined ? this.tension : 0.5;\n\t\t\t\tpx.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );\n\t\t\t\tpy.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );\n\t\t\t\tpz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );\n\n\t\t\t}\n\n\t\t\tvar v = new THREE.Vector3(\n\t\t\t\tpx.calc( weight ),\n\t\t\t\tpy.calc( weight ),\n\t\t\t\tpz.calc( weight )\n\t\t\t);\n\n\t\t\treturn v;\n\n\t\t}\n\n\t);\n\n} )();\n\n// File:src/extras/curves/ClosedSplineCurve3.js\n\n/**************************************************************\n *\tClosed Spline 3D curve\n **************************************************************/\n\n\nTHREE.ClosedSplineCurve3 = function ( points ) {\n\n\tconsole.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3.' );\n\n\tTHREE.CatmullRomCurve3.call( this, points );\n\tthis.type = 'catmullrom';\n\tthis.closed = true;\n\n};\n\nTHREE.ClosedSplineCurve3.prototype = Object.create( THREE.CatmullRomCurve3.prototype );\n\n// File:src/extras/geometries/BoxGeometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as\n */\n\nTHREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'BoxGeometry';\n\n\tthis.parameters = {\n\t\twidth: width,\n\t\theight: height,\n\t\tdepth: depth,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments,\n\t\tdepthSegments: depthSegments\n\t};\n\n\tthis.fromBufferGeometry( new THREE.BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );\n\tthis.mergeVertices();\n\n};\n\nTHREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;\n\nTHREE.CubeGeometry = THREE.BoxGeometry;\n\n// File:src/extras/geometries/BoxBufferGeometry.js\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nTHREE.BoxBufferGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'BoxBufferGeometry';\n\n\tthis.parameters = {\n\t\twidth: width,\n\t\theight: height,\n\t\tdepth: depth,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments,\n\t\tdepthSegments: depthSegments\n\t};\n\n\tvar scope = this;\n\n\t// segments\n\twidthSegments = Math.floor( widthSegments ) || 1;\n\theightSegments = Math.floor( heightSegments ) || 1;\n\tdepthSegments = Math.floor( depthSegments ) || 1;\n\n\t// these are used to calculate buffer length\n\tvar vertexCount = calculateVertexCount( widthSegments, heightSegments, depthSegments );\n\tvar indexCount = calculateIndexCount( widthSegments, heightSegments, depthSegments );\n\n\t// buffers\n\tvar indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );\n\tvar vertices = new Float32Array( vertexCount * 3 );\n\tvar normals = new Float32Array( vertexCount * 3 );\n\tvar uvs = new Float32Array( vertexCount * 2 );\n\n\t// offset variables\n\tvar vertexBufferOffset = 0;\n\tvar uvBufferOffset = 0;\n\tvar indexBufferOffset = 0;\n\tvar numberOfVertices = 0;\n\n\t// group variables\n\tvar groupStart = 0;\n\n\t// build each side of the box geometry\n\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height,   width,  depthSegments, heightSegments, 0 ); // px\n\tbuildPlane( 'z', 'y', 'x',   1, - 1, depth, height, - width,  depthSegments, heightSegments, 1 ); // nx\n\tbuildPlane( 'x', 'z', 'y',   1,   1, width, depth,    height, widthSegments, depthSegments,  2 ); // py\n\tbuildPlane( 'x', 'z', 'y',   1, - 1, width, depth,  - height, widthSegments, depthSegments,  3 ); // ny\n\tbuildPlane( 'x', 'y', 'z',   1, - 1, width, height,   depth,  widthSegments, heightSegments, 4 ); // pz\n\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth,  widthSegments, heightSegments, 5 ); // nz\n\n\t// build geometry\n\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ) );\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\n\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\n\n\t// helper functions\n\n\tfunction calculateVertexCount ( w, h, d ) {\n\n\t\tvar vertices = 0;\n\n\t\t// calculate the amount of vertices for each side (plane)\n\t\tvertices += (w + 1) * (h + 1) * 2; // xy\n\t\tvertices += (w + 1) * (d + 1) * 2; // xz\n\t\tvertices += (d + 1) * (h + 1) * 2; // zy\n\n\t\treturn vertices;\n\n\t}\n\n\tfunction calculateIndexCount ( w, h, d ) {\n\n\t\tvar index = 0;\n\n\t\t// calculate the amount of squares for each side\n\t\tindex += w * h * 2; // xy\n\t\tindex += w * d * 2; // xz\n\t\tindex += d * h * 2; // zy\n\n\t\treturn index * 6; // two triangles per square => six vertices per square\n\n\t}\n\n\tfunction buildPlane ( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\n\n\t\tvar segmentWidth\t= width / gridX;\n\t\tvar segmentHeight = height / gridY;\n\n\t\tvar widthHalf = width / 2;\n\t\tvar heightHalf = height / 2;\n\t\tvar depthHalf = depth / 2;\n\n\t\tvar gridX1 = gridX + 1;\n\t\tvar gridY1 = gridY + 1;\n\n\t\tvar vertexCounter = 0;\n\t\tvar groupCount = 0;\n\n\t\tvar vector = new THREE.Vector3();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\tvar y = iy * segmentHeight - heightHalf;\n\n\t\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\tvar x = ix * segmentWidth - widthHalf;\n\n\t\t\t\t// set values to correct vector component\n\t\t\t\tvector[ u ] = x * udir;\n\t\t\t\tvector[ v ] = y * vdir;\n\t\t\t\tvector[ w ] = depthHalf;\n\n\t\t\t\t// now apply vector to vertex buffer\n\t\t\t\tvertices[ vertexBufferOffset ] = vector.x;\n\t\t\t\tvertices[ vertexBufferOffset + 1 ] = vector.y;\n\t\t\t\tvertices[ vertexBufferOffset + 2 ] = vector.z;\n\n\t\t\t\t// set values to correct vector component\n\t\t\t\tvector[ u ] = 0;\n\t\t\t\tvector[ v ] = 0;\n\t\t\t\tvector[ w ] = depth > 0 ? 1 : - 1;\n\n\t\t\t\t// now apply vector to normal buffer\n\t\t\t\tnormals[ vertexBufferOffset ] = vector.x;\n\t\t\t\tnormals[ vertexBufferOffset + 1 ] = vector.y;\n\t\t\t\tnormals[ vertexBufferOffset + 2 ] = vector.z;\n\n\t\t\t\t// uvs\n\t\t\t\tuvs[ uvBufferOffset ] = ix / gridX;\n\t\t\t\tuvs[ uvBufferOffset + 1 ] = 1 - ( iy / gridY );\n\n\t\t\t\t// update offsets and counters\n\t\t\t\tvertexBufferOffset += 3;\n\t\t\t\tuvBufferOffset += 2;\n\t\t\t\tvertexCounter += 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// 1. you need three indices to draw a single face\n\t\t// 2. a single segment consists of two faces\n\t\t// 3. so we need to generate six (2*3) indices per segment\n\n\t\tfor ( iy = 0; iy < gridY; iy ++ ) {\n\n\t\t\tfor ( ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\t\t// indices\n\t\t\t\tvar a = numberOfVertices + ix + gridX1 * iy;\n\t\t\t\tvar b = numberOfVertices + ix + gridX1 * ( iy + 1 );\n\t\t\t\tvar c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\tvar d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\t// face one\n\t\t\t\tindices[ indexBufferOffset ] = a;\n\t\t\t\tindices[ indexBufferOffset + 1 ] = b;\n\t\t\t\tindices[ indexBufferOffset + 2 ] = d;\n\n\t\t\t\t// face two\n\t\t\t\tindices[ indexBufferOffset + 3 ] = b;\n\t\t\t\tindices[ indexBufferOffset + 4 ] = c;\n\t\t\t\tindices[ indexBufferOffset + 5 ] = d;\n\n\t\t\t\t// update offsets and counters\n\t\t\t\tindexBufferOffset += 6;\n\t\t\t\tgroupCount += 6;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// add a group to the geometry. this will ensure multi material support\n\t\tscope.addGroup( groupStart, groupCount, materialIndex );\n\n\t\t// calculate new start value for groups\n\t\tgroupStart += groupCount;\n\n\t\t// update total number of vertices\n\t\tnumberOfVertices += vertexCounter;\n\n\t}\n\n};\n\nTHREE.BoxBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.BoxBufferGeometry.prototype.constructor = THREE.BoxBufferGeometry;\n\n// File:src/extras/geometries/CircleGeometry.js\n\n/**\n * @author hughes\n */\n\nTHREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'CircleGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tsegments: segments,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tthis.fromBufferGeometry( new THREE.CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );\n\n};\n\nTHREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;\n\n// File:src/extras/geometries/CircleBufferGeometry.js\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nTHREE.CircleBufferGeometry = function ( radius, segments, thetaStart, thetaLength ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'CircleBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tsegments: segments,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tradius = radius || 50;\n\tsegments = segments !== undefined ? Math.max( 3, segments ) : 8;\n\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\n\tvar vertices = segments + 2;\n\n\tvar positions = new Float32Array( vertices * 3 );\n\tvar normals = new Float32Array( vertices * 3 );\n\tvar uvs = new Float32Array( vertices * 2 );\n\n\t// center data is already zero, but need to set a few extras\n\tnormals[ 2 ] = 1.0;\n\tuvs[ 0 ] = 0.5;\n\tuvs[ 1 ] = 0.5;\n\n\tfor ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {\n\n\t\tvar segment = thetaStart + s / segments * thetaLength;\n\n\t\tpositions[ i ] = radius * Math.cos( segment );\n\t\tpositions[ i + 1 ] = radius * Math.sin( segment );\n\n\t\tnormals[ i + 2 ] = 1; // normal z\n\n\t\tuvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;\n\t\tuvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;\n\n\t}\n\n\tvar indices = [];\n\n\tfor ( var i = 1; i <= segments; i ++ ) {\n\n\t\tindices.push( i, i + 1, 0 );\n\n\t}\n\n\tthis.setIndex( new THREE.BufferAttribute( new Uint16Array( indices ), 1 ) );\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\n\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\n\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\n\n};\n\nTHREE.CircleBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry;\n\n// File:src/extras/geometries/CylinderBufferGeometry.js\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nTHREE.CylinderBufferGeometry = function( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'CylinderBufferGeometry';\n\n\tthis.parameters = {\n\t\tradiusTop: radiusTop,\n\t\tradiusBottom: radiusBottom,\n\t\theight: height,\n\t\tradialSegments: radialSegments,\n\t\theightSegments: heightSegments,\n\t\topenEnded: openEnded,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tvar scope = this;\n\n\tradiusTop = radiusTop !== undefined ? radiusTop : 20;\n\tradiusBottom = radiusBottom !== undefined ? radiusBottom : 20;\n\theight = height !== undefined ? height : 100;\n\n\tradialSegments = Math.floor( radialSegments ) || 8;\n\theightSegments = Math.floor( heightSegments ) || 1;\n\n\topenEnded = openEnded !== undefined ? openEnded : false;\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0.0;\n\tthetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI;\n\n\t// used to calculate buffer length\n\n\tvar nbCap = 0;\n\n\tif ( openEnded === false ) {\n\n\t\tif ( radiusTop > 0 ) nbCap ++;\n\t\tif ( radiusBottom > 0 ) nbCap ++;\n\n\t}\n\n\tvar vertexCount = calculateVertexCount();\n\tvar indexCount = calculateIndexCount();\n\n\t// buffers\n\n\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ), 1 );\n\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t// helper variables\n\n\tvar index = 0,\n\t    indexOffset = 0,\n\t    indexArray = [],\n\t    halfHeight = height / 2;\n\n\t// group variables\n\tvar groupStart = 0;\n\n\t// generate geometry\n\n\tgenerateTorso();\n\n\tif ( openEnded === false ) {\n\n\t\tif ( radiusTop > 0 ) generateCap( true );\n\t\tif ( radiusBottom > 0 ) generateCap( false );\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', vertices );\n\tthis.addAttribute( 'normal', normals );\n\tthis.addAttribute( 'uv', uvs );\n\n\t// helper functions\n\n\tfunction calculateVertexCount() {\n\n\t\tvar count = ( radialSegments + 1 ) * ( heightSegments + 1 );\n\n\t\tif ( openEnded === false ) {\n\n\t\t\tcount += ( ( radialSegments + 1 ) * nbCap ) + ( radialSegments * nbCap );\n\n\t\t}\n\n\t\treturn count;\n\n\t}\n\n\tfunction calculateIndexCount() {\n\n\t\tvar count = radialSegments * heightSegments * 2 * 3;\n\n\t\tif ( openEnded === false ) {\n\n\t\t\tcount += radialSegments * nbCap * 3;\n\n\t\t}\n\n\t\treturn count;\n\n\t}\n\n\tfunction generateTorso() {\n\n\t\tvar x, y;\n\t\tvar normal = new THREE.Vector3();\n\t\tvar vertex = new THREE.Vector3();\n\n\t\tvar groupCount = 0;\n\n\t\t// this will be used to calculate the normal\n\t\tvar tanTheta = ( radiusBottom - radiusTop ) / height;\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( y = 0; y <= heightSegments; y ++ ) {\n\n\t\t\tvar indexRow = [];\n\n\t\t\tvar v = y / heightSegments;\n\n\t\t\t// calculate the radius of the current row\n\t\t\tvar radius = v * ( radiusBottom - radiusTop ) + radiusTop;\n\n\t\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\t\tvar u = x / radialSegments;\n\n\t\t\t\t// vertex\n\t\t\t\tvertex.x = radius * Math.sin( u * thetaLength + thetaStart );\n\t\t\t\tvertex.y = - v * height + halfHeight;\n\t\t\t\tvertex.z = radius * Math.cos( u * thetaLength + thetaStart );\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\t\t\t\tnormal.copy( vertex );\n\n\t\t\t\t// handle special case if radiusTop/radiusBottom is zero\n\n\t\t\t\tif ( ( radiusTop === 0 && y === 0 ) || ( radiusBottom === 0 && y === heightSegments ) ) {\n\n\t\t\t\t\tnormal.x = Math.sin( u * thetaLength + thetaStart );\n\t\t\t\t\tnormal.z = Math.cos( u * thetaLength + thetaStart );\n\n\t\t\t\t}\n\n\t\t\t\tnormal.setY( Math.sqrt( normal.x * normal.x + normal.z * normal.z ) * tanTheta ).normalize();\n\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\t\t\t\tuvs.setXY( index, u, 1 - v );\n\n\t\t\t\t// save index of vertex in respective row\n\t\t\t\tindexRow.push( index );\n\n\t\t\t\t// increase index\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\t// now save vertices of the row in our index array\n\t\t\tindexArray.push( indexRow );\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\n\t\t\tfor ( y = 0; y < heightSegments; y ++ ) {\n\n\t\t\t\t// we use the index array to access the correct indices\n\t\t\t\tvar i1 = indexArray[ y ][ x ];\n\t\t\t\tvar i2 = indexArray[ y + 1 ][ x ];\n\t\t\t\tvar i3 = indexArray[ y + 1 ][ x + 1 ];\n\t\t\t\tvar i4 = indexArray[ y ][ x + 1 ];\n\n\t\t\t\t// face one\n\t\t\t\tindices.setX( indexOffset, i1 ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, i2 ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, i4 ); indexOffset ++;\n\n\t\t\t\t// face two\n\t\t\t\tindices.setX( indexOffset, i2 ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, i3 ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, i4 ); indexOffset ++;\n\n\t\t\t\t// update counters\n\t\t\t\tgroupCount += 6;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// add a group to the geometry. this will ensure multi material support\n\t\tscope.addGroup( groupStart, groupCount, 0 );\n\n\t\t// calculate new start value for groups\n\t\tgroupStart += groupCount;\n\n\t}\n\n\tfunction generateCap( top ) {\n\n\t\tvar x, centerIndexStart, centerIndexEnd;\n\n\t\tvar uv = new THREE.Vector2();\n\t\tvar vertex = new THREE.Vector3();\n\n\t\tvar groupCount = 0;\n\n\t\tvar radius = ( top === true ) ? radiusTop : radiusBottom;\n\t\tvar sign = ( top === true ) ? 1 : - 1;\n\n\t\t// save the index of the first center vertex\n\t\tcenterIndexStart = index;\n\n\t\t// first we generate the center vertex data of the cap.\n\t\t// because the geometry needs one set of uvs per face,\n\t\t// we must generate a center vertex per face/segment\n\n\t\tfor ( x = 1; x <= radialSegments; x ++ ) {\n\n\t\t\t// vertex\n\t\t\tvertices.setXYZ( index, 0, halfHeight * sign, 0 );\n\n\t\t\t// normal\n\t\t\tnormals.setXYZ( index, 0, sign, 0 );\n\n\t\t\t// uv\n\t\t\tuv.x = 0.5;\n\t\t\tuv.y = 0.5;\n\n\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t// increase index\n\t\t\tindex ++;\n\n\t\t}\n\n\t\t// save the index of the last center vertex\n\t\tcenterIndexEnd = index;\n\n\t\t// now we generate the surrounding vertices, normals and uvs\n\n\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\tvar u = x / radialSegments;\n\t\t\tvar theta = u * thetaLength + thetaStart;\n\n\t\t\tvar cosTheta = Math.cos( theta );\n\t\t\tvar sinTheta = Math.sin( theta );\n\n\t\t\t// vertex\n\t\t\tvertex.x = radius * sinTheta;\n\t\t\tvertex.y = halfHeight * sign;\n\t\t\tvertex.z = radius * cosTheta;\n\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t// normal\n\t\t\tnormals.setXYZ( index, 0, sign, 0 );\n\n\t\t\t// uv\n\t\t\tuv.x = ( cosTheta * 0.5 ) + 0.5;\n\t\t\tuv.y = ( sinTheta * 0.5 * sign ) + 0.5;\n\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t// increase index\n\t\t\tindex ++;\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\n\t\t\tvar c = centerIndexStart + x;\n\t\t\tvar i = centerIndexEnd + x;\n\n\t\t\tif ( top === true ) {\n\n\t\t\t\t// face top\n\t\t\t\tindices.setX( indexOffset, i ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, i + 1 ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset ++;\n\n\t\t\t} else {\n\n\t\t\t\t// face bottom\n\t\t\t\tindices.setX( indexOffset, i + 1 ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, i ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset ++;\n\n\t\t\t}\n\n\t\t\t// update counters\n\t\t\tgroupCount += 3;\n\n\t\t}\n\n\t\t// add a group to the geometry. this will ensure multi material support\n\t\tscope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );\n\n\t\t// calculate new start value for groups\n\t\tgroupStart += groupCount;\n\n\t}\n\n};\n\nTHREE.CylinderBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.CylinderBufferGeometry.prototype.constructor = THREE.CylinderBufferGeometry;\n\n// File:src/extras/geometries/CylinderGeometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'CylinderGeometry';\n\n\tthis.parameters = {\n\t\tradiusTop: radiusTop,\n\t\tradiusBottom: radiusBottom,\n\t\theight: height,\n\t\tradialSegments: radialSegments,\n\t\theightSegments: heightSegments,\n\t\topenEnded: openEnded,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tthis.fromBufferGeometry( new THREE.CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );\n\tthis.mergeVertices();\n\n};\n\nTHREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;\n\n// File:src/extras/geometries/ConeBufferGeometry.js\n\n/*\n * @author: abelnation / http://github.com/abelnation\n */\n\nTHREE.ConeBufferGeometry = function (\n\tradius, height,\n\tradialSegments, heightSegments,\n\topenEnded, thetaStart, thetaLength ) {\n\n\tTHREE.CylinderBufferGeometry.call( this,\n\t\t0, radius, height,\n\t\tradialSegments, heightSegments,\n\t\topenEnded, thetaStart, thetaLength );\n\n\tthis.type = 'ConeBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\theight: height,\n\t\tradialSegments: radialSegments,\n\t\theightSegments: heightSegments,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n};\n\nTHREE.ConeBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.ConeBufferGeometry.prototype.constructor = THREE.ConeBufferGeometry;\n\n// File:src/extras/geometries/ConeGeometry.js\n\n/**\n * @author abelnation / http://github.com/abelnation\n */\n\nTHREE.ConeGeometry = function (\n\tradius, height,\n\tradialSegments, heightSegments,\n\topenEnded, thetaStart, thetaLength ) {\n\n\tTHREE.CylinderGeometry.call( this,\n\t\t0, radius, height,\n\t\tradialSegments, heightSegments,\n\t\topenEnded, thetaStart, thetaLength );\n\n\tthis.type = 'ConeGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\theight: height,\n\t\tradialSegments: radialSegments,\n\t\theightSegments: heightSegments,\n\t\topenEnded: openEnded,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n};\n\nTHREE.ConeGeometry.prototype = Object.create( THREE.CylinderGeometry.prototype );\nTHREE.ConeGeometry.prototype.constructor = THREE.ConeGeometry;\n\n// File:src/extras/geometries/EdgesGeometry.js\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.EdgesGeometry = function ( geometry, thresholdAngle ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;\n\n\tvar thresholdDot = Math.cos( THREE.Math.DEG2RAD * thresholdAngle );\n\n\tvar edge = [ 0, 0 ], hash = {};\n\n\tfunction sortFunction( a, b ) {\n\n\t\treturn a - b;\n\n\t}\n\n\tvar keys = [ 'a', 'b', 'c' ];\n\n\tvar geometry2;\n\n\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\tgeometry2 = new THREE.Geometry();\n\t\tgeometry2.fromBufferGeometry( geometry );\n\n\t} else {\n\n\t\tgeometry2 = geometry.clone();\n\n\t}\n\n\tgeometry2.mergeVertices();\n\tgeometry2.computeFaceNormals();\n\n\tvar vertices = geometry2.vertices;\n\tvar faces = geometry2.faces;\n\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\tvar face = faces[ i ];\n\n\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\tedge[ 0 ] = face[ keys[ j ] ];\n\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\tedge.sort( sortFunction );\n\n\t\t\tvar key = edge.toString();\n\n\t\t\tif ( hash[ key ] === undefined ) {\n\n\t\t\t\thash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };\n\n\t\t\t} else {\n\n\t\t\t\thash[ key ].face2 = i;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tvar coords = [];\n\n\tfor ( var key in hash ) {\n\n\t\tvar h = hash[ key ];\n\n\t\tif ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {\n\n\t\t\tvar vertex = vertices[ h.vert1 ];\n\t\t\tcoords.push( vertex.x );\n\t\t\tcoords.push( vertex.y );\n\t\t\tcoords.push( vertex.z );\n\n\t\t\tvertex = vertices[ h.vert2 ];\n\t\t\tcoords.push( vertex.x );\n\t\t\tcoords.push( vertex.y );\n\t\t\tcoords.push( vertex.z );\n\n\t\t}\n\n\t}\n\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( coords ), 3 ) );\n\n};\n\nTHREE.EdgesGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry;\n\n// File:src/extras/geometries/ExtrudeGeometry.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n *\n * Creates extruded geometry from a path shape.\n *\n * parameters = {\n *\n *  curveSegments: <int>, // number of points on the curves\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\n *  amount: <int>, // Depth to extrude the shape\n *\n *  bevelEnabled: <bool>, // turn on bevel\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\n *  bevelSize: <float>, // how far from shape outline is bevel\n *  bevelSegments: <int>, // number of bevel layers\n *\n *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)\n *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals\n *\n *  uvGenerator: <Object> // object that provides UV generator functions\n *\n * }\n **/\n\nTHREE.ExtrudeGeometry = function ( shapes, options ) {\n\n\tif ( typeof( shapes ) === \"undefined\" ) {\n\n\t\tshapes = [];\n\t\treturn;\n\n\t}\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'ExtrudeGeometry';\n\n\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\n\n\tthis.addShapeList( shapes, options );\n\n\tthis.computeFaceNormals();\n\n\t// can't really use automatic vertex normals\n\t// as then front and back sides get smoothed too\n\t// should do separate smoothing just for sides\n\n\t//this.computeVertexNormals();\n\n\t//console.log( \"took\", ( Date.now() - startTime ) );\n\n};\n\nTHREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;\n\nTHREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {\n\n\tvar sl = shapes.length;\n\n\tfor ( var s = 0; s < sl; s ++ ) {\n\n\t\tvar shape = shapes[ s ];\n\t\tthis.addShape( shape, options );\n\n\t}\n\n};\n\nTHREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {\n\n\tvar amount = options.amount !== undefined ? options.amount : 100;\n\n\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\n\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\n\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n\n\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\n\n\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\n\tvar steps = options.steps !== undefined ? options.steps : 1;\n\n\tvar extrudePath = options.extrudePath;\n\tvar extrudePts, extrudeByPath = false;\n\n\t// Use default WorldUVGenerator if no UV generators are specified.\n\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;\n\n\tvar splineTube, binormal, normal, position2;\n\tif ( extrudePath ) {\n\n\t\textrudePts = extrudePath.getSpacedPoints( steps );\n\n\t\textrudeByPath = true;\n\t\tbevelEnabled = false; // bevels not supported for path extrusion\n\n\t\t// SETUP TNB variables\n\n\t\t// Reuse TNB from TubeGeomtry for now.\n\t\t// TODO1 - have a .isClosed in spline?\n\n\t\tsplineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames( extrudePath, steps, false );\n\n\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\n\t\tbinormal = new THREE.Vector3();\n\t\tnormal = new THREE.Vector3();\n\t\tposition2 = new THREE.Vector3();\n\n\t}\n\n\t// Safeguards if bevels are not enabled\n\n\tif ( ! bevelEnabled ) {\n\n\t\tbevelSegments = 0;\n\t\tbevelThickness = 0;\n\t\tbevelSize = 0;\n\n\t}\n\n\t// Variables initialization\n\n\tvar ahole, h, hl; // looping of holes\n\tvar scope = this;\n\n\tvar shapesOffset = this.vertices.length;\n\n\tvar shapePoints = shape.extractPoints( curveSegments );\n\n\tvar vertices = shapePoints.shape;\n\tvar holes = shapePoints.holes;\n\n\tvar reverse = ! THREE.ShapeUtils.isClockWise( vertices );\n\n\tif ( reverse ) {\n\n\t\tvertices = vertices.reverse();\n\n\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\n\t\t\tif ( THREE.ShapeUtils.isClockWise( ahole ) ) {\n\n\t\t\t\tholes[ h ] = ahole.reverse();\n\n\t\t\t}\n\n\t\t}\n\n\t\treverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!\n\n\t}\n\n\n\tvar faces = THREE.ShapeUtils.triangulateShape( vertices, holes );\n\n\t/* Vertices */\n\n\tvar contour = vertices; // vertices has all points but contour has only points of circumference\n\n\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\tahole = holes[ h ];\n\n\t\tvertices = vertices.concat( ahole );\n\n\t}\n\n\n\tfunction scalePt2 ( pt, vec, size ) {\n\n\t\tif ( ! vec ) console.error( \"THREE.ExtrudeGeometry: vec does not exist\" );\n\n\t\treturn vec.clone().multiplyScalar( size ).add( pt );\n\n\t}\n\n\tvar b, bs, t, z,\n\t\tvert, vlen = vertices.length,\n\t\tface, flen = faces.length;\n\n\n\t// Find directions for point movement\n\n\n\tfunction getBevelVec( inPt, inPrev, inNext ) {\n\n\t\t// computes for inPt the corresponding point inPt' on a new contour\n\t\t//   shifted by 1 unit (length of normalized vector) to the left\n\t\t// if we walk along contour clockwise, this new contour is outside the old one\n\t\t//\n\t\t// inPt' is the intersection of the two lines parallel to the two\n\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\n\n\t\tvar v_trans_x, v_trans_y, shrink_by = 1;\t\t// resulting translation vector for inPt\n\n\t\t// good reading for geometry algorithms (here: line-line intersection)\n\t\t// http://geomalgorithms.com/a05-_intersect-1.html\n\n\t\tvar v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;\n\t\tvar v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;\n\n\t\tvar v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\n\n\t\t// check for collinear edges\n\t\tvar collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\n\n\t\t\t// not collinear\n\n\t\t\t// length of vectors for normalizing\n\n\t\t\tvar v_prev_len = Math.sqrt( v_prev_lensq );\n\t\t\tvar v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\n\n\t\t\t// shift adjacent points by unit vectors to the left\n\n\t\t\tvar ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\n\t\t\tvar ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\n\n\t\t\tvar ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\n\t\t\tvar ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\n\n\t\t\t// scaling factor for v_prev to intersection point\n\n\t\t\tvar sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\n\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /\n\t\t\t\t\t  ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\t// vector from inPt to intersection point\n\n\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\n\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\n\n\t\t\t// Don't normalize!, otherwise sharp corners become ugly\n\t\t\t//  but prevent crazy spikes\n\t\t\tvar v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\n\t\t\tif ( v_trans_lensq <= 2 ) {\n\n\t\t\t\treturn\tnew THREE.Vector2( v_trans_x, v_trans_y );\n\n\t\t\t} else {\n\n\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// handle special case of collinear edges\n\n\t\t\tvar direction_eq = false;\t\t// assumes: opposite\n\t\t\tif ( v_prev_x > Number.EPSILON ) {\n\n\t\t\t\tif ( v_next_x > Number.EPSILON ) {\n\n\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( v_prev_x < - Number.EPSILON ) {\n\n\t\t\t\t\tif ( v_next_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\n\n\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( direction_eq ) {\n\n\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\n\t\t\t\tv_trans_x = - v_prev_y;\n\t\t\t\tv_trans_y =  v_prev_x;\n\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\n\n\t\t\t} else {\n\n\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\n\t\t\t\tv_trans_x = v_prev_x;\n\t\t\t\tv_trans_y = v_prev_y;\n\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn\tnew THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\n\n\t}\n\n\n\tvar contourMovements = [];\n\n\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\tif ( j === il ) j = 0;\n\t\tif ( k === il ) k = 0;\n\n\t\t//  (j)---(i)---(k)\n\t\t// console.log('i,j,k', i, j , k)\n\n\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\n\n\t}\n\n\tvar holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();\n\n\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\tahole = holes[ h ];\n\n\t\toneHoleMovements = [];\n\n\t\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\tif ( j === il ) j = 0;\n\t\t\tif ( k === il ) k = 0;\n\n\t\t\t//  (j)---(i)---(k)\n\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\n\n\t\t}\n\n\t\tholesMovements.push( oneHoleMovements );\n\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\n\n\t}\n\n\n\t// Loop bevelSegments, 1 for the front, 1 for the back\n\n\tfor ( b = 0; b < bevelSegments; b ++ ) {\n\n\t\t//for ( b = bevelSegments; b > 0; b -- ) {\n\n\t\tt = b / bevelSegments;\n\t\tz = bevelThickness * ( 1 - t );\n\n\t\t//z = bevelThickness * t;\n\t\tbs = bevelSize * ( Math.sin ( t * Math.PI / 2 ) ); // curved\n\t\t//bs = bevelSize * t; // linear\n\n\t\t// contract shape\n\n\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\n\t\t\tv( vert.x, vert.y,  - z );\n\n\t\t}\n\n\t\t// expand holes\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\tv( vert.x, vert.y,  - z );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tbs = bevelSize;\n\n\t// Back facing vertices\n\n\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\tif ( ! extrudeByPath ) {\n\n\t\t\tv( vert.x, vert.y, 0 );\n\n\t\t} else {\n\n\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\n\t\t\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\n\t\t\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\n\n\t\t\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\n\n\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t}\n\n\t}\n\n\t// Add stepped vertices...\n\t// Including front facing vertices\n\n\tvar s;\n\n\tfor ( s = 1; s <= steps; s ++ ) {\n\n\t\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\tv( vert.x, vert.y, amount / steps * s );\n\n\t\t\t} else {\n\n\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\n\t\t\t\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\n\t\t\t\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\n\n\t\t\t\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\n\n\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\t// Add bevel segments planes\n\n\t//for ( b = 1; b <= bevelSegments; b ++ ) {\n\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\n\n\t\tt = b / bevelSegments;\n\t\tz = bevelThickness * ( 1 - t );\n\t\t//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );\n\t\tbs = bevelSize * Math.sin ( t * Math.PI / 2 );\n\n\t\t// contract shape\n\n\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\t\tv( vert.x, vert.y,  amount + z );\n\n\t\t}\n\n\t\t// expand holes\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\tv( vert.x, vert.y,  amount + z );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/* Faces */\n\n\t// Top and bottom faces\n\n\tbuildLidFaces();\n\n\t// Sides faces\n\n\tbuildSideFaces();\n\n\n\t/////  Internal functions\n\n\tfunction buildLidFaces() {\n\n\t\tif ( bevelEnabled ) {\n\n\t\t\tvar layer = 0; // steps + 1\n\t\t\tvar offset = vlen * layer;\n\n\t\t\t// Bottom faces\n\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\tface = faces[ i ];\n\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\n\n\t\t\t}\n\n\t\t\tlayer = steps + bevelSegments * 2;\n\t\t\toffset = vlen * layer;\n\n\t\t\t// Top faces\n\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\tface = faces[ i ];\n\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// Bottom faces\n\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\tface = faces[ i ];\n\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\n\n\t\t\t}\n\n\t\t\t// Top faces\n\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\tface = faces[ i ];\n\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// Create faces for the z-sides of the shape\n\n\tfunction buildSideFaces() {\n\n\t\tvar layeroffset = 0;\n\t\tsidewalls( contour, layeroffset );\n\t\tlayeroffset += contour.length;\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\t\t\tsidewalls( ahole, layeroffset );\n\n\t\t\t//, true\n\t\t\tlayeroffset += ahole.length;\n\n\t\t}\n\n\t}\n\n\tfunction sidewalls( contour, layeroffset ) {\n\n\t\tvar j, k;\n\t\ti = contour.length;\n\n\t\twhile ( -- i >= 0 ) {\n\n\t\t\tj = i;\n\t\t\tk = i - 1;\n\t\t\tif ( k < 0 ) k = contour.length - 1;\n\n\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\n\n\t\t\tvar s = 0, sl = steps  + bevelSegments * 2;\n\n\t\t\tfor ( s = 0; s < sl; s ++ ) {\n\n\t\t\t\tvar slen1 = vlen * s;\n\t\t\t\tvar slen2 = vlen * ( s + 1 );\n\n\t\t\t\tvar a = layeroffset + j + slen1,\n\t\t\t\t\tb = layeroffset + k + slen1,\n\t\t\t\t\tc = layeroffset + k + slen2,\n\t\t\t\t\td = layeroffset + j + slen2;\n\n\t\t\t\tf4( a, b, c, d, contour, s, sl, j, k );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\tfunction v( x, y, z ) {\n\n\t\tscope.vertices.push( new THREE.Vector3( x, y, z ) );\n\n\t}\n\n\tfunction f3( a, b, c ) {\n\n\t\ta += shapesOffset;\n\t\tb += shapesOffset;\n\t\tc += shapesOffset;\n\n\t\tscope.faces.push( new THREE.Face3( a, b, c, null, null, 0 ) );\n\n\t\tvar uvs = uvgen.generateTopUV( scope, a, b, c );\n\n\t\tscope.faceVertexUvs[ 0 ].push( uvs );\n\n\t}\n\n\tfunction f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {\n\n\t\ta += shapesOffset;\n\t\tb += shapesOffset;\n\t\tc += shapesOffset;\n\t\td += shapesOffset;\n\n\t\tscope.faces.push( new THREE.Face3( a, b, d, null, null, 1 ) );\n\t\tscope.faces.push( new THREE.Face3( b, c, d, null, null, 1 ) );\n\n\t\tvar uvs = uvgen.generateSideWallUV( scope, a, b, c, d );\n\n\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );\n\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );\n\n\t}\n\n};\n\nTHREE.ExtrudeGeometry.WorldUVGenerator = {\n\n\tgenerateTopUV: function ( geometry, indexA, indexB, indexC ) {\n\n\t\tvar vertices = geometry.vertices;\n\n\t\tvar a = vertices[ indexA ];\n\t\tvar b = vertices[ indexB ];\n\t\tvar c = vertices[ indexC ];\n\n\t\treturn [\n\t\t\tnew THREE.Vector2( a.x, a.y ),\n\t\t\tnew THREE.Vector2( b.x, b.y ),\n\t\t\tnew THREE.Vector2( c.x, c.y )\n\t\t];\n\n\t},\n\n\tgenerateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {\n\n\t\tvar vertices = geometry.vertices;\n\n\t\tvar a = vertices[ indexA ];\n\t\tvar b = vertices[ indexB ];\n\t\tvar c = vertices[ indexC ];\n\t\tvar d = vertices[ indexD ];\n\n\t\tif ( Math.abs( a.y - b.y ) < 0.01 ) {\n\n\t\t\treturn [\n\t\t\t\tnew THREE.Vector2( a.x, 1 - a.z ),\n\t\t\t\tnew THREE.Vector2( b.x, 1 - b.z ),\n\t\t\t\tnew THREE.Vector2( c.x, 1 - c.z ),\n\t\t\t\tnew THREE.Vector2( d.x, 1 - d.z )\n\t\t\t];\n\n\t\t} else {\n\n\t\t\treturn [\n\t\t\t\tnew THREE.Vector2( a.y, 1 - a.z ),\n\t\t\t\tnew THREE.Vector2( b.y, 1 - b.z ),\n\t\t\t\tnew THREE.Vector2( c.y, 1 - c.z ),\n\t\t\t\tnew THREE.Vector2( d.y, 1 - d.z )\n\t\t\t];\n\n\t\t}\n\n\t}\n};\n\n// File:src/extras/geometries/ShapeGeometry.js\n\n/**\n * @author jonobr1 / http://jonobr1.com\n *\n * Creates a one-sided polygonal geometry from a path shape. Similar to\n * ExtrudeGeometry.\n *\n * parameters = {\n *\n *\tcurveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.\n *\n *\tmaterial: <int> // material index for front and back faces\n *\tuvGenerator: <Object> // object that provides UV generator functions\n *\n * }\n **/\n\nTHREE.ShapeGeometry = function ( shapes, options ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'ShapeGeometry';\n\n\tif ( Array.isArray( shapes ) === false ) shapes = [ shapes ];\n\n\tthis.addShapeList( shapes, options );\n\n\tthis.computeFaceNormals();\n\n};\n\nTHREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;\n\n/**\n * Add an array of shapes to THREE.ShapeGeometry.\n */\nTHREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {\n\n\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\tthis.addShape( shapes[ i ], options );\n\n\t}\n\n\treturn this;\n\n};\n\n/**\n * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.\n */\nTHREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {\n\n\tif ( options === undefined ) options = {};\n\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\n\tvar material = options.material;\n\tvar uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;\n\n\t//\n\n\tvar i, l, hole;\n\n\tvar shapesOffset = this.vertices.length;\n\tvar shapePoints = shape.extractPoints( curveSegments );\n\n\tvar vertices = shapePoints.shape;\n\tvar holes = shapePoints.holes;\n\n\tvar reverse = ! THREE.ShapeUtils.isClockWise( vertices );\n\n\tif ( reverse ) {\n\n\t\tvertices = vertices.reverse();\n\n\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe...\n\n\t\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\n\n\t\t\thole = holes[ i ];\n\n\t\t\tif ( THREE.ShapeUtils.isClockWise( hole ) ) {\n\n\t\t\t\tholes[ i ] = hole.reverse();\n\n\t\t\t}\n\n\t\t}\n\n\t\treverse = false;\n\n\t}\n\n\tvar faces = THREE.ShapeUtils.triangulateShape( vertices, holes );\n\n\t// Vertices\n\n\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\n\n\t\thole = holes[ i ];\n\t\tvertices = vertices.concat( hole );\n\n\t}\n\n\t//\n\n\tvar vert, vlen = vertices.length;\n\tvar face, flen = faces.length;\n\n\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\tvert = vertices[ i ];\n\n\t\tthis.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );\n\n\t}\n\n\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\tface = faces[ i ];\n\n\t\tvar a = face[ 0 ] + shapesOffset;\n\t\tvar b = face[ 1 ] + shapesOffset;\n\t\tvar c = face[ 2 ] + shapesOffset;\n\n\t\tthis.faces.push( new THREE.Face3( a, b, c, null, null, material ) );\n\t\tthis.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );\n\n\t}\n\n};\n\n// File:src/extras/geometries/LatheBufferGeometry.js\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n */\n\n // points - to create a closed torus, one must use a set of points\n //    like so: [ a, b, c, d, a ], see first is the same as last.\n // segments - the number of circumference segments to create\n // phiStart - the starting radian\n // phiLength - the radian (0 to 2PI) range of the lathed section\n //    2PI is a closed lathe, less than 2PI is a portion.\n\nTHREE.LatheBufferGeometry = function ( points, segments, phiStart, phiLength ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'LatheBufferGeometry';\n\n\tthis.parameters = {\n\t\tpoints: points,\n\t\tsegments: segments,\n\t\tphiStart: phiStart,\n\t\tphiLength: phiLength\n\t};\n\n\tsegments = Math.floor( segments ) || 12;\n\tphiStart = phiStart || 0;\n\tphiLength = phiLength || Math.PI * 2;\n\n\t// clamp phiLength so it's in range of [ 0, 2PI ]\n\tphiLength = THREE.Math.clamp( phiLength, 0, Math.PI * 2 );\n\n\t// these are used to calculate buffer length\n\tvar vertexCount = ( segments + 1 ) * points.length;\n\tvar indexCount = segments * points.length * 2 * 3;\n\n\t// buffers\n\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t// helper variables\n\tvar index = 0, indexOffset = 0, base;\n\tvar inversePointLength = 1.0 / ( points.length - 1 );\n\tvar inverseSegments = 1.0 / segments;\n\tvar vertex = new THREE.Vector3();\n\tvar uv = new THREE.Vector2();\n\tvar i, j;\n\n\t// generate vertices and uvs\n\n\tfor ( i = 0; i <= segments; i ++ ) {\n\n\t\tvar phi = phiStart + i * inverseSegments * phiLength;\n\n\t\tvar sin = Math.sin( phi );\n\t\tvar cos = Math.cos( phi );\n\n\t\tfor ( j = 0; j <= ( points.length - 1 ); j ++ ) {\n\n\t\t\t// vertex\n\t\t\tvertex.x = points[ j ].x * sin;\n\t\t\tvertex.y = points[ j ].y;\n\t\t\tvertex.z = points[ j ].x * cos;\n\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t// uv\n\t\t\tuv.x = i / segments;\n\t\t\tuv.y = j / ( points.length - 1 );\n\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t// increase index\n\t\t\tindex ++;\n\n\t\t}\n\n\t}\n\n\t// generate indices\n\n\tfor ( i = 0; i < segments; i ++ ) {\n\n\t\tfor ( j = 0; j < ( points.length - 1 ); j ++ ) {\n\n\t\t\tbase = j + i * points.length;\n\n\t\t\t// indices\n\t\t\tvar a = base;\n\t\t\tvar b = base + points.length;\n\t\t\tvar c = base + points.length + 1;\n\t\t\tvar d = base + 1;\n\n\t\t\t// face one\n\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t\t// face two\n\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', vertices );\n\tthis.addAttribute( 'uv', uvs );\n\n\t// generate normals\n\n\tthis.computeVertexNormals();\n\n\t// if the geometry is closed, we need to average the normals along the seam.\n\t// because the corresponding vertices are identical (but still have different UVs).\n\n\tif( phiLength === Math.PI * 2 ) {\n\n\t\tvar normals = this.attributes.normal.array;\n\t\tvar n1 = new THREE.Vector3();\n\t\tvar n2 = new THREE.Vector3();\n\t\tvar n = new THREE.Vector3();\n\n\t\t// this is the buffer offset for the last line of vertices\n\t\tbase = segments * points.length * 3;\n\n\t\tfor( i = 0, j = 0; i < points.length; i ++, j += 3 ) {\n\n\t\t\t// select the normal of the vertex in the first line\n\t\t\tn1.x = normals[ j + 0 ];\n\t\t\tn1.y = normals[ j + 1 ];\n\t\t\tn1.z = normals[ j + 2 ];\n\n\t\t\t// select the normal of the vertex in the last line\n\t\t\tn2.x = normals[ base + j + 0 ];\n\t\t\tn2.y = normals[ base + j + 1 ];\n\t\t\tn2.z = normals[ base + j + 2 ];\n\n\t\t\t// average normals\n\t\t\tn.addVectors( n1, n2 ).normalize();\n\n\t\t\t// assign the new values to both normals\n\t\t\tnormals[ j + 0 ] = normals[ base + j + 0 ] = n.x;\n\t\t\tnormals[ j + 1 ] = normals[ base + j + 1 ] = n.y;\n\t\t\tnormals[ j + 2 ] = normals[ base + j + 2 ] = n.z;\n\n\t\t} // next row\n\n\t}\n\n};\n\nTHREE.LatheBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.LatheBufferGeometry.prototype.constructor = THREE.LatheBufferGeometry;\n\n// File:src/extras/geometries/LatheGeometry.js\n\n/**\n * @author astrodud / http://astrodud.isgreat.org/\n * @author zz85 / https://github.com/zz85\n * @author bhouston / http://clara.io\n */\n\n// points - to create a closed torus, one must use a set of points\n//    like so: [ a, b, c, d, a ], see first is the same as last.\n// segments - the number of circumference segments to create\n// phiStart - the starting radian\n// phiLength - the radian (0 to 2PI) range of the lathed section\n//    2PI is a closed lathe, less than 2PI is a portion.\n\nTHREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'LatheGeometry';\n\n\tthis.parameters = {\n\t\tpoints: points,\n\t\tsegments: segments,\n\t\tphiStart: phiStart,\n\t\tphiLength: phiLength\n\t};\n\n\tthis.fromBufferGeometry( new THREE.LatheBufferGeometry( points, segments, phiStart, phiLength ) );\n\tthis.mergeVertices();\n\n};\n\nTHREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;\n\n// File:src/extras/geometries/PlaneGeometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\n */\n\nTHREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'PlaneGeometry';\n\n\tthis.parameters = {\n\t\twidth: width,\n\t\theight: height,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments\n\t};\n\n\tthis.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );\n\n};\n\nTHREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;\n\n// File:src/extras/geometries/PlaneBufferGeometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\n */\n\nTHREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'PlaneBufferGeometry';\n\n\tthis.parameters = {\n\t\twidth: width,\n\t\theight: height,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments\n\t};\n\n\tvar width_half = width / 2;\n\tvar height_half = height / 2;\n\n\tvar gridX = Math.floor( widthSegments ) || 1;\n\tvar gridY = Math.floor( heightSegments ) || 1;\n\n\tvar gridX1 = gridX + 1;\n\tvar gridY1 = gridY + 1;\n\n\tvar segment_width = width / gridX;\n\tvar segment_height = height / gridY;\n\n\tvar vertices = new Float32Array( gridX1 * gridY1 * 3 );\n\tvar normals = new Float32Array( gridX1 * gridY1 * 3 );\n\tvar uvs = new Float32Array( gridX1 * gridY1 * 2 );\n\n\tvar offset = 0;\n\tvar offset2 = 0;\n\n\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\n\n\t\tvar y = iy * segment_height - height_half;\n\n\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\tvar x = ix * segment_width - width_half;\n\n\t\t\tvertices[ offset ] = x;\n\t\t\tvertices[ offset + 1 ] = - y;\n\n\t\t\tnormals[ offset + 2 ] = 1;\n\n\t\t\tuvs[ offset2 ] = ix / gridX;\n\t\t\tuvs[ offset2 + 1 ] = 1 - ( iy / gridY );\n\n\t\t\toffset += 3;\n\t\t\toffset2 += 2;\n\n\t\t}\n\n\t}\n\n\toffset = 0;\n\n\tvar indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );\n\n\tfor ( var iy = 0; iy < gridY; iy ++ ) {\n\n\t\tfor ( var ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\tvar a = ix + gridX1 * iy;\n\t\t\tvar b = ix + gridX1 * ( iy + 1 );\n\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\tvar d = ( ix + 1 ) + gridX1 * iy;\n\n\t\t\tindices[ offset ] = a;\n\t\t\tindices[ offset + 1 ] = b;\n\t\t\tindices[ offset + 2 ] = d;\n\n\t\t\tindices[ offset + 3 ] = b;\n\t\t\tindices[ offset + 4 ] = c;\n\t\t\tindices[ offset + 5 ] = d;\n\n\t\t\toffset += 6;\n\n\t\t}\n\n\t}\n\n\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ) );\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\n\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\n\n};\n\nTHREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;\n\n// File:src/extras/geometries/RingBufferGeometry.js\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nTHREE.RingBufferGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'RingBufferGeometry';\n\n\tthis.parameters = {\n\t\tinnerRadius: innerRadius,\n\t\touterRadius: outerRadius,\n\t\tthetaSegments: thetaSegments,\n\t\tphiSegments: phiSegments,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tinnerRadius = innerRadius || 20;\n\touterRadius = outerRadius || 50;\n\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\n\tthetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\n\tphiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;\n\n\t// these are used to calculate buffer length\n\tvar vertexCount = ( thetaSegments + 1 ) * ( phiSegments + 1 );\n\tvar indexCount = thetaSegments * phiSegments * 2 * 3;\n\n\t// buffers\n\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t// some helper variables\n\tvar index = 0, indexOffset = 0, segment;\n\tvar radius = innerRadius;\n\tvar radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\n\tvar vertex = new THREE.Vector3();\n\tvar uv = new THREE.Vector2();\n\tvar j, i;\n\n\t// generate vertices, normals and uvs\n\n\t// values are generate from the inside of the ring to the outside\n\n\tfor ( j = 0; j <= phiSegments; j ++ ) {\n\n\t\tfor ( i = 0; i <= thetaSegments; i ++ ) {\n\n\t\t\tsegment = thetaStart + i / thetaSegments * thetaLength;\n\n\t\t\t// vertex\n\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\tvertex.y = radius * Math.sin( segment );\n\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t// normal\n\t\t\tnormals.setXYZ( index, 0, 0, 1 );\n\n\t\t\t// uv\n\t\t\tuv.x = ( vertex.x / outerRadius + 1 ) / 2;\n\t\t\tuv.y = ( vertex.y / outerRadius + 1 ) / 2;\n\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t// increase index\n\t\t\tindex++;\n\n\t\t}\n\n\t\t// increase the radius for next row of vertices\n\t\tradius += radiusStep;\n\n\t}\n\n\t// generate indices\n\n\tfor ( j = 0; j < phiSegments; j ++ ) {\n\n\t\tvar thetaSegmentLevel = j * ( thetaSegments + 1 );\n\n\t\tfor ( i = 0; i < thetaSegments; i ++ ) {\n\n\t\t\tsegment = i + thetaSegmentLevel;\n\n\t\t\t// indices\n\t\t\tvar a = segment;\n\t\t\tvar b = segment + thetaSegments + 1;\n\t\t\tvar c = segment + thetaSegments + 2;\n\t\t\tvar d = segment + 1;\n\n\t\t\t// face one\n\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\n\t\t\t// face two\n\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', vertices );\n\tthis.addAttribute( 'normal', normals );\n\tthis.addAttribute( 'uv', uvs );\n\n};\n\nTHREE.RingBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.RingBufferGeometry.prototype.constructor = THREE.RingBufferGeometry;\n\n// File:src/extras/geometries/RingGeometry.js\n\n/**\n * @author Kaleb Murphy\n */\n\nTHREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'RingGeometry';\n\n\tthis.parameters = {\n\t\tinnerRadius: innerRadius,\n\t\touterRadius: outerRadius,\n\t\tthetaSegments: thetaSegments,\n\t\tphiSegments: phiSegments,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tthis.fromBufferGeometry( new THREE.RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );\n\n};\n\nTHREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.RingGeometry.prototype.constructor = THREE.RingGeometry;\n\n// File:src/extras/geometries/SphereGeometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'SphereGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments,\n\t\tphiStart: phiStart,\n\t\tphiLength: phiLength,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tthis.fromBufferGeometry( new THREE.SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );\n\n};\n\nTHREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;\n\n// File:src/extras/geometries/SphereBufferGeometry.js\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n * based on THREE.SphereGeometry\n */\n\nTHREE.SphereBufferGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'SphereBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments,\n\t\tphiStart: phiStart,\n\t\tphiLength: phiLength,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tradius = radius || 50;\n\n\twidthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\n\theightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\n\n\tphiStart = phiStart !== undefined ? phiStart : 0;\n\tphiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\n\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\n\n\tvar thetaEnd = thetaStart + thetaLength;\n\n\tvar vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );\n\n\tvar positions = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\tvar index = 0, vertices = [], normal = new THREE.Vector3();\n\n\tfor ( var y = 0; y <= heightSegments; y ++ ) {\n\n\t\tvar verticesRow = [];\n\n\t\tvar v = y / heightSegments;\n\n\t\tfor ( var x = 0; x <= widthSegments; x ++ ) {\n\n\t\t\tvar u = x / widthSegments;\n\n\t\t\tvar px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\t\t\tvar py = radius * Math.cos( thetaStart + v * thetaLength );\n\t\t\tvar pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\n\t\t\tnormal.set( px, py, pz ).normalize();\n\n\t\t\tpositions.setXYZ( index, px, py, pz );\n\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\t\t\tuvs.setXY( index, u, 1 - v );\n\n\t\t\tverticesRow.push( index );\n\n\t\t\tindex ++;\n\n\t\t}\n\n\t\tvertices.push( verticesRow );\n\n\t}\n\n\tvar indices = [];\n\n\tfor ( var y = 0; y < heightSegments; y ++ ) {\n\n\t\tfor ( var x = 0; x < widthSegments; x ++ ) {\n\n\t\t\tvar v1 = vertices[ y ][ x + 1 ];\n\t\t\tvar v2 = vertices[ y ][ x ];\n\t\t\tvar v3 = vertices[ y + 1 ][ x ];\n\t\t\tvar v4 = vertices[ y + 1 ][ x + 1 ];\n\n\t\t\tif ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );\n\t\t\tif ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );\n\n\t\t}\n\n\t}\n\n\tthis.setIndex( new ( positions.count > 65535 ? THREE.Uint32Attribute : THREE.Uint16Attribute )( indices, 1 ) );\n\tthis.addAttribute( 'position', positions );\n\tthis.addAttribute( 'normal', normals );\n\tthis.addAttribute( 'uv', uvs );\n\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\n\n};\n\nTHREE.SphereBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry;\n\n// File:src/extras/geometries/TextGeometry.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author alteredq / http://alteredqualia.com/\n *\n * Text = 3D Text\n *\n * parameters = {\n *  font: <THREE.Font>, // font\n *\n *  size: <float>, // size of the text\n *  height: <float>, // thickness to extrude text\n *  curveSegments: <int>, // number of points on the curves\n *\n *  bevelEnabled: <bool>, // turn on bevel\n *  bevelThickness: <float>, // how deep into text bevel goes\n *  bevelSize: <float> // how far from text outline is bevel\n * }\n */\n\nTHREE.TextGeometry = function ( text, parameters ) {\n\n\tparameters = parameters || {};\n\n\tvar font = parameters.font;\n\n\tif ( font instanceof THREE.Font === false ) {\n\n\t\tconsole.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );\n\t\treturn new THREE.Geometry();\n\n\t}\n\n\tvar shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );\n\n\t// translate parameters to ExtrudeGeometry API\n\n\tparameters.amount = parameters.height !== undefined ? parameters.height : 50;\n\n\t// defaults\n\n\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\n\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\n\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\n\n\tTHREE.ExtrudeGeometry.call( this, shapes, parameters );\n\n\tthis.type = 'TextGeometry';\n\n};\n\nTHREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );\nTHREE.TextGeometry.prototype.constructor = THREE.TextGeometry;\n\n// File:src/extras/geometries/TorusBufferGeometry.js\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nTHREE.TorusBufferGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'TorusBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\ttube: tube,\n\t\tradialSegments: radialSegments,\n\t\ttubularSegments: tubularSegments,\n\t\tarc: arc\n\t};\n\n\tradius = radius || 100;\n\ttube = tube || 40;\n\tradialSegments = Math.floor( radialSegments ) || 8;\n\ttubularSegments = Math.floor( tubularSegments ) || 6;\n\tarc = arc || Math.PI * 2;\n\n\t// used to calculate buffer length\n\tvar vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );\n\tvar indexCount = radialSegments * tubularSegments * 2 * 3;\n\n\t// buffers\n\tvar indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );\n\tvar vertices = new Float32Array( vertexCount * 3 );\n\tvar normals = new Float32Array( vertexCount * 3 );\n\tvar uvs = new Float32Array( vertexCount * 2 );\n\n\t// offset variables\n\tvar vertexBufferOffset = 0;\n\tvar uvBufferOffset = 0;\n\tvar indexBufferOffset = 0;\n\n\t// helper variables\n\tvar center = new THREE.Vector3();\n\tvar vertex = new THREE.Vector3();\n\tvar normal = new THREE.Vector3();\n\n\tvar j, i;\n\n\t// generate vertices, normals and uvs\n\n\tfor ( j = 0; j <= radialSegments; j ++ ) {\n\n\t\tfor ( i = 0; i <= tubularSegments; i ++ ) {\n\n\t\t\tvar u = i / tubularSegments * arc;\n\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\n\t\t\t// vertex\n\t\t\tvertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\n\t\t\tvertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\n\t\t\tvertex.z = tube * Math.sin( v );\n\n\t\t\tvertices[ vertexBufferOffset ] = vertex.x;\n\t\t\tvertices[ vertexBufferOffset + 1 ] = vertex.y;\n\t\t\tvertices[ vertexBufferOffset + 2 ] = vertex.z;\n\n\t\t\t// this vector is used to calculate the normal\n\t\t\tcenter.x = radius * Math.cos( u );\n\t\t\tcenter.y = radius * Math.sin( u );\n\n\t\t\t// normal\n\t\t\tnormal.subVectors( vertex, center ).normalize();\n\n\t\t\tnormals[ vertexBufferOffset ] = normal.x;\n\t\t\tnormals[ vertexBufferOffset + 1 ] = normal.y;\n\t\t\tnormals[ vertexBufferOffset + 2 ] = normal.z;\n\n\t\t\t// uv\n\t\t\tuvs[ uvBufferOffset ] = i / tubularSegments;\n\t\t\tuvs[ uvBufferOffset + 1 ] = j / radialSegments;\n\n\t\t\t// update offsets\n\t\t\tvertexBufferOffset += 3;\n\t\t\tuvBufferOffset += 2;\n\n\t\t}\n\n\t}\n\n\t// generate indices\n\n\tfor ( j = 1; j <= radialSegments; j ++ ) {\n\n\t\tfor ( i = 1; i <= tubularSegments; i ++ ) {\n\n\t\t\t// indices\n\t\t\tvar a = ( tubularSegments + 1 ) * j + i - 1;\n\t\t\tvar b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\n\t\t\tvar c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\n\t\t\tvar d = ( tubularSegments + 1 ) * j + i;\n\n\t\t\t// face one\n\t\t\tindices[ indexBufferOffset ] = a;\n\t\t\tindices[ indexBufferOffset + 1 ] = b;\n\t\t\tindices[ indexBufferOffset + 2 ] = d;\n\n\t\t\t// face two\n\t\t\tindices[ indexBufferOffset + 3 ] = b;\n\t\t\tindices[ indexBufferOffset + 4 ] = c;\n\t\t\tindices[ indexBufferOffset + 5 ] = d;\n\n\t\t\t// update offset\n\t\t\tindexBufferOffset += 6;\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ) );\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\n\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\n\n};\n\nTHREE.TorusBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.TorusBufferGeometry.prototype.constructor = THREE.TorusBufferGeometry;\n\n// File:src/extras/geometries/TorusGeometry.js\n\n/**\n * @author oosmoxiecode\n * @author mrdoob / http://mrdoob.com/\n * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888\n */\n\nTHREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'TorusGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\ttube: tube,\n\t\tradialSegments: radialSegments,\n\t\ttubularSegments: tubularSegments,\n\t\tarc: arc\n\t};\n\n\tthis.fromBufferGeometry( new THREE.TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );\n\n};\n\nTHREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;\n\n// File:src/extras/geometries/TorusKnotBufferGeometry.js\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n *\n * see: http://www.blackpawn.com/texts/pqtorus/\n */\nTHREE.TorusKnotBufferGeometry = function ( radius, tube, tubularSegments, radialSegments, p, q ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'TorusKnotBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\ttube: tube,\n\t\ttubularSegments: tubularSegments,\n\t\tradialSegments: radialSegments,\n\t\tp: p,\n\t\tq: q\n\t};\n\n\tradius = radius || 100;\n\ttube = tube || 40;\n\ttubularSegments = Math.floor( tubularSegments ) || 64;\n\tradialSegments = Math.floor( radialSegments ) || 8;\n\tp = p || 2;\n\tq = q || 3;\n\n\t// used to calculate buffer length\n\tvar vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );\n\tvar indexCount = radialSegments * tubularSegments * 2 * 3;\n\n\t// buffers\n\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t// helper variables\n\tvar i, j, index = 0, indexOffset = 0;\n\n\tvar vertex = new THREE.Vector3();\n\tvar normal = new THREE.Vector3();\n\tvar uv = new THREE.Vector2();\n\n\tvar P1 = new THREE.Vector3();\n\tvar P2 = new THREE.Vector3();\n\n\tvar B = new THREE.Vector3();\n\tvar T = new THREE.Vector3();\n\tvar N = new THREE.Vector3();\n\n\t// generate vertices, normals and uvs\n\n\tfor ( i = 0; i <= tubularSegments; ++ i ) {\n\n\t\t// the radian \"u\" is used to calculate the position on the torus curve of the current tubular segement\n\n\t\tvar u = i / tubularSegments * p * Math.PI * 2;\n\n\t\t// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\n\t\t// these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\n\n\t\tcalculatePositionOnCurve( u, p, q, radius, P1 );\n\t\tcalculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\n\n\t\t// calculate orthonormal basis\n\n\t\tT.subVectors( P2, P1 );\n\t\tN.addVectors( P2, P1 );\n\t\tB.crossVectors( T, N );\n\t\tN.crossVectors( B, T );\n\n\t\t// normalize B, N. T can be ignored, we don't use it\n\n\t\tB.normalize();\n\t\tN.normalize();\n\n\t\tfor ( j = 0; j <= radialSegments; ++ j ) {\n\n\t\t\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\n\t\t\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\n\n\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\t\t\tvar cx = - tube * Math.cos( v );\n\t\t\tvar cy = tube * Math.sin( v );\n\n\t\t\t// now calculate the final vertex position.\n\t\t\t// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\n\n\t\t\tvertex.x = P1.x + ( cx * N.x + cy * B.x );\n\t\t\tvertex.y = P1.y + ( cx * N.y + cy * B.y );\n\t\t\tvertex.z = P1.z + ( cx * N.z + cy * B.z );\n\n\t\t\t// vertex\n\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\n\t\t\tnormal.subVectors( vertex, P1 ).normalize();\n\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\n\t\t\t// uv\n\t\t\tuv.x = i / tubularSegments;\n\t\t\tuv.y = j / radialSegments;\n\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t// increase index\n\t\t\tindex ++;\n\n\t\t}\n\n\t}\n\n\t// generate indices\n\n\tfor ( j = 1; j <= tubularSegments; j ++ ) {\n\n\t\tfor ( i = 1; i <= radialSegments; i ++ ) {\n\n\t\t\t// indices\n\t\t\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\tvar c = ( radialSegments + 1 ) * j + i;\n\t\t\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n\t\t\t// face one\n\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t\t// face two\n\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', vertices );\n\tthis.addAttribute( 'normal', normals );\n\tthis.addAttribute( 'uv', uvs );\n\n\t// this function calculates the current position on the torus curve\n\n\tfunction calculatePositionOnCurve( u, p, q, radius, position ) {\n\n\t\tvar cu = Math.cos( u );\n\t\tvar su = Math.sin( u );\n\t\tvar quOverP = q / p * u;\n\t\tvar cs = Math.cos( quOverP );\n\n\t\tposition.x = radius * ( 2 + cs ) * 0.5 * cu;\n\t\tposition.y = radius * ( 2 + cs ) * su * 0.5;\n\t\tposition.z = radius * Math.sin( quOverP ) * 0.5;\n\n\t}\n\n};\n\nTHREE.TorusKnotBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.TorusKnotBufferGeometry.prototype.constructor = THREE.TorusKnotBufferGeometry;\n\n// File:src/extras/geometries/TorusKnotGeometry.js\n\n/**\n * @author oosmoxiecode\n */\n\nTHREE.TorusKnotGeometry = function ( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'TorusKnotGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\ttube: tube,\n\t\ttubularSegments: tubularSegments,\n\t\tradialSegments: radialSegments,\n\t\tp: p,\n\t\tq: q\n\t};\n\n\tif( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );\n\n\tthis.fromBufferGeometry( new THREE.TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );\n\tthis.mergeVertices();\n\n};\n\nTHREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;\n\n// File:src/extras/geometries/TubeGeometry.js\n\n/**\n * @author WestLangley / https://github.com/WestLangley\n * @author zz85 / https://github.com/zz85\n * @author miningold / https://github.com/miningold\n * @author jonobr1 / https://github.com/jonobr1\n *\n * Modified from the TorusKnotGeometry by @oosmoxiecode\n *\n * Creates a tube which extrudes along a 3d spline\n *\n * Uses parallel transport frames as described in\n * http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n */\n\nTHREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed, taper ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'TubeGeometry';\n\n\tthis.parameters = {\n\t\tpath: path,\n\t\tsegments: segments,\n\t\tradius: radius,\n\t\tradialSegments: radialSegments,\n\t\tclosed: closed,\n\t\ttaper: taper\n\t};\n\n\tsegments = segments || 64;\n\tradius = radius || 1;\n\tradialSegments = radialSegments || 8;\n\tclosed = closed || false;\n\ttaper = taper || THREE.TubeGeometry.NoTaper;\n\n\tvar grid = [];\n\n\tvar scope = this,\n\n\t\ttangent,\n\t\tnormal,\n\t\tbinormal,\n\n\t\tnumpoints = segments + 1,\n\n\t\tu, v, r,\n\n\t\tcx, cy,\n\t\tpos, pos2 = new THREE.Vector3(),\n\t\ti, j,\n\t\tip, jp,\n\t\ta, b, c, d,\n\t\tuva, uvb, uvc, uvd;\n\n\tvar frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),\n\t\ttangents = frames.tangents,\n\t\tnormals = frames.normals,\n\t\tbinormals = frames.binormals;\n\n\t// proxy internals\n\tthis.tangents = tangents;\n\tthis.normals = normals;\n\tthis.binormals = binormals;\n\n\tfunction vert( x, y, z ) {\n\n\t\treturn scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;\n\n\t}\n\n\t// construct the grid\n\n\tfor ( i = 0; i < numpoints; i ++ ) {\n\n\t\tgrid[ i ] = [];\n\n\t\tu = i / ( numpoints - 1 );\n\n\t\tpos = path.getPointAt( u );\n\n\t\ttangent = tangents[ i ];\n\t\tnormal = normals[ i ];\n\t\tbinormal = binormals[ i ];\n\n\t\tr = radius * taper( u );\n\n\t\tfor ( j = 0; j < radialSegments; j ++ ) {\n\n\t\t\tv = j / radialSegments * 2 * Math.PI;\n\n\t\t\tcx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.\n\t\t\tcy = r * Math.sin( v );\n\n\t\t\tpos2.copy( pos );\n\t\t\tpos2.x += cx * normal.x + cy * binormal.x;\n\t\t\tpos2.y += cx * normal.y + cy * binormal.y;\n\t\t\tpos2.z += cx * normal.z + cy * binormal.z;\n\n\t\t\tgrid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );\n\n\t\t}\n\n\t}\n\n\n\t// construct the mesh\n\n\tfor ( i = 0; i < segments; i ++ ) {\n\n\t\tfor ( j = 0; j < radialSegments; j ++ ) {\n\n\t\t\tip = ( closed ) ? ( i + 1 ) % segments : i + 1;\n\t\t\tjp = ( j + 1 ) % radialSegments;\n\n\t\t\ta = grid[ i ][ j ];\t\t// *** NOT NECESSARILY PLANAR ! ***\n\t\t\tb = grid[ ip ][ j ];\n\t\t\tc = grid[ ip ][ jp ];\n\t\t\td = grid[ i ][ jp ];\n\n\t\t\tuva = new THREE.Vector2( i / segments, j / radialSegments );\n\t\t\tuvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );\n\t\t\tuvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );\n\t\t\tuvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );\n\n\t\t\tthis.faces.push( new THREE.Face3( a, b, d ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\n\n\t\t\tthis.faces.push( new THREE.Face3( b, c, d ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\n\n\t\t}\n\n\t}\n\n\tthis.computeFaceNormals();\n\tthis.computeVertexNormals();\n\n};\n\nTHREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;\n\nTHREE.TubeGeometry.NoTaper = function ( u ) {\n\n\treturn 1;\n\n};\n\nTHREE.TubeGeometry.SinusoidalTaper = function ( u ) {\n\n\treturn Math.sin( Math.PI * u );\n\n};\n\n// For computing of Frenet frames, exposing the tangents, normals and binormals the spline\nTHREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {\n\n\tvar\tnormal = new THREE.Vector3(),\n\n\t\ttangents = [],\n\t\tnormals = [],\n\t\tbinormals = [],\n\n\t\tvec = new THREE.Vector3(),\n\t\tmat = new THREE.Matrix4(),\n\n\t\tnumpoints = segments + 1,\n\t\ttheta,\n\t\tsmallest,\n\n\t\ttx, ty, tz,\n\t\ti, u;\n\n\n\t// expose internals\n\tthis.tangents = tangents;\n\tthis.normals = normals;\n\tthis.binormals = binormals;\n\n\t// compute the tangent vectors for each segment on the path\n\n\tfor ( i = 0; i < numpoints; i ++ ) {\n\n\t\tu = i / ( numpoints - 1 );\n\n\t\ttangents[ i ] = path.getTangentAt( u );\n\t\ttangents[ i ].normalize();\n\n\t}\n\n\tinitialNormal3();\n\n\t/*\n\tfunction initialNormal1(lastBinormal) {\n\t\t// fixed start binormal. Has dangers of 0 vectors\n\t\tnormals[ 0 ] = new THREE.Vector3();\n\t\tbinormals[ 0 ] = new THREE.Vector3();\n\t\tif (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );\n\t\tnormals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\n\t}\n\n\tfunction initialNormal2() {\n\n\t\t// This uses the Frenet-Serret formula for deriving binormal\n\t\tvar t2 = path.getTangentAt( epsilon );\n\n\t\tnormals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();\n\t\tbinormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );\n\n\t\tnormals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\n\n\t}\n\t*/\n\n\tfunction initialNormal3() {\n\n\t\t// select an initial normal vector perpendicular to the first tangent vector,\n\t\t// and in the direction of the smallest tangent xyz component\n\n\t\tnormals[ 0 ] = new THREE.Vector3();\n\t\tbinormals[ 0 ] = new THREE.Vector3();\n\t\tsmallest = Number.MAX_VALUE;\n\t\ttx = Math.abs( tangents[ 0 ].x );\n\t\tty = Math.abs( tangents[ 0 ].y );\n\t\ttz = Math.abs( tangents[ 0 ].z );\n\n\t\tif ( tx <= smallest ) {\n\n\t\t\tsmallest = tx;\n\t\t\tnormal.set( 1, 0, 0 );\n\n\t\t}\n\n\t\tif ( ty <= smallest ) {\n\n\t\t\tsmallest = ty;\n\t\t\tnormal.set( 0, 1, 0 );\n\n\t\t}\n\n\t\tif ( tz <= smallest ) {\n\n\t\t\tnormal.set( 0, 0, 1 );\n\n\t\t}\n\n\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\n\n\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\n\n\t}\n\n\n\t// compute the slowly-varying normal and binormal vectors for each segment on the path\n\n\tfor ( i = 1; i < numpoints; i ++ ) {\n\n\t\tnormals[ i ] = normals[ i - 1 ].clone();\n\n\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\n\n\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\n\n\t\tif ( vec.length() > Number.EPSILON ) {\n\n\t\t\tvec.normalize();\n\n\t\t\ttheta = Math.acos( THREE.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\n\n\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\n\n\t\t}\n\n\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t}\n\n\n\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n\tif ( closed ) {\n\n\t\ttheta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), - 1, 1 ) );\n\t\ttheta /= ( numpoints - 1 );\n\n\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {\n\n\t\t\ttheta = - theta;\n\n\t\t}\n\n\t\tfor ( i = 1; i < numpoints; i ++ ) {\n\n\t\t\t// twist a little...\n\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\n\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t}\n\n\t}\n\n};\n\n// File:src/extras/geometries/PolyhedronGeometry.js\n\n/**\n * @author clockworkgeek / https://github.com/clockworkgeek\n * @author timothypratley / https://github.com/timothypratley\n * @author WestLangley / http://github.com/WestLangley\n*/\n\nTHREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'PolyhedronGeometry';\n\n\tthis.parameters = {\n\t\tvertices: vertices,\n\t\tindices: indices,\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n\tradius = radius || 1;\n\tdetail = detail || 0;\n\n\tvar that = this;\n\n\tfor ( var i = 0, l = vertices.length; i < l; i += 3 ) {\n\n\t\tprepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );\n\n\t}\n\n\tvar p = this.vertices;\n\n\tvar faces = [];\n\n\tfor ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {\n\n\t\tvar v1 = p[ indices[ i ] ];\n\t\tvar v2 = p[ indices[ i + 1 ] ];\n\t\tvar v3 = p[ indices[ i + 2 ] ];\n\n\t\tfaces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );\n\n\t}\n\n\tvar centroid = new THREE.Vector3();\n\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\tsubdivide( faces[ i ], detail );\n\n\t}\n\n\n\t// Handle case when face straddles the seam\n\n\tfor ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {\n\n\t\tvar uvs = this.faceVertexUvs[ 0 ][ i ];\n\n\t\tvar x0 = uvs[ 0 ].x;\n\t\tvar x1 = uvs[ 1 ].x;\n\t\tvar x2 = uvs[ 2 ].x;\n\n\t\tvar max = Math.max( x0, x1, x2 );\n\t\tvar min = Math.min( x0, x1, x2 );\n\n\t\tif ( max > 0.9 && min < 0.1 ) {\n\n\t\t\t// 0.9 is somewhat arbitrary\n\n\t\t\tif ( x0 < 0.2 ) uvs[ 0 ].x += 1;\n\t\t\tif ( x1 < 0.2 ) uvs[ 1 ].x += 1;\n\t\t\tif ( x2 < 0.2 ) uvs[ 2 ].x += 1;\n\n\t\t}\n\n\t}\n\n\n\t// Apply radius\n\n\tfor ( var i = 0, l = this.vertices.length; i < l; i ++ ) {\n\n\t\tthis.vertices[ i ].multiplyScalar( radius );\n\n\t}\n\n\n\t// Merge vertices\n\n\tthis.mergeVertices();\n\n\tthis.computeFaceNormals();\n\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\n\n\n\t// Project vector onto sphere's surface\n\n\tfunction prepare( vector ) {\n\n\t\tvar vertex = vector.normalize().clone();\n\t\tvertex.index = that.vertices.push( vertex ) - 1;\n\n\t\t// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.\n\n\t\tvar u = azimuth( vector ) / 2 / Math.PI + 0.5;\n\t\tvar v = inclination( vector ) / Math.PI + 0.5;\n\t\tvertex.uv = new THREE.Vector2( u, 1 - v );\n\n\t\treturn vertex;\n\n\t}\n\n\n\t// Approximate a curved face with recursively sub-divided triangles.\n\n\tfunction make( v1, v2, v3 ) {\n\n\t\tvar face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );\n\t\tthat.faces.push( face );\n\n\t\tcentroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );\n\n\t\tvar azi = azimuth( centroid );\n\n\t\tthat.faceVertexUvs[ 0 ].push( [\n\t\t\tcorrectUV( v1.uv, v1, azi ),\n\t\t\tcorrectUV( v2.uv, v2, azi ),\n\t\t\tcorrectUV( v3.uv, v3, azi )\n\t\t] );\n\n\t}\n\n\n\t// Analytically subdivide a face to the required detail level.\n\n\tfunction subdivide( face, detail ) {\n\n\t\tvar cols = Math.pow( 2, detail );\n\t\tvar a = prepare( that.vertices[ face.a ] );\n\t\tvar b = prepare( that.vertices[ face.b ] );\n\t\tvar c = prepare( that.vertices[ face.c ] );\n\t\tvar v = [];\n\n\t\t// Construct all of the vertices for this subdivision.\n\n\t\tfor ( var i = 0 ; i <= cols; i ++ ) {\n\n\t\t\tv[ i ] = [];\n\n\t\t\tvar aj = prepare( a.clone().lerp( c, i / cols ) );\n\t\t\tvar bj = prepare( b.clone().lerp( c, i / cols ) );\n\t\t\tvar rows = cols - i;\n\n\t\t\tfor ( var j = 0; j <= rows; j ++ ) {\n\n\t\t\t\tif ( j === 0 && i === cols ) {\n\n\t\t\t\t\tv[ i ][ j ] = aj;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tv[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Construct all of the faces.\n\n\t\tfor ( var i = 0; i < cols ; i ++ ) {\n\n\t\t\tfor ( var j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\n\n\t\t\t\tvar k = Math.floor( j / 2 );\n\n\t\t\t\tif ( j % 2 === 0 ) {\n\n\t\t\t\t\tmake(\n\t\t\t\t\t\tv[ i ][ k + 1 ],\n\t\t\t\t\t\tv[ i + 1 ][ k ],\n\t\t\t\t\t\tv[ i ][ k ]\n\t\t\t\t\t);\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmake(\n\t\t\t\t\t\tv[ i ][ k + 1 ],\n\t\t\t\t\t\tv[ i + 1 ][ k + 1 ],\n\t\t\t\t\t\tv[ i + 1 ][ k ]\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\t// Angle around the Y axis, counter-clockwise when looking from above.\n\n\tfunction azimuth( vector ) {\n\n\t\treturn Math.atan2( vector.z, - vector.x );\n\n\t}\n\n\n\t// Angle above the XZ plane.\n\n\tfunction inclination( vector ) {\n\n\t\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\n\n\t}\n\n\n\t// Texture fixing helper. Spheres have some odd behaviours.\n\n\tfunction correctUV( uv, vector, azimuth ) {\n\n\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );\n\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );\n\t\treturn uv.clone();\n\n\t}\n\n\n};\n\nTHREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;\n\n// File:src/extras/geometries/DodecahedronGeometry.js\n\n/**\n * @author Abe Pazos / https://hamoid.com\n */\n\nTHREE.DodecahedronGeometry = function ( radius, detail ) {\n\n\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\tvar r = 1 / t;\n\n\tvar vertices = [\n\n\t\t// (±1, ±1, ±1)\n\t\t- 1, - 1, - 1,    - 1, - 1,  1,\n\t\t- 1,  1, - 1,    - 1,  1,  1,\n\t\t 1, - 1, - 1,     1, - 1,  1,\n\t\t 1,  1, - 1,     1,  1,  1,\n\n\t\t// (0, ±1/φ, ±φ)\n\t\t 0, - r, - t,     0, - r,  t,\n\t\t 0,  r, - t,     0,  r,  t,\n\n\t\t// (±1/φ, ±φ, 0)\n\t\t- r, - t,  0,    - r,  t,  0,\n\t\t r, - t,  0,     r,  t,  0,\n\n\t\t// (±φ, 0, ±1/φ)\n\t\t- t,  0, - r,     t,  0, - r,\n\t\t- t,  0,  r,     t,  0,  r\n\t];\n\n\tvar indices = [\n\t\t 3, 11,  7,      3,  7, 15,      3, 15, 13,\n\t\t 7, 19, 17,      7, 17,  6,      7,  6, 15,\n\t\t17,  4,  8,     17,  8, 10,     17, 10,  6,\n\t\t 8,  0, 16,      8, 16,  2,      8,  2, 10,\n\t\t 0, 12,  1,      0,  1, 18,      0, 18, 16,\n\t\t 6, 10,  2,      6,  2, 13,      6, 13, 15,\n\t\t 2, 16, 18,      2, 18,  3,      2,  3, 13,\n\t\t18,  1,  9,     18,  9, 11,     18, 11,  3,\n\t\t 4, 14, 12,      4, 12,  0,      4,  0,  8,\n\t\t11,  9,  5,     11,  5, 19,     11, 19,  7,\n\t\t19,  5, 14,     19, 14,  4,     19,  4, 17,\n\t\t 1, 12, 14,      1, 14,  5,      1,  5,  9\n\t];\n\n\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\n\n\tthis.type = 'DodecahedronGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n};\n\nTHREE.DodecahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\nTHREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;\n\n// File:src/extras/geometries/IcosahedronGeometry.js\n\n/**\n * @author timothypratley / https://github.com/timothypratley\n */\n\nTHREE.IcosahedronGeometry = function ( radius, detail ) {\n\n\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\n\tvar vertices = [\n\t\t- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,\n\t\t 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,\n\t\t t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1\n\t];\n\n\tvar indices = [\n\t\t 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,\n\t\t 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,\n\t\t 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,\n\t\t 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1\n\t];\n\n\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\n\n\tthis.type = 'IcosahedronGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n};\n\nTHREE.IcosahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\nTHREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;\n\n// File:src/extras/geometries/OctahedronGeometry.js\n\n/**\n * @author timothypratley / https://github.com/timothypratley\n */\n\nTHREE.OctahedronGeometry = function ( radius, detail ) {\n\n\tvar vertices = [\n\t\t1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1\n\t];\n\n\tvar indices = [\n\t\t0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2\n\t];\n\n\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\n\n\tthis.type = 'OctahedronGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n};\n\nTHREE.OctahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\nTHREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;\n\n// File:src/extras/geometries/TetrahedronGeometry.js\n\n/**\n * @author timothypratley / https://github.com/timothypratley\n */\n\nTHREE.TetrahedronGeometry = function ( radius, detail ) {\n\n\tvar vertices = [\n\t\t 1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1\n\t];\n\n\tvar indices = [\n\t\t 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1\n\t];\n\n\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\n\n\tthis.type = 'TetrahedronGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n};\n\nTHREE.TetrahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\nTHREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;\n\n// File:src/extras/geometries/ParametricGeometry.js\n\n/**\n * @author zz85 / https://github.com/zz85\n * Parametric Surfaces Geometry\n * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\n *\n * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );\n *\n */\n\nTHREE.ParametricGeometry = function ( func, slices, stacks ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'ParametricGeometry';\n\n\tthis.parameters = {\n\t\tfunc: func,\n\t\tslices: slices,\n\t\tstacks: stacks\n\t};\n\n\tvar verts = this.vertices;\n\tvar faces = this.faces;\n\tvar uvs = this.faceVertexUvs[ 0 ];\n\n\tvar i, j, p;\n\tvar u, v;\n\n\tvar sliceCount = slices + 1;\n\n\tfor ( i = 0; i <= stacks; i ++ ) {\n\n\t\tv = i / stacks;\n\n\t\tfor ( j = 0; j <= slices; j ++ ) {\n\n\t\t\tu = j / slices;\n\n\t\t\tp = func( u, v );\n\t\t\tverts.push( p );\n\n\t\t}\n\n\t}\n\n\tvar a, b, c, d;\n\tvar uva, uvb, uvc, uvd;\n\n\tfor ( i = 0; i < stacks; i ++ ) {\n\n\t\tfor ( j = 0; j < slices; j ++ ) {\n\n\t\t\ta = i * sliceCount + j;\n\t\t\tb = i * sliceCount + j + 1;\n\t\t\tc = ( i + 1 ) * sliceCount + j + 1;\n\t\t\td = ( i + 1 ) * sliceCount + j;\n\n\t\t\tuva = new THREE.Vector2( j / slices, i / stacks );\n\t\t\tuvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );\n\t\t\tuvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );\n\t\t\tuvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );\n\n\t\t\tfaces.push( new THREE.Face3( a, b, d ) );\n\t\t\tuvs.push( [ uva, uvb, uvd ] );\n\n\t\t\tfaces.push( new THREE.Face3( b, c, d ) );\n\t\t\tuvs.push( [ uvb.clone(), uvc, uvd.clone() ] );\n\n\t\t}\n\n\t}\n\n\t// console.log(this);\n\n\t// magic bullet\n\t// var diff = this.mergeVertices();\n\t// console.log('removed ', diff, ' vertices by merging');\n\n\tthis.computeFaceNormals();\n\tthis.computeVertexNormals();\n\n};\n\nTHREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;\n\n// File:src/extras/geometries/WireframeGeometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.WireframeGeometry = function ( geometry ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tvar edge = [ 0, 0 ], hash = {};\n\n\tfunction sortFunction( a, b ) {\n\n\t\treturn a - b;\n\n\t}\n\n\tvar keys = [ 'a', 'b', 'c' ];\n\n\tif ( geometry instanceof THREE.Geometry ) {\n\n\t\tvar vertices = geometry.vertices;\n\t\tvar faces = geometry.faces;\n\t\tvar numEdges = 0;\n\n\t\t// allocate maximal size\n\t\tvar edges = new Uint32Array( 6 * faces.length );\n\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\tedge[ 0 ] = face[ keys[ j ] ];\n\t\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\t\tedge.sort( sortFunction );\n\n\t\t\t\tvar key = edge.toString();\n\n\t\t\t\tif ( hash[ key ] === undefined ) {\n\n\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\n\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\n\t\t\t\t\thash[ key ] = true;\n\t\t\t\t\tnumEdges ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\n\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\n\n\t\t\tfor ( var j = 0; j < 2; j ++ ) {\n\n\t\t\t\tvar vertex = vertices[ edges [ 2 * i + j ] ];\n\n\t\t\t\tvar index = 6 * i + 3 * j;\n\t\t\t\tcoords[ index + 0 ] = vertex.x;\n\t\t\t\tcoords[ index + 1 ] = vertex.y;\n\t\t\t\tcoords[ index + 2 ] = vertex.z;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\n\n\t} else if ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\tif ( geometry.index !== null ) {\n\n\t\t\t// Indexed BufferGeometry\n\n\t\t\tvar indices = geometry.index.array;\n\t\t\tvar vertices = geometry.attributes.position;\n\t\t\tvar groups = geometry.groups;\n\t\t\tvar numEdges = 0;\n\n\t\t\tif ( groups.length === 0 ) {\n\n\t\t\t\tgeometry.addGroup( 0, indices.length );\n\n\t\t\t}\n\n\t\t\t// allocate maximal size\n\t\t\tvar edges = new Uint32Array( 2 * indices.length );\n\n\t\t\tfor ( var o = 0, ol = groups.length; o < ol; ++ o ) {\n\n\t\t\t\tvar group = groups[ o ];\n\n\t\t\t\tvar start = group.start;\n\t\t\t\tvar count = group.count;\n\n\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\n\n\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\tedge[ 0 ] = indices[ i + j ];\n\t\t\t\t\t\tedge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];\n\t\t\t\t\t\tedge.sort( sortFunction );\n\n\t\t\t\t\t\tvar key = edge.toString();\n\n\t\t\t\t\t\tif ( hash[ key ] === undefined ) {\n\n\t\t\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\n\t\t\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\n\t\t\t\t\t\t\thash[ key ] = true;\n\t\t\t\t\t\t\tnumEdges ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\n\t\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\n\n\t\t\t\tfor ( var j = 0; j < 2; j ++ ) {\n\n\t\t\t\t\tvar index = 6 * i + 3 * j;\n\t\t\t\t\tvar index2 = edges[ 2 * i + j ];\n\n\t\t\t\t\tcoords[ index + 0 ] = vertices.getX( index2 );\n\t\t\t\t\tcoords[ index + 1 ] = vertices.getY( index2 );\n\t\t\t\t\tcoords[ index + 2 ] = vertices.getZ( index2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\n\n\t\t} else {\n\n\t\t\t// non-indexed BufferGeometry\n\n\t\t\tvar vertices = geometry.attributes.position.array;\n\t\t\tvar numEdges = vertices.length / 3;\n\t\t\tvar numTris = numEdges / 3;\n\n\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\n\t\t\tfor ( var i = 0, l = numTris; i < l; i ++ ) {\n\n\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\tvar index = 18 * i + 6 * j;\n\n\t\t\t\t\tvar index1 = 9 * i + 3 * j;\n\t\t\t\t\tcoords[ index + 0 ] = vertices[ index1 ];\n\t\t\t\t\tcoords[ index + 1 ] = vertices[ index1 + 1 ];\n\t\t\t\t\tcoords[ index + 2 ] = vertices[ index1 + 2 ];\n\n\t\t\t\t\tvar index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );\n\t\t\t\t\tcoords[ index + 3 ] = vertices[ index2 ];\n\t\t\t\t\tcoords[ index + 4 ] = vertices[ index2 + 1 ];\n\t\t\t\t\tcoords[ index + 5 ] = vertices[ index2 + 2 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\n\n\t\t}\n\n\t}\n\n};\n\nTHREE.WireframeGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry;\n\n// File:src/extras/helpers/AxisHelper.js\n\n/**\n * @author sroucheray / http://sroucheray.org/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.AxisHelper = function ( size ) {\n\n\tsize = size || 1;\n\n\tvar vertices = new Float32Array( [\n\t\t0, 0, 0,  size, 0, 0,\n\t\t0, 0, 0,  0, size, 0,\n\t\t0, 0, 0,  0, 0, size\n\t] );\n\n\tvar colors = new Float32Array( [\n\t\t1, 0, 0,  1, 0.6, 0,\n\t\t0, 1, 0,  0.6, 1, 0,\n\t\t0, 0, 1,  0, 0.6, 1\n\t] );\n\n\tvar geometry = new THREE.BufferGeometry();\n\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\n\tgeometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );\n\n\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\n\n\tTHREE.LineSegments.call( this, geometry, material );\n\n};\n\nTHREE.AxisHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.AxisHelper.prototype.constructor = THREE.AxisHelper;\n\n// File:src/extras/helpers/ArrowHelper.js\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n * @author zz85 / http://github.com/zz85\n * @author bhouston / http://clara.io\n *\n * Creates an arrow for visualizing directions\n *\n * Parameters:\n *  dir - Vector3\n *  origin - Vector3\n *  length - Number\n *  color - color in hex value\n *  headLength - Number\n *  headWidth - Number\n */\n\nTHREE.ArrowHelper = ( function () {\n\n\tvar lineGeometry = new THREE.BufferGeometry();\n\tlineGeometry.addAttribute( 'position', new THREE.Float32Attribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );\n\n\tvar coneGeometry = new THREE.CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );\n\tconeGeometry.translate( 0, - 0.5, 0 );\n\n\treturn function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {\n\n\t\t// dir is assumed to be normalized\n\n\t\tTHREE.Object3D.call( this );\n\n\t\tif ( color === undefined ) color = 0xffff00;\n\t\tif ( length === undefined ) length = 1;\n\t\tif ( headLength === undefined ) headLength = 0.2 * length;\n\t\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\n\t\tthis.position.copy( origin );\n\n\t\tthis.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );\n\t\tthis.line.matrixAutoUpdate = false;\n\t\tthis.add( this.line );\n\n\t\tthis.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );\n\t\tthis.cone.matrixAutoUpdate = false;\n\t\tthis.add( this.cone );\n\n\t\tthis.setDirection( dir );\n\t\tthis.setLength( length, headLength, headWidth );\n\n\t};\n\n}() );\n\nTHREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;\n\nTHREE.ArrowHelper.prototype.setDirection = ( function () {\n\n\tvar axis = new THREE.Vector3();\n\tvar radians;\n\n\treturn function setDirection( dir ) {\n\n\t\t// dir is assumed to be normalized\n\n\t\tif ( dir.y > 0.99999 ) {\n\n\t\t\tthis.quaternion.set( 0, 0, 0, 1 );\n\n\t\t} else if ( dir.y < - 0.99999 ) {\n\n\t\t\tthis.quaternion.set( 1, 0, 0, 0 );\n\n\t\t} else {\n\n\t\t\taxis.set( dir.z, 0, - dir.x ).normalize();\n\n\t\t\tradians = Math.acos( dir.y );\n\n\t\t\tthis.quaternion.setFromAxisAngle( axis, radians );\n\n\t\t}\n\n\t};\n\n}() );\n\nTHREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {\n\n\tif ( headLength === undefined ) headLength = 0.2 * length;\n\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\n\tthis.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );\n\tthis.line.updateMatrix();\n\n\tthis.cone.scale.set( headWidth, headLength, headWidth );\n\tthis.cone.position.y = length;\n\tthis.cone.updateMatrix();\n\n};\n\nTHREE.ArrowHelper.prototype.setColor = function ( color ) {\n\n\tthis.line.material.color.copy( color );\n\tthis.cone.material.color.copy( color );\n\n};\n\n// File:src/extras/helpers/BoxHelper.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.BoxHelper = function ( object, color ) {\n\t\n\tif ( color === undefined ) color = 0xffff00;\n\n\tvar indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\n\tvar positions = new Float32Array( 8 * 3 );\n\n\tvar geometry = new THREE.BufferGeometry();\n\tgeometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );\n\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\n\n\tTHREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ) );\n\n\tif ( object !== undefined ) {\n\n\t\tthis.update( object );\n\n\t}\n\n};\n\nTHREE.BoxHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.BoxHelper.prototype.constructor = THREE.BoxHelper;\n\nTHREE.BoxHelper.prototype.update = ( function () {\n\n\tvar box = new THREE.Box3();\n\n\treturn function update( object ) {\n\n\t\tif ( object instanceof THREE.Box3 ) {\n\n\t\t\tbox.copy( object );\n\n\t\t} else {\n\n\t\t\tbox.setFromObject( object );\n\n\t\t}\n\n\t\tif ( box.isEmpty() ) return;\n\n\t\tvar min = box.min;\n\t\tvar max = box.max;\n\n\t\t/*\n\t\t  5____4\n\t\t1/___0/|\n\t\t| 6__|_7\n\t\t2/___3/\n\n\t\t0: max.x, max.y, max.z\n\t\t1: min.x, max.y, max.z\n\t\t2: min.x, min.y, max.z\n\t\t3: max.x, min.y, max.z\n\t\t4: max.x, max.y, min.z\n\t\t5: min.x, max.y, min.z\n\t\t6: min.x, min.y, min.z\n\t\t7: max.x, min.y, min.z\n\t\t*/\n\n\t\tvar position = this.geometry.attributes.position;\n\t\tvar array = position.array;\n\n\t\tarray[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;\n\t\tarray[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;\n\t\tarray[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;\n\t\tarray[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;\n\t\tarray[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;\n\t\tarray[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;\n\t\tarray[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;\n\t\tarray[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;\n\n\t\tposition.needsUpdate = true;\n\n\t\tthis.geometry.computeBoundingSphere();\n\n\t};\n\n} )();\n\n// File:src/extras/helpers/BoundingBoxHelper.js\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n */\n\n// a helper to show the world-axis-aligned bounding box for an object\n\nTHREE.BoundingBoxHelper = function ( object, hex ) {\n\n\tvar color = ( hex !== undefined ) ? hex : 0x888888;\n\n\tthis.object = object;\n\n\tthis.box = new THREE.Box3();\n\n\tTHREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );\n\n};\n\nTHREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );\nTHREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;\n\nTHREE.BoundingBoxHelper.prototype.update = function () {\n\n\tthis.box.setFromObject( this.object );\n\n\tthis.box.size( this.scale );\n\n\tthis.box.center( this.position );\n\n};\n\n// File:src/extras/helpers/CameraHelper.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n *\t- shows frustum, line of sight and up of the camera\n *\t- suitable for fast updates\n * \t- based on frustum visualization in lightgl.js shadowmap example\n *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\n */\n\nTHREE.CameraHelper = function ( camera ) {\n\n\tvar geometry = new THREE.Geometry();\n\tvar material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );\n\n\tvar pointMap = {};\n\n\t// colors\n\n\tvar hexFrustum = 0xffaa00;\n\tvar hexCone = 0xff0000;\n\tvar hexUp = 0x00aaff;\n\tvar hexTarget = 0xffffff;\n\tvar hexCross = 0x333333;\n\n\t// near\n\n\taddLine( \"n1\", \"n2\", hexFrustum );\n\taddLine( \"n2\", \"n4\", hexFrustum );\n\taddLine( \"n4\", \"n3\", hexFrustum );\n\taddLine( \"n3\", \"n1\", hexFrustum );\n\n\t// far\n\n\taddLine( \"f1\", \"f2\", hexFrustum );\n\taddLine( \"f2\", \"f4\", hexFrustum );\n\taddLine( \"f4\", \"f3\", hexFrustum );\n\taddLine( \"f3\", \"f1\", hexFrustum );\n\n\t// sides\n\n\taddLine( \"n1\", \"f1\", hexFrustum );\n\taddLine( \"n2\", \"f2\", hexFrustum );\n\taddLine( \"n3\", \"f3\", hexFrustum );\n\taddLine( \"n4\", \"f4\", hexFrustum );\n\n\t// cone\n\n\taddLine( \"p\", \"n1\", hexCone );\n\taddLine( \"p\", \"n2\", hexCone );\n\taddLine( \"p\", \"n3\", hexCone );\n\taddLine( \"p\", \"n4\", hexCone );\n\n\t// up\n\n\taddLine( \"u1\", \"u2\", hexUp );\n\taddLine( \"u2\", \"u3\", hexUp );\n\taddLine( \"u3\", \"u1\", hexUp );\n\n\t// target\n\n\taddLine( \"c\", \"t\", hexTarget );\n\taddLine( \"p\", \"c\", hexCross );\n\n\t// cross\n\n\taddLine( \"cn1\", \"cn2\", hexCross );\n\taddLine( \"cn3\", \"cn4\", hexCross );\n\n\taddLine( \"cf1\", \"cf2\", hexCross );\n\taddLine( \"cf3\", \"cf4\", hexCross );\n\n\tfunction addLine( a, b, hex ) {\n\n\t\taddPoint( a, hex );\n\t\taddPoint( b, hex );\n\n\t}\n\n\tfunction addPoint( id, hex ) {\n\n\t\tgeometry.vertices.push( new THREE.Vector3() );\n\t\tgeometry.colors.push( new THREE.Color( hex ) );\n\n\t\tif ( pointMap[ id ] === undefined ) {\n\n\t\t\tpointMap[ id ] = [];\n\n\t\t}\n\n\t\tpointMap[ id ].push( geometry.vertices.length - 1 );\n\n\t}\n\n\tTHREE.LineSegments.call( this, geometry, material );\n\n\tthis.camera = camera;\n\tif( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();\n\n\tthis.matrix = camera.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tthis.pointMap = pointMap;\n\n\tthis.update();\n\n};\n\nTHREE.CameraHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.CameraHelper.prototype.constructor = THREE.CameraHelper;\n\nTHREE.CameraHelper.prototype.update = function () {\n\n\tvar geometry, pointMap;\n\n\tvar vector = new THREE.Vector3();\n\tvar camera = new THREE.Camera();\n\n\tfunction setPoint( point, x, y, z ) {\n\n\t\tvector.set( x, y, z ).unproject( camera );\n\n\t\tvar points = pointMap[ point ];\n\n\t\tif ( points !== undefined ) {\n\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\t\tgeometry.vertices[ points[ i ] ].copy( vector );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn function update() {\n\n\t\tgeometry = this.geometry;\n\t\tpointMap = this.pointMap;\n\n\t\tvar w = 1, h = 1;\n\n\t\t// we need just camera projection matrix\n\t\t// world matrix must be identity\n\n\t\tcamera.projectionMatrix.copy( this.camera.projectionMatrix );\n\n\t\t// center / target\n\n\t\tsetPoint( \"c\", 0, 0, - 1 );\n\t\tsetPoint( \"t\", 0, 0,  1 );\n\n\t\t// near\n\n\t\tsetPoint( \"n1\", - w, - h, - 1 );\n\t\tsetPoint( \"n2\",   w, - h, - 1 );\n\t\tsetPoint( \"n3\", - w,   h, - 1 );\n\t\tsetPoint( \"n4\",   w,   h, - 1 );\n\n\t\t// far\n\n\t\tsetPoint( \"f1\", - w, - h, 1 );\n\t\tsetPoint( \"f2\",   w, - h, 1 );\n\t\tsetPoint( \"f3\", - w,   h, 1 );\n\t\tsetPoint( \"f4\",   w,   h, 1 );\n\n\t\t// up\n\n\t\tsetPoint( \"u1\",   w * 0.7, h * 1.1, - 1 );\n\t\tsetPoint( \"u2\", - w * 0.7, h * 1.1, - 1 );\n\t\tsetPoint( \"u3\",         0, h * 2,   - 1 );\n\n\t\t// cross\n\n\t\tsetPoint( \"cf1\", - w,   0, 1 );\n\t\tsetPoint( \"cf2\",   w,   0, 1 );\n\t\tsetPoint( \"cf3\",   0, - h, 1 );\n\t\tsetPoint( \"cf4\",   0,   h, 1 );\n\n\t\tsetPoint( \"cn1\", - w,   0, - 1 );\n\t\tsetPoint( \"cn2\",   w,   0, - 1 );\n\t\tsetPoint( \"cn3\",   0, - h, - 1 );\n\t\tsetPoint( \"cn4\",   0,   h, - 1 );\n\n\t\tgeometry.verticesNeedUpdate = true;\n\n\t};\n\n}();\n\n// File:src/extras/helpers/DirectionalLightHelper.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.DirectionalLightHelper = function ( light, size ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.light = light;\n\tthis.light.updateMatrixWorld();\n\n\tthis.matrix = light.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tif ( size === undefined ) size = 1;\n\n\tvar geometry = new THREE.BufferGeometry();\n\tgeometry.addAttribute( 'position', new THREE.Float32Attribute( [\n\t\t- size,   size, 0,\n\t\t  size,   size, 0,\n\t\t  size, - size, 0,\n\t\t- size, - size, 0,\n\t\t- size,   size, 0\n\t], 3 ) );\n\n\tvar material = new THREE.LineBasicMaterial( { fog: false } );\n\n\tthis.add( new THREE.Line( geometry, material ) );\n\n\tgeometry = new THREE.BufferGeometry();\n\tgeometry.addAttribute( 'position', new THREE.Float32Attribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );\n\n\tthis.add( new THREE.Line( geometry, material ));\n\n\tthis.update();\n\n};\n\nTHREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;\n\nTHREE.DirectionalLightHelper.prototype.dispose = function () {\n\n\tvar lightPlane = this.children[ 0 ];\n\tvar targetLine = this.children[ 1 ];\n\n\tlightPlane.geometry.dispose();\n\tlightPlane.material.dispose();\n\ttargetLine.geometry.dispose();\n\ttargetLine.material.dispose();\n\n};\n\nTHREE.DirectionalLightHelper.prototype.update = function () {\n\n\tvar v1 = new THREE.Vector3();\n\tvar v2 = new THREE.Vector3();\n\tvar v3 = new THREE.Vector3();\n\n\treturn function update() {\n\n\t\tv1.setFromMatrixPosition( this.light.matrixWorld );\n\t\tv2.setFromMatrixPosition( this.light.target.matrixWorld );\n\t\tv3.subVectors( v2, v1 );\n\n\t\tvar lightPlane = this.children[ 0 ];\n\t\tvar targetLine = this.children[ 1 ];\n\n\t\tlightPlane.lookAt( v3 );\n\t\tlightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t\ttargetLine.lookAt( v3 );\n\t\ttargetLine.scale.z = v3.length();\n\n\t};\n\n}();\n\n// File:src/extras/helpers/EdgesHelper.js\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n * @param object THREE.Mesh whose geometry will be used\n * @param hex line color\n * @param thresholdAngle the minimum angle (in degrees),\n * between the face normals of adjacent faces,\n * that is required to render an edge. A value of 10 means\n * an edge is only rendered if the angle is at least 10 degrees.\n */\n\nTHREE.EdgesHelper = function ( object, hex, thresholdAngle ) {\n\n\tvar color = ( hex !== undefined ) ? hex : 0xffffff;\n\n\tTHREE.LineSegments.call( this, new THREE.EdgesGeometry( object.geometry, thresholdAngle ), new THREE.LineBasicMaterial( { color: color } ) );\n\n\tthis.matrix = object.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n};\n\nTHREE.EdgesHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;\n\n// File:src/extras/helpers/FaceNormalsHelper.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n*/\n\nTHREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {\n\n\t// FaceNormalsHelper only supports THREE.Geometry\n\n\tthis.object = object;\n\n\tthis.size = ( size !== undefined ) ? size : 1;\n\n\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\n\n\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\n\t//\n\n\tvar nNormals = 0;\n\n\tvar objGeometry = this.object.geometry;\n\n\tif ( objGeometry instanceof THREE.Geometry ) {\n\n\t\tnNormals = objGeometry.faces.length;\n\n\t} else {\n\n\t\tconsole.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );\n\n\t}\n\n\t//\n\n\tvar geometry = new THREE.BufferGeometry();\n\n\tvar positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );\n\n\tgeometry.addAttribute( 'position', positions );\n\n\tTHREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );\n\n\t//\n\n\tthis.matrixAutoUpdate = false;\n\tthis.update();\n\n};\n\nTHREE.FaceNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;\n\nTHREE.FaceNormalsHelper.prototype.update = ( function () {\n\n\tvar v1 = new THREE.Vector3();\n\tvar v2 = new THREE.Vector3();\n\tvar normalMatrix = new THREE.Matrix3();\n\n\treturn function update() {\n\n\t\tthis.object.updateMatrixWorld( true );\n\n\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\n\n\t\tvar matrixWorld = this.object.matrixWorld;\n\n\t\tvar position = this.geometry.attributes.position;\n\n\t\t//\n\n\t\tvar objGeometry = this.object.geometry;\n\n\t\tvar vertices = objGeometry.vertices;\n\n\t\tvar faces = objGeometry.faces;\n\n\t\tvar idx = 0;\n\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tvar normal = face.normal;\n\n\t\t\tv1.copy( vertices[ face.a ] )\n\t\t\t\t.add( vertices[ face.b ] )\n\t\t\t\t.add( vertices[ face.c ] )\n\t\t\t\t.divideScalar( 3 )\n\t\t\t\t.applyMatrix4( matrixWorld );\n\n\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\n\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\n\t\t\tidx = idx + 1;\n\n\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\n\t\t\tidx = idx + 1;\n\n\t\t}\n\n\t\tposition.needsUpdate = true;\n\n\t\treturn this;\n\n\t};\n\n}() );\n\n// File:src/extras/helpers/GridHelper.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.GridHelper = function ( size, step, color1, color2 ) {\n\n\tcolor1 = new THREE.Color( color1 !== undefined ? color1 : 0x444444 );\n\tcolor2 = new THREE.Color( color2 !== undefined ? color2 : 0x888888 );\n\n\tvar vertices = [];\n\tvar colors = [];\n\n\tfor ( var i = - size, j = 0; i <= size; i += step ) {\n\n\t\tvertices.push( - size, 0, i, size, 0, i );\n\t\tvertices.push( i, 0, - size, i, 0, size );\n\n\t\tvar color = i === 0 ? color1 : color2;\n\n\t\tcolor.toArray( colors, j ); j += 3;\n\t\tcolor.toArray( colors, j ); j += 3;\n\t\tcolor.toArray( colors, j ); j += 3;\n\t\tcolor.toArray( colors, j ); j += 3;\n\n\t}\n\n\tvar geometry = new THREE.BufferGeometry();\n\tgeometry.addAttribute( 'position', new THREE.Float32Attribute( vertices, 3 ) );\n\tgeometry.addAttribute( 'color', new THREE.Float32Attribute( colors, 3 ) );\n\n\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\n\n\tTHREE.LineSegments.call( this, geometry, material );\n\n};\n\nTHREE.GridHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.GridHelper.prototype.constructor = THREE.GridHelper;\n\nTHREE.GridHelper.prototype.setColors = function () {\n\n\tconsole.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );\n\n};\n\n// File:src/extras/helpers/HemisphereLightHelper.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.HemisphereLightHelper = function ( light, sphereSize ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.light = light;\n\tthis.light.updateMatrixWorld();\n\n\tthis.matrix = light.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tthis.colors = [ new THREE.Color(), new THREE.Color() ];\n\n\tvar geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );\n\tgeometry.rotateX( - Math.PI / 2 );\n\n\tfor ( var i = 0, il = 8; i < il; i ++ ) {\n\n\t\tgeometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];\n\n\t}\n\n\tvar material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );\n\n\tthis.lightSphere = new THREE.Mesh( geometry, material );\n\tthis.add( this.lightSphere );\n\n\tthis.update();\n\n};\n\nTHREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;\n\nTHREE.HemisphereLightHelper.prototype.dispose = function () {\n\n\tthis.lightSphere.geometry.dispose();\n\tthis.lightSphere.material.dispose();\n\n};\n\nTHREE.HemisphereLightHelper.prototype.update = function () {\n\n\tvar vector = new THREE.Vector3();\n\n\treturn function update() {\n\n\t\tthis.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );\n\t\tthis.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );\n\n\t\tthis.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );\n\t\tthis.lightSphere.geometry.colorsNeedUpdate = true;\n\n\t};\n\n}();\n\n// File:src/extras/helpers/PointLightHelper.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.PointLightHelper = function ( light, sphereSize ) {\n\n\tthis.light = light;\n\tthis.light.updateMatrixWorld();\n\n\tvar geometry = new THREE.SphereBufferGeometry( sphereSize, 4, 2 );\n\tvar material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );\n\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\tTHREE.Mesh.call( this, geometry, material );\n\n\tthis.matrix = this.light.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\t/*\n\tvar distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\n\tvar distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\n\n\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\n\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\n\n\tvar d = light.distance;\n\n\tif ( d === 0.0 ) {\n\n\t\tthis.lightDistance.visible = false;\n\n\t} else {\n\n\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t}\n\n\tthis.add( this.lightDistance );\n\t*/\n\n};\n\nTHREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );\nTHREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;\n\nTHREE.PointLightHelper.prototype.dispose = function () {\n\n\tthis.geometry.dispose();\n\tthis.material.dispose();\n\n};\n\nTHREE.PointLightHelper.prototype.update = function () {\n\n\tthis.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t/*\n\tvar d = this.light.distance;\n\n\tif ( d === 0.0 ) {\n\n\t\tthis.lightDistance.visible = false;\n\n\t} else {\n\n\t\tthis.lightDistance.visible = true;\n\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t}\n\t*/\n\n};\n\n// File:src/extras/helpers/SkeletonHelper.js\n\n/**\n * @author Sean Griffin / http://twitter.com/sgrif\n * @author Michael Guerrero / http://realitymeltdown.com\n * @author mrdoob / http://mrdoob.com/\n * @author ikerr / http://verold.com\n */\n\nTHREE.SkeletonHelper = function ( object ) {\n\n\tthis.bones = this.getBoneList( object );\n\n\tvar geometry = new THREE.Geometry();\n\n\tfor ( var i = 0; i < this.bones.length; i ++ ) {\n\n\t\tvar bone = this.bones[ i ];\n\n\t\tif ( bone.parent instanceof THREE.Bone ) {\n\n\t\t\tgeometry.vertices.push( new THREE.Vector3() );\n\t\t\tgeometry.vertices.push( new THREE.Vector3() );\n\t\t\tgeometry.colors.push( new THREE.Color( 0, 0, 1 ) );\n\t\t\tgeometry.colors.push( new THREE.Color( 0, 1, 0 ) );\n\n\t\t}\n\n\t}\n\n\tgeometry.dynamic = true;\n\n\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );\n\n\tTHREE.LineSegments.call( this, geometry, material );\n\n\tthis.root = object;\n\n\tthis.matrix = object.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tthis.update();\n\n};\n\n\nTHREE.SkeletonHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;\n\nTHREE.SkeletonHelper.prototype.getBoneList = function( object ) {\n\n\tvar boneList = [];\n\n\tif ( object instanceof THREE.Bone ) {\n\n\t\tboneList.push( object );\n\n\t}\n\n\tfor ( var i = 0; i < object.children.length; i ++ ) {\n\n\t\tboneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );\n\n\t}\n\n\treturn boneList;\n\n};\n\nTHREE.SkeletonHelper.prototype.update = function () {\n\n\tvar geometry = this.geometry;\n\n\tvar matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );\n\n\tvar boneMatrix = new THREE.Matrix4();\n\n\tvar j = 0;\n\n\tfor ( var i = 0; i < this.bones.length; i ++ ) {\n\n\t\tvar bone = this.bones[ i ];\n\n\t\tif ( bone.parent instanceof THREE.Bone ) {\n\n\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );\n\t\t\tgeometry.vertices[ j ].setFromMatrixPosition( boneMatrix );\n\n\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );\n\t\t\tgeometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );\n\n\t\t\tj += 2;\n\n\t\t}\n\n\t}\n\n\tgeometry.verticesNeedUpdate = true;\n\n\tgeometry.computeBoundingSphere();\n\n};\n\n// File:src/extras/helpers/SpotLightHelper.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n*/\n\nTHREE.SpotLightHelper = function ( light ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.light = light;\n\tthis.light.updateMatrixWorld();\n\n\tthis.matrix = light.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tvar geometry = new THREE.BufferGeometry();\n\n\tvar positions = [\n\t\t0, 0, 0,   0,   0,   1,\n\t\t0, 0, 0,   1,   0,   1,\n\t\t0, 0, 0, - 1,   0,   1,\n\t\t0, 0, 0,   0,   1,   1,\n\t\t0, 0, 0,   0, - 1,   1\n\t];\n\n\tfor ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {\n\n\t\tvar p1 = ( i / l ) * Math.PI * 2;\n\t\tvar p2 = ( j / l ) * Math.PI * 2;\n\n\t\tpositions.push(\n\t\t\tMath.cos( p1 ), Math.sin( p1 ), 1,\n\t\t\tMath.cos( p2 ), Math.sin( p2 ), 1\n\t\t);\n\n\t}\n\n\tgeometry.addAttribute( 'position', new THREE.Float32Attribute( positions, 3 ) );\n\n\tvar material = new THREE.LineBasicMaterial( { fog: false } );\n\n\tthis.cone = new THREE.LineSegments( geometry, material );\n\tthis.add( this.cone );\n\n\tthis.update();\n\n};\n\nTHREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;\n\nTHREE.SpotLightHelper.prototype.dispose = function () {\n\n\tthis.cone.geometry.dispose();\n\tthis.cone.material.dispose();\n\n};\n\nTHREE.SpotLightHelper.prototype.update = function () {\n\n\tvar vector = new THREE.Vector3();\n\tvar vector2 = new THREE.Vector3();\n\n\treturn function update() {\n\n\t\tvar coneLength = this.light.distance ? this.light.distance : 1000;\n\t\tvar coneWidth = coneLength * Math.tan( this.light.angle );\n\n\t\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\n\n\t\tvector.setFromMatrixPosition( this.light.matrixWorld );\n\t\tvector2.setFromMatrixPosition( this.light.target.matrixWorld );\n\n\t\tthis.cone.lookAt( vector2.sub( vector ) );\n\n\t\tthis.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t};\n\n}();\n\n// File:src/extras/helpers/VertexNormalsHelper.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n*/\n\nTHREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {\n\n\tthis.object = object;\n\n\tthis.size = ( size !== undefined ) ? size : 1;\n\n\tvar color = ( hex !== undefined ) ? hex : 0xff0000;\n\n\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\n\t//\n\n\tvar nNormals = 0;\n\n\tvar objGeometry = this.object.geometry;\n\n\tif ( objGeometry instanceof THREE.Geometry ) {\n\n\t\tnNormals = objGeometry.faces.length * 3;\n\n\t} else if ( objGeometry instanceof THREE.BufferGeometry ) {\n\n\t\tnNormals = objGeometry.attributes.normal.count;\n\n\t}\n\n\t//\n\n\tvar geometry = new THREE.BufferGeometry();\n\n\tvar positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );\n\n\tgeometry.addAttribute( 'position', positions );\n\n\tTHREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );\n\n\t//\n\n\tthis.matrixAutoUpdate = false;\n\n\tthis.update();\n\n};\n\nTHREE.VertexNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;\n\nTHREE.VertexNormalsHelper.prototype.update = ( function () {\n\n\tvar v1 = new THREE.Vector3();\n\tvar v2 = new THREE.Vector3();\n\tvar normalMatrix = new THREE.Matrix3();\n\n\treturn function update() {\n\n\t\tvar keys = [ 'a', 'b', 'c' ];\n\n\t\tthis.object.updateMatrixWorld( true );\n\n\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\n\n\t\tvar matrixWorld = this.object.matrixWorld;\n\n\t\tvar position = this.geometry.attributes.position;\n\n\t\t//\n\n\t\tvar objGeometry = this.object.geometry;\n\n\t\tif ( objGeometry instanceof THREE.Geometry ) {\n\n\t\t\tvar vertices = objGeometry.vertices;\n\n\t\t\tvar faces = objGeometry.faces;\n\n\t\t\tvar idx = 0;\n\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\t\tvar vertex = vertices[ face[ keys[ j ] ] ];\n\n\t\t\t\t\tvar normal = face.vertexNormals[ j ];\n\n\t\t\t\t\tv1.copy( vertex ).applyMatrix4( matrixWorld );\n\n\t\t\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\n\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\n\t\t\t\t\tidx = idx + 1;\n\n\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\n\t\t\t\t\tidx = idx + 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( objGeometry instanceof THREE.BufferGeometry ) {\n\n\t\t\tvar objPos = objGeometry.attributes.position;\n\n\t\t\tvar objNorm = objGeometry.attributes.normal;\n\n\t\t\tvar idx = 0;\n\n\t\t\t// for simplicity, ignore index and drawcalls, and render every normal\n\n\t\t\tfor ( var j = 0, jl = objPos.count; j < jl; j ++ ) {\n\n\t\t\t\tv1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );\n\n\t\t\t\tv2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );\n\n\t\t\t\tv2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\n\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\n\t\t\t\tidx = idx + 1;\n\n\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\n\t\t\t\tidx = idx + 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tposition.needsUpdate = true;\n\n\t\treturn this;\n\n\t};\n\n}() );\n\n// File:src/extras/helpers/WireframeHelper.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.WireframeHelper = function ( object, hex ) {\n\n\tvar color = ( hex !== undefined ) ? hex : 0xffffff;\n\n\tTHREE.LineSegments.call( this, new THREE.WireframeGeometry( object.geometry ), new THREE.LineBasicMaterial( { color: color } ) );\n\n\tthis.matrix = object.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n};\n\nTHREE.WireframeHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;\n\n// File:src/extras/objects/ImmediateRenderObject.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.ImmediateRenderObject = function ( material ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.material = material;\n\tthis.render = function ( renderCallback ) {};\n\n};\n\nTHREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;\n\n// File:src/extras/objects/MorphBlendMesh.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.MorphBlendMesh = function( geometry, material ) {\n\n\tTHREE.Mesh.call( this, geometry, material );\n\n\tthis.animationsMap = {};\n\tthis.animationsList = [];\n\n\t// prepare default animation\n\t// (all frames played together in 1 second)\n\n\tvar numFrames = this.geometry.morphTargets.length;\n\n\tvar name = \"__default\";\n\n\tvar startFrame = 0;\n\tvar endFrame = numFrames - 1;\n\n\tvar fps = numFrames / 1;\n\n\tthis.createAnimation( name, startFrame, endFrame, fps );\n\tthis.setAnimationWeight( name, 1 );\n\n};\n\nTHREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );\nTHREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;\n\nTHREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {\n\n\tvar animation = {\n\n\t\tstart: start,\n\t\tend: end,\n\n\t\tlength: end - start + 1,\n\n\t\tfps: fps,\n\t\tduration: ( end - start ) / fps,\n\n\t\tlastFrame: 0,\n\t\tcurrentFrame: 0,\n\n\t\tactive: false,\n\n\t\ttime: 0,\n\t\tdirection: 1,\n\t\tweight: 1,\n\n\t\tdirectionBackwards: false,\n\t\tmirroredLoop: false\n\n\t};\n\n\tthis.animationsMap[ name ] = animation;\n\tthis.animationsList.push( animation );\n\n};\n\nTHREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {\n\n\tvar pattern = /([a-z]+)_?(\\d+)/i;\n\n\tvar firstAnimation, frameRanges = {};\n\n\tvar geometry = this.geometry;\n\n\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\n\n\t\tvar morph = geometry.morphTargets[ i ];\n\t\tvar chunks = morph.name.match( pattern );\n\n\t\tif ( chunks && chunks.length > 1 ) {\n\n\t\t\tvar name = chunks[ 1 ];\n\n\t\t\tif ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };\n\n\t\t\tvar range = frameRanges[ name ];\n\n\t\t\tif ( i < range.start ) range.start = i;\n\t\t\tif ( i > range.end ) range.end = i;\n\n\t\t\tif ( ! firstAnimation ) firstAnimation = name;\n\n\t\t}\n\n\t}\n\n\tfor ( var name in frameRanges ) {\n\n\t\tvar range = frameRanges[ name ];\n\t\tthis.createAnimation( name, range.start, range.end, fps );\n\n\t}\n\n\tthis.firstAnimation = firstAnimation;\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.direction = 1;\n\t\tanimation.directionBackwards = false;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.direction = - 1;\n\t\tanimation.directionBackwards = true;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.fps = fps;\n\t\tanimation.duration = ( animation.end - animation.start ) / animation.fps;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.duration = duration;\n\t\tanimation.fps = ( animation.end - animation.start ) / animation.duration;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.weight = weight;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.time = time;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {\n\n\tvar time = 0;\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\ttime = animation.time;\n\n\t}\n\n\treturn time;\n\n};\n\nTHREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {\n\n\tvar duration = - 1;\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tduration = animation.duration;\n\n\t}\n\n\treturn duration;\n\n};\n\nTHREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.time = 0;\n\t\tanimation.active = true;\n\n\t} else {\n\n\t\tconsole.warn( \"THREE.MorphBlendMesh: animation[\" + name + \"] undefined in .playAnimation()\" );\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.active = false;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.update = function ( delta ) {\n\n\tfor ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {\n\n\t\tvar animation = this.animationsList[ i ];\n\n\t\tif ( ! animation.active ) continue;\n\n\t\tvar frameTime = animation.duration / animation.length;\n\n\t\tanimation.time += animation.direction * delta;\n\n\t\tif ( animation.mirroredLoop ) {\n\n\t\t\tif ( animation.time > animation.duration || animation.time < 0 ) {\n\n\t\t\t\tanimation.direction *= - 1;\n\n\t\t\t\tif ( animation.time > animation.duration ) {\n\n\t\t\t\t\tanimation.time = animation.duration;\n\t\t\t\t\tanimation.directionBackwards = true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( animation.time < 0 ) {\n\n\t\t\t\t\tanimation.time = 0;\n\t\t\t\t\tanimation.directionBackwards = false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tanimation.time = animation.time % animation.duration;\n\n\t\t\tif ( animation.time < 0 ) animation.time += animation.duration;\n\n\t\t}\n\n\t\tvar keyframe = animation.start + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );\n\t\tvar weight = animation.weight;\n\n\t\tif ( keyframe !== animation.currentFrame ) {\n\n\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = 0;\n\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;\n\n\t\t\tthis.morphTargetInfluences[ keyframe ] = 0;\n\n\t\t\tanimation.lastFrame = animation.currentFrame;\n\t\t\tanimation.currentFrame = keyframe;\n\n\t\t}\n\n\t\tvar mix = ( animation.time % frameTime ) / frameTime;\n\n\t\tif ( animation.directionBackwards ) mix = 1 - mix;\n\n\t\tif ( animation.currentFrame !== animation.lastFrame ) {\n\n\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = mix * weight;\n\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;\n\n\t\t} else {\n\n\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = weight;\n\n\t\t}\n\n\t}\n\n};\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/three/build/three.js\n ** module id = 1\n ** module chunks = 0\n **/","/*!\n * vue-resource v0.9.0\n * https://github.com/vuejs/vue-resource\n * Released under the MIT License.\n */\n\n'use strict';\n\n/**\n * Promises/A+ polyfill v1.1.4 (https://github.com/bramstein/promis)\n */\n\nvar RESOLVED = 0;\nvar REJECTED = 1;\nvar PENDING = 2;\n\nfunction Promise$2(executor) {\n\n    this.state = PENDING;\n    this.value = undefined;\n    this.deferred = [];\n\n    var promise = this;\n\n    try {\n        executor(function (x) {\n            promise.resolve(x);\n        }, function (r) {\n            promise.reject(r);\n        });\n    } catch (e) {\n        promise.reject(e);\n    }\n}\n\nPromise$2.reject = function (r) {\n    return new Promise$2(function (resolve, reject) {\n        reject(r);\n    });\n};\n\nPromise$2.resolve = function (x) {\n    return new Promise$2(function (resolve, reject) {\n        resolve(x);\n    });\n};\n\nPromise$2.all = function all(iterable) {\n    return new Promise$2(function (resolve, reject) {\n        var count = 0,\n            result = [];\n\n        if (iterable.length === 0) {\n            resolve(result);\n        }\n\n        function resolver(i) {\n            return function (x) {\n                result[i] = x;\n                count += 1;\n\n                if (count === iterable.length) {\n                    resolve(result);\n                }\n            };\n        }\n\n        for (var i = 0; i < iterable.length; i += 1) {\n            Promise$2.resolve(iterable[i]).then(resolver(i), reject);\n        }\n    });\n};\n\nPromise$2.race = function race(iterable) {\n    return new Promise$2(function (resolve, reject) {\n        for (var i = 0; i < iterable.length; i += 1) {\n            Promise$2.resolve(iterable[i]).then(resolve, reject);\n        }\n    });\n};\n\nvar p$1 = Promise$2.prototype;\n\np$1.resolve = function resolve(x) {\n    var promise = this;\n\n    if (promise.state === PENDING) {\n        if (x === promise) {\n            throw new TypeError('Promise settled with itself.');\n        }\n\n        var called = false;\n\n        try {\n            var then = x && x['then'];\n\n            if (x !== null && typeof x === 'object' && typeof then === 'function') {\n                then.call(x, function (x) {\n                    if (!called) {\n                        promise.resolve(x);\n                    }\n                    called = true;\n                }, function (r) {\n                    if (!called) {\n                        promise.reject(r);\n                    }\n                    called = true;\n                });\n                return;\n            }\n        } catch (e) {\n            if (!called) {\n                promise.reject(e);\n            }\n            return;\n        }\n\n        promise.state = RESOLVED;\n        promise.value = x;\n        promise.notify();\n    }\n};\n\np$1.reject = function reject(reason) {\n    var promise = this;\n\n    if (promise.state === PENDING) {\n        if (reason === promise) {\n            throw new TypeError('Promise settled with itself.');\n        }\n\n        promise.state = REJECTED;\n        promise.value = reason;\n        promise.notify();\n    }\n};\n\np$1.notify = function notify() {\n    var promise = this;\n\n    nextTick(function () {\n        if (promise.state !== PENDING) {\n            while (promise.deferred.length) {\n                var deferred = promise.deferred.shift(),\n                    onResolved = deferred[0],\n                    onRejected = deferred[1],\n                    resolve = deferred[2],\n                    reject = deferred[3];\n\n                try {\n                    if (promise.state === RESOLVED) {\n                        if (typeof onResolved === 'function') {\n                            resolve(onResolved.call(undefined, promise.value));\n                        } else {\n                            resolve(promise.value);\n                        }\n                    } else if (promise.state === REJECTED) {\n                        if (typeof onRejected === 'function') {\n                            resolve(onRejected.call(undefined, promise.value));\n                        } else {\n                            reject(promise.value);\n                        }\n                    }\n                } catch (e) {\n                    reject(e);\n                }\n            }\n        }\n    });\n};\n\np$1.then = function then(onResolved, onRejected) {\n    var promise = this;\n\n    return new Promise$2(function (resolve, reject) {\n        promise.deferred.push([onResolved, onRejected, resolve, reject]);\n        promise.notify();\n    });\n};\n\np$1.catch = function (onRejected) {\n    return this.then(undefined, onRejected);\n};\n\nvar PromiseObj = window.Promise || Promise$2;\n\nfunction Promise$1(executor, context) {\n\n    if (executor instanceof PromiseObj) {\n        this.promise = executor;\n    } else {\n        this.promise = new PromiseObj(executor.bind(context));\n    }\n\n    this.context = context;\n}\n\nPromise$1.all = function (iterable, context) {\n    return new Promise$1(PromiseObj.all(iterable), context);\n};\n\nPromise$1.resolve = function (value, context) {\n    return new Promise$1(PromiseObj.resolve(value), context);\n};\n\nPromise$1.reject = function (reason, context) {\n    return new Promise$1(PromiseObj.reject(reason), context);\n};\n\nPromise$1.race = function (iterable, context) {\n    return new Promise$1(PromiseObj.race(iterable), context);\n};\n\nvar p = Promise$1.prototype;\n\np.bind = function (context) {\n    this.context = context;\n    return this;\n};\n\np.then = function (fulfilled, rejected) {\n\n    if (fulfilled && fulfilled.bind && this.context) {\n        fulfilled = fulfilled.bind(this.context);\n    }\n\n    if (rejected && rejected.bind && this.context) {\n        rejected = rejected.bind(this.context);\n    }\n\n    return new Promise$1(this.promise.then(fulfilled, rejected), this.context);\n};\n\np.catch = function (rejected) {\n\n    if (rejected && rejected.bind && this.context) {\n        rejected = rejected.bind(this.context);\n    }\n\n    return new Promise$1(this.promise.catch(rejected), this.context);\n};\n\np.finally = function (callback) {\n\n    return this.then(function (value) {\n        callback.call(this);\n        return value;\n    }, function (reason) {\n        callback.call(this);\n        return PromiseObj.reject(reason);\n    });\n};\n\nvar debug = false;\nvar util = {};\nvar array = [];\nfunction Util (Vue) {\n    util = Vue.util;\n    debug = Vue.config.debug || !Vue.config.silent;\n}\n\nfunction warn(msg) {\n    if (typeof console !== 'undefined' && debug) {\n        console.warn('[VueResource warn]: ' + msg);\n    }\n}\n\nfunction error(msg) {\n    if (typeof console !== 'undefined') {\n        console.error(msg);\n    }\n}\n\nfunction nextTick(cb, ctx) {\n    return util.nextTick(cb, ctx);\n}\n\nfunction trim(str) {\n    return str.replace(/^\\s*|\\s*$/g, '');\n}\n\nvar isArray = Array.isArray;\n\nfunction isString(val) {\n    return typeof val === 'string';\n}\n\nfunction isBoolean(val) {\n    return val === true || val === false;\n}\n\nfunction isFunction(val) {\n    return typeof val === 'function';\n}\n\nfunction isObject(obj) {\n    return obj !== null && typeof obj === 'object';\n}\n\nfunction isPlainObject(obj) {\n    return isObject(obj) && Object.getPrototypeOf(obj) == Object.prototype;\n}\n\nfunction isFormData(obj) {\n    return typeof FormData !== 'undefined' && obj instanceof FormData;\n}\n\nfunction when(value, fulfilled, rejected) {\n\n    var promise = Promise$1.resolve(value);\n\n    if (arguments.length < 2) {\n        return promise;\n    }\n\n    return promise.then(fulfilled, rejected);\n}\n\nfunction options(fn, obj, opts) {\n\n    opts = opts || {};\n\n    if (isFunction(opts)) {\n        opts = opts.call(obj);\n    }\n\n    return merge(fn.bind({ $vm: obj, $options: opts }), fn, { $options: opts });\n}\n\nfunction each(obj, iterator) {\n\n    var i, key;\n\n    if (typeof obj.length == 'number') {\n        for (i = 0; i < obj.length; i++) {\n            iterator.call(obj[i], obj[i], i);\n        }\n    } else if (isObject(obj)) {\n        for (key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                iterator.call(obj[key], obj[key], key);\n            }\n        }\n    }\n\n    return obj;\n}\n\nvar assign = Object.assign || _assign;\n\nfunction merge(target) {\n\n    var args = array.slice.call(arguments, 1);\n\n    args.forEach(function (source) {\n        _merge(target, source, true);\n    });\n\n    return target;\n}\n\nfunction defaults(target) {\n\n    var args = array.slice.call(arguments, 1);\n\n    args.forEach(function (source) {\n\n        for (var key in source) {\n            if (target[key] === undefined) {\n                target[key] = source[key];\n            }\n        }\n    });\n\n    return target;\n}\n\nfunction _assign(target) {\n\n    var args = array.slice.call(arguments, 1);\n\n    args.forEach(function (source) {\n        _merge(target, source);\n    });\n\n    return target;\n}\n\nfunction _merge(target, source, deep) {\n    for (var key in source) {\n        if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {\n            if (isPlainObject(source[key]) && !isPlainObject(target[key])) {\n                target[key] = {};\n            }\n            if (isArray(source[key]) && !isArray(target[key])) {\n                target[key] = [];\n            }\n            _merge(target[key], source[key], deep);\n        } else if (source[key] !== undefined) {\n            target[key] = source[key];\n        }\n    }\n}\n\nfunction root (options, next) {\n\n    var url = next(options);\n\n    if (isString(options.root) && !url.match(/^(https?:)?\\//)) {\n        url = options.root + '/' + url;\n    }\n\n    return url;\n}\n\nfunction query (options, next) {\n\n    var urlParams = Object.keys(Url.options.params),\n        query = {},\n        url = next(options);\n\n    each(options.params, function (value, key) {\n        if (urlParams.indexOf(key) === -1) {\n            query[key] = value;\n        }\n    });\n\n    query = Url.params(query);\n\n    if (query) {\n        url += (url.indexOf('?') == -1 ? '?' : '&') + query;\n    }\n\n    return url;\n}\n\n/**\n * URL Template v2.0.6 (https://github.com/bramstein/url-template)\n */\n\nfunction expand(url, params, variables) {\n\n    var tmpl = parse(url),\n        expanded = tmpl.expand(params);\n\n    if (variables) {\n        variables.push.apply(variables, tmpl.vars);\n    }\n\n    return expanded;\n}\n\nfunction parse(template) {\n\n    var operators = ['+', '#', '.', '/', ';', '?', '&'],\n        variables = [];\n\n    return {\n        vars: variables,\n        expand: function (context) {\n            return template.replace(/\\{([^\\{\\}]+)\\}|([^\\{\\}]+)/g, function (_, expression, literal) {\n                if (expression) {\n\n                    var operator = null,\n                        values = [];\n\n                    if (operators.indexOf(expression.charAt(0)) !== -1) {\n                        operator = expression.charAt(0);\n                        expression = expression.substr(1);\n                    }\n\n                    expression.split(/,/g).forEach(function (variable) {\n                        var tmp = /([^:\\*]*)(?::(\\d+)|(\\*))?/.exec(variable);\n                        values.push.apply(values, getValues(context, operator, tmp[1], tmp[2] || tmp[3]));\n                        variables.push(tmp[1]);\n                    });\n\n                    if (operator && operator !== '+') {\n\n                        var separator = ',';\n\n                        if (operator === '?') {\n                            separator = '&';\n                        } else if (operator !== '#') {\n                            separator = operator;\n                        }\n\n                        return (values.length !== 0 ? operator : '') + values.join(separator);\n                    } else {\n                        return values.join(',');\n                    }\n                } else {\n                    return encodeReserved(literal);\n                }\n            });\n        }\n    };\n}\n\nfunction getValues(context, operator, key, modifier) {\n\n    var value = context[key],\n        result = [];\n\n    if (isDefined(value) && value !== '') {\n        if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n            value = value.toString();\n\n            if (modifier && modifier !== '*') {\n                value = value.substring(0, parseInt(modifier, 10));\n            }\n\n            result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));\n        } else {\n            if (modifier === '*') {\n                if (Array.isArray(value)) {\n                    value.filter(isDefined).forEach(function (value) {\n                        result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));\n                    });\n                } else {\n                    Object.keys(value).forEach(function (k) {\n                        if (isDefined(value[k])) {\n                            result.push(encodeValue(operator, value[k], k));\n                        }\n                    });\n                }\n            } else {\n                var tmp = [];\n\n                if (Array.isArray(value)) {\n                    value.filter(isDefined).forEach(function (value) {\n                        tmp.push(encodeValue(operator, value));\n                    });\n                } else {\n                    Object.keys(value).forEach(function (k) {\n                        if (isDefined(value[k])) {\n                            tmp.push(encodeURIComponent(k));\n                            tmp.push(encodeValue(operator, value[k].toString()));\n                        }\n                    });\n                }\n\n                if (isKeyOperator(operator)) {\n                    result.push(encodeURIComponent(key) + '=' + tmp.join(','));\n                } else if (tmp.length !== 0) {\n                    result.push(tmp.join(','));\n                }\n            }\n        }\n    } else {\n        if (operator === ';') {\n            result.push(encodeURIComponent(key));\n        } else if (value === '' && (operator === '&' || operator === '?')) {\n            result.push(encodeURIComponent(key) + '=');\n        } else if (value === '') {\n            result.push('');\n        }\n    }\n\n    return result;\n}\n\nfunction isDefined(value) {\n    return value !== undefined && value !== null;\n}\n\nfunction isKeyOperator(operator) {\n    return operator === ';' || operator === '&' || operator === '?';\n}\n\nfunction encodeValue(operator, value, key) {\n\n    value = operator === '+' || operator === '#' ? encodeReserved(value) : encodeURIComponent(value);\n\n    if (key) {\n        return encodeURIComponent(key) + '=' + value;\n    } else {\n        return value;\n    }\n}\n\nfunction encodeReserved(str) {\n    return str.split(/(%[0-9A-Fa-f]{2})/g).map(function (part) {\n        if (!/%[0-9A-Fa-f]/.test(part)) {\n            part = encodeURI(part);\n        }\n        return part;\n    }).join('');\n}\n\nfunction template (options) {\n\n    var variables = [],\n        url = expand(options.url, options.params, variables);\n\n    variables.forEach(function (key) {\n        delete options.params[key];\n    });\n\n    return url;\n}\n\n/**\n * Service for URL templating.\n */\n\nvar ie = document.documentMode;\nvar el = document.createElement('a');\n\nfunction Url(url, params) {\n\n    var self = this || {},\n        options = url,\n        transform;\n\n    if (isString(url)) {\n        options = { url: url, params: params };\n    }\n\n    options = merge({}, Url.options, self.$options, options);\n\n    Url.transforms.forEach(function (handler) {\n        transform = factory(handler, transform, self.$vm);\n    });\n\n    return transform(options);\n}\n\n/**\n * Url options.\n */\n\nUrl.options = {\n    url: '',\n    root: null,\n    params: {}\n};\n\n/**\n * Url transforms.\n */\n\nUrl.transforms = [template, query, root];\n\n/**\n * Encodes a Url parameter string.\n *\n * @param {Object} obj\n */\n\nUrl.params = function (obj) {\n\n    var params = [],\n        escape = encodeURIComponent;\n\n    params.add = function (key, value) {\n\n        if (isFunction(value)) {\n            value = value();\n        }\n\n        if (value === null) {\n            value = '';\n        }\n\n        this.push(escape(key) + '=' + escape(value));\n    };\n\n    serialize(params, obj);\n\n    return params.join('&').replace(/%20/g, '+');\n};\n\n/**\n * Parse a URL and return its components.\n *\n * @param {String} url\n */\n\nUrl.parse = function (url) {\n\n    if (ie) {\n        el.href = url;\n        url = el.href;\n    }\n\n    el.href = url;\n\n    return {\n        href: el.href,\n        protocol: el.protocol ? el.protocol.replace(/:$/, '') : '',\n        port: el.port,\n        host: el.host,\n        hostname: el.hostname,\n        pathname: el.pathname.charAt(0) === '/' ? el.pathname : '/' + el.pathname,\n        search: el.search ? el.search.replace(/^\\?/, '') : '',\n        hash: el.hash ? el.hash.replace(/^#/, '') : ''\n    };\n};\n\nfunction factory(handler, next, vm) {\n    return function (options) {\n        return handler.call(vm, options, next);\n    };\n}\n\nfunction serialize(params, obj, scope) {\n\n    var array = isArray(obj),\n        plain = isPlainObject(obj),\n        hash;\n\n    each(obj, function (value, key) {\n\n        hash = isObject(value) || isArray(value);\n\n        if (scope) {\n            key = scope + '[' + (plain || hash ? key : '') + ']';\n        }\n\n        if (!scope && array) {\n            params.add(value.name, value.value);\n        } else if (hash) {\n            serialize(params, value, key);\n        } else {\n            params.add(key, value);\n        }\n    });\n}\n\nfunction xdrClient (request) {\n    return new Promise$1(function (resolve) {\n\n        var xdr = new XDomainRequest(),\n            handler = function (event) {\n\n            var response = request.respondWith(xdr.responseText, {\n                status: xhr.status,\n                statusText: xdr.statusText\n            });\n\n            resolve(response);\n        };\n\n        request.abort = function () {\n            return xdr.abort();\n        };\n\n        xdr.open(request.method, request.getUrl(), true);\n        xdr.timeout = 0;\n        xdr.onload = handler;\n        xdr.onerror = handler;\n        xdr.ontimeout = function () {};\n        xdr.onprogress = function () {};\n        xdr.send(request.getBody());\n    });\n}\n\nvar ORIGIN_URL = Url.parse(location.href);\nvar SUPPORTS_CORS = 'withCredentials' in new XMLHttpRequest();\n\nfunction cors (request, next) {\n\n    if (!isBoolean(request.crossOrigin) && crossOrigin(request)) {\n        request.crossOrigin = true;\n    }\n\n    if (request.crossOrigin) {\n\n        if (!SUPPORTS_CORS) {\n            request.client = xdrClient;\n        }\n\n        delete request.emulateHTTP;\n    }\n\n    next();\n}\n\nfunction crossOrigin(request) {\n\n    var requestUrl = Url.parse(Url(request));\n\n    return requestUrl.protocol !== ORIGIN_URL.protocol || requestUrl.host !== ORIGIN_URL.host;\n}\n\nfunction body (request, next) {\n\n    if (request.emulateJSON && isPlainObject(request.body)) {\n        request.body = Url.params(request.body);\n        request.headers['Content-Type'] = 'application/x-www-form-urlencoded';\n    }\n\n    if (isFormData(request.body)) {\n        delete request.headers['Content-Type'];\n    }\n\n    if (isPlainObject(request.body)) {\n        request.body = JSON.stringify(request.body);\n    }\n\n    next(function (response) {\n\n        var contentType = response.headers['Content-Type'];\n\n        if (isString(contentType) && contentType.indexOf('application/json') === 0) {\n\n            try {\n                response.data = response.json();\n            } catch (e) {\n                response.data = null;\n            }\n        } else {\n            response.data = response.text();\n        }\n    });\n}\n\nfunction jsonpClient (request) {\n    return new Promise$1(function (resolve) {\n\n        var name = request.jsonp || 'callback',\n            callback = '_jsonp' + Math.random().toString(36).substr(2),\n            body = null,\n            handler,\n            script;\n\n        handler = function (event) {\n\n            var status = 0;\n\n            if (event.type === 'load' && body !== null) {\n                status = 200;\n            } else if (event.type === 'error') {\n                status = 404;\n            }\n\n            resolve(request.respondWith(body, { status: status }));\n\n            delete window[callback];\n            document.body.removeChild(script);\n        };\n\n        request.params[name] = callback;\n\n        window[callback] = function (result) {\n            body = JSON.stringify(result);\n        };\n\n        script = document.createElement('script');\n        script.src = request.getUrl();\n        script.type = 'text/javascript';\n        script.async = true;\n        script.onload = handler;\n        script.onerror = handler;\n\n        document.body.appendChild(script);\n    });\n}\n\nfunction jsonp (request, next) {\n\n    if (request.method == 'JSONP') {\n        request.client = jsonpClient;\n    }\n\n    next(function (response) {\n\n        if (request.method == 'JSONP') {\n            response.data = response.json();\n        }\n    });\n}\n\nfunction before (request, next) {\n\n    if (isFunction(request.before)) {\n        request.before.call(this, request);\n    }\n\n    next();\n}\n\n/**\n * HTTP method override Interceptor.\n */\n\nfunction method (request, next) {\n\n    if (request.emulateHTTP && /^(PUT|PATCH|DELETE)$/i.test(request.method)) {\n        request.headers['X-HTTP-Method-Override'] = request.method;\n        request.method = 'POST';\n    }\n\n    next();\n}\n\nfunction header (request, next) {\n\n    request.method = request.method.toUpperCase();\n    request.headers = assign({}, Http.headers.common, !request.crossOrigin ? Http.headers.custom : {}, Http.headers[request.method.toLowerCase()], request.headers);\n\n    next();\n}\n\n/**\n * Timeout Interceptor.\n */\n\nfunction timeout (request, next) {\n\n    var timeout;\n\n    if (request.timeout) {\n        timeout = setTimeout(function () {\n            request.cancel();\n        }, request.timeout);\n    }\n\n    next(function (response) {\n\n        clearTimeout(timeout);\n    });\n}\n\nfunction xhrClient (request) {\n    return new Promise$1(function (resolve) {\n\n        var xhr = new XMLHttpRequest(),\n            handler = function (event) {\n\n            var response = request.respondWith('response' in xhr ? xhr.response : xhr.responseText, {\n                status: xhr.status === 1223 ? 204 : xhr.status, // IE9 status bug\n                statusText: xhr.status === 1223 ? 'No Content' : trim(xhr.statusText),\n                headers: parseHeaders(xhr.getAllResponseHeaders())\n            });\n\n            resolve(response);\n        };\n\n        request.abort = function () {\n            return xhr.abort();\n        };\n\n        xhr.open(request.method, request.getUrl(), true);\n        xhr.timeout = 0;\n        xhr.onload = handler;\n        xhr.onerror = handler;\n\n        if (request.progress) {\n            if (request.method === 'GET') {\n                xhr.addEventListener('progress', request.progress);\n            } else if (/^(POST|PUT)$/i.test(request.method)) {\n                xhr.upload.addEventListener('progress', request.progress);\n            }\n        }\n\n        if (request.credentials === true) {\n            xhr.withCredentials = true;\n        }\n\n        each(request.headers || {}, function (value, header) {\n            xhr.setRequestHeader(header, value);\n        });\n\n        xhr.send(request.getBody());\n    });\n}\n\nfunction parseHeaders(str) {\n\n    var headers = {},\n        value,\n        name,\n        i;\n\n    each(trim(str).split('\\n'), function (row) {\n\n        i = row.indexOf(':');\n        name = trim(row.slice(0, i));\n        value = trim(row.slice(i + 1));\n\n        if (headers[name]) {\n\n            if (isArray(headers[name])) {\n                headers[name].push(value);\n            } else {\n                headers[name] = [headers[name], value];\n            }\n        } else {\n\n            headers[name] = value;\n        }\n    });\n\n    return headers;\n}\n\nfunction Client (context) {\n\n    var reqHandlers = [sendRequest],\n        resHandlers = [],\n        handler;\n\n    if (!isObject(context)) {\n        context = null;\n    }\n\n    function Client(request) {\n        return new Promise$1(function (resolve) {\n\n            function exec() {\n\n                handler = reqHandlers.pop();\n\n                if (isFunction(handler)) {\n                    handler.call(context, request, next);\n                } else {\n                    warn('Invalid interceptor of type ' + typeof handler + ', must be a function');\n                    next();\n                }\n            }\n\n            function next(response) {\n                when(response, function (response) {\n\n                    if (isFunction(response)) {\n\n                        resHandlers.unshift(response);\n                    } else if (isObject(response)) {\n\n                        resHandlers.forEach(function (handler) {\n                            handler.call(context, response);\n                        });\n\n                        resolve(response);\n\n                        return;\n                    }\n\n                    exec();\n                });\n            }\n\n            exec();\n        }, context);\n    }\n\n    Client.use = function (handler) {\n        reqHandlers.push(handler);\n    };\n\n    return Client;\n}\n\nfunction sendRequest(request, resolve) {\n\n    var client = request.client || xhrClient;\n\n    resolve(client(request));\n}\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\n/**\n * HTTP Response.\n */\n\nvar Response = function () {\n    function Response(body, _ref) {\n        var url = _ref.url;\n        var headers = _ref.headers;\n        var status = _ref.status;\n        var statusText = _ref.statusText;\n        classCallCheck(this, Response);\n\n\n        this.url = url;\n        this.body = body;\n        this.headers = headers || {};\n        this.status = status || 0;\n        this.statusText = statusText || '';\n        this.ok = status >= 200 && status < 300;\n    }\n\n    Response.prototype.text = function text() {\n        return this.body;\n    };\n\n    Response.prototype.blob = function blob() {\n        return new Blob([this.body]);\n    };\n\n    Response.prototype.json = function json() {\n        return JSON.parse(this.body);\n    };\n\n    return Response;\n}();\n\nvar Request = function () {\n    function Request(options) {\n        classCallCheck(this, Request);\n\n\n        this.method = 'GET';\n        this.body = null;\n        this.params = {};\n        this.headers = {};\n\n        assign(this, options);\n    }\n\n    Request.prototype.getUrl = function getUrl() {\n        return Url(this);\n    };\n\n    Request.prototype.getBody = function getBody() {\n        return this.body;\n    };\n\n    Request.prototype.respondWith = function respondWith(body, options) {\n        return new Response(body, assign(options || {}, { url: this.getUrl() }));\n    };\n\n    return Request;\n}();\n\n/**\n * Service for sending network requests.\n */\n\nvar CUSTOM_HEADERS = { 'X-Requested-With': 'XMLHttpRequest' };\nvar COMMON_HEADERS = { 'Accept': 'application/json, text/plain, */*' };\nvar JSON_CONTENT_TYPE = { 'Content-Type': 'application/json;charset=utf-8' };\n\nfunction Http(options) {\n\n    var self = this || {},\n        client = Client(self.$vm);\n\n    defaults(options || {}, self.$options, Http.options);\n\n    Http.interceptors.forEach(function (handler) {\n        client.use(handler);\n    });\n\n    return client(new Request(options)).then(function (response) {\n\n        return response.ok ? response : Promise$1.reject(response);\n    }, function (response) {\n\n        if (response instanceof Error) {\n            error(response);\n        }\n\n        return Promise$1.reject(response);\n    });\n}\n\nHttp.options = {};\n\nHttp.headers = {\n    put: JSON_CONTENT_TYPE,\n    post: JSON_CONTENT_TYPE,\n    patch: JSON_CONTENT_TYPE,\n    delete: JSON_CONTENT_TYPE,\n    custom: CUSTOM_HEADERS,\n    common: COMMON_HEADERS\n};\n\nHttp.interceptors = [before, timeout, method, body, jsonp, header, cors];\n\n['get', 'delete', 'head', 'jsonp'].forEach(function (method) {\n\n    Http[method] = function (url, options) {\n        return this(assign(options || {}, { url: url, method: method }));\n    };\n});\n\n['post', 'put', 'patch'].forEach(function (method) {\n\n    Http[method] = function (url, body, options) {\n        return this(assign(options || {}, { url: url, method: method, body: body }));\n    };\n});\n\nfunction Resource(url, params, actions, options) {\n\n    var self = this || {},\n        resource = {};\n\n    actions = assign({}, Resource.actions, actions);\n\n    each(actions, function (action, name) {\n\n        action = merge({ url: url, params: params || {} }, options, action);\n\n        resource[name] = function () {\n            return (self.$http || Http)(opts(action, arguments));\n        };\n    });\n\n    return resource;\n}\n\nfunction opts(action, args) {\n\n    var options = assign({}, action),\n        params = {},\n        body;\n\n    switch (args.length) {\n\n        case 2:\n\n            params = args[0];\n            body = args[1];\n\n            break;\n\n        case 1:\n\n            if (/^(POST|PUT|PATCH)$/i.test(options.method)) {\n                body = args[0];\n            } else {\n                params = args[0];\n            }\n\n            break;\n\n        case 0:\n\n            break;\n\n        default:\n\n            throw 'Expected up to 4 arguments [params, body], got ' + args.length + ' arguments';\n    }\n\n    options.body = body;\n    options.params = assign({}, options.params, params);\n\n    return options;\n}\n\nResource.actions = {\n\n    get: { method: 'GET' },\n    save: { method: 'POST' },\n    query: { method: 'GET' },\n    update: { method: 'PUT' },\n    remove: { method: 'DELETE' },\n    delete: { method: 'DELETE' }\n\n};\n\nfunction plugin(Vue) {\n\n    if (plugin.installed) {\n        return;\n    }\n\n    Util(Vue);\n\n    Vue.url = Url;\n    Vue.http = Http;\n    Vue.resource = Resource;\n    Vue.Promise = Promise$1;\n\n    Object.defineProperties(Vue.prototype, {\n\n        $url: {\n            get: function () {\n                return options(Vue.url, this, this.$options.url);\n            }\n        },\n\n        $http: {\n            get: function () {\n                return options(Vue.http, this, this.$options.http);\n            }\n        },\n\n        $resource: {\n            get: function () {\n                return Vue.resource.bind(this);\n            }\n        },\n\n        $promise: {\n            get: function () {\n                var _this = this;\n\n                return function (executor) {\n                    return new Vue.Promise(executor, _this);\n                };\n            }\n        }\n\n    });\n}\n\nif (typeof window !== 'undefined' && window.Vue) {\n    window.Vue.use(plugin);\n}\n\nmodule.exports = plugin;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vue-resource/dist/vue-resource.common.js\n ** module id = 2\n ** module chunks = 0\n **/","/*!\n * Vue.js v1.0.25\n * (c) 2016 Evan You\n * Released under the MIT License.\n */\n'use strict';\n\nfunction set(obj, key, val) {\n  if (hasOwn(obj, key)) {\n    obj[key] = val;\n    return;\n  }\n  if (obj._isVue) {\n    set(obj._data, key, val);\n    return;\n  }\n  var ob = obj.__ob__;\n  if (!ob) {\n    obj[key] = val;\n    return;\n  }\n  ob.convert(key, val);\n  ob.dep.notify();\n  if (ob.vms) {\n    var i = ob.vms.length;\n    while (i--) {\n      var vm = ob.vms[i];\n      vm._proxy(key);\n      vm._digest();\n    }\n  }\n  return val;\n}\n\n/**\n * Delete a property and trigger change if necessary.\n *\n * @param {Object} obj\n * @param {String} key\n */\n\nfunction del(obj, key) {\n  if (!hasOwn(obj, key)) {\n    return;\n  }\n  delete obj[key];\n  var ob = obj.__ob__;\n  if (!ob) {\n    if (obj._isVue) {\n      delete obj._data[key];\n      obj._digest();\n    }\n    return;\n  }\n  ob.dep.notify();\n  if (ob.vms) {\n    var i = ob.vms.length;\n    while (i--) {\n      var vm = ob.vms[i];\n      vm._unproxy(key);\n      vm._digest();\n    }\n  }\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\n * Check whether the object has the property.\n *\n * @param {Object} obj\n * @param {String} key\n * @return {Boolean}\n */\n\nfunction hasOwn(obj, key) {\n  return hasOwnProperty.call(obj, key);\n}\n\n/**\n * Check if an expression is a literal value.\n *\n * @param {String} exp\n * @return {Boolean}\n */\n\nvar literalValueRE = /^\\s?(true|false|-?[\\d\\.]+|'[^']*'|\"[^\"]*\")\\s?$/;\n\nfunction isLiteral(exp) {\n  return literalValueRE.test(exp);\n}\n\n/**\n * Check if a string starts with $ or _\n *\n * @param {String} str\n * @return {Boolean}\n */\n\nfunction isReserved(str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F;\n}\n\n/**\n * Guard text output, make sure undefined outputs\n * empty string\n *\n * @param {*} value\n * @return {String}\n */\n\nfunction _toString(value) {\n  return value == null ? '' : value.toString();\n}\n\n/**\n * Check and convert possible numeric strings to numbers\n * before setting back to data\n *\n * @param {*} value\n * @return {*|Number}\n */\n\nfunction toNumber(value) {\n  if (typeof value !== 'string') {\n    return value;\n  } else {\n    var parsed = Number(value);\n    return isNaN(parsed) ? value : parsed;\n  }\n}\n\n/**\n * Convert string boolean literals into real booleans.\n *\n * @param {*} value\n * @return {*|Boolean}\n */\n\nfunction toBoolean(value) {\n  return value === 'true' ? true : value === 'false' ? false : value;\n}\n\n/**\n * Strip quotes from a string\n *\n * @param {String} str\n * @return {String | false}\n */\n\nfunction stripQuotes(str) {\n  var a = str.charCodeAt(0);\n  var b = str.charCodeAt(str.length - 1);\n  return a === b && (a === 0x22 || a === 0x27) ? str.slice(1, -1) : str;\n}\n\n/**\n * Camelize a hyphen-delmited string.\n *\n * @param {String} str\n * @return {String}\n */\n\nvar camelizeRE = /-(\\w)/g;\n\nfunction camelize(str) {\n  return str.replace(camelizeRE, toUpper);\n}\n\nfunction toUpper(_, c) {\n  return c ? c.toUpperCase() : '';\n}\n\n/**\n * Hyphenate a camelCase string.\n *\n * @param {String} str\n * @return {String}\n */\n\nvar hyphenateRE = /([a-z\\d])([A-Z])/g;\n\nfunction hyphenate(str) {\n  return str.replace(hyphenateRE, '$1-$2').toLowerCase();\n}\n\n/**\n * Converts hyphen/underscore/slash delimitered names into\n * camelized classNames.\n *\n * e.g. my-component => MyComponent\n *      some_else    => SomeElse\n *      some/comp    => SomeComp\n *\n * @param {String} str\n * @return {String}\n */\n\nvar classifyRE = /(?:^|[-_\\/])(\\w)/g;\n\nfunction classify(str) {\n  return str.replace(classifyRE, toUpper);\n}\n\n/**\n * Simple bind, faster than native\n *\n * @param {Function} fn\n * @param {Object} ctx\n * @return {Function}\n */\n\nfunction bind(fn, ctx) {\n  return function (a) {\n    var l = arguments.length;\n    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);\n  };\n}\n\n/**\n * Convert an Array-like object to a real Array.\n *\n * @param {Array-like} list\n * @param {Number} [start] - start index\n * @return {Array}\n */\n\nfunction toArray(list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret;\n}\n\n/**\n * Mix properties into target object.\n *\n * @param {Object} to\n * @param {Object} from\n */\n\nfunction extend(to, from) {\n  var keys = Object.keys(from);\n  var i = keys.length;\n  while (i--) {\n    to[keys[i]] = from[keys[i]];\n  }\n  return to;\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n *\n * @param {*} obj\n * @return {Boolean}\n */\n\nfunction isObject(obj) {\n  return obj !== null && typeof obj === 'object';\n}\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n *\n * @param {*} obj\n * @return {Boolean}\n */\n\nvar toString = Object.prototype.toString;\nvar OBJECT_STRING = '[object Object]';\n\nfunction isPlainObject(obj) {\n  return toString.call(obj) === OBJECT_STRING;\n}\n\n/**\n * Array type check.\n *\n * @param {*} obj\n * @return {Boolean}\n */\n\nvar isArray = Array.isArray;\n\n/**\n * Define a property.\n *\n * @param {Object} obj\n * @param {String} key\n * @param {*} val\n * @param {Boolean} [enumerable]\n */\n\nfunction def(obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Debounce a function so it only gets called after the\n * input stops arriving after the given wait period.\n *\n * @param {Function} func\n * @param {Number} wait\n * @return {Function} - the debounced function\n */\n\nfunction _debounce(func, wait) {\n  var timeout, args, context, timestamp, result;\n  var later = function later() {\n    var last = Date.now() - timestamp;\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    }\n  };\n  return function () {\n    context = this;\n    args = arguments;\n    timestamp = Date.now();\n    if (!timeout) {\n      timeout = setTimeout(later, wait);\n    }\n    return result;\n  };\n}\n\n/**\n * Manual indexOf because it's slightly faster than\n * native.\n *\n * @param {Array} arr\n * @param {*} obj\n */\n\nfunction indexOf(arr, obj) {\n  var i = arr.length;\n  while (i--) {\n    if (arr[i] === obj) return i;\n  }\n  return -1;\n}\n\n/**\n * Make a cancellable version of an async callback.\n *\n * @param {Function} fn\n * @return {Function}\n */\n\nfunction cancellable(fn) {\n  var cb = function cb() {\n    if (!cb.cancelled) {\n      return fn.apply(this, arguments);\n    }\n  };\n  cb.cancel = function () {\n    cb.cancelled = true;\n  };\n  return cb;\n}\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n *\n * @param {*} a\n * @param {*} b\n * @return {Boolean}\n */\n\nfunction looseEqual(a, b) {\n  /* eslint-disable eqeqeq */\n  return a == b || (isObject(a) && isObject(b) ? JSON.stringify(a) === JSON.stringify(b) : false);\n  /* eslint-enable eqeqeq */\n}\n\nvar hasProto = ('__proto__' in {});\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined' && Object.prototype.toString.call(window) !== '[object Object]';\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n// UA sniffing for working around browser-specific quirks\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && UA.indexOf('trident') > 0;\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isAndroid = UA && UA.indexOf('android') > 0;\nvar isIos = UA && /(iphone|ipad|ipod|ios)/i.test(UA);\nvar iosVersionMatch = isIos && UA.match(/os ([\\d_]+)/);\nvar iosVersion = iosVersionMatch && iosVersionMatch[1].split('_');\n\n// detecting iOS UIWebView by indexedDB\nvar hasMutationObserverBug = iosVersion && Number(iosVersion[0]) >= 9 && Number(iosVersion[1]) >= 3 && !window.indexedDB;\n\nvar transitionProp = undefined;\nvar transitionEndEvent = undefined;\nvar animationProp = undefined;\nvar animationEndEvent = undefined;\n\n// Transition property/event sniffing\nif (inBrowser && !isIE9) {\n  var isWebkitTrans = window.ontransitionend === undefined && window.onwebkittransitionend !== undefined;\n  var isWebkitAnim = window.onanimationend === undefined && window.onwebkitanimationend !== undefined;\n  transitionProp = isWebkitTrans ? 'WebkitTransition' : 'transition';\n  transitionEndEvent = isWebkitTrans ? 'webkitTransitionEnd' : 'transitionend';\n  animationProp = isWebkitAnim ? 'WebkitAnimation' : 'animation';\n  animationEndEvent = isWebkitAnim ? 'webkitAnimationEnd' : 'animationend';\n}\n\n/**\n * Defer a task to execute it asynchronously. Ideally this\n * should be executed as a microtask, so we leverage\n * MutationObserver if it's available, and fallback to\n * setTimeout(0).\n *\n * @param {Function} cb\n * @param {Object} ctx\n */\n\nvar nextTick = (function () {\n  var callbacks = [];\n  var pending = false;\n  var timerFunc;\n  function nextTickHandler() {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks = [];\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  }\n\n  /* istanbul ignore if */\n  if (typeof MutationObserver !== 'undefined' && !hasMutationObserverBug) {\n    var counter = 1;\n    var observer = new MutationObserver(nextTickHandler);\n    var textNode = document.createTextNode(counter);\n    observer.observe(textNode, {\n      characterData: true\n    });\n    timerFunc = function () {\n      counter = (counter + 1) % 2;\n      textNode.data = counter;\n    };\n  } else {\n    // webpack attempts to inject a shim for setImmediate\n    // if it is used as a global, so we have to work around that to\n    // avoid bundling unnecessary code.\n    var context = inBrowser ? window : typeof global !== 'undefined' ? global : {};\n    timerFunc = context.setImmediate || setTimeout;\n  }\n  return function (cb, ctx) {\n    var func = ctx ? function () {\n      cb.call(ctx);\n    } : cb;\n    callbacks.push(func);\n    if (pending) return;\n    pending = true;\n    timerFunc(nextTickHandler, 0);\n  };\n})();\n\nvar _Set = undefined;\n/* istanbul ignore if */\nif (typeof Set !== 'undefined' && Set.toString().match(/native code/)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = function () {\n    this.set = Object.create(null);\n  };\n  _Set.prototype.has = function (key) {\n    return this.set[key] !== undefined;\n  };\n  _Set.prototype.add = function (key) {\n    this.set[key] = 1;\n  };\n  _Set.prototype.clear = function () {\n    this.set = Object.create(null);\n  };\n}\n\nfunction Cache(limit) {\n  this.size = 0;\n  this.limit = limit;\n  this.head = this.tail = undefined;\n  this._keymap = Object.create(null);\n}\n\nvar p = Cache.prototype;\n\n/**\n * Put <value> into the cache associated with <key>.\n * Returns the entry which was removed to make room for\n * the new entry. Otherwise undefined is returned.\n * (i.e. if there was enough room already).\n *\n * @param {String} key\n * @param {*} value\n * @return {Entry|undefined}\n */\n\np.put = function (key, value) {\n  var removed;\n\n  var entry = this.get(key, true);\n  if (!entry) {\n    if (this.size === this.limit) {\n      removed = this.shift();\n    }\n    entry = {\n      key: key\n    };\n    this._keymap[key] = entry;\n    if (this.tail) {\n      this.tail.newer = entry;\n      entry.older = this.tail;\n    } else {\n      this.head = entry;\n    }\n    this.tail = entry;\n    this.size++;\n  }\n  entry.value = value;\n\n  return removed;\n};\n\n/**\n * Purge the least recently used (oldest) entry from the\n * cache. Returns the removed entry or undefined if the\n * cache was empty.\n */\n\np.shift = function () {\n  var entry = this.head;\n  if (entry) {\n    this.head = this.head.newer;\n    this.head.older = undefined;\n    entry.newer = entry.older = undefined;\n    this._keymap[entry.key] = undefined;\n    this.size--;\n  }\n  return entry;\n};\n\n/**\n * Get and register recent use of <key>. Returns the value\n * associated with <key> or undefined if not in cache.\n *\n * @param {String} key\n * @param {Boolean} returnEntry\n * @return {Entry|*}\n */\n\np.get = function (key, returnEntry) {\n  var entry = this._keymap[key];\n  if (entry === undefined) return;\n  if (entry === this.tail) {\n    return returnEntry ? entry : entry.value;\n  }\n  // HEAD--------------TAIL\n  //   <.older   .newer>\n  //  <--- add direction --\n  //   A  B  C  <D>  E\n  if (entry.newer) {\n    if (entry === this.head) {\n      this.head = entry.newer;\n    }\n    entry.newer.older = entry.older; // C <-- E.\n  }\n  if (entry.older) {\n    entry.older.newer = entry.newer; // C. --> E\n  }\n  entry.newer = undefined; // D --x\n  entry.older = this.tail; // D. --> E\n  if (this.tail) {\n    this.tail.newer = entry; // E. <-- D\n  }\n  this.tail = entry;\n  return returnEntry ? entry : entry.value;\n};\n\nvar cache$1 = new Cache(1000);\nvar filterTokenRE = /[^\\s'\"]+|'[^']*'|\"[^\"]*\"/g;\nvar reservedArgRE = /^in$|^-?\\d+/;\n\n/**\n * Parser state\n */\n\nvar str;\nvar dir;\nvar c;\nvar prev;\nvar i;\nvar l;\nvar lastFilterIndex;\nvar inSingle;\nvar inDouble;\nvar curly;\nvar square;\nvar paren;\n/**\n * Push a filter to the current directive object\n */\n\nfunction pushFilter() {\n  var exp = str.slice(lastFilterIndex, i).trim();\n  var filter;\n  if (exp) {\n    filter = {};\n    var tokens = exp.match(filterTokenRE);\n    filter.name = tokens[0];\n    if (tokens.length > 1) {\n      filter.args = tokens.slice(1).map(processFilterArg);\n    }\n  }\n  if (filter) {\n    (dir.filters = dir.filters || []).push(filter);\n  }\n  lastFilterIndex = i + 1;\n}\n\n/**\n * Check if an argument is dynamic and strip quotes.\n *\n * @param {String} arg\n * @return {Object}\n */\n\nfunction processFilterArg(arg) {\n  if (reservedArgRE.test(arg)) {\n    return {\n      value: toNumber(arg),\n      dynamic: false\n    };\n  } else {\n    var stripped = stripQuotes(arg);\n    var dynamic = stripped === arg;\n    return {\n      value: dynamic ? arg : stripped,\n      dynamic: dynamic\n    };\n  }\n}\n\n/**\n * Parse a directive value and extract the expression\n * and its filters into a descriptor.\n *\n * Example:\n *\n * \"a + 1 | uppercase\" will yield:\n * {\n *   expression: 'a + 1',\n *   filters: [\n *     { name: 'uppercase', args: null }\n *   ]\n * }\n *\n * @param {String} s\n * @return {Object}\n */\n\nfunction parseDirective(s) {\n  var hit = cache$1.get(s);\n  if (hit) {\n    return hit;\n  }\n\n  // reset parser state\n  str = s;\n  inSingle = inDouble = false;\n  curly = square = paren = 0;\n  lastFilterIndex = 0;\n  dir = {};\n\n  for (i = 0, l = str.length; i < l; i++) {\n    prev = c;\n    c = str.charCodeAt(i);\n    if (inSingle) {\n      // check single quote\n      if (c === 0x27 && prev !== 0x5C) inSingle = !inSingle;\n    } else if (inDouble) {\n      // check double quote\n      if (c === 0x22 && prev !== 0x5C) inDouble = !inDouble;\n    } else if (c === 0x7C && // pipe\n    str.charCodeAt(i + 1) !== 0x7C && str.charCodeAt(i - 1) !== 0x7C) {\n      if (dir.expression == null) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1;\n        dir.expression = str.slice(0, i).trim();\n      } else {\n        // already has filter\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 0x22:\n          inDouble = true;break; // \"\n        case 0x27:\n          inSingle = true;break; // '\n        case 0x28:\n          paren++;break; // (\n        case 0x29:\n          paren--;break; // )\n        case 0x5B:\n          square++;break; // [\n        case 0x5D:\n          square--;break; // ]\n        case 0x7B:\n          curly++;break; // {\n        case 0x7D:\n          curly--;break; // }\n      }\n    }\n  }\n\n  if (dir.expression == null) {\n    dir.expression = str.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n\n  cache$1.put(s, dir);\n  return dir;\n}\n\nvar directive = Object.freeze({\n  parseDirective: parseDirective\n});\n\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\nvar cache = undefined;\nvar tagRE = undefined;\nvar htmlRE = undefined;\n/**\n * Escape a string so it can be used in a RegExp\n * constructor.\n *\n * @param {String} str\n */\n\nfunction escapeRegex(str) {\n  return str.replace(regexEscapeRE, '\\\\$&');\n}\n\nfunction compileRegex() {\n  var open = escapeRegex(config.delimiters[0]);\n  var close = escapeRegex(config.delimiters[1]);\n  var unsafeOpen = escapeRegex(config.unsafeDelimiters[0]);\n  var unsafeClose = escapeRegex(config.unsafeDelimiters[1]);\n  tagRE = new RegExp(unsafeOpen + '((?:.|\\\\n)+?)' + unsafeClose + '|' + open + '((?:.|\\\\n)+?)' + close, 'g');\n  htmlRE = new RegExp('^' + unsafeOpen + '((?:.|\\\\n)+?)' + unsafeClose + '$');\n  // reset cache\n  cache = new Cache(1000);\n}\n\n/**\n * Parse a template text string into an array of tokens.\n *\n * @param {String} text\n * @return {Array<Object> | null}\n *               - {String} type\n *               - {String} value\n *               - {Boolean} [html]\n *               - {Boolean} [oneTime]\n */\n\nfunction parseText(text) {\n  if (!cache) {\n    compileRegex();\n  }\n  var hit = cache.get(text);\n  if (hit) {\n    return hit;\n  }\n  if (!tagRE.test(text)) {\n    return null;\n  }\n  var tokens = [];\n  var lastIndex = tagRE.lastIndex = 0;\n  var match, index, html, value, first, oneTime;\n  /* eslint-disable no-cond-assign */\n  while (match = tagRE.exec(text)) {\n    /* eslint-enable no-cond-assign */\n    index = match.index;\n    // push text token\n    if (index > lastIndex) {\n      tokens.push({\n        value: text.slice(lastIndex, index)\n      });\n    }\n    // tag token\n    html = htmlRE.test(match[0]);\n    value = html ? match[1] : match[2];\n    first = value.charCodeAt(0);\n    oneTime = first === 42; // *\n    value = oneTime ? value.slice(1) : value;\n    tokens.push({\n      tag: true,\n      value: value.trim(),\n      html: html,\n      oneTime: oneTime\n    });\n    lastIndex = index + match[0].length;\n  }\n  if (lastIndex < text.length) {\n    tokens.push({\n      value: text.slice(lastIndex)\n    });\n  }\n  cache.put(text, tokens);\n  return tokens;\n}\n\n/**\n * Format a list of tokens into an expression.\n * e.g. tokens parsed from 'a {{b}} c' can be serialized\n * into one single expression as '\"a \" + b + \" c\"'.\n *\n * @param {Array} tokens\n * @param {Vue} [vm]\n * @return {String}\n */\n\nfunction tokensToExp(tokens, vm) {\n  if (tokens.length > 1) {\n    return tokens.map(function (token) {\n      return formatToken(token, vm);\n    }).join('+');\n  } else {\n    return formatToken(tokens[0], vm, true);\n  }\n}\n\n/**\n * Format a single token.\n *\n * @param {Object} token\n * @param {Vue} [vm]\n * @param {Boolean} [single]\n * @return {String}\n */\n\nfunction formatToken(token, vm, single) {\n  return token.tag ? token.oneTime && vm ? '\"' + vm.$eval(token.value) + '\"' : inlineFilters(token.value, single) : '\"' + token.value + '\"';\n}\n\n/**\n * For an attribute with multiple interpolation tags,\n * e.g. attr=\"some-{{thing | filter}}\", in order to combine\n * the whole thing into a single watchable expression, we\n * have to inline those filters. This function does exactly\n * that. This is a bit hacky but it avoids heavy changes\n * to directive parser and watcher mechanism.\n *\n * @param {String} exp\n * @param {Boolean} single\n * @return {String}\n */\n\nvar filterRE = /[^|]\\|[^|]/;\nfunction inlineFilters(exp, single) {\n  if (!filterRE.test(exp)) {\n    return single ? exp : '(' + exp + ')';\n  } else {\n    var dir = parseDirective(exp);\n    if (!dir.filters) {\n      return '(' + exp + ')';\n    } else {\n      return 'this._applyFilters(' + dir.expression + // value\n      ',null,' + // oldValue (null for read)\n      JSON.stringify(dir.filters) + // filter descriptors\n      ',false)'; // write?\n    }\n  }\n}\n\nvar text = Object.freeze({\n  compileRegex: compileRegex,\n  parseText: parseText,\n  tokensToExp: tokensToExp\n});\n\nvar delimiters = ['{{', '}}'];\nvar unsafeDelimiters = ['{{{', '}}}'];\n\nvar config = Object.defineProperties({\n\n  /**\n   * Whether to print debug messages.\n   * Also enables stack trace for warnings.\n   *\n   * @type {Boolean}\n   */\n\n  debug: false,\n\n  /**\n   * Whether to suppress warnings.\n   *\n   * @type {Boolean}\n   */\n\n  silent: false,\n\n  /**\n   * Whether to use async rendering.\n   */\n\n  async: true,\n\n  /**\n   * Whether to warn against errors caught when evaluating\n   * expressions.\n   */\n\n  warnExpressionErrors: true,\n\n  /**\n   * Whether to allow devtools inspection.\n   * Disabled by default in production builds.\n   */\n\n  devtools: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Internal flag to indicate the delimiters have been\n   * changed.\n   *\n   * @type {Boolean}\n   */\n\n  _delimitersChanged: true,\n\n  /**\n   * List of asset types that a component can own.\n   *\n   * @type {Array}\n   */\n\n  _assetTypes: ['component', 'directive', 'elementDirective', 'filter', 'transition', 'partial'],\n\n  /**\n   * prop binding modes\n   */\n\n  _propBindingModes: {\n    ONE_WAY: 0,\n    TWO_WAY: 1,\n    ONE_TIME: 2\n  },\n\n  /**\n   * Max circular updates allowed in a batcher flush cycle.\n   */\n\n  _maxUpdateCount: 100\n\n}, {\n  delimiters: { /**\n                 * Interpolation delimiters. Changing these would trigger\n                 * the text parser to re-compile the regular expressions.\n                 *\n                 * @type {Array<String>}\n                 */\n\n    get: function get() {\n      return delimiters;\n    },\n    set: function set(val) {\n      delimiters = val;\n      compileRegex();\n    },\n    configurable: true,\n    enumerable: true\n  },\n  unsafeDelimiters: {\n    get: function get() {\n      return unsafeDelimiters;\n    },\n    set: function set(val) {\n      unsafeDelimiters = val;\n      compileRegex();\n    },\n    configurable: true,\n    enumerable: true\n  }\n});\n\nvar warn = undefined;\nvar formatComponentName = undefined;\n\nif (process.env.NODE_ENV !== 'production') {\n  (function () {\n    var hasConsole = typeof console !== 'undefined';\n\n    warn = function (msg, vm) {\n      if (hasConsole && !config.silent) {\n        console.error('[Vue warn]: ' + msg + (vm ? formatComponentName(vm) : ''));\n      }\n    };\n\n    formatComponentName = function (vm) {\n      var name = vm._isVue ? vm.$options.name : vm.name;\n      return name ? ' (found in component: <' + hyphenate(name) + '>)' : '';\n    };\n  })();\n}\n\n/**\n * Append with transition.\n *\n * @param {Element} el\n * @param {Element} target\n * @param {Vue} vm\n * @param {Function} [cb]\n */\n\nfunction appendWithTransition(el, target, vm, cb) {\n  applyTransition(el, 1, function () {\n    target.appendChild(el);\n  }, vm, cb);\n}\n\n/**\n * InsertBefore with transition.\n *\n * @param {Element} el\n * @param {Element} target\n * @param {Vue} vm\n * @param {Function} [cb]\n */\n\nfunction beforeWithTransition(el, target, vm, cb) {\n  applyTransition(el, 1, function () {\n    before(el, target);\n  }, vm, cb);\n}\n\n/**\n * Remove with transition.\n *\n * @param {Element} el\n * @param {Vue} vm\n * @param {Function} [cb]\n */\n\nfunction removeWithTransition(el, vm, cb) {\n  applyTransition(el, -1, function () {\n    remove(el);\n  }, vm, cb);\n}\n\n/**\n * Apply transitions with an operation callback.\n *\n * @param {Element} el\n * @param {Number} direction\n *                  1: enter\n *                 -1: leave\n * @param {Function} op - the actual DOM operation\n * @param {Vue} vm\n * @param {Function} [cb]\n */\n\nfunction applyTransition(el, direction, op, vm, cb) {\n  var transition = el.__v_trans;\n  if (!transition ||\n  // skip if there are no js hooks and CSS transition is\n  // not supported\n  !transition.hooks && !transitionEndEvent ||\n  // skip transitions for initial compile\n  !vm._isCompiled ||\n  // if the vm is being manipulated by a parent directive\n  // during the parent's compilation phase, skip the\n  // animation.\n  vm.$parent && !vm.$parent._isCompiled) {\n    op();\n    if (cb) cb();\n    return;\n  }\n  var action = direction > 0 ? 'enter' : 'leave';\n  transition[action](op, cb);\n}\n\nvar transition = Object.freeze({\n  appendWithTransition: appendWithTransition,\n  beforeWithTransition: beforeWithTransition,\n  removeWithTransition: removeWithTransition,\n  applyTransition: applyTransition\n});\n\n/**\n * Query an element selector if it's not an element already.\n *\n * @param {String|Element} el\n * @return {Element}\n */\n\nfunction query(el) {\n  if (typeof el === 'string') {\n    var selector = el;\n    el = document.querySelector(el);\n    if (!el) {\n      process.env.NODE_ENV !== 'production' && warn('Cannot find element: ' + selector);\n    }\n  }\n  return el;\n}\n\n/**\n * Check if a node is in the document.\n * Note: document.documentElement.contains should work here\n * but always returns false for comment nodes in phantomjs,\n * making unit tests difficult. This is fixed by doing the\n * contains() check on the node's parentNode instead of\n * the node itself.\n *\n * @param {Node} node\n * @return {Boolean}\n */\n\nfunction inDoc(node) {\n  if (!node) return false;\n  var doc = node.ownerDocument.documentElement;\n  var parent = node.parentNode;\n  return doc === node || doc === parent || !!(parent && parent.nodeType === 1 && doc.contains(parent));\n}\n\n/**\n * Get and remove an attribute from a node.\n *\n * @param {Node} node\n * @param {String} _attr\n */\n\nfunction getAttr(node, _attr) {\n  var val = node.getAttribute(_attr);\n  if (val !== null) {\n    node.removeAttribute(_attr);\n  }\n  return val;\n}\n\n/**\n * Get an attribute with colon or v-bind: prefix.\n *\n * @param {Node} node\n * @param {String} name\n * @return {String|null}\n */\n\nfunction getBindAttr(node, name) {\n  var val = getAttr(node, ':' + name);\n  if (val === null) {\n    val = getAttr(node, 'v-bind:' + name);\n  }\n  return val;\n}\n\n/**\n * Check the presence of a bind attribute.\n *\n * @param {Node} node\n * @param {String} name\n * @return {Boolean}\n */\n\nfunction hasBindAttr(node, name) {\n  return node.hasAttribute(name) || node.hasAttribute(':' + name) || node.hasAttribute('v-bind:' + name);\n}\n\n/**\n * Insert el before target\n *\n * @param {Element} el\n * @param {Element} target\n */\n\nfunction before(el, target) {\n  target.parentNode.insertBefore(el, target);\n}\n\n/**\n * Insert el after target\n *\n * @param {Element} el\n * @param {Element} target\n */\n\nfunction after(el, target) {\n  if (target.nextSibling) {\n    before(el, target.nextSibling);\n  } else {\n    target.parentNode.appendChild(el);\n  }\n}\n\n/**\n * Remove el from DOM\n *\n * @param {Element} el\n */\n\nfunction remove(el) {\n  el.parentNode.removeChild(el);\n}\n\n/**\n * Prepend el to target\n *\n * @param {Element} el\n * @param {Element} target\n */\n\nfunction prepend(el, target) {\n  if (target.firstChild) {\n    before(el, target.firstChild);\n  } else {\n    target.appendChild(el);\n  }\n}\n\n/**\n * Replace target with el\n *\n * @param {Element} target\n * @param {Element} el\n */\n\nfunction replace(target, el) {\n  var parent = target.parentNode;\n  if (parent) {\n    parent.replaceChild(el, target);\n  }\n}\n\n/**\n * Add event listener shorthand.\n *\n * @param {Element} el\n * @param {String} event\n * @param {Function} cb\n * @param {Boolean} [useCapture]\n */\n\nfunction on(el, event, cb, useCapture) {\n  el.addEventListener(event, cb, useCapture);\n}\n\n/**\n * Remove event listener shorthand.\n *\n * @param {Element} el\n * @param {String} event\n * @param {Function} cb\n */\n\nfunction off(el, event, cb) {\n  el.removeEventListener(event, cb);\n}\n\n/**\n * For IE9 compat: when both class and :class are present\n * getAttribute('class') returns wrong value...\n *\n * @param {Element} el\n * @return {String}\n */\n\nfunction getClass(el) {\n  var classname = el.className;\n  if (typeof classname === 'object') {\n    classname = classname.baseVal || '';\n  }\n  return classname;\n}\n\n/**\n * In IE9, setAttribute('class') will result in empty class\n * if the element also has the :class attribute; However in\n * PhantomJS, setting `className` does not work on SVG elements...\n * So we have to do a conditional check here.\n *\n * @param {Element} el\n * @param {String} cls\n */\n\nfunction setClass(el, cls) {\n  /* istanbul ignore if */\n  if (isIE9 && !/svg$/.test(el.namespaceURI)) {\n    el.className = cls;\n  } else {\n    el.setAttribute('class', cls);\n  }\n}\n\n/**\n * Add class with compatibility for IE & SVG\n *\n * @param {Element} el\n * @param {String} cls\n */\n\nfunction addClass(el, cls) {\n  if (el.classList) {\n    el.classList.add(cls);\n  } else {\n    var cur = ' ' + getClass(el) + ' ';\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      setClass(el, (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for IE & SVG\n *\n * @param {Element} el\n * @param {String} cls\n */\n\nfunction removeClass(el, cls) {\n  if (el.classList) {\n    el.classList.remove(cls);\n  } else {\n    var cur = ' ' + getClass(el) + ' ';\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    setClass(el, cur.trim());\n  }\n  if (!el.className) {\n    el.removeAttribute('class');\n  }\n}\n\n/**\n * Extract raw content inside an element into a temporary\n * container div\n *\n * @param {Element} el\n * @param {Boolean} asFragment\n * @return {Element|DocumentFragment}\n */\n\nfunction extractContent(el, asFragment) {\n  var child;\n  var rawContent;\n  /* istanbul ignore if */\n  if (isTemplate(el) && isFragment(el.content)) {\n    el = el.content;\n  }\n  if (el.hasChildNodes()) {\n    trimNode(el);\n    rawContent = asFragment ? document.createDocumentFragment() : document.createElement('div');\n    /* eslint-disable no-cond-assign */\n    while (child = el.firstChild) {\n      /* eslint-enable no-cond-assign */\n      rawContent.appendChild(child);\n    }\n  }\n  return rawContent;\n}\n\n/**\n * Trim possible empty head/tail text and comment\n * nodes inside a parent.\n *\n * @param {Node} node\n */\n\nfunction trimNode(node) {\n  var child;\n  /* eslint-disable no-sequences */\n  while ((child = node.firstChild, isTrimmable(child))) {\n    node.removeChild(child);\n  }\n  while ((child = node.lastChild, isTrimmable(child))) {\n    node.removeChild(child);\n  }\n  /* eslint-enable no-sequences */\n}\n\nfunction isTrimmable(node) {\n  return node && (node.nodeType === 3 && !node.data.trim() || node.nodeType === 8);\n}\n\n/**\n * Check if an element is a template tag.\n * Note if the template appears inside an SVG its tagName\n * will be in lowercase.\n *\n * @param {Element} el\n */\n\nfunction isTemplate(el) {\n  return el.tagName && el.tagName.toLowerCase() === 'template';\n}\n\n/**\n * Create an \"anchor\" for performing dom insertion/removals.\n * This is used in a number of scenarios:\n * - fragment instance\n * - v-html\n * - v-if\n * - v-for\n * - component\n *\n * @param {String} content\n * @param {Boolean} persist - IE trashes empty textNodes on\n *                            cloneNode(true), so in certain\n *                            cases the anchor needs to be\n *                            non-empty to be persisted in\n *                            templates.\n * @return {Comment|Text}\n */\n\nfunction createAnchor(content, persist) {\n  var anchor = config.debug ? document.createComment(content) : document.createTextNode(persist ? ' ' : '');\n  anchor.__v_anchor = true;\n  return anchor;\n}\n\n/**\n * Find a component ref attribute that starts with $.\n *\n * @param {Element} node\n * @return {String|undefined}\n */\n\nvar refRE = /^v-ref:/;\n\nfunction findRef(node) {\n  if (node.hasAttributes()) {\n    var attrs = node.attributes;\n    for (var i = 0, l = attrs.length; i < l; i++) {\n      var name = attrs[i].name;\n      if (refRE.test(name)) {\n        return camelize(name.replace(refRE, ''));\n      }\n    }\n  }\n}\n\n/**\n * Map a function to a range of nodes .\n *\n * @param {Node} node\n * @param {Node} end\n * @param {Function} op\n */\n\nfunction mapNodeRange(node, end, op) {\n  var next;\n  while (node !== end) {\n    next = node.nextSibling;\n    op(node);\n    node = next;\n  }\n  op(end);\n}\n\n/**\n * Remove a range of nodes with transition, store\n * the nodes in a fragment with correct ordering,\n * and call callback when done.\n *\n * @param {Node} start\n * @param {Node} end\n * @param {Vue} vm\n * @param {DocumentFragment} frag\n * @param {Function} cb\n */\n\nfunction removeNodeRange(start, end, vm, frag, cb) {\n  var done = false;\n  var removed = 0;\n  var nodes = [];\n  mapNodeRange(start, end, function (node) {\n    if (node === end) done = true;\n    nodes.push(node);\n    removeWithTransition(node, vm, onRemoved);\n  });\n  function onRemoved() {\n    removed++;\n    if (done && removed >= nodes.length) {\n      for (var i = 0; i < nodes.length; i++) {\n        frag.appendChild(nodes[i]);\n      }\n      cb && cb();\n    }\n  }\n}\n\n/**\n * Check if a node is a DocumentFragment.\n *\n * @param {Node} node\n * @return {Boolean}\n */\n\nfunction isFragment(node) {\n  return node && node.nodeType === 11;\n}\n\n/**\n * Get outerHTML of elements, taking care\n * of SVG elements in IE as well.\n *\n * @param {Element} el\n * @return {String}\n */\n\nfunction getOuterHTML(el) {\n  if (el.outerHTML) {\n    return el.outerHTML;\n  } else {\n    var container = document.createElement('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML;\n  }\n}\n\nvar commonTagRE = /^(div|p|span|img|a|b|i|br|ul|ol|li|h1|h2|h3|h4|h5|h6|code|pre|table|th|td|tr|form|label|input|select|option|nav|article|section|header|footer)$/i;\nvar reservedTagRE = /^(slot|partial|component)$/i;\n\nvar isUnknownElement = undefined;\nif (process.env.NODE_ENV !== 'production') {\n  isUnknownElement = function (el, tag) {\n    if (tag.indexOf('-') > -1) {\n      // http://stackoverflow.com/a/28210364/1070244\n      return el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;\n    } else {\n      return (/HTMLUnknownElement/.test(el.toString()) &&\n        // Chrome returns unknown for several HTML5 elements.\n        // https://code.google.com/p/chromium/issues/detail?id=540526\n        // Firefox returns unknown for some \"Interactive elements.\"\n        !/^(data|time|rtc|rb|details|dialog|summary)$/.test(tag)\n      );\n    }\n  };\n}\n\n/**\n * Check if an element is a component, if yes return its\n * component id.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Object|undefined}\n */\n\nfunction checkComponentAttr(el, options) {\n  var tag = el.tagName.toLowerCase();\n  var hasAttrs = el.hasAttributes();\n  if (!commonTagRE.test(tag) && !reservedTagRE.test(tag)) {\n    if (resolveAsset(options, 'components', tag)) {\n      return { id: tag };\n    } else {\n      var is = hasAttrs && getIsBinding(el, options);\n      if (is) {\n        return is;\n      } else if (process.env.NODE_ENV !== 'production') {\n        var expectedTag = options._componentNameMap && options._componentNameMap[tag];\n        if (expectedTag) {\n          warn('Unknown custom element: <' + tag + '> - ' + 'did you mean <' + expectedTag + '>? ' + 'HTML is case-insensitive, remember to use kebab-case in templates.');\n        } else if (isUnknownElement(el, tag)) {\n          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the \"name\" option.');\n        }\n      }\n    }\n  } else if (hasAttrs) {\n    return getIsBinding(el, options);\n  }\n}\n\n/**\n * Get \"is\" binding from an element.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Object|undefined}\n */\n\nfunction getIsBinding(el, options) {\n  // dynamic syntax\n  var exp = el.getAttribute('is');\n  if (exp != null) {\n    if (resolveAsset(options, 'components', exp)) {\n      el.removeAttribute('is');\n      return { id: exp };\n    }\n  } else {\n    exp = getBindAttr(el, 'is');\n    if (exp != null) {\n      return { id: exp, dynamic: true };\n    }\n  }\n}\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n *\n * All strategy functions follow the same signature:\n *\n * @param {*} parentVal\n * @param {*} childVal\n * @param {Vue} [vm]\n */\n\nvar strats = config.optionMergeStrategies = Object.create(null);\n\n/**\n * Helper that recursively merges two data objects together.\n */\n\nfunction mergeData(to, from) {\n  var key, toVal, fromVal;\n  for (key in from) {\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (isObject(toVal) && isObject(fromVal)) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to;\n}\n\n/**\n * Data\n */\n\nstrats.data = function (parentVal, childVal, vm) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal;\n    }\n    if (typeof childVal !== 'function') {\n      process.env.NODE_ENV !== 'production' && warn('The \"data\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);\n      return parentVal;\n    }\n    if (!parentVal) {\n      return childVal;\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn() {\n      return mergeData(childVal.call(this), parentVal.call(this));\n    };\n  } else if (parentVal || childVal) {\n    return function mergedInstanceDataFn() {\n      // instance merge\n      var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;\n      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData);\n      } else {\n        return defaultData;\n      }\n    };\n  }\n};\n\n/**\n * El\n */\n\nstrats.el = function (parentVal, childVal, vm) {\n  if (!vm && childVal && typeof childVal !== 'function') {\n    process.env.NODE_ENV !== 'production' && warn('The \"el\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);\n    return;\n  }\n  var ret = childVal || parentVal;\n  // invoke the element factory if this is instance merge\n  return vm && typeof ret === 'function' ? ret.call(vm) : ret;\n};\n\n/**\n * Hooks and param attributes are merged as arrays.\n */\n\nstrats.init = strats.created = strats.ready = strats.attached = strats.detached = strats.beforeCompile = strats.compiled = strats.beforeDestroy = strats.destroyed = strats.activate = function (parentVal, childVal) {\n  return childVal ? parentVal ? parentVal.concat(childVal) : isArray(childVal) ? childVal : [childVal] : parentVal;\n};\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\n\nfunction mergeAssets(parentVal, childVal) {\n  var res = Object.create(parentVal || null);\n  return childVal ? extend(res, guardArrayAssets(childVal)) : res;\n}\n\nconfig._assetTypes.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Events & Watchers.\n *\n * Events & watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\n\nstrats.watch = strats.events = function (parentVal, childVal) {\n  if (!childVal) return parentVal;\n  if (!parentVal) return childVal;\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key in childVal) {\n    var parent = ret[key];\n    var child = childVal[key];\n    if (parent && !isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key] = parent ? parent.concat(child) : [child];\n  }\n  return ret;\n};\n\n/**\n * Other object hashes.\n */\n\nstrats.props = strats.methods = strats.computed = function (parentVal, childVal) {\n  if (!childVal) return parentVal;\n  if (!parentVal) return childVal;\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  extend(ret, childVal);\n  return ret;\n};\n\n/**\n * Default strategy.\n */\n\nvar defaultStrat = function defaultStrat(parentVal, childVal) {\n  return childVal === undefined ? parentVal : childVal;\n};\n\n/**\n * Make sure component options get converted to actual\n * constructors.\n *\n * @param {Object} options\n */\n\nfunction guardComponents(options) {\n  if (options.components) {\n    var components = options.components = guardArrayAssets(options.components);\n    var ids = Object.keys(components);\n    var def;\n    if (process.env.NODE_ENV !== 'production') {\n      var map = options._componentNameMap = {};\n    }\n    for (var i = 0, l = ids.length; i < l; i++) {\n      var key = ids[i];\n      if (commonTagRE.test(key) || reservedTagRE.test(key)) {\n        process.env.NODE_ENV !== 'production' && warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);\n        continue;\n      }\n      // record a all lowercase <-> kebab-case mapping for\n      // possible custom element case error warning\n      if (process.env.NODE_ENV !== 'production') {\n        map[key.replace(/-/g, '').toLowerCase()] = hyphenate(key);\n      }\n      def = components[key];\n      if (isPlainObject(def)) {\n        components[key] = Vue.extend(def);\n      }\n    }\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n *\n * @param {Object} options\n */\n\nfunction guardProps(options) {\n  var props = options.props;\n  var i, val;\n  if (isArray(props)) {\n    options.props = {};\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        options.props[val] = null;\n      } else if (val.name) {\n        options.props[val.name] = val;\n      }\n    }\n  } else if (isPlainObject(props)) {\n    var keys = Object.keys(props);\n    i = keys.length;\n    while (i--) {\n      val = props[keys[i]];\n      if (typeof val === 'function') {\n        props[keys[i]] = { type: val };\n      }\n    }\n  }\n}\n\n/**\n * Guard an Array-format assets option and converted it\n * into the key-value Object format.\n *\n * @param {Object|Array} assets\n * @return {Object}\n */\n\nfunction guardArrayAssets(assets) {\n  if (isArray(assets)) {\n    var res = {};\n    var i = assets.length;\n    var asset;\n    while (i--) {\n      asset = assets[i];\n      var id = typeof asset === 'function' ? asset.options && asset.options.name || asset.id : asset.name || asset.id;\n      if (!id) {\n        process.env.NODE_ENV !== 'production' && warn('Array-syntax assets must provide a \"name\" or \"id\" field.');\n      } else {\n        res[id] = asset;\n      }\n    }\n    return res;\n  }\n  return assets;\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n *\n * @param {Object} parent\n * @param {Object} child\n * @param {Vue} [vm] - if vm is present, indicates this is\n *                     an instantiation merge.\n */\n\nfunction mergeOptions(parent, child, vm) {\n  guardComponents(child);\n  guardProps(child);\n  if (process.env.NODE_ENV !== 'production') {\n    if (child.propsData && !vm) {\n      warn('propsData can only be used as an instantiation option.');\n    }\n  }\n  var options = {};\n  var key;\n  if (child['extends']) {\n    parent = typeof child['extends'] === 'function' ? mergeOptions(parent, child['extends'].options, vm) : mergeOptions(parent, child['extends'], vm);\n  }\n  if (child.mixins) {\n    for (var i = 0, l = child.mixins.length; i < l; i++) {\n      var mixin = child.mixins[i];\n      var mixinOptions = mixin.prototype instanceof Vue ? mixin.options : mixin;\n      parent = mergeOptions(parent, mixinOptions, vm);\n    }\n  }\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField(key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options;\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n *\n * @param {Object} options\n * @param {String} type\n * @param {String} id\n * @param {Boolean} warnMissing\n * @return {Object|Function}\n */\n\nfunction resolveAsset(options, type, id, warnMissing) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return;\n  }\n  var assets = options[type];\n  var camelizedId;\n  var res = assets[id] ||\n  // camelCase ID\n  assets[camelizedId = camelize(id)] ||\n  // Pascal Case ID\n  assets[camelizedId.charAt(0).toUpperCase() + camelizedId.slice(1)];\n  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {\n    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);\n  }\n  return res;\n}\n\nvar uid$1 = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n *\n * @constructor\n */\nfunction Dep() {\n  this.id = uid$1++;\n  this.subs = [];\n}\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null;\n\n/**\n * Add a directive subscriber.\n *\n * @param {Directive} sub\n */\n\nDep.prototype.addSub = function (sub) {\n  this.subs.push(sub);\n};\n\n/**\n * Remove a directive subscriber.\n *\n * @param {Directive} sub\n */\n\nDep.prototype.removeSub = function (sub) {\n  this.subs.$remove(sub);\n};\n\n/**\n * Add self as a dependency to the target watcher.\n */\n\nDep.prototype.depend = function () {\n  Dep.target.addDep(this);\n};\n\n/**\n * Notify all subscribers of a new value.\n */\n\nDep.prototype.notify = function () {\n  // stablize the subscriber list first\n  var subs = toArray(this.subs);\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto)\n\n/**\n * Intercept mutating methods and emit events\n */\n\n;['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator() {\n    // avoid leaking arguments:\n    // http://jsperf.com/closure-with-arguments\n    var i = arguments.length;\n    var args = new Array(i);\n    while (i--) {\n      args[i] = arguments[i];\n    }\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n        inserted = args;\n        break;\n      case 'unshift':\n        inserted = args;\n        break;\n      case 'splice':\n        inserted = args.slice(2);\n        break;\n    }\n    if (inserted) ob.observeArray(inserted);\n    // notify change\n    ob.dep.notify();\n    return result;\n  });\n});\n\n/**\n * Swap the element at the given index with a new value\n * and emits corresponding event.\n *\n * @param {Number} index\n * @param {*} val\n * @return {*} - replaced element\n */\n\ndef(arrayProto, '$set', function $set(index, val) {\n  if (index >= this.length) {\n    this.length = Number(index) + 1;\n  }\n  return this.splice(index, 1, val)[0];\n});\n\n/**\n * Convenience method to remove the element at given index or target element reference.\n *\n * @param {*} item\n */\n\ndef(arrayProto, '$remove', function $remove(item) {\n  /* istanbul ignore if */\n  if (!this.length) return;\n  var index = indexOf(this, item);\n  if (index > -1) {\n    return this.splice(index, 1);\n  }\n});\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * By default, when a reactive property is set, the new value is\n * also converted to become reactive. However in certain cases, e.g.\n * v-for scope alias and props, we don't want to force conversion\n * because the value may be a nested value under a frozen data structure.\n *\n * So whenever we want to set a reactive property without forcing\n * conversion on the new value, we wrap that call inside this function.\n */\n\nvar shouldConvert = true;\n\nfunction withoutConversion(fn) {\n  shouldConvert = false;\n  fn();\n  shouldConvert = true;\n}\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n *\n * @param {Array|Object} value\n * @constructor\n */\n\nfunction Observer(value) {\n  this.value = value;\n  this.dep = new Dep();\n  def(value, '__ob__', this);\n  if (isArray(value)) {\n    var augment = hasProto ? protoAugment : copyAugment;\n    augment(value, arrayMethods, arrayKeys);\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n}\n\n// Instance methods\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n *\n * @param {Object} obj\n */\n\nObserver.prototype.walk = function (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0, l = keys.length; i < l; i++) {\n    this.convert(keys[i], obj[keys[i]]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n *\n * @param {Array} items\n */\n\nObserver.prototype.observeArray = function (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n/**\n * Convert a property into getter/setter so we can emit\n * the events when the property is accessed/changed.\n *\n * @param {String} key\n * @param {*} val\n */\n\nObserver.prototype.convert = function (key, val) {\n  defineReactive(this.value, key, val);\n};\n\n/**\n * Add an owner vm, so that when $set/$delete mutations\n * happen we can notify owner vms to proxy the keys and\n * digest the watchers. This is only called when the object\n * is observed as an instance's root $data.\n *\n * @param {Vue} vm\n */\n\nObserver.prototype.addVm = function (vm) {\n  (this.vms || (this.vms = [])).push(vm);\n};\n\n/**\n * Remove an owner vm. This is called when the object is\n * swapped out as an instance's $data object.\n *\n * @param {Vue} vm\n */\n\nObserver.prototype.removeVm = function (vm) {\n  this.vms.$remove(vm);\n};\n\n// helpers\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n *\n * @param {Object|Array} target\n * @param {Object} src\n */\n\nfunction protoAugment(target, src) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n *\n * @param {Object|Array} target\n * @param {Object} proto\n */\n\nfunction copyAugment(target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n *\n * @param {*} value\n * @param {Vue} [vm]\n * @return {Observer|undefined}\n * @static\n */\n\nfunction observe(value, vm) {\n  if (!value || typeof value !== 'object') {\n    return;\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (shouldConvert && (isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {\n    ob = new Observer(value);\n  }\n  if (ob && vm) {\n    ob.addVm(vm);\n  }\n  return ob;\n}\n\n/**\n * Define a reactive property on an Object.\n *\n * @param {Object} obj\n * @param {String} key\n * @param {*} val\n */\n\nfunction defineReactive(obj, key, val) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return;\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n\n  var childOb = observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter() {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n        }\n        if (isArray(value)) {\n          for (var e, i = 0, l = value.length; i < l; i++) {\n            e = value[i];\n            e && e.__ob__ && e.__ob__.dep.depend();\n          }\n        }\n      }\n      return value;\n    },\n    set: function reactiveSetter(newVal) {\n      var value = getter ? getter.call(obj) : val;\n      if (newVal === value) {\n        return;\n      }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n\n\nvar util = Object.freeze({\n\tdefineReactive: defineReactive,\n\tset: set,\n\tdel: del,\n\thasOwn: hasOwn,\n\tisLiteral: isLiteral,\n\tisReserved: isReserved,\n\t_toString: _toString,\n\ttoNumber: toNumber,\n\ttoBoolean: toBoolean,\n\tstripQuotes: stripQuotes,\n\tcamelize: camelize,\n\thyphenate: hyphenate,\n\tclassify: classify,\n\tbind: bind,\n\ttoArray: toArray,\n\textend: extend,\n\tisObject: isObject,\n\tisPlainObject: isPlainObject,\n\tdef: def,\n\tdebounce: _debounce,\n\tindexOf: indexOf,\n\tcancellable: cancellable,\n\tlooseEqual: looseEqual,\n\tisArray: isArray,\n\thasProto: hasProto,\n\tinBrowser: inBrowser,\n\tdevtools: devtools,\n\tisIE: isIE,\n\tisIE9: isIE9,\n\tisAndroid: isAndroid,\n\tisIos: isIos,\n\tiosVersionMatch: iosVersionMatch,\n\tiosVersion: iosVersion,\n\thasMutationObserverBug: hasMutationObserverBug,\n\tget transitionProp () { return transitionProp; },\n\tget transitionEndEvent () { return transitionEndEvent; },\n\tget animationProp () { return animationProp; },\n\tget animationEndEvent () { return animationEndEvent; },\n\tnextTick: nextTick,\n\tget _Set () { return _Set; },\n\tquery: query,\n\tinDoc: inDoc,\n\tgetAttr: getAttr,\n\tgetBindAttr: getBindAttr,\n\thasBindAttr: hasBindAttr,\n\tbefore: before,\n\tafter: after,\n\tremove: remove,\n\tprepend: prepend,\n\treplace: replace,\n\ton: on,\n\toff: off,\n\tsetClass: setClass,\n\taddClass: addClass,\n\tremoveClass: removeClass,\n\textractContent: extractContent,\n\ttrimNode: trimNode,\n\tisTemplate: isTemplate,\n\tcreateAnchor: createAnchor,\n\tfindRef: findRef,\n\tmapNodeRange: mapNodeRange,\n\tremoveNodeRange: removeNodeRange,\n\tisFragment: isFragment,\n\tgetOuterHTML: getOuterHTML,\n\tmergeOptions: mergeOptions,\n\tresolveAsset: resolveAsset,\n\tcheckComponentAttr: checkComponentAttr,\n\tcommonTagRE: commonTagRE,\n\treservedTagRE: reservedTagRE,\n\tget warn () { return warn; }\n});\n\nvar uid = 0;\n\nfunction initMixin (Vue) {\n  /**\n   * The main init sequence. This is called for every\n   * instance, including ones that are created from extended\n   * constructors.\n   *\n   * @param {Object} options - this options object should be\n   *                           the result of merging class\n   *                           options and the options passed\n   *                           in to the constructor.\n   */\n\n  Vue.prototype._init = function (options) {\n    options = options || {};\n\n    this.$el = null;\n    this.$parent = options.parent;\n    this.$root = this.$parent ? this.$parent.$root : this;\n    this.$children = [];\n    this.$refs = {}; // child vm references\n    this.$els = {}; // element references\n    this._watchers = []; // all watchers as an array\n    this._directives = []; // all directives\n\n    // a uid\n    this._uid = uid++;\n\n    // a flag to avoid this being observed\n    this._isVue = true;\n\n    // events bookkeeping\n    this._events = {}; // registered callbacks\n    this._eventsCount = {}; // for $broadcast optimization\n\n    // fragment instance properties\n    this._isFragment = false;\n    this._fragment = // @type {DocumentFragment}\n    this._fragmentStart = // @type {Text|Comment}\n    this._fragmentEnd = null; // @type {Text|Comment}\n\n    // lifecycle state\n    this._isCompiled = this._isDestroyed = this._isReady = this._isAttached = this._isBeingDestroyed = this._vForRemoving = false;\n    this._unlinkFn = null;\n\n    // context:\n    // if this is a transcluded component, context\n    // will be the common parent vm of this instance\n    // and its host.\n    this._context = options._context || this.$parent;\n\n    // scope:\n    // if this is inside an inline v-for, the scope\n    // will be the intermediate scope created for this\n    // repeat fragment. this is used for linking props\n    // and container directives.\n    this._scope = options._scope;\n\n    // fragment:\n    // if this instance is compiled inside a Fragment, it\n    // needs to reigster itself as a child of that fragment\n    // for attach/detach to work properly.\n    this._frag = options._frag;\n    if (this._frag) {\n      this._frag.children.push(this);\n    }\n\n    // push self into parent / transclusion host\n    if (this.$parent) {\n      this.$parent.$children.push(this);\n    }\n\n    // merge options.\n    options = this.$options = mergeOptions(this.constructor.options, options, this);\n\n    // set ref\n    this._updateRef();\n\n    // initialize data as empty object.\n    // it will be filled up in _initData().\n    this._data = {};\n\n    // call init hook\n    this._callHook('init');\n\n    // initialize data observation and scope inheritance.\n    this._initState();\n\n    // setup event system and option events.\n    this._initEvents();\n\n    // call created hook\n    this._callHook('created');\n\n    // if `el` option is passed, start compilation.\n    if (options.el) {\n      this.$mount(options.el);\n    }\n  };\n}\n\nvar pathCache = new Cache(1000);\n\n// actions\nvar APPEND = 0;\nvar PUSH = 1;\nvar INC_SUB_PATH_DEPTH = 2;\nvar PUSH_SUB_PATH = 3;\n\n// states\nvar BEFORE_PATH = 0;\nvar IN_PATH = 1;\nvar BEFORE_IDENT = 2;\nvar IN_IDENT = 3;\nvar IN_SUB_PATH = 4;\nvar IN_SINGLE_QUOTE = 5;\nvar IN_DOUBLE_QUOTE = 6;\nvar AFTER_PATH = 7;\nvar ERROR = 8;\n\nvar pathStateMachine = [];\n\npathStateMachine[BEFORE_PATH] = {\n  'ws': [BEFORE_PATH],\n  'ident': [IN_IDENT, APPEND],\n  '[': [IN_SUB_PATH],\n  'eof': [AFTER_PATH]\n};\n\npathStateMachine[IN_PATH] = {\n  'ws': [IN_PATH],\n  '.': [BEFORE_IDENT],\n  '[': [IN_SUB_PATH],\n  'eof': [AFTER_PATH]\n};\n\npathStateMachine[BEFORE_IDENT] = {\n  'ws': [BEFORE_IDENT],\n  'ident': [IN_IDENT, APPEND]\n};\n\npathStateMachine[IN_IDENT] = {\n  'ident': [IN_IDENT, APPEND],\n  '0': [IN_IDENT, APPEND],\n  'number': [IN_IDENT, APPEND],\n  'ws': [IN_PATH, PUSH],\n  '.': [BEFORE_IDENT, PUSH],\n  '[': [IN_SUB_PATH, PUSH],\n  'eof': [AFTER_PATH, PUSH]\n};\n\npathStateMachine[IN_SUB_PATH] = {\n  \"'\": [IN_SINGLE_QUOTE, APPEND],\n  '\"': [IN_DOUBLE_QUOTE, APPEND],\n  '[': [IN_SUB_PATH, INC_SUB_PATH_DEPTH],\n  ']': [IN_PATH, PUSH_SUB_PATH],\n  'eof': ERROR,\n  'else': [IN_SUB_PATH, APPEND]\n};\n\npathStateMachine[IN_SINGLE_QUOTE] = {\n  \"'\": [IN_SUB_PATH, APPEND],\n  'eof': ERROR,\n  'else': [IN_SINGLE_QUOTE, APPEND]\n};\n\npathStateMachine[IN_DOUBLE_QUOTE] = {\n  '\"': [IN_SUB_PATH, APPEND],\n  'eof': ERROR,\n  'else': [IN_DOUBLE_QUOTE, APPEND]\n};\n\n/**\n * Determine the type of a character in a keypath.\n *\n * @param {Char} ch\n * @return {String} type\n */\n\nfunction getPathCharType(ch) {\n  if (ch === undefined) {\n    return 'eof';\n  }\n\n  var code = ch.charCodeAt(0);\n\n  switch (code) {\n    case 0x5B: // [\n    case 0x5D: // ]\n    case 0x2E: // .\n    case 0x22: // \"\n    case 0x27: // '\n    case 0x30:\n      // 0\n      return ch;\n\n    case 0x5F: // _\n    case 0x24:\n      // $\n      return 'ident';\n\n    case 0x20: // Space\n    case 0x09: // Tab\n    case 0x0A: // Newline\n    case 0x0D: // Return\n    case 0xA0: // No-break space\n    case 0xFEFF: // Byte Order Mark\n    case 0x2028: // Line Separator\n    case 0x2029:\n      // Paragraph Separator\n      return 'ws';\n  }\n\n  // a-z, A-Z\n  if (code >= 0x61 && code <= 0x7A || code >= 0x41 && code <= 0x5A) {\n    return 'ident';\n  }\n\n  // 1-9\n  if (code >= 0x31 && code <= 0x39) {\n    return 'number';\n  }\n\n  return 'else';\n}\n\n/**\n * Format a subPath, return its plain form if it is\n * a literal string or number. Otherwise prepend the\n * dynamic indicator (*).\n *\n * @param {String} path\n * @return {String}\n */\n\nfunction formatSubPath(path) {\n  var trimmed = path.trim();\n  // invalid leading 0\n  if (path.charAt(0) === '0' && isNaN(path)) {\n    return false;\n  }\n  return isLiteral(trimmed) ? stripQuotes(trimmed) : '*' + trimmed;\n}\n\n/**\n * Parse a string path into an array of segments\n *\n * @param {String} path\n * @return {Array|undefined}\n */\n\nfunction parse(path) {\n  var keys = [];\n  var index = -1;\n  var mode = BEFORE_PATH;\n  var subPathDepth = 0;\n  var c, newChar, key, type, transition, action, typeMap;\n\n  var actions = [];\n\n  actions[PUSH] = function () {\n    if (key !== undefined) {\n      keys.push(key);\n      key = undefined;\n    }\n  };\n\n  actions[APPEND] = function () {\n    if (key === undefined) {\n      key = newChar;\n    } else {\n      key += newChar;\n    }\n  };\n\n  actions[INC_SUB_PATH_DEPTH] = function () {\n    actions[APPEND]();\n    subPathDepth++;\n  };\n\n  actions[PUSH_SUB_PATH] = function () {\n    if (subPathDepth > 0) {\n      subPathDepth--;\n      mode = IN_SUB_PATH;\n      actions[APPEND]();\n    } else {\n      subPathDepth = 0;\n      key = formatSubPath(key);\n      if (key === false) {\n        return false;\n      } else {\n        actions[PUSH]();\n      }\n    }\n  };\n\n  function maybeUnescapeQuote() {\n    var nextChar = path[index + 1];\n    if (mode === IN_SINGLE_QUOTE && nextChar === \"'\" || mode === IN_DOUBLE_QUOTE && nextChar === '\"') {\n      index++;\n      newChar = '\\\\' + nextChar;\n      actions[APPEND]();\n      return true;\n    }\n  }\n\n  while (mode != null) {\n    index++;\n    c = path[index];\n\n    if (c === '\\\\' && maybeUnescapeQuote()) {\n      continue;\n    }\n\n    type = getPathCharType(c);\n    typeMap = pathStateMachine[mode];\n    transition = typeMap[type] || typeMap['else'] || ERROR;\n\n    if (transition === ERROR) {\n      return; // parse error\n    }\n\n    mode = transition[0];\n    action = actions[transition[1]];\n    if (action) {\n      newChar = transition[2];\n      newChar = newChar === undefined ? c : newChar;\n      if (action() === false) {\n        return;\n      }\n    }\n\n    if (mode === AFTER_PATH) {\n      keys.raw = path;\n      return keys;\n    }\n  }\n}\n\n/**\n * External parse that check for a cache hit first\n *\n * @param {String} path\n * @return {Array|undefined}\n */\n\nfunction parsePath(path) {\n  var hit = pathCache.get(path);\n  if (!hit) {\n    hit = parse(path);\n    if (hit) {\n      pathCache.put(path, hit);\n    }\n  }\n  return hit;\n}\n\n/**\n * Get from an object from a path string\n *\n * @param {Object} obj\n * @param {String} path\n */\n\nfunction getPath(obj, path) {\n  return parseExpression(path).get(obj);\n}\n\n/**\n * Warn against setting non-existent root path on a vm.\n */\n\nvar warnNonExistent;\nif (process.env.NODE_ENV !== 'production') {\n  warnNonExistent = function (path, vm) {\n    warn('You are setting a non-existent path \"' + path.raw + '\" ' + 'on a vm instance. Consider pre-initializing the property ' + 'with the \"data\" option for more reliable reactivity ' + 'and better performance.', vm);\n  };\n}\n\n/**\n * Set on an object from a path\n *\n * @param {Object} obj\n * @param {String | Array} path\n * @param {*} val\n */\n\nfunction setPath(obj, path, val) {\n  var original = obj;\n  if (typeof path === 'string') {\n    path = parse(path);\n  }\n  if (!path || !isObject(obj)) {\n    return false;\n  }\n  var last, key;\n  for (var i = 0, l = path.length; i < l; i++) {\n    last = obj;\n    key = path[i];\n    if (key.charAt(0) === '*') {\n      key = parseExpression(key.slice(1)).get.call(original, original);\n    }\n    if (i < l - 1) {\n      obj = obj[key];\n      if (!isObject(obj)) {\n        obj = {};\n        if (process.env.NODE_ENV !== 'production' && last._isVue) {\n          warnNonExistent(path, last);\n        }\n        set(last, key, obj);\n      }\n    } else {\n      if (isArray(obj)) {\n        obj.$set(key, val);\n      } else if (key in obj) {\n        obj[key] = val;\n      } else {\n        if (process.env.NODE_ENV !== 'production' && obj._isVue) {\n          warnNonExistent(path, obj);\n        }\n        set(obj, key, val);\n      }\n    }\n  }\n  return true;\n}\n\nvar path = Object.freeze({\n  parsePath: parsePath,\n  getPath: getPath,\n  setPath: setPath\n});\n\nvar expressionCache = new Cache(1000);\n\nvar allowedKeywords = 'Math,Date,this,true,false,null,undefined,Infinity,NaN,' + 'isNaN,isFinite,decodeURI,decodeURIComponent,encodeURI,' + 'encodeURIComponent,parseInt,parseFloat';\nvar allowedKeywordsRE = new RegExp('^(' + allowedKeywords.replace(/,/g, '\\\\b|') + '\\\\b)');\n\n// keywords that don't make sense inside expressions\nvar improperKeywords = 'break,case,class,catch,const,continue,debugger,default,' + 'delete,do,else,export,extends,finally,for,function,if,' + 'import,in,instanceof,let,return,super,switch,throw,try,' + 'var,while,with,yield,enum,await,implements,package,' + 'protected,static,interface,private,public';\nvar improperKeywordsRE = new RegExp('^(' + improperKeywords.replace(/,/g, '\\\\b|') + '\\\\b)');\n\nvar wsRE = /\\s/g;\nvar newlineRE = /\\n/g;\nvar saveRE = /[\\{,]\\s*[\\w\\$_]+\\s*:|('(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`)|new |typeof |void /g;\nvar restoreRE = /\"(\\d+)\"/g;\nvar pathTestRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?'\\]|\\[\".*?\"\\]|\\[\\d+\\]|\\[[A-Za-z_$][\\w$]*\\])*$/;\nvar identRE = /[^\\w$\\.](?:[A-Za-z_$][\\w$]*)/g;\nvar literalValueRE$1 = /^(?:true|false|null|undefined|Infinity|NaN)$/;\n\nfunction noop() {}\n\n/**\n * Save / Rewrite / Restore\n *\n * When rewriting paths found in an expression, it is\n * possible for the same letter sequences to be found in\n * strings and Object literal property keys. Therefore we\n * remove and store these parts in a temporary array, and\n * restore them after the path rewrite.\n */\n\nvar saved = [];\n\n/**\n * Save replacer\n *\n * The save regex can match two possible cases:\n * 1. An opening object literal\n * 2. A string\n * If matched as a plain string, we need to escape its\n * newlines, since the string needs to be preserved when\n * generating the function body.\n *\n * @param {String} str\n * @param {String} isString - str if matched as a string\n * @return {String} - placeholder with index\n */\n\nfunction save(str, isString) {\n  var i = saved.length;\n  saved[i] = isString ? str.replace(newlineRE, '\\\\n') : str;\n  return '\"' + i + '\"';\n}\n\n/**\n * Path rewrite replacer\n *\n * @param {String} raw\n * @return {String}\n */\n\nfunction rewrite(raw) {\n  var c = raw.charAt(0);\n  var path = raw.slice(1);\n  if (allowedKeywordsRE.test(path)) {\n    return raw;\n  } else {\n    path = path.indexOf('\"') > -1 ? path.replace(restoreRE, restore) : path;\n    return c + 'scope.' + path;\n  }\n}\n\n/**\n * Restore replacer\n *\n * @param {String} str\n * @param {String} i - matched save index\n * @return {String}\n */\n\nfunction restore(str, i) {\n  return saved[i];\n}\n\n/**\n * Rewrite an expression, prefixing all path accessors with\n * `scope.` and generate getter/setter functions.\n *\n * @param {String} exp\n * @return {Function}\n */\n\nfunction compileGetter(exp) {\n  if (improperKeywordsRE.test(exp)) {\n    process.env.NODE_ENV !== 'production' && warn('Avoid using reserved keywords in expression: ' + exp);\n  }\n  // reset state\n  saved.length = 0;\n  // save strings and object literal keys\n  var body = exp.replace(saveRE, save).replace(wsRE, '');\n  // rewrite all paths\n  // pad 1 space here because the regex matches 1 extra char\n  body = (' ' + body).replace(identRE, rewrite).replace(restoreRE, restore);\n  return makeGetterFn(body);\n}\n\n/**\n * Build a getter function. Requires eval.\n *\n * We isolate the try/catch so it doesn't affect the\n * optimization of the parse function when it is not called.\n *\n * @param {String} body\n * @return {Function|undefined}\n */\n\nfunction makeGetterFn(body) {\n  try {\n    /* eslint-disable no-new-func */\n    return new Function('scope', 'return ' + body + ';');\n    /* eslint-enable no-new-func */\n  } catch (e) {\n    if (process.env.NODE_ENV !== 'production') {\n      /* istanbul ignore if */\n      if (e.toString().match(/unsafe-eval|CSP/)) {\n        warn('It seems you are using the default build of Vue.js in an environment ' + 'with Content Security Policy that prohibits unsafe-eval. ' + 'Use the CSP-compliant build instead: ' + 'http://vuejs.org/guide/installation.html#CSP-compliant-build');\n      } else {\n        warn('Invalid expression. ' + 'Generated function body: ' + body);\n      }\n    }\n    return noop;\n  }\n}\n\n/**\n * Compile a setter function for the expression.\n *\n * @param {String} exp\n * @return {Function|undefined}\n */\n\nfunction compileSetter(exp) {\n  var path = parsePath(exp);\n  if (path) {\n    return function (scope, val) {\n      setPath(scope, path, val);\n    };\n  } else {\n    process.env.NODE_ENV !== 'production' && warn('Invalid setter expression: ' + exp);\n  }\n}\n\n/**\n * Parse an expression into re-written getter/setters.\n *\n * @param {String} exp\n * @param {Boolean} needSet\n * @return {Function}\n */\n\nfunction parseExpression(exp, needSet) {\n  exp = exp.trim();\n  // try cache\n  var hit = expressionCache.get(exp);\n  if (hit) {\n    if (needSet && !hit.set) {\n      hit.set = compileSetter(hit.exp);\n    }\n    return hit;\n  }\n  var res = { exp: exp };\n  res.get = isSimplePath(exp) && exp.indexOf('[') < 0\n  // optimized super simple getter\n  ? makeGetterFn('scope.' + exp)\n  // dynamic getter\n  : compileGetter(exp);\n  if (needSet) {\n    res.set = compileSetter(exp);\n  }\n  expressionCache.put(exp, res);\n  return res;\n}\n\n/**\n * Check if an expression is a simple path.\n *\n * @param {String} exp\n * @return {Boolean}\n */\n\nfunction isSimplePath(exp) {\n  return pathTestRE.test(exp) &&\n  // don't treat literal values as paths\n  !literalValueRE$1.test(exp) &&\n  // Math constants e.g. Math.PI, Math.E etc.\n  exp.slice(0, 5) !== 'Math.';\n}\n\nvar expression = Object.freeze({\n  parseExpression: parseExpression,\n  isSimplePath: isSimplePath\n});\n\n// we have two separate queues: one for directive updates\n// and one for user watcher registered via $watch().\n// we want to guarantee directive updates to be called\n// before user watchers so that when user watchers are\n// triggered, the DOM would have already been in updated\n// state.\n\nvar queue = [];\nvar userQueue = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\n\n/**\n * Reset the batcher's state.\n */\n\nfunction resetBatcherState() {\n  queue.length = 0;\n  userQueue.length = 0;\n  has = {};\n  circular = {};\n  waiting = false;\n}\n\n/**\n * Flush both queues and run the watchers.\n */\n\nfunction flushBatcherQueue() {\n  var _again = true;\n\n  _function: while (_again) {\n    _again = false;\n\n    runBatcherQueue(queue);\n    runBatcherQueue(userQueue);\n    // user watchers triggered more watchers,\n    // keep flushing until it depletes\n    if (queue.length) {\n      _again = true;\n      continue _function;\n    }\n    // dev tool hook\n    /* istanbul ignore if */\n    if (devtools && config.devtools) {\n      devtools.emit('flush');\n    }\n    resetBatcherState();\n  }\n}\n\n/**\n * Run the watchers in a single queue.\n *\n * @param {Array} queue\n */\n\nfunction runBatcherQueue(queue) {\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (var i = 0; i < queue.length; i++) {\n    var watcher = queue[i];\n    var id = watcher.id;\n    has[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if (process.env.NODE_ENV !== 'production' && has[id] != null) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > config._maxUpdateCount) {\n        warn('You may have an infinite update loop for watcher ' + 'with expression \"' + watcher.expression + '\"', watcher.vm);\n        break;\n      }\n    }\n  }\n  queue.length = 0;\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n *\n * @param {Watcher} watcher\n *   properties:\n *   - {Number} id\n *   - {Function} run\n */\n\nfunction pushWatcher(watcher) {\n  var id = watcher.id;\n  if (has[id] == null) {\n    // push watcher into appropriate queue\n    var q = watcher.user ? userQueue : queue;\n    has[id] = q.length;\n    q.push(watcher);\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n      nextTick(flushBatcherQueue);\n    }\n  }\n}\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n *\n * @param {Vue} vm\n * @param {String|Function} expOrFn\n * @param {Function} cb\n * @param {Object} options\n *                 - {Array} filters\n *                 - {Boolean} twoWay\n *                 - {Boolean} deep\n *                 - {Boolean} user\n *                 - {Boolean} sync\n *                 - {Boolean} lazy\n *                 - {Function} [preProcess]\n *                 - {Function} [postProcess]\n * @constructor\n */\nfunction Watcher(vm, expOrFn, cb, options) {\n  // mix in options\n  if (options) {\n    extend(this, options);\n  }\n  var isFn = typeof expOrFn === 'function';\n  this.vm = vm;\n  vm._watchers.push(this);\n  this.expression = expOrFn;\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.prevError = null; // for async error stacks\n  // parse expression for getter/setter\n  if (isFn) {\n    this.getter = expOrFn;\n    this.setter = undefined;\n  } else {\n    var res = parseExpression(expOrFn, this.twoWay);\n    this.getter = res.get;\n    this.setter = res.set;\n  }\n  this.value = this.lazy ? undefined : this.get();\n  // state for avoiding false triggers for deep and Array\n  // watchers during vm._digest()\n  this.queued = this.shallow = false;\n}\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\n\nWatcher.prototype.get = function () {\n  this.beforeGet();\n  var scope = this.scope || this.vm;\n  var value;\n  try {\n    value = this.getter.call(scope, scope);\n  } catch (e) {\n    if (process.env.NODE_ENV !== 'production' && config.warnExpressionErrors) {\n      warn('Error when evaluating expression ' + '\"' + this.expression + '\": ' + e.toString(), this.vm);\n    }\n  }\n  // \"touch\" every property so they are all tracked as\n  // dependencies for deep watching\n  if (this.deep) {\n    traverse(value);\n  }\n  if (this.preProcess) {\n    value = this.preProcess(value);\n  }\n  if (this.filters) {\n    value = scope._applyFilters(value, null, this.filters, false);\n  }\n  if (this.postProcess) {\n    value = this.postProcess(value);\n  }\n  this.afterGet();\n  return value;\n};\n\n/**\n * Set the corresponding value with the setter.\n *\n * @param {*} value\n */\n\nWatcher.prototype.set = function (value) {\n  var scope = this.scope || this.vm;\n  if (this.filters) {\n    value = scope._applyFilters(value, this.value, this.filters, true);\n  }\n  try {\n    this.setter.call(scope, scope, value);\n  } catch (e) {\n    if (process.env.NODE_ENV !== 'production' && config.warnExpressionErrors) {\n      warn('Error when evaluating setter ' + '\"' + this.expression + '\": ' + e.toString(), this.vm);\n    }\n  }\n  // two-way sync for v-for alias\n  var forContext = scope.$forContext;\n  if (forContext && forContext.alias === this.expression) {\n    if (forContext.filters) {\n      process.env.NODE_ENV !== 'production' && warn('It seems you are using two-way binding on ' + 'a v-for alias (' + this.expression + '), and the ' + 'v-for has filters. This will not work properly. ' + 'Either remove the filters or use an array of ' + 'objects and bind to object properties instead.', this.vm);\n      return;\n    }\n    forContext._withLock(function () {\n      if (scope.$key) {\n        // original is an object\n        forContext.rawValue[scope.$key] = value;\n      } else {\n        forContext.rawValue.$set(scope.$index, value);\n      }\n    });\n  }\n};\n\n/**\n * Prepare for dependency collection.\n */\n\nWatcher.prototype.beforeGet = function () {\n  Dep.target = this;\n};\n\n/**\n * Add a dependency to this directive.\n *\n * @param {Dep} dep\n */\n\nWatcher.prototype.addDep = function (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\n\nWatcher.prototype.afterGet = function () {\n  Dep.target = null;\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this.deps[i];\n    if (!this.newDepIds.has(dep.id)) {\n      dep.removeSub(this);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n *\n * @param {Boolean} shallow\n */\n\nWatcher.prototype.update = function (shallow) {\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync || !config.async) {\n    this.run();\n  } else {\n    // if queued, only overwrite shallow with non-shallow,\n    // but not the other way around.\n    this.shallow = this.queued ? shallow ? this.shallow : false : !!shallow;\n    this.queued = true;\n    // record before-push error stack in debug mode\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.debug) {\n      this.prevError = new Error('[vue] async stack trace');\n    }\n    pushWatcher(this);\n  }\n};\n\n/**\n * Batcher job interface.\n * Will be called by the batcher.\n */\n\nWatcher.prototype.run = function () {\n  if (this.active) {\n    var value = this.get();\n    if (value !== this.value ||\n    // Deep watchers and watchers on Object/Arrays should fire even\n    // when the value is the same, because the value may\n    // have mutated; but only do so if this is a\n    // non-shallow update (caused by a vm digest).\n    (isObject(value) || this.deep) && !this.shallow) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      // in debug + async mode, when a watcher callbacks\n      // throws, we also throw the saved before-push error\n      // so the full cross-tick stack trace is available.\n      var prevError = this.prevError;\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.debug && prevError) {\n        this.prevError = null;\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          nextTick(function () {\n            throw prevError;\n          }, 0);\n          throw e;\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n    this.queued = this.shallow = false;\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\n\nWatcher.prototype.evaluate = function () {\n  // avoid overwriting another watcher that is being\n  // collected.\n  var current = Dep.target;\n  this.value = this.get();\n  this.dirty = false;\n  Dep.target = current;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\n\nWatcher.prototype.depend = function () {\n  var i = this.deps.length;\n  while (i--) {\n    this.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subcriber list.\n */\n\nWatcher.prototype.teardown = function () {\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed or is performing a v-for\n    // re-render (the watcher list is then filtered by v-for).\n    if (!this.vm._isBeingDestroyed && !this.vm._vForRemoving) {\n      this.vm._watchers.$remove(this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this.deps[i].removeSub(this);\n    }\n    this.active = false;\n    this.vm = this.cb = this.value = null;\n  }\n};\n\n/**\n * Recrusively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n *\n * @param {*} val\n */\n\nvar seenObjects = new _Set();\nfunction traverse(val, seen) {\n  var i = undefined,\n      keys = undefined;\n  if (!seen) {\n    seen = seenObjects;\n    seen.clear();\n  }\n  var isA = isArray(val);\n  var isO = isObject(val);\n  if (isA || isO) {\n    if (val.__ob__) {\n      var depId = val.__ob__.dep.id;\n      if (seen.has(depId)) {\n        return;\n      } else {\n        seen.add(depId);\n      }\n    }\n    if (isA) {\n      i = val.length;\n      while (i--) traverse(val[i], seen);\n    } else if (isO) {\n      keys = Object.keys(val);\n      i = keys.length;\n      while (i--) traverse(val[keys[i]], seen);\n    }\n  }\n}\n\nvar text$1 = {\n\n  bind: function bind() {\n    this.attr = this.el.nodeType === 3 ? 'data' : 'textContent';\n  },\n\n  update: function update(value) {\n    this.el[this.attr] = _toString(value);\n  }\n};\n\nvar templateCache = new Cache(1000);\nvar idSelectorCache = new Cache(1000);\n\nvar map = {\n  efault: [0, '', ''],\n  legend: [1, '<fieldset>', '</fieldset>'],\n  tr: [2, '<table><tbody>', '</tbody></table>'],\n  col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>']\n};\n\nmap.td = map.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];\n\nmap.option = map.optgroup = [1, '<select multiple=\"multiple\">', '</select>'];\n\nmap.thead = map.tbody = map.colgroup = map.caption = map.tfoot = [1, '<table>', '</table>'];\n\nmap.g = map.defs = map.symbol = map.use = map.image = map.text = map.circle = map.ellipse = map.line = map.path = map.polygon = map.polyline = map.rect = [1, '<svg ' + 'xmlns=\"http://www.w3.org/2000/svg\" ' + 'xmlns:xlink=\"http://www.w3.org/1999/xlink\" ' + 'xmlns:ev=\"http://www.w3.org/2001/xml-events\"' + 'version=\"1.1\">', '</svg>'];\n\n/**\n * Check if a node is a supported template node with a\n * DocumentFragment content.\n *\n * @param {Node} node\n * @return {Boolean}\n */\n\nfunction isRealTemplate(node) {\n  return isTemplate(node) && isFragment(node.content);\n}\n\nvar tagRE$1 = /<([\\w:-]+)/;\nvar entityRE = /&#?\\w+?;/;\nvar commentRE = /<!--/;\n\n/**\n * Convert a string template to a DocumentFragment.\n * Determines correct wrapping by tag types. Wrapping\n * strategy found in jQuery & component/domify.\n *\n * @param {String} templateString\n * @param {Boolean} raw\n * @return {DocumentFragment}\n */\n\nfunction stringToFragment(templateString, raw) {\n  // try a cache hit first\n  var cacheKey = raw ? templateString : templateString.trim();\n  var hit = templateCache.get(cacheKey);\n  if (hit) {\n    return hit;\n  }\n\n  var frag = document.createDocumentFragment();\n  var tagMatch = templateString.match(tagRE$1);\n  var entityMatch = entityRE.test(templateString);\n  var commentMatch = commentRE.test(templateString);\n\n  if (!tagMatch && !entityMatch && !commentMatch) {\n    // text only, return a single text node.\n    frag.appendChild(document.createTextNode(templateString));\n  } else {\n    var tag = tagMatch && tagMatch[1];\n    var wrap = map[tag] || map.efault;\n    var depth = wrap[0];\n    var prefix = wrap[1];\n    var suffix = wrap[2];\n    var node = document.createElement('div');\n\n    node.innerHTML = prefix + templateString + suffix;\n    while (depth--) {\n      node = node.lastChild;\n    }\n\n    var child;\n    /* eslint-disable no-cond-assign */\n    while (child = node.firstChild) {\n      /* eslint-enable no-cond-assign */\n      frag.appendChild(child);\n    }\n  }\n  if (!raw) {\n    trimNode(frag);\n  }\n  templateCache.put(cacheKey, frag);\n  return frag;\n}\n\n/**\n * Convert a template node to a DocumentFragment.\n *\n * @param {Node} node\n * @return {DocumentFragment}\n */\n\nfunction nodeToFragment(node) {\n  // if its a template tag and the browser supports it,\n  // its content is already a document fragment. However, iOS Safari has\n  // bug when using directly cloned template content with touch\n  // events and can cause crashes when the nodes are removed from DOM, so we\n  // have to treat template elements as string templates. (#2805)\n  /* istanbul ignore if */\n  if (isRealTemplate(node)) {\n    return stringToFragment(node.innerHTML);\n  }\n  // script template\n  if (node.tagName === 'SCRIPT') {\n    return stringToFragment(node.textContent);\n  }\n  // normal node, clone it to avoid mutating the original\n  var clonedNode = cloneNode(node);\n  var frag = document.createDocumentFragment();\n  var child;\n  /* eslint-disable no-cond-assign */\n  while (child = clonedNode.firstChild) {\n    /* eslint-enable no-cond-assign */\n    frag.appendChild(child);\n  }\n  trimNode(frag);\n  return frag;\n}\n\n// Test for the presence of the Safari template cloning bug\n// https://bugs.webkit.org/showug.cgi?id=137755\nvar hasBrokenTemplate = (function () {\n  /* istanbul ignore else */\n  if (inBrowser) {\n    var a = document.createElement('div');\n    a.innerHTML = '<template>1</template>';\n    return !a.cloneNode(true).firstChild.innerHTML;\n  } else {\n    return false;\n  }\n})();\n\n// Test for IE10/11 textarea placeholder clone bug\nvar hasTextareaCloneBug = (function () {\n  /* istanbul ignore else */\n  if (inBrowser) {\n    var t = document.createElement('textarea');\n    t.placeholder = 't';\n    return t.cloneNode(true).value === 't';\n  } else {\n    return false;\n  }\n})();\n\n/**\n * 1. Deal with Safari cloning nested <template> bug by\n *    manually cloning all template instances.\n * 2. Deal with IE10/11 textarea placeholder bug by setting\n *    the correct value after cloning.\n *\n * @param {Element|DocumentFragment} node\n * @return {Element|DocumentFragment}\n */\n\nfunction cloneNode(node) {\n  /* istanbul ignore if */\n  if (!node.querySelectorAll) {\n    return node.cloneNode();\n  }\n  var res = node.cloneNode(true);\n  var i, original, cloned;\n  /* istanbul ignore if */\n  if (hasBrokenTemplate) {\n    var tempClone = res;\n    if (isRealTemplate(node)) {\n      node = node.content;\n      tempClone = res.content;\n    }\n    original = node.querySelectorAll('template');\n    if (original.length) {\n      cloned = tempClone.querySelectorAll('template');\n      i = cloned.length;\n      while (i--) {\n        cloned[i].parentNode.replaceChild(cloneNode(original[i]), cloned[i]);\n      }\n    }\n  }\n  /* istanbul ignore if */\n  if (hasTextareaCloneBug) {\n    if (node.tagName === 'TEXTAREA') {\n      res.value = node.value;\n    } else {\n      original = node.querySelectorAll('textarea');\n      if (original.length) {\n        cloned = res.querySelectorAll('textarea');\n        i = cloned.length;\n        while (i--) {\n          cloned[i].value = original[i].value;\n        }\n      }\n    }\n  }\n  return res;\n}\n\n/**\n * Process the template option and normalizes it into a\n * a DocumentFragment that can be used as a partial or a\n * instance template.\n *\n * @param {*} template\n *        Possible values include:\n *        - DocumentFragment object\n *        - Node object of type Template\n *        - id selector: '#some-template-id'\n *        - template string: '<div><span>{{msg}}</span></div>'\n * @param {Boolean} shouldClone\n * @param {Boolean} raw\n *        inline HTML interpolation. Do not check for id\n *        selector and keep whitespace in the string.\n * @return {DocumentFragment|undefined}\n */\n\nfunction parseTemplate(template, shouldClone, raw) {\n  var node, frag;\n\n  // if the template is already a document fragment,\n  // do nothing\n  if (isFragment(template)) {\n    trimNode(template);\n    return shouldClone ? cloneNode(template) : template;\n  }\n\n  if (typeof template === 'string') {\n    // id selector\n    if (!raw && template.charAt(0) === '#') {\n      // id selector can be cached too\n      frag = idSelectorCache.get(template);\n      if (!frag) {\n        node = document.getElementById(template.slice(1));\n        if (node) {\n          frag = nodeToFragment(node);\n          // save selector to cache\n          idSelectorCache.put(template, frag);\n        }\n      }\n    } else {\n      // normal string template\n      frag = stringToFragment(template, raw);\n    }\n  } else if (template.nodeType) {\n    // a direct node\n    frag = nodeToFragment(template);\n  }\n\n  return frag && shouldClone ? cloneNode(frag) : frag;\n}\n\nvar template = Object.freeze({\n  cloneNode: cloneNode,\n  parseTemplate: parseTemplate\n});\n\nvar html = {\n\n  bind: function bind() {\n    // a comment node means this is a binding for\n    // {{{ inline unescaped html }}}\n    if (this.el.nodeType === 8) {\n      // hold nodes\n      this.nodes = [];\n      // replace the placeholder with proper anchor\n      this.anchor = createAnchor('v-html');\n      replace(this.el, this.anchor);\n    }\n  },\n\n  update: function update(value) {\n    value = _toString(value);\n    if (this.nodes) {\n      this.swap(value);\n    } else {\n      this.el.innerHTML = value;\n    }\n  },\n\n  swap: function swap(value) {\n    // remove old nodes\n    var i = this.nodes.length;\n    while (i--) {\n      remove(this.nodes[i]);\n    }\n    // convert new value to a fragment\n    // do not attempt to retrieve from id selector\n    var frag = parseTemplate(value, true, true);\n    // save a reference to these nodes so we can remove later\n    this.nodes = toArray(frag.childNodes);\n    before(frag, this.anchor);\n  }\n};\n\n/**\n * Abstraction for a partially-compiled fragment.\n * Can optionally compile content with a child scope.\n *\n * @param {Function} linker\n * @param {Vue} vm\n * @param {DocumentFragment} frag\n * @param {Vue} [host]\n * @param {Object} [scope]\n * @param {Fragment} [parentFrag]\n */\nfunction Fragment(linker, vm, frag, host, scope, parentFrag) {\n  this.children = [];\n  this.childFrags = [];\n  this.vm = vm;\n  this.scope = scope;\n  this.inserted = false;\n  this.parentFrag = parentFrag;\n  if (parentFrag) {\n    parentFrag.childFrags.push(this);\n  }\n  this.unlink = linker(vm, frag, host, scope, this);\n  var single = this.single = frag.childNodes.length === 1 &&\n  // do not go single mode if the only node is an anchor\n  !frag.childNodes[0].__v_anchor;\n  if (single) {\n    this.node = frag.childNodes[0];\n    this.before = singleBefore;\n    this.remove = singleRemove;\n  } else {\n    this.node = createAnchor('fragment-start');\n    this.end = createAnchor('fragment-end');\n    this.frag = frag;\n    prepend(this.node, frag);\n    frag.appendChild(this.end);\n    this.before = multiBefore;\n    this.remove = multiRemove;\n  }\n  this.node.__v_frag = this;\n}\n\n/**\n * Call attach/detach for all components contained within\n * this fragment. Also do so recursively for all child\n * fragments.\n *\n * @param {Function} hook\n */\n\nFragment.prototype.callHook = function (hook) {\n  var i, l;\n  for (i = 0, l = this.childFrags.length; i < l; i++) {\n    this.childFrags[i].callHook(hook);\n  }\n  for (i = 0, l = this.children.length; i < l; i++) {\n    hook(this.children[i]);\n  }\n};\n\n/**\n * Insert fragment before target, single node version\n *\n * @param {Node} target\n * @param {Boolean} withTransition\n */\n\nfunction singleBefore(target, withTransition) {\n  this.inserted = true;\n  var method = withTransition !== false ? beforeWithTransition : before;\n  method(this.node, target, this.vm);\n  if (inDoc(this.node)) {\n    this.callHook(attach);\n  }\n}\n\n/**\n * Remove fragment, single node version\n */\n\nfunction singleRemove() {\n  this.inserted = false;\n  var shouldCallRemove = inDoc(this.node);\n  var self = this;\n  this.beforeRemove();\n  removeWithTransition(this.node, this.vm, function () {\n    if (shouldCallRemove) {\n      self.callHook(detach);\n    }\n    self.destroy();\n  });\n}\n\n/**\n * Insert fragment before target, multi-nodes version\n *\n * @param {Node} target\n * @param {Boolean} withTransition\n */\n\nfunction multiBefore(target, withTransition) {\n  this.inserted = true;\n  var vm = this.vm;\n  var method = withTransition !== false ? beforeWithTransition : before;\n  mapNodeRange(this.node, this.end, function (node) {\n    method(node, target, vm);\n  });\n  if (inDoc(this.node)) {\n    this.callHook(attach);\n  }\n}\n\n/**\n * Remove fragment, multi-nodes version\n */\n\nfunction multiRemove() {\n  this.inserted = false;\n  var self = this;\n  var shouldCallRemove = inDoc(this.node);\n  this.beforeRemove();\n  removeNodeRange(this.node, this.end, this.vm, this.frag, function () {\n    if (shouldCallRemove) {\n      self.callHook(detach);\n    }\n    self.destroy();\n  });\n}\n\n/**\n * Prepare the fragment for removal.\n */\n\nFragment.prototype.beforeRemove = function () {\n  var i, l;\n  for (i = 0, l = this.childFrags.length; i < l; i++) {\n    // call the same method recursively on child\n    // fragments, depth-first\n    this.childFrags[i].beforeRemove(false);\n  }\n  for (i = 0, l = this.children.length; i < l; i++) {\n    // Call destroy for all contained instances,\n    // with remove:false and defer:true.\n    // Defer is necessary because we need to\n    // keep the children to call detach hooks\n    // on them.\n    this.children[i].$destroy(false, true);\n  }\n  var dirs = this.unlink.dirs;\n  for (i = 0, l = dirs.length; i < l; i++) {\n    // disable the watchers on all the directives\n    // so that the rendered content stays the same\n    // during removal.\n    dirs[i]._watcher && dirs[i]._watcher.teardown();\n  }\n};\n\n/**\n * Destroy the fragment.\n */\n\nFragment.prototype.destroy = function () {\n  if (this.parentFrag) {\n    this.parentFrag.childFrags.$remove(this);\n  }\n  this.node.__v_frag = null;\n  this.unlink();\n};\n\n/**\n * Call attach hook for a Vue instance.\n *\n * @param {Vue} child\n */\n\nfunction attach(child) {\n  if (!child._isAttached && inDoc(child.$el)) {\n    child._callHook('attached');\n  }\n}\n\n/**\n * Call detach hook for a Vue instance.\n *\n * @param {Vue} child\n */\n\nfunction detach(child) {\n  if (child._isAttached && !inDoc(child.$el)) {\n    child._callHook('detached');\n  }\n}\n\nvar linkerCache = new Cache(5000);\n\n/**\n * A factory that can be used to create instances of a\n * fragment. Caches the compiled linker if possible.\n *\n * @param {Vue} vm\n * @param {Element|String} el\n */\nfunction FragmentFactory(vm, el) {\n  this.vm = vm;\n  var template;\n  var isString = typeof el === 'string';\n  if (isString || isTemplate(el) && !el.hasAttribute('v-if')) {\n    template = parseTemplate(el, true);\n  } else {\n    template = document.createDocumentFragment();\n    template.appendChild(el);\n  }\n  this.template = template;\n  // linker can be cached, but only for components\n  var linker;\n  var cid = vm.constructor.cid;\n  if (cid > 0) {\n    var cacheId = cid + (isString ? el : getOuterHTML(el));\n    linker = linkerCache.get(cacheId);\n    if (!linker) {\n      linker = compile(template, vm.$options, true);\n      linkerCache.put(cacheId, linker);\n    }\n  } else {\n    linker = compile(template, vm.$options, true);\n  }\n  this.linker = linker;\n}\n\n/**\n * Create a fragment instance with given host and scope.\n *\n * @param {Vue} host\n * @param {Object} scope\n * @param {Fragment} parentFrag\n */\n\nFragmentFactory.prototype.create = function (host, scope, parentFrag) {\n  var frag = cloneNode(this.template);\n  return new Fragment(this.linker, this.vm, frag, host, scope, parentFrag);\n};\n\nvar ON = 700;\nvar MODEL = 800;\nvar BIND = 850;\nvar TRANSITION = 1100;\nvar EL = 1500;\nvar COMPONENT = 1500;\nvar PARTIAL = 1750;\nvar IF = 2100;\nvar FOR = 2200;\nvar SLOT = 2300;\n\nvar uid$3 = 0;\n\nvar vFor = {\n\n  priority: FOR,\n  terminal: true,\n\n  params: ['track-by', 'stagger', 'enter-stagger', 'leave-stagger'],\n\n  bind: function bind() {\n    // support \"item in/of items\" syntax\n    var inMatch = this.expression.match(/(.*) (?:in|of) (.*)/);\n    if (inMatch) {\n      var itMatch = inMatch[1].match(/\\((.*),(.*)\\)/);\n      if (itMatch) {\n        this.iterator = itMatch[1].trim();\n        this.alias = itMatch[2].trim();\n      } else {\n        this.alias = inMatch[1].trim();\n      }\n      this.expression = inMatch[2];\n    }\n\n    if (!this.alias) {\n      process.env.NODE_ENV !== 'production' && warn('Invalid v-for expression \"' + this.descriptor.raw + '\": ' + 'alias is required.', this.vm);\n      return;\n    }\n\n    // uid as a cache identifier\n    this.id = '__v-for__' + ++uid$3;\n\n    // check if this is an option list,\n    // so that we know if we need to update the <select>'s\n    // v-model when the option list has changed.\n    // because v-model has a lower priority than v-for,\n    // the v-model is not bound here yet, so we have to\n    // retrive it in the actual updateModel() function.\n    var tag = this.el.tagName;\n    this.isOption = (tag === 'OPTION' || tag === 'OPTGROUP') && this.el.parentNode.tagName === 'SELECT';\n\n    // setup anchor nodes\n    this.start = createAnchor('v-for-start');\n    this.end = createAnchor('v-for-end');\n    replace(this.el, this.end);\n    before(this.start, this.end);\n\n    // cache\n    this.cache = Object.create(null);\n\n    // fragment factory\n    this.factory = new FragmentFactory(this.vm, this.el);\n  },\n\n  update: function update(data) {\n    this.diff(data);\n    this.updateRef();\n    this.updateModel();\n  },\n\n  /**\n   * Diff, based on new data and old data, determine the\n   * minimum amount of DOM manipulations needed to make the\n   * DOM reflect the new data Array.\n   *\n   * The algorithm diffs the new data Array by storing a\n   * hidden reference to an owner vm instance on previously\n   * seen data. This allows us to achieve O(n) which is\n   * better than a levenshtein distance based algorithm,\n   * which is O(m * n).\n   *\n   * @param {Array} data\n   */\n\n  diff: function diff(data) {\n    // check if the Array was converted from an Object\n    var item = data[0];\n    var convertedFromObject = this.fromObject = isObject(item) && hasOwn(item, '$key') && hasOwn(item, '$value');\n\n    var trackByKey = this.params.trackBy;\n    var oldFrags = this.frags;\n    var frags = this.frags = new Array(data.length);\n    var alias = this.alias;\n    var iterator = this.iterator;\n    var start = this.start;\n    var end = this.end;\n    var inDocument = inDoc(start);\n    var init = !oldFrags;\n    var i, l, frag, key, value, primitive;\n\n    // First pass, go through the new Array and fill up\n    // the new frags array. If a piece of data has a cached\n    // instance for it, we reuse it. Otherwise build a new\n    // instance.\n    for (i = 0, l = data.length; i < l; i++) {\n      item = data[i];\n      key = convertedFromObject ? item.$key : null;\n      value = convertedFromObject ? item.$value : item;\n      primitive = !isObject(value);\n      frag = !init && this.getCachedFrag(value, i, key);\n      if (frag) {\n        // reusable fragment\n        frag.reused = true;\n        // update $index\n        frag.scope.$index = i;\n        // update $key\n        if (key) {\n          frag.scope.$key = key;\n        }\n        // update iterator\n        if (iterator) {\n          frag.scope[iterator] = key !== null ? key : i;\n        }\n        // update data for track-by, object repeat &\n        // primitive values.\n        if (trackByKey || convertedFromObject || primitive) {\n          withoutConversion(function () {\n            frag.scope[alias] = value;\n          });\n        }\n      } else {\n        // new isntance\n        frag = this.create(value, alias, i, key);\n        frag.fresh = !init;\n      }\n      frags[i] = frag;\n      if (init) {\n        frag.before(end);\n      }\n    }\n\n    // we're done for the initial render.\n    if (init) {\n      return;\n    }\n\n    // Second pass, go through the old fragments and\n    // destroy those who are not reused (and remove them\n    // from cache)\n    var removalIndex = 0;\n    var totalRemoved = oldFrags.length - frags.length;\n    // when removing a large number of fragments, watcher removal\n    // turns out to be a perf bottleneck, so we batch the watcher\n    // removals into a single filter call!\n    this.vm._vForRemoving = true;\n    for (i = 0, l = oldFrags.length; i < l; i++) {\n      frag = oldFrags[i];\n      if (!frag.reused) {\n        this.deleteCachedFrag(frag);\n        this.remove(frag, removalIndex++, totalRemoved, inDocument);\n      }\n    }\n    this.vm._vForRemoving = false;\n    if (removalIndex) {\n      this.vm._watchers = this.vm._watchers.filter(function (w) {\n        return w.active;\n      });\n    }\n\n    // Final pass, move/insert new fragments into the\n    // right place.\n    var targetPrev, prevEl, currentPrev;\n    var insertionIndex = 0;\n    for (i = 0, l = frags.length; i < l; i++) {\n      frag = frags[i];\n      // this is the frag that we should be after\n      targetPrev = frags[i - 1];\n      prevEl = targetPrev ? targetPrev.staggerCb ? targetPrev.staggerAnchor : targetPrev.end || targetPrev.node : start;\n      if (frag.reused && !frag.staggerCb) {\n        currentPrev = findPrevFrag(frag, start, this.id);\n        if (currentPrev !== targetPrev && (!currentPrev ||\n        // optimization for moving a single item.\n        // thanks to suggestions by @livoras in #1807\n        findPrevFrag(currentPrev, start, this.id) !== targetPrev)) {\n          this.move(frag, prevEl);\n        }\n      } else {\n        // new instance, or still in stagger.\n        // insert with updated stagger index.\n        this.insert(frag, insertionIndex++, prevEl, inDocument);\n      }\n      frag.reused = frag.fresh = false;\n    }\n  },\n\n  /**\n   * Create a new fragment instance.\n   *\n   * @param {*} value\n   * @param {String} alias\n   * @param {Number} index\n   * @param {String} [key]\n   * @return {Fragment}\n   */\n\n  create: function create(value, alias, index, key) {\n    var host = this._host;\n    // create iteration scope\n    var parentScope = this._scope || this.vm;\n    var scope = Object.create(parentScope);\n    // ref holder for the scope\n    scope.$refs = Object.create(parentScope.$refs);\n    scope.$els = Object.create(parentScope.$els);\n    // make sure point $parent to parent scope\n    scope.$parent = parentScope;\n    // for two-way binding on alias\n    scope.$forContext = this;\n    // define scope properties\n    // important: define the scope alias without forced conversion\n    // so that frozen data structures remain non-reactive.\n    withoutConversion(function () {\n      defineReactive(scope, alias, value);\n    });\n    defineReactive(scope, '$index', index);\n    if (key) {\n      defineReactive(scope, '$key', key);\n    } else if (scope.$key) {\n      // avoid accidental fallback\n      def(scope, '$key', null);\n    }\n    if (this.iterator) {\n      defineReactive(scope, this.iterator, key !== null ? key : index);\n    }\n    var frag = this.factory.create(host, scope, this._frag);\n    frag.forId = this.id;\n    this.cacheFrag(value, frag, index, key);\n    return frag;\n  },\n\n  /**\n   * Update the v-ref on owner vm.\n   */\n\n  updateRef: function updateRef() {\n    var ref = this.descriptor.ref;\n    if (!ref) return;\n    var hash = (this._scope || this.vm).$refs;\n    var refs;\n    if (!this.fromObject) {\n      refs = this.frags.map(findVmFromFrag);\n    } else {\n      refs = {};\n      this.frags.forEach(function (frag) {\n        refs[frag.scope.$key] = findVmFromFrag(frag);\n      });\n    }\n    hash[ref] = refs;\n  },\n\n  /**\n   * For option lists, update the containing v-model on\n   * parent <select>.\n   */\n\n  updateModel: function updateModel() {\n    if (this.isOption) {\n      var parent = this.start.parentNode;\n      var model = parent && parent.__v_model;\n      if (model) {\n        model.forceUpdate();\n      }\n    }\n  },\n\n  /**\n   * Insert a fragment. Handles staggering.\n   *\n   * @param {Fragment} frag\n   * @param {Number} index\n   * @param {Node} prevEl\n   * @param {Boolean} inDocument\n   */\n\n  insert: function insert(frag, index, prevEl, inDocument) {\n    if (frag.staggerCb) {\n      frag.staggerCb.cancel();\n      frag.staggerCb = null;\n    }\n    var staggerAmount = this.getStagger(frag, index, null, 'enter');\n    if (inDocument && staggerAmount) {\n      // create an anchor and insert it synchronously,\n      // so that we can resolve the correct order without\n      // worrying about some elements not inserted yet\n      var anchor = frag.staggerAnchor;\n      if (!anchor) {\n        anchor = frag.staggerAnchor = createAnchor('stagger-anchor');\n        anchor.__v_frag = frag;\n      }\n      after(anchor, prevEl);\n      var op = frag.staggerCb = cancellable(function () {\n        frag.staggerCb = null;\n        frag.before(anchor);\n        remove(anchor);\n      });\n      setTimeout(op, staggerAmount);\n    } else {\n      var target = prevEl.nextSibling;\n      /* istanbul ignore if */\n      if (!target) {\n        // reset end anchor position in case the position was messed up\n        // by an external drag-n-drop library.\n        after(this.end, prevEl);\n        target = this.end;\n      }\n      frag.before(target);\n    }\n  },\n\n  /**\n   * Remove a fragment. Handles staggering.\n   *\n   * @param {Fragment} frag\n   * @param {Number} index\n   * @param {Number} total\n   * @param {Boolean} inDocument\n   */\n\n  remove: function remove(frag, index, total, inDocument) {\n    if (frag.staggerCb) {\n      frag.staggerCb.cancel();\n      frag.staggerCb = null;\n      // it's not possible for the same frag to be removed\n      // twice, so if we have a pending stagger callback,\n      // it means this frag is queued for enter but removed\n      // before its transition started. Since it is already\n      // destroyed, we can just leave it in detached state.\n      return;\n    }\n    var staggerAmount = this.getStagger(frag, index, total, 'leave');\n    if (inDocument && staggerAmount) {\n      var op = frag.staggerCb = cancellable(function () {\n        frag.staggerCb = null;\n        frag.remove();\n      });\n      setTimeout(op, staggerAmount);\n    } else {\n      frag.remove();\n    }\n  },\n\n  /**\n   * Move a fragment to a new position.\n   * Force no transition.\n   *\n   * @param {Fragment} frag\n   * @param {Node} prevEl\n   */\n\n  move: function move(frag, prevEl) {\n    // fix a common issue with Sortable:\n    // if prevEl doesn't have nextSibling, this means it's\n    // been dragged after the end anchor. Just re-position\n    // the end anchor to the end of the container.\n    /* istanbul ignore if */\n    if (!prevEl.nextSibling) {\n      this.end.parentNode.appendChild(this.end);\n    }\n    frag.before(prevEl.nextSibling, false);\n  },\n\n  /**\n   * Cache a fragment using track-by or the object key.\n   *\n   * @param {*} value\n   * @param {Fragment} frag\n   * @param {Number} index\n   * @param {String} [key]\n   */\n\n  cacheFrag: function cacheFrag(value, frag, index, key) {\n    var trackByKey = this.params.trackBy;\n    var cache = this.cache;\n    var primitive = !isObject(value);\n    var id;\n    if (key || trackByKey || primitive) {\n      id = getTrackByKey(index, key, value, trackByKey);\n      if (!cache[id]) {\n        cache[id] = frag;\n      } else if (trackByKey !== '$index') {\n        process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);\n      }\n    } else {\n      id = this.id;\n      if (hasOwn(value, id)) {\n        if (value[id] === null) {\n          value[id] = frag;\n        } else {\n          process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);\n        }\n      } else if (Object.isExtensible(value)) {\n        def(value, id, frag);\n      } else if (process.env.NODE_ENV !== 'production') {\n        warn('Frozen v-for objects cannot be automatically tracked, make sure to ' + 'provide a track-by key.');\n      }\n    }\n    frag.raw = value;\n  },\n\n  /**\n   * Get a cached fragment from the value/index/key\n   *\n   * @param {*} value\n   * @param {Number} index\n   * @param {String} key\n   * @return {Fragment}\n   */\n\n  getCachedFrag: function getCachedFrag(value, index, key) {\n    var trackByKey = this.params.trackBy;\n    var primitive = !isObject(value);\n    var frag;\n    if (key || trackByKey || primitive) {\n      var id = getTrackByKey(index, key, value, trackByKey);\n      frag = this.cache[id];\n    } else {\n      frag = value[this.id];\n    }\n    if (frag && (frag.reused || frag.fresh)) {\n      process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);\n    }\n    return frag;\n  },\n\n  /**\n   * Delete a fragment from cache.\n   *\n   * @param {Fragment} frag\n   */\n\n  deleteCachedFrag: function deleteCachedFrag(frag) {\n    var value = frag.raw;\n    var trackByKey = this.params.trackBy;\n    var scope = frag.scope;\n    var index = scope.$index;\n    // fix #948: avoid accidentally fall through to\n    // a parent repeater which happens to have $key.\n    var key = hasOwn(scope, '$key') && scope.$key;\n    var primitive = !isObject(value);\n    if (trackByKey || key || primitive) {\n      var id = getTrackByKey(index, key, value, trackByKey);\n      this.cache[id] = null;\n    } else {\n      value[this.id] = null;\n      frag.raw = null;\n    }\n  },\n\n  /**\n   * Get the stagger amount for an insertion/removal.\n   *\n   * @param {Fragment} frag\n   * @param {Number} index\n   * @param {Number} total\n   * @param {String} type\n   */\n\n  getStagger: function getStagger(frag, index, total, type) {\n    type = type + 'Stagger';\n    var trans = frag.node.__v_trans;\n    var hooks = trans && trans.hooks;\n    var hook = hooks && (hooks[type] || hooks.stagger);\n    return hook ? hook.call(frag, index, total) : index * parseInt(this.params[type] || this.params.stagger, 10);\n  },\n\n  /**\n   * Pre-process the value before piping it through the\n   * filters. This is passed to and called by the watcher.\n   */\n\n  _preProcess: function _preProcess(value) {\n    // regardless of type, store the un-filtered raw value.\n    this.rawValue = value;\n    return value;\n  },\n\n  /**\n   * Post-process the value after it has been piped through\n   * the filters. This is passed to and called by the watcher.\n   *\n   * It is necessary for this to be called during the\n   * watcher's dependency collection phase because we want\n   * the v-for to update when the source Object is mutated.\n   */\n\n  _postProcess: function _postProcess(value) {\n    if (isArray(value)) {\n      return value;\n    } else if (isPlainObject(value)) {\n      // convert plain object to array.\n      var keys = Object.keys(value);\n      var i = keys.length;\n      var res = new Array(i);\n      var key;\n      while (i--) {\n        key = keys[i];\n        res[i] = {\n          $key: key,\n          $value: value[key]\n        };\n      }\n      return res;\n    } else {\n      if (typeof value === 'number' && !isNaN(value)) {\n        value = range(value);\n      }\n      return value || [];\n    }\n  },\n\n  unbind: function unbind() {\n    if (this.descriptor.ref) {\n      (this._scope || this.vm).$refs[this.descriptor.ref] = null;\n    }\n    if (this.frags) {\n      var i = this.frags.length;\n      var frag;\n      while (i--) {\n        frag = this.frags[i];\n        this.deleteCachedFrag(frag);\n        frag.destroy();\n      }\n    }\n  }\n};\n\n/**\n * Helper to find the previous element that is a fragment\n * anchor. This is necessary because a destroyed frag's\n * element could still be lingering in the DOM before its\n * leaving transition finishes, but its inserted flag\n * should have been set to false so we can skip them.\n *\n * If this is a block repeat, we want to make sure we only\n * return frag that is bound to this v-for. (see #929)\n *\n * @param {Fragment} frag\n * @param {Comment|Text} anchor\n * @param {String} id\n * @return {Fragment}\n */\n\nfunction findPrevFrag(frag, anchor, id) {\n  var el = frag.node.previousSibling;\n  /* istanbul ignore if */\n  if (!el) return;\n  frag = el.__v_frag;\n  while ((!frag || frag.forId !== id || !frag.inserted) && el !== anchor) {\n    el = el.previousSibling;\n    /* istanbul ignore if */\n    if (!el) return;\n    frag = el.__v_frag;\n  }\n  return frag;\n}\n\n/**\n * Find a vm from a fragment.\n *\n * @param {Fragment} frag\n * @return {Vue|undefined}\n */\n\nfunction findVmFromFrag(frag) {\n  var node = frag.node;\n  // handle multi-node frag\n  if (frag.end) {\n    while (!node.__vue__ && node !== frag.end && node.nextSibling) {\n      node = node.nextSibling;\n    }\n  }\n  return node.__vue__;\n}\n\n/**\n * Create a range array from given number.\n *\n * @param {Number} n\n * @return {Array}\n */\n\nfunction range(n) {\n  var i = -1;\n  var ret = new Array(Math.floor(n));\n  while (++i < n) {\n    ret[i] = i;\n  }\n  return ret;\n}\n\n/**\n * Get the track by key for an item.\n *\n * @param {Number} index\n * @param {String} key\n * @param {*} value\n * @param {String} [trackByKey]\n */\n\nfunction getTrackByKey(index, key, value, trackByKey) {\n  return trackByKey ? trackByKey === '$index' ? index : trackByKey.charAt(0).match(/\\w/) ? getPath(value, trackByKey) : value[trackByKey] : key || value;\n}\n\nif (process.env.NODE_ENV !== 'production') {\n  vFor.warnDuplicate = function (value) {\n    warn('Duplicate value found in v-for=\"' + this.descriptor.raw + '\": ' + JSON.stringify(value) + '. Use track-by=\"$index\" if ' + 'you are expecting duplicate values.', this.vm);\n  };\n}\n\nvar vIf = {\n\n  priority: IF,\n  terminal: true,\n\n  bind: function bind() {\n    var el = this.el;\n    if (!el.__vue__) {\n      // check else block\n      var next = el.nextElementSibling;\n      if (next && getAttr(next, 'v-else') !== null) {\n        remove(next);\n        this.elseEl = next;\n      }\n      // check main block\n      this.anchor = createAnchor('v-if');\n      replace(el, this.anchor);\n    } else {\n      process.env.NODE_ENV !== 'production' && warn('v-if=\"' + this.expression + '\" cannot be ' + 'used on an instance root element.', this.vm);\n      this.invalid = true;\n    }\n  },\n\n  update: function update(value) {\n    if (this.invalid) return;\n    if (value) {\n      if (!this.frag) {\n        this.insert();\n      }\n    } else {\n      this.remove();\n    }\n  },\n\n  insert: function insert() {\n    if (this.elseFrag) {\n      this.elseFrag.remove();\n      this.elseFrag = null;\n    }\n    // lazy init factory\n    if (!this.factory) {\n      this.factory = new FragmentFactory(this.vm, this.el);\n    }\n    this.frag = this.factory.create(this._host, this._scope, this._frag);\n    this.frag.before(this.anchor);\n  },\n\n  remove: function remove() {\n    if (this.frag) {\n      this.frag.remove();\n      this.frag = null;\n    }\n    if (this.elseEl && !this.elseFrag) {\n      if (!this.elseFactory) {\n        this.elseFactory = new FragmentFactory(this.elseEl._context || this.vm, this.elseEl);\n      }\n      this.elseFrag = this.elseFactory.create(this._host, this._scope, this._frag);\n      this.elseFrag.before(this.anchor);\n    }\n  },\n\n  unbind: function unbind() {\n    if (this.frag) {\n      this.frag.destroy();\n    }\n    if (this.elseFrag) {\n      this.elseFrag.destroy();\n    }\n  }\n};\n\nvar show = {\n\n  bind: function bind() {\n    // check else block\n    var next = this.el.nextElementSibling;\n    if (next && getAttr(next, 'v-else') !== null) {\n      this.elseEl = next;\n    }\n  },\n\n  update: function update(value) {\n    this.apply(this.el, value);\n    if (this.elseEl) {\n      this.apply(this.elseEl, !value);\n    }\n  },\n\n  apply: function apply(el, value) {\n    if (inDoc(el)) {\n      applyTransition(el, value ? 1 : -1, toggle, this.vm);\n    } else {\n      toggle();\n    }\n    function toggle() {\n      el.style.display = value ? '' : 'none';\n    }\n  }\n};\n\nvar text$2 = {\n\n  bind: function bind() {\n    var self = this;\n    var el = this.el;\n    var isRange = el.type === 'range';\n    var lazy = this.params.lazy;\n    var number = this.params.number;\n    var debounce = this.params.debounce;\n\n    // handle composition events.\n    //   http://blog.evanyou.me/2014/01/03/composition-event/\n    // skip this for Android because it handles composition\n    // events quite differently. Android doesn't trigger\n    // composition events for language input methods e.g.\n    // Chinese, but instead triggers them for spelling\n    // suggestions... (see Discussion/#162)\n    var composing = false;\n    if (!isAndroid && !isRange) {\n      this.on('compositionstart', function () {\n        composing = true;\n      });\n      this.on('compositionend', function () {\n        composing = false;\n        // in IE11 the \"compositionend\" event fires AFTER\n        // the \"input\" event, so the input handler is blocked\n        // at the end... have to call it here.\n        //\n        // #1327: in lazy mode this is unecessary.\n        if (!lazy) {\n          self.listener();\n        }\n      });\n    }\n\n    // prevent messing with the input when user is typing,\n    // and force update on blur.\n    this.focused = false;\n    if (!isRange && !lazy) {\n      this.on('focus', function () {\n        self.focused = true;\n      });\n      this.on('blur', function () {\n        self.focused = false;\n        // do not sync value after fragment removal (#2017)\n        if (!self._frag || self._frag.inserted) {\n          self.rawListener();\n        }\n      });\n    }\n\n    // Now attach the main listener\n    this.listener = this.rawListener = function () {\n      if (composing || !self._bound) {\n        return;\n      }\n      var val = number || isRange ? toNumber(el.value) : el.value;\n      self.set(val);\n      // force update on next tick to avoid lock & same value\n      // also only update when user is not typing\n      nextTick(function () {\n        if (self._bound && !self.focused) {\n          self.update(self._watcher.value);\n        }\n      });\n    };\n\n    // apply debounce\n    if (debounce) {\n      this.listener = _debounce(this.listener, debounce);\n    }\n\n    // Support jQuery events, since jQuery.trigger() doesn't\n    // trigger native events in some cases and some plugins\n    // rely on $.trigger()\n    //\n    // We want to make sure if a listener is attached using\n    // jQuery, it is also removed with jQuery, that's why\n    // we do the check for each directive instance and\n    // store that check result on itself. This also allows\n    // easier test coverage control by unsetting the global\n    // jQuery variable in tests.\n    this.hasjQuery = typeof jQuery === 'function';\n    if (this.hasjQuery) {\n      var method = jQuery.fn.on ? 'on' : 'bind';\n      jQuery(el)[method]('change', this.rawListener);\n      if (!lazy) {\n        jQuery(el)[method]('input', this.listener);\n      }\n    } else {\n      this.on('change', this.rawListener);\n      if (!lazy) {\n        this.on('input', this.listener);\n      }\n    }\n\n    // IE9 doesn't fire input event on backspace/del/cut\n    if (!lazy && isIE9) {\n      this.on('cut', function () {\n        nextTick(self.listener);\n      });\n      this.on('keyup', function (e) {\n        if (e.keyCode === 46 || e.keyCode === 8) {\n          self.listener();\n        }\n      });\n    }\n\n    // set initial value if present\n    if (el.hasAttribute('value') || el.tagName === 'TEXTAREA' && el.value.trim()) {\n      this.afterBind = this.listener;\n    }\n  },\n\n  update: function update(value) {\n    // #3029 only update when the value changes. This prevent\n    // browsers from overwriting values like selectionStart\n    value = _toString(value);\n    if (value !== this.el.value) this.el.value = value;\n  },\n\n  unbind: function unbind() {\n    var el = this.el;\n    if (this.hasjQuery) {\n      var method = jQuery.fn.off ? 'off' : 'unbind';\n      jQuery(el)[method]('change', this.listener);\n      jQuery(el)[method]('input', this.listener);\n    }\n  }\n};\n\nvar radio = {\n\n  bind: function bind() {\n    var self = this;\n    var el = this.el;\n\n    this.getValue = function () {\n      // value overwrite via v-bind:value\n      if (el.hasOwnProperty('_value')) {\n        return el._value;\n      }\n      var val = el.value;\n      if (self.params.number) {\n        val = toNumber(val);\n      }\n      return val;\n    };\n\n    this.listener = function () {\n      self.set(self.getValue());\n    };\n    this.on('change', this.listener);\n\n    if (el.hasAttribute('checked')) {\n      this.afterBind = this.listener;\n    }\n  },\n\n  update: function update(value) {\n    this.el.checked = looseEqual(value, this.getValue());\n  }\n};\n\nvar select = {\n\n  bind: function bind() {\n    var _this = this;\n\n    var self = this;\n    var el = this.el;\n\n    // method to force update DOM using latest value.\n    this.forceUpdate = function () {\n      if (self._watcher) {\n        self.update(self._watcher.get());\n      }\n    };\n\n    // check if this is a multiple select\n    var multiple = this.multiple = el.hasAttribute('multiple');\n\n    // attach listener\n    this.listener = function () {\n      var value = getValue(el, multiple);\n      value = self.params.number ? isArray(value) ? value.map(toNumber) : toNumber(value) : value;\n      self.set(value);\n    };\n    this.on('change', this.listener);\n\n    // if has initial value, set afterBind\n    var initValue = getValue(el, multiple, true);\n    if (multiple && initValue.length || !multiple && initValue !== null) {\n      this.afterBind = this.listener;\n    }\n\n    // All major browsers except Firefox resets\n    // selectedIndex with value -1 to 0 when the element\n    // is appended to a new parent, therefore we have to\n    // force a DOM update whenever that happens...\n    this.vm.$on('hook:attached', function () {\n      nextTick(_this.forceUpdate);\n    });\n  },\n\n  update: function update(value) {\n    var el = this.el;\n    if (!inDoc(el)) {\n      return nextTick(this.forceUpdate);\n    }\n    el.selectedIndex = -1;\n    var multi = this.multiple && isArray(value);\n    var options = el.options;\n    var i = options.length;\n    var op, val;\n    while (i--) {\n      op = options[i];\n      val = op.hasOwnProperty('_value') ? op._value : op.value;\n      /* eslint-disable eqeqeq */\n      op.selected = multi ? indexOf$1(value, val) > -1 : looseEqual(value, val);\n      /* eslint-enable eqeqeq */\n    }\n  },\n\n  unbind: function unbind() {\n    /* istanbul ignore next */\n    this.vm.$off('hook:attached', this.forceUpdate);\n  }\n};\n\n/**\n * Get select value\n *\n * @param {SelectElement} el\n * @param {Boolean} multi\n * @param {Boolean} init\n * @return {Array|*}\n */\n\nfunction getValue(el, multi, init) {\n  var res = multi ? [] : null;\n  var op, val, selected;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    op = el.options[i];\n    selected = init ? op.hasAttribute('selected') : op.selected;\n    if (selected) {\n      val = op.hasOwnProperty('_value') ? op._value : op.value;\n      if (multi) {\n        res.push(val);\n      } else {\n        return val;\n      }\n    }\n  }\n  return res;\n}\n\n/**\n * Native Array.indexOf uses strict equal, but in this\n * case we need to match string/numbers with custom equal.\n *\n * @param {Array} arr\n * @param {*} val\n */\n\nfunction indexOf$1(arr, val) {\n  var i = arr.length;\n  while (i--) {\n    if (looseEqual(arr[i], val)) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nvar checkbox = {\n\n  bind: function bind() {\n    var self = this;\n    var el = this.el;\n\n    this.getValue = function () {\n      return el.hasOwnProperty('_value') ? el._value : self.params.number ? toNumber(el.value) : el.value;\n    };\n\n    function getBooleanValue() {\n      var val = el.checked;\n      if (val && el.hasOwnProperty('_trueValue')) {\n        return el._trueValue;\n      }\n      if (!val && el.hasOwnProperty('_falseValue')) {\n        return el._falseValue;\n      }\n      return val;\n    }\n\n    this.listener = function () {\n      var model = self._watcher.value;\n      if (isArray(model)) {\n        var val = self.getValue();\n        if (el.checked) {\n          if (indexOf(model, val) < 0) {\n            model.push(val);\n          }\n        } else {\n          model.$remove(val);\n        }\n      } else {\n        self.set(getBooleanValue());\n      }\n    };\n\n    this.on('change', this.listener);\n    if (el.hasAttribute('checked')) {\n      this.afterBind = this.listener;\n    }\n  },\n\n  update: function update(value) {\n    var el = this.el;\n    if (isArray(value)) {\n      el.checked = indexOf(value, this.getValue()) > -1;\n    } else {\n      if (el.hasOwnProperty('_trueValue')) {\n        el.checked = looseEqual(value, el._trueValue);\n      } else {\n        el.checked = !!value;\n      }\n    }\n  }\n};\n\nvar handlers = {\n  text: text$2,\n  radio: radio,\n  select: select,\n  checkbox: checkbox\n};\n\nvar model = {\n\n  priority: MODEL,\n  twoWay: true,\n  handlers: handlers,\n  params: ['lazy', 'number', 'debounce'],\n\n  /**\n   * Possible elements:\n   *   <select>\n   *   <textarea>\n   *   <input type=\"*\">\n   *     - text\n   *     - checkbox\n   *     - radio\n   *     - number\n   */\n\n  bind: function bind() {\n    // friendly warning...\n    this.checkFilters();\n    if (this.hasRead && !this.hasWrite) {\n      process.env.NODE_ENV !== 'production' && warn('It seems you are using a read-only filter with ' + 'v-model=\"' + this.descriptor.raw + '\". ' + 'You might want to use a two-way filter to ensure correct behavior.', this.vm);\n    }\n    var el = this.el;\n    var tag = el.tagName;\n    var handler;\n    if (tag === 'INPUT') {\n      handler = handlers[el.type] || handlers.text;\n    } else if (tag === 'SELECT') {\n      handler = handlers.select;\n    } else if (tag === 'TEXTAREA') {\n      handler = handlers.text;\n    } else {\n      process.env.NODE_ENV !== 'production' && warn('v-model does not support element type: ' + tag, this.vm);\n      return;\n    }\n    el.__v_model = this;\n    handler.bind.call(this);\n    this.update = handler.update;\n    this._unbind = handler.unbind;\n  },\n\n  /**\n   * Check read/write filter stats.\n   */\n\n  checkFilters: function checkFilters() {\n    var filters = this.filters;\n    if (!filters) return;\n    var i = filters.length;\n    while (i--) {\n      var filter = resolveAsset(this.vm.$options, 'filters', filters[i].name);\n      if (typeof filter === 'function' || filter.read) {\n        this.hasRead = true;\n      }\n      if (filter.write) {\n        this.hasWrite = true;\n      }\n    }\n  },\n\n  unbind: function unbind() {\n    this.el.__v_model = null;\n    this._unbind && this._unbind();\n  }\n};\n\n// keyCode aliases\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  'delete': [8, 46],\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40\n};\n\nfunction keyFilter(handler, keys) {\n  var codes = keys.map(function (key) {\n    var charCode = key.charCodeAt(0);\n    if (charCode > 47 && charCode < 58) {\n      return parseInt(key, 10);\n    }\n    if (key.length === 1) {\n      charCode = key.toUpperCase().charCodeAt(0);\n      if (charCode > 64 && charCode < 91) {\n        return charCode;\n      }\n    }\n    return keyCodes[key];\n  });\n  codes = [].concat.apply([], codes);\n  return function keyHandler(e) {\n    if (codes.indexOf(e.keyCode) > -1) {\n      return handler.call(this, e);\n    }\n  };\n}\n\nfunction stopFilter(handler) {\n  return function stopHandler(e) {\n    e.stopPropagation();\n    return handler.call(this, e);\n  };\n}\n\nfunction preventFilter(handler) {\n  return function preventHandler(e) {\n    e.preventDefault();\n    return handler.call(this, e);\n  };\n}\n\nfunction selfFilter(handler) {\n  return function selfHandler(e) {\n    if (e.target === e.currentTarget) {\n      return handler.call(this, e);\n    }\n  };\n}\n\nvar on$1 = {\n\n  priority: ON,\n  acceptStatement: true,\n  keyCodes: keyCodes,\n\n  bind: function bind() {\n    // deal with iframes\n    if (this.el.tagName === 'IFRAME' && this.arg !== 'load') {\n      var self = this;\n      this.iframeBind = function () {\n        on(self.el.contentWindow, self.arg, self.handler, self.modifiers.capture);\n      };\n      this.on('load', this.iframeBind);\n    }\n  },\n\n  update: function update(handler) {\n    // stub a noop for v-on with no value,\n    // e.g. @mousedown.prevent\n    if (!this.descriptor.raw) {\n      handler = function () {};\n    }\n\n    if (typeof handler !== 'function') {\n      process.env.NODE_ENV !== 'production' && warn('v-on:' + this.arg + '=\"' + this.expression + '\" expects a function value, ' + 'got ' + handler, this.vm);\n      return;\n    }\n\n    // apply modifiers\n    if (this.modifiers.stop) {\n      handler = stopFilter(handler);\n    }\n    if (this.modifiers.prevent) {\n      handler = preventFilter(handler);\n    }\n    if (this.modifiers.self) {\n      handler = selfFilter(handler);\n    }\n    // key filter\n    var keys = Object.keys(this.modifiers).filter(function (key) {\n      return key !== 'stop' && key !== 'prevent' && key !== 'self' && key !== 'capture';\n    });\n    if (keys.length) {\n      handler = keyFilter(handler, keys);\n    }\n\n    this.reset();\n    this.handler = handler;\n\n    if (this.iframeBind) {\n      this.iframeBind();\n    } else {\n      on(this.el, this.arg, this.handler, this.modifiers.capture);\n    }\n  },\n\n  reset: function reset() {\n    var el = this.iframeBind ? this.el.contentWindow : this.el;\n    if (this.handler) {\n      off(el, this.arg, this.handler);\n    }\n  },\n\n  unbind: function unbind() {\n    this.reset();\n  }\n};\n\nvar prefixes = ['-webkit-', '-moz-', '-ms-'];\nvar camelPrefixes = ['Webkit', 'Moz', 'ms'];\nvar importantRE = /!important;?$/;\nvar propCache = Object.create(null);\n\nvar testEl = null;\n\nvar style = {\n\n  deep: true,\n\n  update: function update(value) {\n    if (typeof value === 'string') {\n      this.el.style.cssText = value;\n    } else if (isArray(value)) {\n      this.handleObject(value.reduce(extend, {}));\n    } else {\n      this.handleObject(value || {});\n    }\n  },\n\n  handleObject: function handleObject(value) {\n    // cache object styles so that only changed props\n    // are actually updated.\n    var cache = this.cache || (this.cache = {});\n    var name, val;\n    for (name in cache) {\n      if (!(name in value)) {\n        this.handleSingle(name, null);\n        delete cache[name];\n      }\n    }\n    for (name in value) {\n      val = value[name];\n      if (val !== cache[name]) {\n        cache[name] = val;\n        this.handleSingle(name, val);\n      }\n    }\n  },\n\n  handleSingle: function handleSingle(prop, value) {\n    prop = normalize(prop);\n    if (!prop) return; // unsupported prop\n    // cast possible numbers/booleans into strings\n    if (value != null) value += '';\n    if (value) {\n      var isImportant = importantRE.test(value) ? 'important' : '';\n      if (isImportant) {\n        /* istanbul ignore if */\n        if (process.env.NODE_ENV !== 'production') {\n          warn('It\\'s probably a bad idea to use !important with inline rules. ' + 'This feature will be deprecated in a future version of Vue.');\n        }\n        value = value.replace(importantRE, '').trim();\n        this.el.style.setProperty(prop.kebab, value, isImportant);\n      } else {\n        this.el.style[prop.camel] = value;\n      }\n    } else {\n      this.el.style[prop.camel] = '';\n    }\n  }\n\n};\n\n/**\n * Normalize a CSS property name.\n * - cache result\n * - auto prefix\n * - camelCase -> dash-case\n *\n * @param {String} prop\n * @return {String}\n */\n\nfunction normalize(prop) {\n  if (propCache[prop]) {\n    return propCache[prop];\n  }\n  var res = prefix(prop);\n  propCache[prop] = propCache[res] = res;\n  return res;\n}\n\n/**\n * Auto detect the appropriate prefix for a CSS property.\n * https://gist.github.com/paulirish/523692\n *\n * @param {String} prop\n * @return {String}\n */\n\nfunction prefix(prop) {\n  prop = hyphenate(prop);\n  var camel = camelize(prop);\n  var upper = camel.charAt(0).toUpperCase() + camel.slice(1);\n  if (!testEl) {\n    testEl = document.createElement('div');\n  }\n  var i = prefixes.length;\n  var prefixed;\n  if (camel !== 'filter' && camel in testEl.style) {\n    return {\n      kebab: prop,\n      camel: camel\n    };\n  }\n  while (i--) {\n    prefixed = camelPrefixes[i] + upper;\n    if (prefixed in testEl.style) {\n      return {\n        kebab: prefixes[i] + prop,\n        camel: prefixed\n      };\n    }\n  }\n}\n\n// xlink\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\nvar xlinkRE = /^xlink:/;\n\n// check for attributes that prohibit interpolations\nvar disallowedInterpAttrRE = /^v-|^:|^@|^(?:is|transition|transition-mode|debounce|track-by|stagger|enter-stagger|leave-stagger)$/;\n// these attributes should also set their corresponding properties\n// because they only affect the initial state of the element\nvar attrWithPropsRE = /^(?:value|checked|selected|muted)$/;\n// these attributes expect enumrated values of \"true\" or \"false\"\n// but are not boolean attributes\nvar enumeratedAttrRE = /^(?:draggable|contenteditable|spellcheck)$/;\n\n// these attributes should set a hidden property for\n// binding v-model to object values\nvar modelProps = {\n  value: '_value',\n  'true-value': '_trueValue',\n  'false-value': '_falseValue'\n};\n\nvar bind$1 = {\n\n  priority: BIND,\n\n  bind: function bind() {\n    var attr = this.arg;\n    var tag = this.el.tagName;\n    // should be deep watch on object mode\n    if (!attr) {\n      this.deep = true;\n    }\n    // handle interpolation bindings\n    var descriptor = this.descriptor;\n    var tokens = descriptor.interp;\n    if (tokens) {\n      // handle interpolations with one-time tokens\n      if (descriptor.hasOneTime) {\n        this.expression = tokensToExp(tokens, this._scope || this.vm);\n      }\n\n      // only allow binding on native attributes\n      if (disallowedInterpAttrRE.test(attr) || attr === 'name' && (tag === 'PARTIAL' || tag === 'SLOT')) {\n        process.env.NODE_ENV !== 'production' && warn(attr + '=\"' + descriptor.raw + '\": ' + 'attribute interpolation is not allowed in Vue.js ' + 'directives and special attributes.', this.vm);\n        this.el.removeAttribute(attr);\n        this.invalid = true;\n      }\n\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production') {\n        var raw = attr + '=\"' + descriptor.raw + '\": ';\n        // warn src\n        if (attr === 'src') {\n          warn(raw + 'interpolation in \"src\" attribute will cause ' + 'a 404 request. Use v-bind:src instead.', this.vm);\n        }\n\n        // warn style\n        if (attr === 'style') {\n          warn(raw + 'interpolation in \"style\" attribute will cause ' + 'the attribute to be discarded in Internet Explorer. ' + 'Use v-bind:style instead.', this.vm);\n        }\n      }\n    }\n  },\n\n  update: function update(value) {\n    if (this.invalid) {\n      return;\n    }\n    var attr = this.arg;\n    if (this.arg) {\n      this.handleSingle(attr, value);\n    } else {\n      this.handleObject(value || {});\n    }\n  },\n\n  // share object handler with v-bind:class\n  handleObject: style.handleObject,\n\n  handleSingle: function handleSingle(attr, value) {\n    var el = this.el;\n    var interp = this.descriptor.interp;\n    if (this.modifiers.camel) {\n      attr = camelize(attr);\n    }\n    if (!interp && attrWithPropsRE.test(attr) && attr in el) {\n      var attrValue = attr === 'value' ? value == null // IE9 will set input.value to \"null\" for null...\n      ? '' : value : value;\n\n      if (el[attr] !== attrValue) {\n        el[attr] = attrValue;\n      }\n    }\n    // set model props\n    var modelProp = modelProps[attr];\n    if (!interp && modelProp) {\n      el[modelProp] = value;\n      // update v-model if present\n      var model = el.__v_model;\n      if (model) {\n        model.listener();\n      }\n    }\n    // do not set value attribute for textarea\n    if (attr === 'value' && el.tagName === 'TEXTAREA') {\n      el.removeAttribute(attr);\n      return;\n    }\n    // update attribute\n    if (enumeratedAttrRE.test(attr)) {\n      el.setAttribute(attr, value ? 'true' : 'false');\n    } else if (value != null && value !== false) {\n      if (attr === 'class') {\n        // handle edge case #1960:\n        // class interpolation should not overwrite Vue transition class\n        if (el.__v_trans) {\n          value += ' ' + el.__v_trans.id + '-transition';\n        }\n        setClass(el, value);\n      } else if (xlinkRE.test(attr)) {\n        el.setAttributeNS(xlinkNS, attr, value === true ? '' : value);\n      } else {\n        el.setAttribute(attr, value === true ? '' : value);\n      }\n    } else {\n      el.removeAttribute(attr);\n    }\n  }\n};\n\nvar el = {\n\n  priority: EL,\n\n  bind: function bind() {\n    /* istanbul ignore if */\n    if (!this.arg) {\n      return;\n    }\n    var id = this.id = camelize(this.arg);\n    var refs = (this._scope || this.vm).$els;\n    if (hasOwn(refs, id)) {\n      refs[id] = this.el;\n    } else {\n      defineReactive(refs, id, this.el);\n    }\n  },\n\n  unbind: function unbind() {\n    var refs = (this._scope || this.vm).$els;\n    if (refs[this.id] === this.el) {\n      refs[this.id] = null;\n    }\n  }\n};\n\nvar ref = {\n  bind: function bind() {\n    process.env.NODE_ENV !== 'production' && warn('v-ref:' + this.arg + ' must be used on a child ' + 'component. Found on <' + this.el.tagName.toLowerCase() + '>.', this.vm);\n  }\n};\n\nvar cloak = {\n  bind: function bind() {\n    var el = this.el;\n    this.vm.$once('pre-hook:compiled', function () {\n      el.removeAttribute('v-cloak');\n    });\n  }\n};\n\n// must export plain object\nvar directives = {\n  text: text$1,\n  html: html,\n  'for': vFor,\n  'if': vIf,\n  show: show,\n  model: model,\n  on: on$1,\n  bind: bind$1,\n  el: el,\n  ref: ref,\n  cloak: cloak\n};\n\nvar vClass = {\n\n  deep: true,\n\n  update: function update(value) {\n    if (!value) {\n      this.cleanup();\n    } else if (typeof value === 'string') {\n      this.setClass(value.trim().split(/\\s+/));\n    } else {\n      this.setClass(normalize$1(value));\n    }\n  },\n\n  setClass: function setClass(value) {\n    this.cleanup(value);\n    for (var i = 0, l = value.length; i < l; i++) {\n      var val = value[i];\n      if (val) {\n        apply(this.el, val, addClass);\n      }\n    }\n    this.prevKeys = value;\n  },\n\n  cleanup: function cleanup(value) {\n    var prevKeys = this.prevKeys;\n    if (!prevKeys) return;\n    var i = prevKeys.length;\n    while (i--) {\n      var key = prevKeys[i];\n      if (!value || value.indexOf(key) < 0) {\n        apply(this.el, key, removeClass);\n      }\n    }\n  }\n};\n\n/**\n * Normalize objects and arrays (potentially containing objects)\n * into array of strings.\n *\n * @param {Object|Array<String|Object>} value\n * @return {Array<String>}\n */\n\nfunction normalize$1(value) {\n  var res = [];\n  if (isArray(value)) {\n    for (var i = 0, l = value.length; i < l; i++) {\n      var _key = value[i];\n      if (_key) {\n        if (typeof _key === 'string') {\n          res.push(_key);\n        } else {\n          for (var k in _key) {\n            if (_key[k]) res.push(k);\n          }\n        }\n      }\n    }\n  } else if (isObject(value)) {\n    for (var key in value) {\n      if (value[key]) res.push(key);\n    }\n  }\n  return res;\n}\n\n/**\n * Add or remove a class/classes on an element\n *\n * @param {Element} el\n * @param {String} key The class name. This may or may not\n *                     contain a space character, in such a\n *                     case we'll deal with multiple class\n *                     names at once.\n * @param {Function} fn\n */\n\nfunction apply(el, key, fn) {\n  key = key.trim();\n  if (key.indexOf(' ') === -1) {\n    fn(el, key);\n    return;\n  }\n  // The key contains one or more space characters.\n  // Since a class name doesn't accept such characters, we\n  // treat it as multiple classes.\n  var keys = key.split(/\\s+/);\n  for (var i = 0, l = keys.length; i < l; i++) {\n    fn(el, keys[i]);\n  }\n}\n\nvar component = {\n\n  priority: COMPONENT,\n\n  params: ['keep-alive', 'transition-mode', 'inline-template'],\n\n  /**\n   * Setup. Two possible usages:\n   *\n   * - static:\n   *   <comp> or <div v-component=\"comp\">\n   *\n   * - dynamic:\n   *   <component :is=\"view\">\n   */\n\n  bind: function bind() {\n    if (!this.el.__vue__) {\n      // keep-alive cache\n      this.keepAlive = this.params.keepAlive;\n      if (this.keepAlive) {\n        this.cache = {};\n      }\n      // check inline-template\n      if (this.params.inlineTemplate) {\n        // extract inline template as a DocumentFragment\n        this.inlineTemplate = extractContent(this.el, true);\n      }\n      // component resolution related state\n      this.pendingComponentCb = this.Component = null;\n      // transition related state\n      this.pendingRemovals = 0;\n      this.pendingRemovalCb = null;\n      // create a ref anchor\n      this.anchor = createAnchor('v-component');\n      replace(this.el, this.anchor);\n      // remove is attribute.\n      // this is removed during compilation, but because compilation is\n      // cached, when the component is used elsewhere this attribute\n      // will remain at link time.\n      this.el.removeAttribute('is');\n      this.el.removeAttribute(':is');\n      // remove ref, same as above\n      if (this.descriptor.ref) {\n        this.el.removeAttribute('v-ref:' + hyphenate(this.descriptor.ref));\n      }\n      // if static, build right now.\n      if (this.literal) {\n        this.setComponent(this.expression);\n      }\n    } else {\n      process.env.NODE_ENV !== 'production' && warn('cannot mount component \"' + this.expression + '\" ' + 'on already mounted element: ' + this.el);\n    }\n  },\n\n  /**\n   * Public update, called by the watcher in the dynamic\n   * literal scenario, e.g. <component :is=\"view\">\n   */\n\n  update: function update(value) {\n    if (!this.literal) {\n      this.setComponent(value);\n    }\n  },\n\n  /**\n   * Switch dynamic components. May resolve the component\n   * asynchronously, and perform transition based on\n   * specified transition mode. Accepts a few additional\n   * arguments specifically for vue-router.\n   *\n   * The callback is called when the full transition is\n   * finished.\n   *\n   * @param {String} value\n   * @param {Function} [cb]\n   */\n\n  setComponent: function setComponent(value, cb) {\n    this.invalidatePending();\n    if (!value) {\n      // just remove current\n      this.unbuild(true);\n      this.remove(this.childVM, cb);\n      this.childVM = null;\n    } else {\n      var self = this;\n      this.resolveComponent(value, function () {\n        self.mountComponent(cb);\n      });\n    }\n  },\n\n  /**\n   * Resolve the component constructor to use when creating\n   * the child vm.\n   *\n   * @param {String|Function} value\n   * @param {Function} cb\n   */\n\n  resolveComponent: function resolveComponent(value, cb) {\n    var self = this;\n    this.pendingComponentCb = cancellable(function (Component) {\n      self.ComponentName = Component.options.name || (typeof value === 'string' ? value : null);\n      self.Component = Component;\n      cb();\n    });\n    this.vm._resolveComponent(value, this.pendingComponentCb);\n  },\n\n  /**\n   * Create a new instance using the current constructor and\n   * replace the existing instance. This method doesn't care\n   * whether the new component and the old one are actually\n   * the same.\n   *\n   * @param {Function} [cb]\n   */\n\n  mountComponent: function mountComponent(cb) {\n    // actual mount\n    this.unbuild(true);\n    var self = this;\n    var activateHooks = this.Component.options.activate;\n    var cached = this.getCached();\n    var newComponent = this.build();\n    if (activateHooks && !cached) {\n      this.waitingFor = newComponent;\n      callActivateHooks(activateHooks, newComponent, function () {\n        if (self.waitingFor !== newComponent) {\n          return;\n        }\n        self.waitingFor = null;\n        self.transition(newComponent, cb);\n      });\n    } else {\n      // update ref for kept-alive component\n      if (cached) {\n        newComponent._updateRef();\n      }\n      this.transition(newComponent, cb);\n    }\n  },\n\n  /**\n   * When the component changes or unbinds before an async\n   * constructor is resolved, we need to invalidate its\n   * pending callback.\n   */\n\n  invalidatePending: function invalidatePending() {\n    if (this.pendingComponentCb) {\n      this.pendingComponentCb.cancel();\n      this.pendingComponentCb = null;\n    }\n  },\n\n  /**\n   * Instantiate/insert a new child vm.\n   * If keep alive and has cached instance, insert that\n   * instance; otherwise build a new one and cache it.\n   *\n   * @param {Object} [extraOptions]\n   * @return {Vue} - the created instance\n   */\n\n  build: function build(extraOptions) {\n    var cached = this.getCached();\n    if (cached) {\n      return cached;\n    }\n    if (this.Component) {\n      // default options\n      var options = {\n        name: this.ComponentName,\n        el: cloneNode(this.el),\n        template: this.inlineTemplate,\n        // make sure to add the child with correct parent\n        // if this is a transcluded component, its parent\n        // should be the transclusion host.\n        parent: this._host || this.vm,\n        // if no inline-template, then the compiled\n        // linker can be cached for better performance.\n        _linkerCachable: !this.inlineTemplate,\n        _ref: this.descriptor.ref,\n        _asComponent: true,\n        _isRouterView: this._isRouterView,\n        // if this is a transcluded component, context\n        // will be the common parent vm of this instance\n        // and its host.\n        _context: this.vm,\n        // if this is inside an inline v-for, the scope\n        // will be the intermediate scope created for this\n        // repeat fragment. this is used for linking props\n        // and container directives.\n        _scope: this._scope,\n        // pass in the owner fragment of this component.\n        // this is necessary so that the fragment can keep\n        // track of its contained components in order to\n        // call attach/detach hooks for them.\n        _frag: this._frag\n      };\n      // extra options\n      // in 1.0.0 this is used by vue-router only\n      /* istanbul ignore if */\n      if (extraOptions) {\n        extend(options, extraOptions);\n      }\n      var child = new this.Component(options);\n      if (this.keepAlive) {\n        this.cache[this.Component.cid] = child;\n      }\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && this.el.hasAttribute('transition') && child._isFragment) {\n        warn('Transitions will not work on a fragment instance. ' + 'Template: ' + child.$options.template, child);\n      }\n      return child;\n    }\n  },\n\n  /**\n   * Try to get a cached instance of the current component.\n   *\n   * @return {Vue|undefined}\n   */\n\n  getCached: function getCached() {\n    return this.keepAlive && this.cache[this.Component.cid];\n  },\n\n  /**\n   * Teardown the current child, but defers cleanup so\n   * that we can separate the destroy and removal steps.\n   *\n   * @param {Boolean} defer\n   */\n\n  unbuild: function unbuild(defer) {\n    if (this.waitingFor) {\n      if (!this.keepAlive) {\n        this.waitingFor.$destroy();\n      }\n      this.waitingFor = null;\n    }\n    var child = this.childVM;\n    if (!child || this.keepAlive) {\n      if (child) {\n        // remove ref\n        child._inactive = true;\n        child._updateRef(true);\n      }\n      return;\n    }\n    // the sole purpose of `deferCleanup` is so that we can\n    // \"deactivate\" the vm right now and perform DOM removal\n    // later.\n    child.$destroy(false, defer);\n  },\n\n  /**\n   * Remove current destroyed child and manually do\n   * the cleanup after removal.\n   *\n   * @param {Function} cb\n   */\n\n  remove: function remove(child, cb) {\n    var keepAlive = this.keepAlive;\n    if (child) {\n      // we may have a component switch when a previous\n      // component is still being transitioned out.\n      // we want to trigger only one lastest insertion cb\n      // when the existing transition finishes. (#1119)\n      this.pendingRemovals++;\n      this.pendingRemovalCb = cb;\n      var self = this;\n      child.$remove(function () {\n        self.pendingRemovals--;\n        if (!keepAlive) child._cleanup();\n        if (!self.pendingRemovals && self.pendingRemovalCb) {\n          self.pendingRemovalCb();\n          self.pendingRemovalCb = null;\n        }\n      });\n    } else if (cb) {\n      cb();\n    }\n  },\n\n  /**\n   * Actually swap the components, depending on the\n   * transition mode. Defaults to simultaneous.\n   *\n   * @param {Vue} target\n   * @param {Function} [cb]\n   */\n\n  transition: function transition(target, cb) {\n    var self = this;\n    var current = this.childVM;\n    // for devtool inspection\n    if (current) current._inactive = true;\n    target._inactive = false;\n    this.childVM = target;\n    switch (self.params.transitionMode) {\n      case 'in-out':\n        target.$before(self.anchor, function () {\n          self.remove(current, cb);\n        });\n        break;\n      case 'out-in':\n        self.remove(current, function () {\n          target.$before(self.anchor, cb);\n        });\n        break;\n      default:\n        self.remove(current);\n        target.$before(self.anchor, cb);\n    }\n  },\n\n  /**\n   * Unbind.\n   */\n\n  unbind: function unbind() {\n    this.invalidatePending();\n    // Do not defer cleanup when unbinding\n    this.unbuild();\n    // destroy all keep-alive cached instances\n    if (this.cache) {\n      for (var key in this.cache) {\n        this.cache[key].$destroy();\n      }\n      this.cache = null;\n    }\n  }\n};\n\n/**\n * Call activate hooks in order (asynchronous)\n *\n * @param {Array} hooks\n * @param {Vue} vm\n * @param {Function} cb\n */\n\nfunction callActivateHooks(hooks, vm, cb) {\n  var total = hooks.length;\n  var called = 0;\n  hooks[0].call(vm, next);\n  function next() {\n    if (++called >= total) {\n      cb();\n    } else {\n      hooks[called].call(vm, next);\n    }\n  }\n}\n\nvar propBindingModes = config._propBindingModes;\nvar empty = {};\n\n// regexes\nvar identRE$1 = /^[$_a-zA-Z]+[\\w$]*$/;\nvar settablePathRE = /^[A-Za-z_$][\\w$]*(\\.[A-Za-z_$][\\w$]*|\\[[^\\[\\]]+\\])*$/;\n\n/**\n * Compile props on a root element and return\n * a props link function.\n *\n * @param {Element|DocumentFragment} el\n * @param {Array} propOptions\n * @param {Vue} vm\n * @return {Function} propsLinkFn\n */\n\nfunction compileProps(el, propOptions, vm) {\n  var props = [];\n  var names = Object.keys(propOptions);\n  var i = names.length;\n  var options, name, attr, value, path, parsed, prop;\n  while (i--) {\n    name = names[i];\n    options = propOptions[name] || empty;\n\n    if (process.env.NODE_ENV !== 'production' && name === '$data') {\n      warn('Do not use $data as prop.', vm);\n      continue;\n    }\n\n    // props could contain dashes, which will be\n    // interpreted as minus calculations by the parser\n    // so we need to camelize the path here\n    path = camelize(name);\n    if (!identRE$1.test(path)) {\n      process.env.NODE_ENV !== 'production' && warn('Invalid prop key: \"' + name + '\". Prop keys ' + 'must be valid identifiers.', vm);\n      continue;\n    }\n\n    prop = {\n      name: name,\n      path: path,\n      options: options,\n      mode: propBindingModes.ONE_WAY,\n      raw: null\n    };\n\n    attr = hyphenate(name);\n    // first check dynamic version\n    if ((value = getBindAttr(el, attr)) === null) {\n      if ((value = getBindAttr(el, attr + '.sync')) !== null) {\n        prop.mode = propBindingModes.TWO_WAY;\n      } else if ((value = getBindAttr(el, attr + '.once')) !== null) {\n        prop.mode = propBindingModes.ONE_TIME;\n      }\n    }\n    if (value !== null) {\n      // has dynamic binding!\n      prop.raw = value;\n      parsed = parseDirective(value);\n      value = parsed.expression;\n      prop.filters = parsed.filters;\n      // check binding type\n      if (isLiteral(value) && !parsed.filters) {\n        // for expressions containing literal numbers and\n        // booleans, there's no need to setup a prop binding,\n        // so we can optimize them as a one-time set.\n        prop.optimizedLiteral = true;\n      } else {\n        prop.dynamic = true;\n        // check non-settable path for two-way bindings\n        if (process.env.NODE_ENV !== 'production' && prop.mode === propBindingModes.TWO_WAY && !settablePathRE.test(value)) {\n          prop.mode = propBindingModes.ONE_WAY;\n          warn('Cannot bind two-way prop with non-settable ' + 'parent path: ' + value, vm);\n        }\n      }\n      prop.parentPath = value;\n\n      // warn required two-way\n      if (process.env.NODE_ENV !== 'production' && options.twoWay && prop.mode !== propBindingModes.TWO_WAY) {\n        warn('Prop \"' + name + '\" expects a two-way binding type.', vm);\n      }\n    } else if ((value = getAttr(el, attr)) !== null) {\n      // has literal binding!\n      prop.raw = value;\n    } else if (process.env.NODE_ENV !== 'production') {\n      // check possible camelCase prop usage\n      var lowerCaseName = path.toLowerCase();\n      value = /[A-Z\\-]/.test(name) && (el.getAttribute(lowerCaseName) || el.getAttribute(':' + lowerCaseName) || el.getAttribute('v-bind:' + lowerCaseName) || el.getAttribute(':' + lowerCaseName + '.once') || el.getAttribute('v-bind:' + lowerCaseName + '.once') || el.getAttribute(':' + lowerCaseName + '.sync') || el.getAttribute('v-bind:' + lowerCaseName + '.sync'));\n      if (value) {\n        warn('Possible usage error for prop `' + lowerCaseName + '` - ' + 'did you mean `' + attr + '`? HTML is case-insensitive, remember to use ' + 'kebab-case for props in templates.', vm);\n      } else if (options.required) {\n        // warn missing required\n        warn('Missing required prop: ' + name, vm);\n      }\n    }\n    // push prop\n    props.push(prop);\n  }\n  return makePropsLinkFn(props);\n}\n\n/**\n * Build a function that applies props to a vm.\n *\n * @param {Array} props\n * @return {Function} propsLinkFn\n */\n\nfunction makePropsLinkFn(props) {\n  return function propsLinkFn(vm, scope) {\n    // store resolved props info\n    vm._props = {};\n    var inlineProps = vm.$options.propsData;\n    var i = props.length;\n    var prop, path, options, value, raw;\n    while (i--) {\n      prop = props[i];\n      raw = prop.raw;\n      path = prop.path;\n      options = prop.options;\n      vm._props[path] = prop;\n      if (inlineProps && hasOwn(inlineProps, path)) {\n        initProp(vm, prop, inlineProps[path]);\n      }if (raw === null) {\n        // initialize absent prop\n        initProp(vm, prop, undefined);\n      } else if (prop.dynamic) {\n        // dynamic prop\n        if (prop.mode === propBindingModes.ONE_TIME) {\n          // one time binding\n          value = (scope || vm._context || vm).$get(prop.parentPath);\n          initProp(vm, prop, value);\n        } else {\n          if (vm._context) {\n            // dynamic binding\n            vm._bindDir({\n              name: 'prop',\n              def: propDef,\n              prop: prop\n            }, null, null, scope); // el, host, scope\n          } else {\n              // root instance\n              initProp(vm, prop, vm.$get(prop.parentPath));\n            }\n        }\n      } else if (prop.optimizedLiteral) {\n        // optimized literal, cast it and just set once\n        var stripped = stripQuotes(raw);\n        value = stripped === raw ? toBoolean(toNumber(raw)) : stripped;\n        initProp(vm, prop, value);\n      } else {\n        // string literal, but we need to cater for\n        // Boolean props with no value, or with same\n        // literal value (e.g. disabled=\"disabled\")\n        // see https://github.com/vuejs/vue-loader/issues/182\n        value = options.type === Boolean && (raw === '' || raw === hyphenate(prop.name)) ? true : raw;\n        initProp(vm, prop, value);\n      }\n    }\n  };\n}\n\n/**\n * Process a prop with a rawValue, applying necessary coersions,\n * default values & assertions and call the given callback with\n * processed value.\n *\n * @param {Vue} vm\n * @param {Object} prop\n * @param {*} rawValue\n * @param {Function} fn\n */\n\nfunction processPropValue(vm, prop, rawValue, fn) {\n  var isSimple = prop.dynamic && isSimplePath(prop.parentPath);\n  var value = rawValue;\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop);\n  }\n  value = coerceProp(prop, value, vm);\n  var coerced = value !== rawValue;\n  if (!assertProp(prop, value, vm)) {\n    value = undefined;\n  }\n  if (isSimple && !coerced) {\n    withoutConversion(function () {\n      fn(value);\n    });\n  } else {\n    fn(value);\n  }\n}\n\n/**\n * Set a prop's initial value on a vm and its data object.\n *\n * @param {Vue} vm\n * @param {Object} prop\n * @param {*} value\n */\n\nfunction initProp(vm, prop, value) {\n  processPropValue(vm, prop, value, function (value) {\n    defineReactive(vm, prop.path, value);\n  });\n}\n\n/**\n * Update a prop's value on a vm.\n *\n * @param {Vue} vm\n * @param {Object} prop\n * @param {*} value\n */\n\nfunction updateProp(vm, prop, value) {\n  processPropValue(vm, prop, value, function (value) {\n    vm[prop.path] = value;\n  });\n}\n\n/**\n * Get the default value of a prop.\n *\n * @param {Vue} vm\n * @param {Object} prop\n * @return {*}\n */\n\nfunction getPropDefaultValue(vm, prop) {\n  // no default, return undefined\n  var options = prop.options;\n  if (!hasOwn(options, 'default')) {\n    // absent boolean value defaults to false\n    return options.type === Boolean ? false : undefined;\n  }\n  var def = options['default'];\n  // warn against non-factory defaults for Object & Array\n  if (isObject(def)) {\n    process.env.NODE_ENV !== 'production' && warn('Invalid default value for prop \"' + prop.name + '\": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);\n  }\n  // call factory function for non-Function types\n  return typeof def === 'function' && options.type !== Function ? def.call(vm) : def;\n}\n\n/**\n * Assert whether a prop is valid.\n *\n * @param {Object} prop\n * @param {*} value\n * @param {Vue} vm\n */\n\nfunction assertProp(prop, value, vm) {\n  if (!prop.options.required && ( // non-required\n  prop.raw === null || // abscent\n  value == null) // null or undefined\n  ) {\n      return true;\n    }\n  var options = prop.options;\n  var type = options.type;\n  var valid = !type;\n  var expectedTypes = [];\n  if (type) {\n    if (!isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType);\n      valid = assertedType.valid;\n    }\n  }\n  if (!valid) {\n    if (process.env.NODE_ENV !== 'production') {\n      warn('Invalid prop: type check failed for prop \"' + prop.name + '\".' + ' Expected ' + expectedTypes.map(formatType).join(', ') + ', got ' + formatValue(value) + '.', vm);\n    }\n    return false;\n  }\n  var validator = options.validator;\n  if (validator) {\n    if (!validator(value)) {\n      process.env.NODE_ENV !== 'production' && warn('Invalid prop: custom validator check failed for prop \"' + prop.name + '\".', vm);\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Force parsing value with coerce option.\n *\n * @param {*} value\n * @param {Object} options\n * @return {*}\n */\n\nfunction coerceProp(prop, value, vm) {\n  var coerce = prop.options.coerce;\n  if (!coerce) {\n    return value;\n  }\n  if (typeof coerce === 'function') {\n    return coerce(value);\n  } else {\n    process.env.NODE_ENV !== 'production' && warn('Invalid coerce for prop \"' + prop.name + '\": expected function, got ' + typeof coerce + '.', vm);\n    return value;\n  }\n}\n\n/**\n * Assert the type of a value\n *\n * @param {*} value\n * @param {Function} type\n * @return {Object}\n */\n\nfunction assertType(value, type) {\n  var valid;\n  var expectedType;\n  if (type === String) {\n    expectedType = 'string';\n    valid = typeof value === expectedType;\n  } else if (type === Number) {\n    expectedType = 'number';\n    valid = typeof value === expectedType;\n  } else if (type === Boolean) {\n    expectedType = 'boolean';\n    valid = typeof value === expectedType;\n  } else if (type === Function) {\n    expectedType = 'function';\n    valid = typeof value === expectedType;\n  } else if (type === Object) {\n    expectedType = 'object';\n    valid = isPlainObject(value);\n  } else if (type === Array) {\n    expectedType = 'array';\n    valid = isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  };\n}\n\n/**\n * Format type for output\n *\n * @param {String} type\n * @return {String}\n */\n\nfunction formatType(type) {\n  return type ? type.charAt(0).toUpperCase() + type.slice(1) : 'custom type';\n}\n\n/**\n * Format value\n *\n * @param {*} value\n * @return {String}\n */\n\nfunction formatValue(val) {\n  return Object.prototype.toString.call(val).slice(8, -1);\n}\n\nvar bindingModes = config._propBindingModes;\n\nvar propDef = {\n\n  bind: function bind() {\n    var child = this.vm;\n    var parent = child._context;\n    // passed in from compiler directly\n    var prop = this.descriptor.prop;\n    var childKey = prop.path;\n    var parentKey = prop.parentPath;\n    var twoWay = prop.mode === bindingModes.TWO_WAY;\n\n    var parentWatcher = this.parentWatcher = new Watcher(parent, parentKey, function (val) {\n      updateProp(child, prop, val);\n    }, {\n      twoWay: twoWay,\n      filters: prop.filters,\n      // important: props need to be observed on the\n      // v-for scope if present\n      scope: this._scope\n    });\n\n    // set the child initial value.\n    initProp(child, prop, parentWatcher.value);\n\n    // setup two-way binding\n    if (twoWay) {\n      // important: defer the child watcher creation until\n      // the created hook (after data observation)\n      var self = this;\n      child.$once('pre-hook:created', function () {\n        self.childWatcher = new Watcher(child, childKey, function (val) {\n          parentWatcher.set(val);\n        }, {\n          // ensure sync upward before parent sync down.\n          // this is necessary in cases e.g. the child\n          // mutates a prop array, then replaces it. (#1683)\n          sync: true\n        });\n      });\n    }\n  },\n\n  unbind: function unbind() {\n    this.parentWatcher.teardown();\n    if (this.childWatcher) {\n      this.childWatcher.teardown();\n    }\n  }\n};\n\nvar queue$1 = [];\nvar queued = false;\n\n/**\n * Push a job into the queue.\n *\n * @param {Function} job\n */\n\nfunction pushJob(job) {\n  queue$1.push(job);\n  if (!queued) {\n    queued = true;\n    nextTick(flush);\n  }\n}\n\n/**\n * Flush the queue, and do one forced reflow before\n * triggering transitions.\n */\n\nfunction flush() {\n  // Force layout\n  var f = document.documentElement.offsetHeight;\n  for (var i = 0; i < queue$1.length; i++) {\n    queue$1[i]();\n  }\n  queue$1 = [];\n  queued = false;\n  // dummy return, so js linters don't complain about\n  // unused variable f\n  return f;\n}\n\nvar TYPE_TRANSITION = 'transition';\nvar TYPE_ANIMATION = 'animation';\nvar transDurationProp = transitionProp + 'Duration';\nvar animDurationProp = animationProp + 'Duration';\n\n/**\n * If a just-entered element is applied the\n * leave class while its enter transition hasn't started yet,\n * and the transitioned property has the same value for both\n * enter/leave, then the leave transition will be skipped and\n * the transitionend event never fires. This function ensures\n * its callback to be called after a transition has started\n * by waiting for double raf.\n *\n * It falls back to setTimeout on devices that support CSS\n * transitions but not raf (e.g. Android 4.2 browser) - since\n * these environments are usually slow, we are giving it a\n * relatively large timeout.\n */\n\nvar raf = inBrowser && window.requestAnimationFrame;\nvar waitForTransitionStart = raf\n/* istanbul ignore next */\n? function (fn) {\n  raf(function () {\n    raf(fn);\n  });\n} : function (fn) {\n  setTimeout(fn, 50);\n};\n\n/**\n * A Transition object that encapsulates the state and logic\n * of the transition.\n *\n * @param {Element} el\n * @param {String} id\n * @param {Object} hooks\n * @param {Vue} vm\n */\nfunction Transition(el, id, hooks, vm) {\n  this.id = id;\n  this.el = el;\n  this.enterClass = hooks && hooks.enterClass || id + '-enter';\n  this.leaveClass = hooks && hooks.leaveClass || id + '-leave';\n  this.hooks = hooks;\n  this.vm = vm;\n  // async state\n  this.pendingCssEvent = this.pendingCssCb = this.cancel = this.pendingJsCb = this.op = this.cb = null;\n  this.justEntered = false;\n  this.entered = this.left = false;\n  this.typeCache = {};\n  // check css transition type\n  this.type = hooks && hooks.type;\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production') {\n    if (this.type && this.type !== TYPE_TRANSITION && this.type !== TYPE_ANIMATION) {\n      warn('invalid CSS transition type for transition=\"' + this.id + '\": ' + this.type, vm);\n    }\n  }\n  // bind\n  var self = this;['enterNextTick', 'enterDone', 'leaveNextTick', 'leaveDone'].forEach(function (m) {\n    self[m] = bind(self[m], self);\n  });\n}\n\nvar p$1 = Transition.prototype;\n\n/**\n * Start an entering transition.\n *\n * 1. enter transition triggered\n * 2. call beforeEnter hook\n * 3. add enter class\n * 4. insert/show element\n * 5. call enter hook (with possible explicit js callback)\n * 6. reflow\n * 7. based on transition type:\n *    - transition:\n *        remove class now, wait for transitionend,\n *        then done if there's no explicit js callback.\n *    - animation:\n *        wait for animationend, remove class,\n *        then done if there's no explicit js callback.\n *    - no css transition:\n *        done now if there's no explicit js callback.\n * 8. wait for either done or js callback, then call\n *    afterEnter hook.\n *\n * @param {Function} op - insert/show the element\n * @param {Function} [cb]\n */\n\np$1.enter = function (op, cb) {\n  this.cancelPending();\n  this.callHook('beforeEnter');\n  this.cb = cb;\n  addClass(this.el, this.enterClass);\n  op();\n  this.entered = false;\n  this.callHookWithCb('enter');\n  if (this.entered) {\n    return; // user called done synchronously.\n  }\n  this.cancel = this.hooks && this.hooks.enterCancelled;\n  pushJob(this.enterNextTick);\n};\n\n/**\n * The \"nextTick\" phase of an entering transition, which is\n * to be pushed into a queue and executed after a reflow so\n * that removing the class can trigger a CSS transition.\n */\n\np$1.enterNextTick = function () {\n  var _this = this;\n\n  // prevent transition skipping\n  this.justEntered = true;\n  waitForTransitionStart(function () {\n    _this.justEntered = false;\n  });\n  var enterDone = this.enterDone;\n  var type = this.getCssTransitionType(this.enterClass);\n  if (!this.pendingJsCb) {\n    if (type === TYPE_TRANSITION) {\n      // trigger transition by removing enter class now\n      removeClass(this.el, this.enterClass);\n      this.setupCssCb(transitionEndEvent, enterDone);\n    } else if (type === TYPE_ANIMATION) {\n      this.setupCssCb(animationEndEvent, enterDone);\n    } else {\n      enterDone();\n    }\n  } else if (type === TYPE_TRANSITION) {\n    removeClass(this.el, this.enterClass);\n  }\n};\n\n/**\n * The \"cleanup\" phase of an entering transition.\n */\n\np$1.enterDone = function () {\n  this.entered = true;\n  this.cancel = this.pendingJsCb = null;\n  removeClass(this.el, this.enterClass);\n  this.callHook('afterEnter');\n  if (this.cb) this.cb();\n};\n\n/**\n * Start a leaving transition.\n *\n * 1. leave transition triggered.\n * 2. call beforeLeave hook\n * 3. add leave class (trigger css transition)\n * 4. call leave hook (with possible explicit js callback)\n * 5. reflow if no explicit js callback is provided\n * 6. based on transition type:\n *    - transition or animation:\n *        wait for end event, remove class, then done if\n *        there's no explicit js callback.\n *    - no css transition:\n *        done if there's no explicit js callback.\n * 7. wait for either done or js callback, then call\n *    afterLeave hook.\n *\n * @param {Function} op - remove/hide the element\n * @param {Function} [cb]\n */\n\np$1.leave = function (op, cb) {\n  this.cancelPending();\n  this.callHook('beforeLeave');\n  this.op = op;\n  this.cb = cb;\n  addClass(this.el, this.leaveClass);\n  this.left = false;\n  this.callHookWithCb('leave');\n  if (this.left) {\n    return; // user called done synchronously.\n  }\n  this.cancel = this.hooks && this.hooks.leaveCancelled;\n  // only need to handle leaveDone if\n  // 1. the transition is already done (synchronously called\n  //    by the user, which causes this.op set to null)\n  // 2. there's no explicit js callback\n  if (this.op && !this.pendingJsCb) {\n    // if a CSS transition leaves immediately after enter,\n    // the transitionend event never fires. therefore we\n    // detect such cases and end the leave immediately.\n    if (this.justEntered) {\n      this.leaveDone();\n    } else {\n      pushJob(this.leaveNextTick);\n    }\n  }\n};\n\n/**\n * The \"nextTick\" phase of a leaving transition.\n */\n\np$1.leaveNextTick = function () {\n  var type = this.getCssTransitionType(this.leaveClass);\n  if (type) {\n    var event = type === TYPE_TRANSITION ? transitionEndEvent : animationEndEvent;\n    this.setupCssCb(event, this.leaveDone);\n  } else {\n    this.leaveDone();\n  }\n};\n\n/**\n * The \"cleanup\" phase of a leaving transition.\n */\n\np$1.leaveDone = function () {\n  this.left = true;\n  this.cancel = this.pendingJsCb = null;\n  this.op();\n  removeClass(this.el, this.leaveClass);\n  this.callHook('afterLeave');\n  if (this.cb) this.cb();\n  this.op = null;\n};\n\n/**\n * Cancel any pending callbacks from a previously running\n * but not finished transition.\n */\n\np$1.cancelPending = function () {\n  this.op = this.cb = null;\n  var hasPending = false;\n  if (this.pendingCssCb) {\n    hasPending = true;\n    off(this.el, this.pendingCssEvent, this.pendingCssCb);\n    this.pendingCssEvent = this.pendingCssCb = null;\n  }\n  if (this.pendingJsCb) {\n    hasPending = true;\n    this.pendingJsCb.cancel();\n    this.pendingJsCb = null;\n  }\n  if (hasPending) {\n    removeClass(this.el, this.enterClass);\n    removeClass(this.el, this.leaveClass);\n  }\n  if (this.cancel) {\n    this.cancel.call(this.vm, this.el);\n    this.cancel = null;\n  }\n};\n\n/**\n * Call a user-provided synchronous hook function.\n *\n * @param {String} type\n */\n\np$1.callHook = function (type) {\n  if (this.hooks && this.hooks[type]) {\n    this.hooks[type].call(this.vm, this.el);\n  }\n};\n\n/**\n * Call a user-provided, potentially-async hook function.\n * We check for the length of arguments to see if the hook\n * expects a `done` callback. If true, the transition's end\n * will be determined by when the user calls that callback;\n * otherwise, the end is determined by the CSS transition or\n * animation.\n *\n * @param {String} type\n */\n\np$1.callHookWithCb = function (type) {\n  var hook = this.hooks && this.hooks[type];\n  if (hook) {\n    if (hook.length > 1) {\n      this.pendingJsCb = cancellable(this[type + 'Done']);\n    }\n    hook.call(this.vm, this.el, this.pendingJsCb);\n  }\n};\n\n/**\n * Get an element's transition type based on the\n * calculated styles.\n *\n * @param {String} className\n * @return {Number}\n */\n\np$1.getCssTransitionType = function (className) {\n  /* istanbul ignore if */\n  if (!transitionEndEvent ||\n  // skip CSS transitions if page is not visible -\n  // this solves the issue of transitionend events not\n  // firing until the page is visible again.\n  // pageVisibility API is supported in IE10+, same as\n  // CSS transitions.\n  document.hidden ||\n  // explicit js-only transition\n  this.hooks && this.hooks.css === false ||\n  // element is hidden\n  isHidden(this.el)) {\n    return;\n  }\n  var type = this.type || this.typeCache[className];\n  if (type) return type;\n  var inlineStyles = this.el.style;\n  var computedStyles = window.getComputedStyle(this.el);\n  var transDuration = inlineStyles[transDurationProp] || computedStyles[transDurationProp];\n  if (transDuration && transDuration !== '0s') {\n    type = TYPE_TRANSITION;\n  } else {\n    var animDuration = inlineStyles[animDurationProp] || computedStyles[animDurationProp];\n    if (animDuration && animDuration !== '0s') {\n      type = TYPE_ANIMATION;\n    }\n  }\n  if (type) {\n    this.typeCache[className] = type;\n  }\n  return type;\n};\n\n/**\n * Setup a CSS transitionend/animationend callback.\n *\n * @param {String} event\n * @param {Function} cb\n */\n\np$1.setupCssCb = function (event, cb) {\n  this.pendingCssEvent = event;\n  var self = this;\n  var el = this.el;\n  var onEnd = this.pendingCssCb = function (e) {\n    if (e.target === el) {\n      off(el, event, onEnd);\n      self.pendingCssEvent = self.pendingCssCb = null;\n      if (!self.pendingJsCb && cb) {\n        cb();\n      }\n    }\n  };\n  on(el, event, onEnd);\n};\n\n/**\n * Check if an element is hidden - in that case we can just\n * skip the transition alltogether.\n *\n * @param {Element} el\n * @return {Boolean}\n */\n\nfunction isHidden(el) {\n  if (/svg$/.test(el.namespaceURI)) {\n    // SVG elements do not have offset(Width|Height)\n    // so we need to check the client rect\n    var rect = el.getBoundingClientRect();\n    return !(rect.width || rect.height);\n  } else {\n    return !(el.offsetWidth || el.offsetHeight || el.getClientRects().length);\n  }\n}\n\nvar transition$1 = {\n\n  priority: TRANSITION,\n\n  update: function update(id, oldId) {\n    var el = this.el;\n    // resolve on owner vm\n    var hooks = resolveAsset(this.vm.$options, 'transitions', id);\n    id = id || 'v';\n    oldId = oldId || 'v';\n    el.__v_trans = new Transition(el, id, hooks, this.vm);\n    removeClass(el, oldId + '-transition');\n    addClass(el, id + '-transition');\n  }\n};\n\nvar internalDirectives = {\n  style: style,\n  'class': vClass,\n  component: component,\n  prop: propDef,\n  transition: transition$1\n};\n\n// special binding prefixes\nvar bindRE = /^v-bind:|^:/;\nvar onRE = /^v-on:|^@/;\nvar dirAttrRE = /^v-([^:]+)(?:$|:(.*)$)/;\nvar modifierRE = /\\.[^\\.]+/g;\nvar transitionRE = /^(v-bind:|:)?transition$/;\n\n// default directive priority\nvar DEFAULT_PRIORITY = 1000;\nvar DEFAULT_TERMINAL_PRIORITY = 2000;\n\n/**\n * Compile a template and return a reusable composite link\n * function, which recursively contains more link functions\n * inside. This top level compile function would normally\n * be called on instance root nodes, but can also be used\n * for partial compilation if the partial argument is true.\n *\n * The returned composite link function, when called, will\n * return an unlink function that tearsdown all directives\n * created during the linking phase.\n *\n * @param {Element|DocumentFragment} el\n * @param {Object} options\n * @param {Boolean} partial\n * @return {Function}\n */\n\nfunction compile(el, options, partial) {\n  // link function for the node itself.\n  var nodeLinkFn = partial || !options._asComponent ? compileNode(el, options) : null;\n  // link function for the childNodes\n  var childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && !isScript(el) && el.hasChildNodes() ? compileNodeList(el.childNodes, options) : null;\n\n  /**\n   * A composite linker function to be called on a already\n   * compiled piece of DOM, which instantiates all directive\n   * instances.\n   *\n   * @param {Vue} vm\n   * @param {Element|DocumentFragment} el\n   * @param {Vue} [host] - host vm of transcluded content\n   * @param {Object} [scope] - v-for scope\n   * @param {Fragment} [frag] - link context fragment\n   * @return {Function|undefined}\n   */\n\n  return function compositeLinkFn(vm, el, host, scope, frag) {\n    // cache childNodes before linking parent, fix #657\n    var childNodes = toArray(el.childNodes);\n    // link\n    var dirs = linkAndCapture(function compositeLinkCapturer() {\n      if (nodeLinkFn) nodeLinkFn(vm, el, host, scope, frag);\n      if (childLinkFn) childLinkFn(vm, childNodes, host, scope, frag);\n    }, vm);\n    return makeUnlinkFn(vm, dirs);\n  };\n}\n\n/**\n * Apply a linker to a vm/element pair and capture the\n * directives created during the process.\n *\n * @param {Function} linker\n * @param {Vue} vm\n */\n\nfunction linkAndCapture(linker, vm) {\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV === 'production') {\n    // reset directives before every capture in production\n    // mode, so that when unlinking we don't need to splice\n    // them out (which turns out to be a perf hit).\n    // they are kept in development mode because they are\n    // useful for Vue's own tests.\n    vm._directives = [];\n  }\n  var originalDirCount = vm._directives.length;\n  linker();\n  var dirs = vm._directives.slice(originalDirCount);\n  dirs.sort(directiveComparator);\n  for (var i = 0, l = dirs.length; i < l; i++) {\n    dirs[i]._bind();\n  }\n  return dirs;\n}\n\n/**\n * Directive priority sort comparator\n *\n * @param {Object} a\n * @param {Object} b\n */\n\nfunction directiveComparator(a, b) {\n  a = a.descriptor.def.priority || DEFAULT_PRIORITY;\n  b = b.descriptor.def.priority || DEFAULT_PRIORITY;\n  return a > b ? -1 : a === b ? 0 : 1;\n}\n\n/**\n * Linker functions return an unlink function that\n * tearsdown all directives instances generated during\n * the process.\n *\n * We create unlink functions with only the necessary\n * information to avoid retaining additional closures.\n *\n * @param {Vue} vm\n * @param {Array} dirs\n * @param {Vue} [context]\n * @param {Array} [contextDirs]\n * @return {Function}\n */\n\nfunction makeUnlinkFn(vm, dirs, context, contextDirs) {\n  function unlink(destroying) {\n    teardownDirs(vm, dirs, destroying);\n    if (context && contextDirs) {\n      teardownDirs(context, contextDirs);\n    }\n  }\n  // expose linked directives\n  unlink.dirs = dirs;\n  return unlink;\n}\n\n/**\n * Teardown partial linked directives.\n *\n * @param {Vue} vm\n * @param {Array} dirs\n * @param {Boolean} destroying\n */\n\nfunction teardownDirs(vm, dirs, destroying) {\n  var i = dirs.length;\n  while (i--) {\n    dirs[i]._teardown();\n    if (process.env.NODE_ENV !== 'production' && !destroying) {\n      vm._directives.$remove(dirs[i]);\n    }\n  }\n}\n\n/**\n * Compile link props on an instance.\n *\n * @param {Vue} vm\n * @param {Element} el\n * @param {Object} props\n * @param {Object} [scope]\n * @return {Function}\n */\n\nfunction compileAndLinkProps(vm, el, props, scope) {\n  var propsLinkFn = compileProps(el, props, vm);\n  var propDirs = linkAndCapture(function () {\n    propsLinkFn(vm, scope);\n  }, vm);\n  return makeUnlinkFn(vm, propDirs);\n}\n\n/**\n * Compile the root element of an instance.\n *\n * 1. attrs on context container (context scope)\n * 2. attrs on the component template root node, if\n *    replace:true (child scope)\n *\n * If this is a fragment instance, we only need to compile 1.\n *\n * @param {Element} el\n * @param {Object} options\n * @param {Object} contextOptions\n * @return {Function}\n */\n\nfunction compileRoot(el, options, contextOptions) {\n  var containerAttrs = options._containerAttrs;\n  var replacerAttrs = options._replacerAttrs;\n  var contextLinkFn, replacerLinkFn;\n\n  // only need to compile other attributes for\n  // non-fragment instances\n  if (el.nodeType !== 11) {\n    // for components, container and replacer need to be\n    // compiled separately and linked in different scopes.\n    if (options._asComponent) {\n      // 2. container attributes\n      if (containerAttrs && contextOptions) {\n        contextLinkFn = compileDirectives(containerAttrs, contextOptions);\n      }\n      if (replacerAttrs) {\n        // 3. replacer attributes\n        replacerLinkFn = compileDirectives(replacerAttrs, options);\n      }\n    } else {\n      // non-component, just compile as a normal element.\n      replacerLinkFn = compileDirectives(el.attributes, options);\n    }\n  } else if (process.env.NODE_ENV !== 'production' && containerAttrs) {\n    // warn container directives for fragment instances\n    var names = containerAttrs.filter(function (attr) {\n      // allow vue-loader/vueify scoped css attributes\n      return attr.name.indexOf('_v-') < 0 &&\n      // allow event listeners\n      !onRE.test(attr.name) &&\n      // allow slots\n      attr.name !== 'slot';\n    }).map(function (attr) {\n      return '\"' + attr.name + '\"';\n    });\n    if (names.length) {\n      var plural = names.length > 1;\n      warn('Attribute' + (plural ? 's ' : ' ') + names.join(', ') + (plural ? ' are' : ' is') + ' ignored on component ' + '<' + options.el.tagName.toLowerCase() + '> because ' + 'the component is a fragment instance: ' + 'http://vuejs.org/guide/components.html#Fragment-Instance');\n    }\n  }\n\n  options._containerAttrs = options._replacerAttrs = null;\n  return function rootLinkFn(vm, el, scope) {\n    // link context scope dirs\n    var context = vm._context;\n    var contextDirs;\n    if (context && contextLinkFn) {\n      contextDirs = linkAndCapture(function () {\n        contextLinkFn(context, el, null, scope);\n      }, context);\n    }\n\n    // link self\n    var selfDirs = linkAndCapture(function () {\n      if (replacerLinkFn) replacerLinkFn(vm, el);\n    }, vm);\n\n    // return the unlink function that tearsdown context\n    // container directives.\n    return makeUnlinkFn(vm, selfDirs, context, contextDirs);\n  };\n}\n\n/**\n * Compile a node and return a nodeLinkFn based on the\n * node type.\n *\n * @param {Node} node\n * @param {Object} options\n * @return {Function|null}\n */\n\nfunction compileNode(node, options) {\n  var type = node.nodeType;\n  if (type === 1 && !isScript(node)) {\n    return compileElement(node, options);\n  } else if (type === 3 && node.data.trim()) {\n    return compileTextNode(node, options);\n  } else {\n    return null;\n  }\n}\n\n/**\n * Compile an element and return a nodeLinkFn.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Function|null}\n */\n\nfunction compileElement(el, options) {\n  // preprocess textareas.\n  // textarea treats its text content as the initial value.\n  // just bind it as an attr directive for value.\n  if (el.tagName === 'TEXTAREA') {\n    var tokens = parseText(el.value);\n    if (tokens) {\n      el.setAttribute(':value', tokensToExp(tokens));\n      el.value = '';\n    }\n  }\n  var linkFn;\n  var hasAttrs = el.hasAttributes();\n  var attrs = hasAttrs && toArray(el.attributes);\n  // check terminal directives (for & if)\n  if (hasAttrs) {\n    linkFn = checkTerminalDirectives(el, attrs, options);\n  }\n  // check element directives\n  if (!linkFn) {\n    linkFn = checkElementDirectives(el, options);\n  }\n  // check component\n  if (!linkFn) {\n    linkFn = checkComponent(el, options);\n  }\n  // normal directives\n  if (!linkFn && hasAttrs) {\n    linkFn = compileDirectives(attrs, options);\n  }\n  return linkFn;\n}\n\n/**\n * Compile a textNode and return a nodeLinkFn.\n *\n * @param {TextNode} node\n * @param {Object} options\n * @return {Function|null} textNodeLinkFn\n */\n\nfunction compileTextNode(node, options) {\n  // skip marked text nodes\n  if (node._skip) {\n    return removeText;\n  }\n\n  var tokens = parseText(node.wholeText);\n  if (!tokens) {\n    return null;\n  }\n\n  // mark adjacent text nodes as skipped,\n  // because we are using node.wholeText to compile\n  // all adjacent text nodes together. This fixes\n  // issues in IE where sometimes it splits up a single\n  // text node into multiple ones.\n  var next = node.nextSibling;\n  while (next && next.nodeType === 3) {\n    next._skip = true;\n    next = next.nextSibling;\n  }\n\n  var frag = document.createDocumentFragment();\n  var el, token;\n  for (var i = 0, l = tokens.length; i < l; i++) {\n    token = tokens[i];\n    el = token.tag ? processTextToken(token, options) : document.createTextNode(token.value);\n    frag.appendChild(el);\n  }\n  return makeTextNodeLinkFn(tokens, frag, options);\n}\n\n/**\n * Linker for an skipped text node.\n *\n * @param {Vue} vm\n * @param {Text} node\n */\n\nfunction removeText(vm, node) {\n  remove(node);\n}\n\n/**\n * Process a single text token.\n *\n * @param {Object} token\n * @param {Object} options\n * @return {Node}\n */\n\nfunction processTextToken(token, options) {\n  var el;\n  if (token.oneTime) {\n    el = document.createTextNode(token.value);\n  } else {\n    if (token.html) {\n      el = document.createComment('v-html');\n      setTokenType('html');\n    } else {\n      // IE will clean up empty textNodes during\n      // frag.cloneNode(true), so we have to give it\n      // something here...\n      el = document.createTextNode(' ');\n      setTokenType('text');\n    }\n  }\n  function setTokenType(type) {\n    if (token.descriptor) return;\n    var parsed = parseDirective(token.value);\n    token.descriptor = {\n      name: type,\n      def: directives[type],\n      expression: parsed.expression,\n      filters: parsed.filters\n    };\n  }\n  return el;\n}\n\n/**\n * Build a function that processes a textNode.\n *\n * @param {Array<Object>} tokens\n * @param {DocumentFragment} frag\n */\n\nfunction makeTextNodeLinkFn(tokens, frag) {\n  return function textNodeLinkFn(vm, el, host, scope) {\n    var fragClone = frag.cloneNode(true);\n    var childNodes = toArray(fragClone.childNodes);\n    var token, value, node;\n    for (var i = 0, l = tokens.length; i < l; i++) {\n      token = tokens[i];\n      value = token.value;\n      if (token.tag) {\n        node = childNodes[i];\n        if (token.oneTime) {\n          value = (scope || vm).$eval(value);\n          if (token.html) {\n            replace(node, parseTemplate(value, true));\n          } else {\n            node.data = _toString(value);\n          }\n        } else {\n          vm._bindDir(token.descriptor, node, host, scope);\n        }\n      }\n    }\n    replace(el, fragClone);\n  };\n}\n\n/**\n * Compile a node list and return a childLinkFn.\n *\n * @param {NodeList} nodeList\n * @param {Object} options\n * @return {Function|undefined}\n */\n\nfunction compileNodeList(nodeList, options) {\n  var linkFns = [];\n  var nodeLinkFn, childLinkFn, node;\n  for (var i = 0, l = nodeList.length; i < l; i++) {\n    node = nodeList[i];\n    nodeLinkFn = compileNode(node, options);\n    childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && node.tagName !== 'SCRIPT' && node.hasChildNodes() ? compileNodeList(node.childNodes, options) : null;\n    linkFns.push(nodeLinkFn, childLinkFn);\n  }\n  return linkFns.length ? makeChildLinkFn(linkFns) : null;\n}\n\n/**\n * Make a child link function for a node's childNodes.\n *\n * @param {Array<Function>} linkFns\n * @return {Function} childLinkFn\n */\n\nfunction makeChildLinkFn(linkFns) {\n  return function childLinkFn(vm, nodes, host, scope, frag) {\n    var node, nodeLinkFn, childrenLinkFn;\n    for (var i = 0, n = 0, l = linkFns.length; i < l; n++) {\n      node = nodes[n];\n      nodeLinkFn = linkFns[i++];\n      childrenLinkFn = linkFns[i++];\n      // cache childNodes before linking parent, fix #657\n      var childNodes = toArray(node.childNodes);\n      if (nodeLinkFn) {\n        nodeLinkFn(vm, node, host, scope, frag);\n      }\n      if (childrenLinkFn) {\n        childrenLinkFn(vm, childNodes, host, scope, frag);\n      }\n    }\n  };\n}\n\n/**\n * Check for element directives (custom elements that should\n * be resovled as terminal directives).\n *\n * @param {Element} el\n * @param {Object} options\n */\n\nfunction checkElementDirectives(el, options) {\n  var tag = el.tagName.toLowerCase();\n  if (commonTagRE.test(tag)) {\n    return;\n  }\n  var def = resolveAsset(options, 'elementDirectives', tag);\n  if (def) {\n    return makeTerminalNodeLinkFn(el, tag, '', options, def);\n  }\n}\n\n/**\n * Check if an element is a component. If yes, return\n * a component link function.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Function|undefined}\n */\n\nfunction checkComponent(el, options) {\n  var component = checkComponentAttr(el, options);\n  if (component) {\n    var ref = findRef(el);\n    var descriptor = {\n      name: 'component',\n      ref: ref,\n      expression: component.id,\n      def: internalDirectives.component,\n      modifiers: {\n        literal: !component.dynamic\n      }\n    };\n    var componentLinkFn = function componentLinkFn(vm, el, host, scope, frag) {\n      if (ref) {\n        defineReactive((scope || vm).$refs, ref, null);\n      }\n      vm._bindDir(descriptor, el, host, scope, frag);\n    };\n    componentLinkFn.terminal = true;\n    return componentLinkFn;\n  }\n}\n\n/**\n * Check an element for terminal directives in fixed order.\n * If it finds one, return a terminal link function.\n *\n * @param {Element} el\n * @param {Array} attrs\n * @param {Object} options\n * @return {Function} terminalLinkFn\n */\n\nfunction checkTerminalDirectives(el, attrs, options) {\n  // skip v-pre\n  if (getAttr(el, 'v-pre') !== null) {\n    return skip;\n  }\n  // skip v-else block, but only if following v-if\n  if (el.hasAttribute('v-else')) {\n    var prev = el.previousElementSibling;\n    if (prev && prev.hasAttribute('v-if')) {\n      return skip;\n    }\n  }\n\n  var attr, name, value, modifiers, matched, dirName, rawName, arg, def, termDef;\n  for (var i = 0, j = attrs.length; i < j; i++) {\n    attr = attrs[i];\n    name = attr.name.replace(modifierRE, '');\n    if (matched = name.match(dirAttrRE)) {\n      def = resolveAsset(options, 'directives', matched[1]);\n      if (def && def.terminal) {\n        if (!termDef || (def.priority || DEFAULT_TERMINAL_PRIORITY) > termDef.priority) {\n          termDef = def;\n          rawName = attr.name;\n          modifiers = parseModifiers(attr.name);\n          value = attr.value;\n          dirName = matched[1];\n          arg = matched[2];\n        }\n      }\n    }\n  }\n\n  if (termDef) {\n    return makeTerminalNodeLinkFn(el, dirName, value, options, termDef, rawName, arg, modifiers);\n  }\n}\n\nfunction skip() {}\nskip.terminal = true;\n\n/**\n * Build a node link function for a terminal directive.\n * A terminal link function terminates the current\n * compilation recursion and handles compilation of the\n * subtree in the directive.\n *\n * @param {Element} el\n * @param {String} dirName\n * @param {String} value\n * @param {Object} options\n * @param {Object} def\n * @param {String} [rawName]\n * @param {String} [arg]\n * @param {Object} [modifiers]\n * @return {Function} terminalLinkFn\n */\n\nfunction makeTerminalNodeLinkFn(el, dirName, value, options, def, rawName, arg, modifiers) {\n  var parsed = parseDirective(value);\n  var descriptor = {\n    name: dirName,\n    arg: arg,\n    expression: parsed.expression,\n    filters: parsed.filters,\n    raw: value,\n    attr: rawName,\n    modifiers: modifiers,\n    def: def\n  };\n  // check ref for v-for and router-view\n  if (dirName === 'for' || dirName === 'router-view') {\n    descriptor.ref = findRef(el);\n  }\n  var fn = function terminalNodeLinkFn(vm, el, host, scope, frag) {\n    if (descriptor.ref) {\n      defineReactive((scope || vm).$refs, descriptor.ref, null);\n    }\n    vm._bindDir(descriptor, el, host, scope, frag);\n  };\n  fn.terminal = true;\n  return fn;\n}\n\n/**\n * Compile the directives on an element and return a linker.\n *\n * @param {Array|NamedNodeMap} attrs\n * @param {Object} options\n * @return {Function}\n */\n\nfunction compileDirectives(attrs, options) {\n  var i = attrs.length;\n  var dirs = [];\n  var attr, name, value, rawName, rawValue, dirName, arg, modifiers, dirDef, tokens, matched;\n  while (i--) {\n    attr = attrs[i];\n    name = rawName = attr.name;\n    value = rawValue = attr.value;\n    tokens = parseText(value);\n    // reset arg\n    arg = null;\n    // check modifiers\n    modifiers = parseModifiers(name);\n    name = name.replace(modifierRE, '');\n\n    // attribute interpolations\n    if (tokens) {\n      value = tokensToExp(tokens);\n      arg = name;\n      pushDir('bind', directives.bind, tokens);\n      // warn against mixing mustaches with v-bind\n      if (process.env.NODE_ENV !== 'production') {\n        if (name === 'class' && Array.prototype.some.call(attrs, function (attr) {\n          return attr.name === ':class' || attr.name === 'v-bind:class';\n        })) {\n          warn('class=\"' + rawValue + '\": Do not mix mustache interpolation ' + 'and v-bind for \"class\" on the same element. Use one or the other.', options);\n        }\n      }\n    } else\n\n      // special attribute: transition\n      if (transitionRE.test(name)) {\n        modifiers.literal = !bindRE.test(name);\n        pushDir('transition', internalDirectives.transition);\n      } else\n\n        // event handlers\n        if (onRE.test(name)) {\n          arg = name.replace(onRE, '');\n          pushDir('on', directives.on);\n        } else\n\n          // attribute bindings\n          if (bindRE.test(name)) {\n            dirName = name.replace(bindRE, '');\n            if (dirName === 'style' || dirName === 'class') {\n              pushDir(dirName, internalDirectives[dirName]);\n            } else {\n              arg = dirName;\n              pushDir('bind', directives.bind);\n            }\n          } else\n\n            // normal directives\n            if (matched = name.match(dirAttrRE)) {\n              dirName = matched[1];\n              arg = matched[2];\n\n              // skip v-else (when used with v-show)\n              if (dirName === 'else') {\n                continue;\n              }\n\n              dirDef = resolveAsset(options, 'directives', dirName, true);\n              if (dirDef) {\n                pushDir(dirName, dirDef);\n              }\n            }\n  }\n\n  /**\n   * Push a directive.\n   *\n   * @param {String} dirName\n   * @param {Object|Function} def\n   * @param {Array} [interpTokens]\n   */\n\n  function pushDir(dirName, def, interpTokens) {\n    var hasOneTimeToken = interpTokens && hasOneTime(interpTokens);\n    var parsed = !hasOneTimeToken && parseDirective(value);\n    dirs.push({\n      name: dirName,\n      attr: rawName,\n      raw: rawValue,\n      def: def,\n      arg: arg,\n      modifiers: modifiers,\n      // conversion from interpolation strings with one-time token\n      // to expression is differed until directive bind time so that we\n      // have access to the actual vm context for one-time bindings.\n      expression: parsed && parsed.expression,\n      filters: parsed && parsed.filters,\n      interp: interpTokens,\n      hasOneTime: hasOneTimeToken\n    });\n  }\n\n  if (dirs.length) {\n    return makeNodeLinkFn(dirs);\n  }\n}\n\n/**\n * Parse modifiers from directive attribute name.\n *\n * @param {String} name\n * @return {Object}\n */\n\nfunction parseModifiers(name) {\n  var res = Object.create(null);\n  var match = name.match(modifierRE);\n  if (match) {\n    var i = match.length;\n    while (i--) {\n      res[match[i].slice(1)] = true;\n    }\n  }\n  return res;\n}\n\n/**\n * Build a link function for all directives on a single node.\n *\n * @param {Array} directives\n * @return {Function} directivesLinkFn\n */\n\nfunction makeNodeLinkFn(directives) {\n  return function nodeLinkFn(vm, el, host, scope, frag) {\n    // reverse apply because it's sorted low to high\n    var i = directives.length;\n    while (i--) {\n      vm._bindDir(directives[i], el, host, scope, frag);\n    }\n  };\n}\n\n/**\n * Check if an interpolation string contains one-time tokens.\n *\n * @param {Array} tokens\n * @return {Boolean}\n */\n\nfunction hasOneTime(tokens) {\n  var i = tokens.length;\n  while (i--) {\n    if (tokens[i].oneTime) return true;\n  }\n}\n\nfunction isScript(el) {\n  return el.tagName === 'SCRIPT' && (!el.hasAttribute('type') || el.getAttribute('type') === 'text/javascript');\n}\n\nvar specialCharRE = /[^\\w\\-:\\.]/;\n\n/**\n * Process an element or a DocumentFragment based on a\n * instance option object. This allows us to transclude\n * a template node/fragment before the instance is created,\n * so the processed fragment can then be cloned and reused\n * in v-for.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Element|DocumentFragment}\n */\n\nfunction transclude(el, options) {\n  // extract container attributes to pass them down\n  // to compiler, because they need to be compiled in\n  // parent scope. we are mutating the options object here\n  // assuming the same object will be used for compile\n  // right after this.\n  if (options) {\n    options._containerAttrs = extractAttrs(el);\n  }\n  // for template tags, what we want is its content as\n  // a documentFragment (for fragment instances)\n  if (isTemplate(el)) {\n    el = parseTemplate(el);\n  }\n  if (options) {\n    if (options._asComponent && !options.template) {\n      options.template = '<slot></slot>';\n    }\n    if (options.template) {\n      options._content = extractContent(el);\n      el = transcludeTemplate(el, options);\n    }\n  }\n  if (isFragment(el)) {\n    // anchors for fragment instance\n    // passing in `persist: true` to avoid them being\n    // discarded by IE during template cloning\n    prepend(createAnchor('v-start', true), el);\n    el.appendChild(createAnchor('v-end', true));\n  }\n  return el;\n}\n\n/**\n * Process the template option.\n * If the replace option is true this will swap the $el.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Element|DocumentFragment}\n */\n\nfunction transcludeTemplate(el, options) {\n  var template = options.template;\n  var frag = parseTemplate(template, true);\n  if (frag) {\n    var replacer = frag.firstChild;\n    var tag = replacer.tagName && replacer.tagName.toLowerCase();\n    if (options.replace) {\n      /* istanbul ignore if */\n      if (el === document.body) {\n        process.env.NODE_ENV !== 'production' && warn('You are mounting an instance with a template to ' + '<body>. This will replace <body> entirely. You ' + 'should probably use `replace: false` here.');\n      }\n      // there are many cases where the instance must\n      // become a fragment instance: basically anything that\n      // can create more than 1 root nodes.\n      if (\n      // multi-children template\n      frag.childNodes.length > 1 ||\n      // non-element template\n      replacer.nodeType !== 1 ||\n      // single nested component\n      tag === 'component' || resolveAsset(options, 'components', tag) || hasBindAttr(replacer, 'is') ||\n      // element directive\n      resolveAsset(options, 'elementDirectives', tag) ||\n      // for block\n      replacer.hasAttribute('v-for') ||\n      // if block\n      replacer.hasAttribute('v-if')) {\n        return frag;\n      } else {\n        options._replacerAttrs = extractAttrs(replacer);\n        mergeAttrs(el, replacer);\n        return replacer;\n      }\n    } else {\n      el.appendChild(frag);\n      return el;\n    }\n  } else {\n    process.env.NODE_ENV !== 'production' && warn('Invalid template option: ' + template);\n  }\n}\n\n/**\n * Helper to extract a component container's attributes\n * into a plain object array.\n *\n * @param {Element} el\n * @return {Array}\n */\n\nfunction extractAttrs(el) {\n  if (el.nodeType === 1 && el.hasAttributes()) {\n    return toArray(el.attributes);\n  }\n}\n\n/**\n * Merge the attributes of two elements, and make sure\n * the class names are merged properly.\n *\n * @param {Element} from\n * @param {Element} to\n */\n\nfunction mergeAttrs(from, to) {\n  var attrs = from.attributes;\n  var i = attrs.length;\n  var name, value;\n  while (i--) {\n    name = attrs[i].name;\n    value = attrs[i].value;\n    if (!to.hasAttribute(name) && !specialCharRE.test(name)) {\n      to.setAttribute(name, value);\n    } else if (name === 'class' && !parseText(value) && (value = value.trim())) {\n      value.split(/\\s+/).forEach(function (cls) {\n        addClass(to, cls);\n      });\n    }\n  }\n}\n\n/**\n * Scan and determine slot content distribution.\n * We do this during transclusion instead at compile time so that\n * the distribution is decoupled from the compilation order of\n * the slots.\n *\n * @param {Element|DocumentFragment} template\n * @param {Element} content\n * @param {Vue} vm\n */\n\nfunction resolveSlots(vm, content) {\n  if (!content) {\n    return;\n  }\n  var contents = vm._slotContents = Object.create(null);\n  var el, name;\n  for (var i = 0, l = content.children.length; i < l; i++) {\n    el = content.children[i];\n    /* eslint-disable no-cond-assign */\n    if (name = el.getAttribute('slot')) {\n      (contents[name] || (contents[name] = [])).push(el);\n    }\n    /* eslint-enable no-cond-assign */\n    if (process.env.NODE_ENV !== 'production' && getBindAttr(el, 'slot')) {\n      warn('The \"slot\" attribute must be static.', vm.$parent);\n    }\n  }\n  for (name in contents) {\n    contents[name] = extractFragment(contents[name], content);\n  }\n  if (content.hasChildNodes()) {\n    var nodes = content.childNodes;\n    if (nodes.length === 1 && nodes[0].nodeType === 3 && !nodes[0].data.trim()) {\n      return;\n    }\n    contents['default'] = extractFragment(content.childNodes, content);\n  }\n}\n\n/**\n * Extract qualified content nodes from a node list.\n *\n * @param {NodeList} nodes\n * @return {DocumentFragment}\n */\n\nfunction extractFragment(nodes, parent) {\n  var frag = document.createDocumentFragment();\n  nodes = toArray(nodes);\n  for (var i = 0, l = nodes.length; i < l; i++) {\n    var node = nodes[i];\n    if (isTemplate(node) && !node.hasAttribute('v-if') && !node.hasAttribute('v-for')) {\n      parent.removeChild(node);\n      node = parseTemplate(node, true);\n    }\n    frag.appendChild(node);\n  }\n  return frag;\n}\n\n\n\nvar compiler = Object.freeze({\n\tcompile: compile,\n\tcompileAndLinkProps: compileAndLinkProps,\n\tcompileRoot: compileRoot,\n\ttransclude: transclude,\n\tresolveSlots: resolveSlots\n});\n\nfunction stateMixin (Vue) {\n  /**\n   * Accessor for `$data` property, since setting $data\n   * requires observing the new object and updating\n   * proxied properties.\n   */\n\n  Object.defineProperty(Vue.prototype, '$data', {\n    get: function get() {\n      return this._data;\n    },\n    set: function set(newData) {\n      if (newData !== this._data) {\n        this._setData(newData);\n      }\n    }\n  });\n\n  /**\n   * Setup the scope of an instance, which contains:\n   * - observed data\n   * - computed properties\n   * - user methods\n   * - meta properties\n   */\n\n  Vue.prototype._initState = function () {\n    this._initProps();\n    this._initMeta();\n    this._initMethods();\n    this._initData();\n    this._initComputed();\n  };\n\n  /**\n   * Initialize props.\n   */\n\n  Vue.prototype._initProps = function () {\n    var options = this.$options;\n    var el = options.el;\n    var props = options.props;\n    if (props && !el) {\n      process.env.NODE_ENV !== 'production' && warn('Props will not be compiled if no `el` option is ' + 'provided at instantiation.', this);\n    }\n    // make sure to convert string selectors into element now\n    el = options.el = query(el);\n    this._propsUnlinkFn = el && el.nodeType === 1 && props\n    // props must be linked in proper scope if inside v-for\n    ? compileAndLinkProps(this, el, props, this._scope) : null;\n  };\n\n  /**\n   * Initialize the data.\n   */\n\n  Vue.prototype._initData = function () {\n    var dataFn = this.$options.data;\n    var data = this._data = dataFn ? dataFn() : {};\n    if (!isPlainObject(data)) {\n      data = {};\n      process.env.NODE_ENV !== 'production' && warn('data functions should return an object.', this);\n    }\n    var props = this._props;\n    // proxy data on instance\n    var keys = Object.keys(data);\n    var i, key;\n    i = keys.length;\n    while (i--) {\n      key = keys[i];\n      // there are two scenarios where we can proxy a data key:\n      // 1. it's not already defined as a prop\n      // 2. it's provided via a instantiation option AND there are no\n      //    template prop present\n      if (!props || !hasOwn(props, key)) {\n        this._proxy(key);\n      } else if (process.env.NODE_ENV !== 'production') {\n        warn('Data field \"' + key + '\" is already defined ' + 'as a prop. To provide default value for a prop, use the \"default\" ' + 'prop option; if you want to pass prop values to an instantiation ' + 'call, use the \"propsData\" option.', this);\n      }\n    }\n    // observe data\n    observe(data, this);\n  };\n\n  /**\n   * Swap the instance's $data. Called in $data's setter.\n   *\n   * @param {Object} newData\n   */\n\n  Vue.prototype._setData = function (newData) {\n    newData = newData || {};\n    var oldData = this._data;\n    this._data = newData;\n    var keys, key, i;\n    // unproxy keys not present in new data\n    keys = Object.keys(oldData);\n    i = keys.length;\n    while (i--) {\n      key = keys[i];\n      if (!(key in newData)) {\n        this._unproxy(key);\n      }\n    }\n    // proxy keys not already proxied,\n    // and trigger change for changed values\n    keys = Object.keys(newData);\n    i = keys.length;\n    while (i--) {\n      key = keys[i];\n      if (!hasOwn(this, key)) {\n        // new property\n        this._proxy(key);\n      }\n    }\n    oldData.__ob__.removeVm(this);\n    observe(newData, this);\n    this._digest();\n  };\n\n  /**\n   * Proxy a property, so that\n   * vm.prop === vm._data.prop\n   *\n   * @param {String} key\n   */\n\n  Vue.prototype._proxy = function (key) {\n    if (!isReserved(key)) {\n      // need to store ref to self here\n      // because these getter/setters might\n      // be called by child scopes via\n      // prototype inheritance.\n      var self = this;\n      Object.defineProperty(self, key, {\n        configurable: true,\n        enumerable: true,\n        get: function proxyGetter() {\n          return self._data[key];\n        },\n        set: function proxySetter(val) {\n          self._data[key] = val;\n        }\n      });\n    }\n  };\n\n  /**\n   * Unproxy a property.\n   *\n   * @param {String} key\n   */\n\n  Vue.prototype._unproxy = function (key) {\n    if (!isReserved(key)) {\n      delete this[key];\n    }\n  };\n\n  /**\n   * Force update on every watcher in scope.\n   */\n\n  Vue.prototype._digest = function () {\n    for (var i = 0, l = this._watchers.length; i < l; i++) {\n      this._watchers[i].update(true); // shallow updates\n    }\n  };\n\n  /**\n   * Setup computed properties. They are essentially\n   * special getter/setters\n   */\n\n  function noop() {}\n  Vue.prototype._initComputed = function () {\n    var computed = this.$options.computed;\n    if (computed) {\n      for (var key in computed) {\n        var userDef = computed[key];\n        var def = {\n          enumerable: true,\n          configurable: true\n        };\n        if (typeof userDef === 'function') {\n          def.get = makeComputedGetter(userDef, this);\n          def.set = noop;\n        } else {\n          def.get = userDef.get ? userDef.cache !== false ? makeComputedGetter(userDef.get, this) : bind(userDef.get, this) : noop;\n          def.set = userDef.set ? bind(userDef.set, this) : noop;\n        }\n        Object.defineProperty(this, key, def);\n      }\n    }\n  };\n\n  function makeComputedGetter(getter, owner) {\n    var watcher = new Watcher(owner, getter, null, {\n      lazy: true\n    });\n    return function computedGetter() {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n      if (Dep.target) {\n        watcher.depend();\n      }\n      return watcher.value;\n    };\n  }\n\n  /**\n   * Setup instance methods. Methods must be bound to the\n   * instance since they might be passed down as a prop to\n   * child components.\n   */\n\n  Vue.prototype._initMethods = function () {\n    var methods = this.$options.methods;\n    if (methods) {\n      for (var key in methods) {\n        this[key] = bind(methods[key], this);\n      }\n    }\n  };\n\n  /**\n   * Initialize meta information like $index, $key & $value.\n   */\n\n  Vue.prototype._initMeta = function () {\n    var metas = this.$options._meta;\n    if (metas) {\n      for (var key in metas) {\n        defineReactive(this, key, metas[key]);\n      }\n    }\n  };\n}\n\nvar eventRE = /^v-on:|^@/;\n\nfunction eventsMixin (Vue) {\n  /**\n   * Setup the instance's option events & watchers.\n   * If the value is a string, we pull it from the\n   * instance's methods by name.\n   */\n\n  Vue.prototype._initEvents = function () {\n    var options = this.$options;\n    if (options._asComponent) {\n      registerComponentEvents(this, options.el);\n    }\n    registerCallbacks(this, '$on', options.events);\n    registerCallbacks(this, '$watch', options.watch);\n  };\n\n  /**\n   * Register v-on events on a child component\n   *\n   * @param {Vue} vm\n   * @param {Element} el\n   */\n\n  function registerComponentEvents(vm, el) {\n    var attrs = el.attributes;\n    var name, value, handler;\n    for (var i = 0, l = attrs.length; i < l; i++) {\n      name = attrs[i].name;\n      if (eventRE.test(name)) {\n        name = name.replace(eventRE, '');\n        // force the expression into a statement so that\n        // it always dynamically resolves the method to call (#2670)\n        // kinda ugly hack, but does the job.\n        value = attrs[i].value;\n        if (isSimplePath(value)) {\n          value += '.apply(this, $arguments)';\n        }\n        handler = (vm._scope || vm._context).$eval(value, true);\n        handler._fromParent = true;\n        vm.$on(name.replace(eventRE), handler);\n      }\n    }\n  }\n\n  /**\n   * Register callbacks for option events and watchers.\n   *\n   * @param {Vue} vm\n   * @param {String} action\n   * @param {Object} hash\n   */\n\n  function registerCallbacks(vm, action, hash) {\n    if (!hash) return;\n    var handlers, key, i, j;\n    for (key in hash) {\n      handlers = hash[key];\n      if (isArray(handlers)) {\n        for (i = 0, j = handlers.length; i < j; i++) {\n          register(vm, action, key, handlers[i]);\n        }\n      } else {\n        register(vm, action, key, handlers);\n      }\n    }\n  }\n\n  /**\n   * Helper to register an event/watch callback.\n   *\n   * @param {Vue} vm\n   * @param {String} action\n   * @param {String} key\n   * @param {Function|String|Object} handler\n   * @param {Object} [options]\n   */\n\n  function register(vm, action, key, handler, options) {\n    var type = typeof handler;\n    if (type === 'function') {\n      vm[action](key, handler, options);\n    } else if (type === 'string') {\n      var methods = vm.$options.methods;\n      var method = methods && methods[handler];\n      if (method) {\n        vm[action](key, method, options);\n      } else {\n        process.env.NODE_ENV !== 'production' && warn('Unknown method: \"' + handler + '\" when ' + 'registering callback for ' + action + ': \"' + key + '\".', vm);\n      }\n    } else if (handler && type === 'object') {\n      register(vm, action, key, handler.handler, handler);\n    }\n  }\n\n  /**\n   * Setup recursive attached/detached calls\n   */\n\n  Vue.prototype._initDOMHooks = function () {\n    this.$on('hook:attached', onAttached);\n    this.$on('hook:detached', onDetached);\n  };\n\n  /**\n   * Callback to recursively call attached hook on children\n   */\n\n  function onAttached() {\n    if (!this._isAttached) {\n      this._isAttached = true;\n      this.$children.forEach(callAttach);\n    }\n  }\n\n  /**\n   * Iterator to call attached hook\n   *\n   * @param {Vue} child\n   */\n\n  function callAttach(child) {\n    if (!child._isAttached && inDoc(child.$el)) {\n      child._callHook('attached');\n    }\n  }\n\n  /**\n   * Callback to recursively call detached hook on children\n   */\n\n  function onDetached() {\n    if (this._isAttached) {\n      this._isAttached = false;\n      this.$children.forEach(callDetach);\n    }\n  }\n\n  /**\n   * Iterator to call detached hook\n   *\n   * @param {Vue} child\n   */\n\n  function callDetach(child) {\n    if (child._isAttached && !inDoc(child.$el)) {\n      child._callHook('detached');\n    }\n  }\n\n  /**\n   * Trigger all handlers for a hook\n   *\n   * @param {String} hook\n   */\n\n  Vue.prototype._callHook = function (hook) {\n    this.$emit('pre-hook:' + hook);\n    var handlers = this.$options[hook];\n    if (handlers) {\n      for (var i = 0, j = handlers.length; i < j; i++) {\n        handlers[i].call(this);\n      }\n    }\n    this.$emit('hook:' + hook);\n  };\n}\n\nfunction noop$1() {}\n\n/**\n * A directive links a DOM element with a piece of data,\n * which is the result of evaluating an expression.\n * It registers a watcher with the expression and calls\n * the DOM update function when a change is triggered.\n *\n * @param {Object} descriptor\n *                 - {String} name\n *                 - {Object} def\n *                 - {String} expression\n *                 - {Array<Object>} [filters]\n *                 - {Object} [modifiers]\n *                 - {Boolean} literal\n *                 - {String} attr\n *                 - {String} arg\n *                 - {String} raw\n *                 - {String} [ref]\n *                 - {Array<Object>} [interp]\n *                 - {Boolean} [hasOneTime]\n * @param {Vue} vm\n * @param {Node} el\n * @param {Vue} [host] - transclusion host component\n * @param {Object} [scope] - v-for scope\n * @param {Fragment} [frag] - owner fragment\n * @constructor\n */\nfunction Directive(descriptor, vm, el, host, scope, frag) {\n  this.vm = vm;\n  this.el = el;\n  // copy descriptor properties\n  this.descriptor = descriptor;\n  this.name = descriptor.name;\n  this.expression = descriptor.expression;\n  this.arg = descriptor.arg;\n  this.modifiers = descriptor.modifiers;\n  this.filters = descriptor.filters;\n  this.literal = this.modifiers && this.modifiers.literal;\n  // private\n  this._locked = false;\n  this._bound = false;\n  this._listeners = null;\n  // link context\n  this._host = host;\n  this._scope = scope;\n  this._frag = frag;\n  // store directives on node in dev mode\n  if (process.env.NODE_ENV !== 'production' && this.el) {\n    this.el._vue_directives = this.el._vue_directives || [];\n    this.el._vue_directives.push(this);\n  }\n}\n\n/**\n * Initialize the directive, mixin definition properties,\n * setup the watcher, call definition bind() and update()\n * if present.\n */\n\nDirective.prototype._bind = function () {\n  var name = this.name;\n  var descriptor = this.descriptor;\n\n  // remove attribute\n  if ((name !== 'cloak' || this.vm._isCompiled) && this.el && this.el.removeAttribute) {\n    var attr = descriptor.attr || 'v-' + name;\n    this.el.removeAttribute(attr);\n  }\n\n  // copy def properties\n  var def = descriptor.def;\n  if (typeof def === 'function') {\n    this.update = def;\n  } else {\n    extend(this, def);\n  }\n\n  // setup directive params\n  this._setupParams();\n\n  // initial bind\n  if (this.bind) {\n    this.bind();\n  }\n  this._bound = true;\n\n  if (this.literal) {\n    this.update && this.update(descriptor.raw);\n  } else if ((this.expression || this.modifiers) && (this.update || this.twoWay) && !this._checkStatement()) {\n    // wrapped updater for context\n    var dir = this;\n    if (this.update) {\n      this._update = function (val, oldVal) {\n        if (!dir._locked) {\n          dir.update(val, oldVal);\n        }\n      };\n    } else {\n      this._update = noop$1;\n    }\n    var preProcess = this._preProcess ? bind(this._preProcess, this) : null;\n    var postProcess = this._postProcess ? bind(this._postProcess, this) : null;\n    var watcher = this._watcher = new Watcher(this.vm, this.expression, this._update, // callback\n    {\n      filters: this.filters,\n      twoWay: this.twoWay,\n      deep: this.deep,\n      preProcess: preProcess,\n      postProcess: postProcess,\n      scope: this._scope\n    });\n    // v-model with inital inline value need to sync back to\n    // model instead of update to DOM on init. They would\n    // set the afterBind hook to indicate that.\n    if (this.afterBind) {\n      this.afterBind();\n    } else if (this.update) {\n      this.update(watcher.value);\n    }\n  }\n};\n\n/**\n * Setup all param attributes, e.g. track-by,\n * transition-mode, etc...\n */\n\nDirective.prototype._setupParams = function () {\n  if (!this.params) {\n    return;\n  }\n  var params = this.params;\n  // swap the params array with a fresh object.\n  this.params = Object.create(null);\n  var i = params.length;\n  var key, val, mappedKey;\n  while (i--) {\n    key = hyphenate(params[i]);\n    mappedKey = camelize(key);\n    val = getBindAttr(this.el, key);\n    if (val != null) {\n      // dynamic\n      this._setupParamWatcher(mappedKey, val);\n    } else {\n      // static\n      val = getAttr(this.el, key);\n      if (val != null) {\n        this.params[mappedKey] = val === '' ? true : val;\n      }\n    }\n  }\n};\n\n/**\n * Setup a watcher for a dynamic param.\n *\n * @param {String} key\n * @param {String} expression\n */\n\nDirective.prototype._setupParamWatcher = function (key, expression) {\n  var self = this;\n  var called = false;\n  var unwatch = (this._scope || this.vm).$watch(expression, function (val, oldVal) {\n    self.params[key] = val;\n    // since we are in immediate mode,\n    // only call the param change callbacks if this is not the first update.\n    if (called) {\n      var cb = self.paramWatchers && self.paramWatchers[key];\n      if (cb) {\n        cb.call(self, val, oldVal);\n      }\n    } else {\n      called = true;\n    }\n  }, {\n    immediate: true,\n    user: false\n  });(this._paramUnwatchFns || (this._paramUnwatchFns = [])).push(unwatch);\n};\n\n/**\n * Check if the directive is a function caller\n * and if the expression is a callable one. If both true,\n * we wrap up the expression and use it as the event\n * handler.\n *\n * e.g. on-click=\"a++\"\n *\n * @return {Boolean}\n */\n\nDirective.prototype._checkStatement = function () {\n  var expression = this.expression;\n  if (expression && this.acceptStatement && !isSimplePath(expression)) {\n    var fn = parseExpression(expression).get;\n    var scope = this._scope || this.vm;\n    var handler = function handler(e) {\n      scope.$event = e;\n      fn.call(scope, scope);\n      scope.$event = null;\n    };\n    if (this.filters) {\n      handler = scope._applyFilters(handler, null, this.filters);\n    }\n    this.update(handler);\n    return true;\n  }\n};\n\n/**\n * Set the corresponding value with the setter.\n * This should only be used in two-way directives\n * e.g. v-model.\n *\n * @param {*} value\n * @public\n */\n\nDirective.prototype.set = function (value) {\n  /* istanbul ignore else */\n  if (this.twoWay) {\n    this._withLock(function () {\n      this._watcher.set(value);\n    });\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn('Directive.set() can only be used inside twoWay' + 'directives.');\n  }\n};\n\n/**\n * Execute a function while preventing that function from\n * triggering updates on this directive instance.\n *\n * @param {Function} fn\n */\n\nDirective.prototype._withLock = function (fn) {\n  var self = this;\n  self._locked = true;\n  fn.call(self);\n  nextTick(function () {\n    self._locked = false;\n  });\n};\n\n/**\n * Convenience method that attaches a DOM event listener\n * to the directive element and autometically tears it down\n * during unbind.\n *\n * @param {String} event\n * @param {Function} handler\n * @param {Boolean} [useCapture]\n */\n\nDirective.prototype.on = function (event, handler, useCapture) {\n  on(this.el, event, handler, useCapture);(this._listeners || (this._listeners = [])).push([event, handler]);\n};\n\n/**\n * Teardown the watcher and call unbind.\n */\n\nDirective.prototype._teardown = function () {\n  if (this._bound) {\n    this._bound = false;\n    if (this.unbind) {\n      this.unbind();\n    }\n    if (this._watcher) {\n      this._watcher.teardown();\n    }\n    var listeners = this._listeners;\n    var i;\n    if (listeners) {\n      i = listeners.length;\n      while (i--) {\n        off(this.el, listeners[i][0], listeners[i][1]);\n      }\n    }\n    var unwatchFns = this._paramUnwatchFns;\n    if (unwatchFns) {\n      i = unwatchFns.length;\n      while (i--) {\n        unwatchFns[i]();\n      }\n    }\n    if (process.env.NODE_ENV !== 'production' && this.el) {\n      this.el._vue_directives.$remove(this);\n    }\n    this.vm = this.el = this._watcher = this._listeners = null;\n  }\n};\n\nfunction lifecycleMixin (Vue) {\n  /**\n   * Update v-ref for component.\n   *\n   * @param {Boolean} remove\n   */\n\n  Vue.prototype._updateRef = function (remove) {\n    var ref = this.$options._ref;\n    if (ref) {\n      var refs = (this._scope || this._context).$refs;\n      if (remove) {\n        if (refs[ref] === this) {\n          refs[ref] = null;\n        }\n      } else {\n        refs[ref] = this;\n      }\n    }\n  };\n\n  /**\n   * Transclude, compile and link element.\n   *\n   * If a pre-compiled linker is available, that means the\n   * passed in element will be pre-transcluded and compiled\n   * as well - all we need to do is to call the linker.\n   *\n   * Otherwise we need to call transclude/compile/link here.\n   *\n   * @param {Element} el\n   */\n\n  Vue.prototype._compile = function (el) {\n    var options = this.$options;\n\n    // transclude and init element\n    // transclude can potentially replace original\n    // so we need to keep reference; this step also injects\n    // the template and caches the original attributes\n    // on the container node and replacer node.\n    var original = el;\n    el = transclude(el, options);\n    this._initElement(el);\n\n    // handle v-pre on root node (#2026)\n    if (el.nodeType === 1 && getAttr(el, 'v-pre') !== null) {\n      return;\n    }\n\n    // root is always compiled per-instance, because\n    // container attrs and props can be different every time.\n    var contextOptions = this._context && this._context.$options;\n    var rootLinker = compileRoot(el, options, contextOptions);\n\n    // resolve slot distribution\n    resolveSlots(this, options._content);\n\n    // compile and link the rest\n    var contentLinkFn;\n    var ctor = this.constructor;\n    // component compilation can be cached\n    // as long as it's not using inline-template\n    if (options._linkerCachable) {\n      contentLinkFn = ctor.linker;\n      if (!contentLinkFn) {\n        contentLinkFn = ctor.linker = compile(el, options);\n      }\n    }\n\n    // link phase\n    // make sure to link root with prop scope!\n    var rootUnlinkFn = rootLinker(this, el, this._scope);\n    var contentUnlinkFn = contentLinkFn ? contentLinkFn(this, el) : compile(el, options)(this, el);\n\n    // register composite unlink function\n    // to be called during instance destruction\n    this._unlinkFn = function () {\n      rootUnlinkFn();\n      // passing destroying: true to avoid searching and\n      // splicing the directives\n      contentUnlinkFn(true);\n    };\n\n    // finally replace original\n    if (options.replace) {\n      replace(original, el);\n    }\n\n    this._isCompiled = true;\n    this._callHook('compiled');\n  };\n\n  /**\n   * Initialize instance element. Called in the public\n   * $mount() method.\n   *\n   * @param {Element} el\n   */\n\n  Vue.prototype._initElement = function (el) {\n    if (isFragment(el)) {\n      this._isFragment = true;\n      this.$el = this._fragmentStart = el.firstChild;\n      this._fragmentEnd = el.lastChild;\n      // set persisted text anchors to empty\n      if (this._fragmentStart.nodeType === 3) {\n        this._fragmentStart.data = this._fragmentEnd.data = '';\n      }\n      this._fragment = el;\n    } else {\n      this.$el = el;\n    }\n    this.$el.__vue__ = this;\n    this._callHook('beforeCompile');\n  };\n\n  /**\n   * Create and bind a directive to an element.\n   *\n   * @param {Object} descriptor - parsed directive descriptor\n   * @param {Node} node   - target node\n   * @param {Vue} [host] - transclusion host component\n   * @param {Object} [scope] - v-for scope\n   * @param {Fragment} [frag] - owner fragment\n   */\n\n  Vue.prototype._bindDir = function (descriptor, node, host, scope, frag) {\n    this._directives.push(new Directive(descriptor, this, node, host, scope, frag));\n  };\n\n  /**\n   * Teardown an instance, unobserves the data, unbind all the\n   * directives, turn off all the event listeners, etc.\n   *\n   * @param {Boolean} remove - whether to remove the DOM node.\n   * @param {Boolean} deferCleanup - if true, defer cleanup to\n   *                                 be called later\n   */\n\n  Vue.prototype._destroy = function (remove, deferCleanup) {\n    if (this._isBeingDestroyed) {\n      if (!deferCleanup) {\n        this._cleanup();\n      }\n      return;\n    }\n\n    var destroyReady;\n    var pendingRemoval;\n\n    var self = this;\n    // Cleanup should be called either synchronously or asynchronoysly as\n    // callback of this.$remove(), or if remove and deferCleanup are false.\n    // In any case it should be called after all other removing, unbinding and\n    // turning of is done\n    var cleanupIfPossible = function cleanupIfPossible() {\n      if (destroyReady && !pendingRemoval && !deferCleanup) {\n        self._cleanup();\n      }\n    };\n\n    // remove DOM element\n    if (remove && this.$el) {\n      pendingRemoval = true;\n      this.$remove(function () {\n        pendingRemoval = false;\n        cleanupIfPossible();\n      });\n    }\n\n    this._callHook('beforeDestroy');\n    this._isBeingDestroyed = true;\n    var i;\n    // remove self from parent. only necessary\n    // if parent is not being destroyed as well.\n    var parent = this.$parent;\n    if (parent && !parent._isBeingDestroyed) {\n      parent.$children.$remove(this);\n      // unregister ref (remove: true)\n      this._updateRef(true);\n    }\n    // destroy all children.\n    i = this.$children.length;\n    while (i--) {\n      this.$children[i].$destroy();\n    }\n    // teardown props\n    if (this._propsUnlinkFn) {\n      this._propsUnlinkFn();\n    }\n    // teardown all directives. this also tearsdown all\n    // directive-owned watchers.\n    if (this._unlinkFn) {\n      this._unlinkFn();\n    }\n    i = this._watchers.length;\n    while (i--) {\n      this._watchers[i].teardown();\n    }\n    // remove reference to self on $el\n    if (this.$el) {\n      this.$el.__vue__ = null;\n    }\n\n    destroyReady = true;\n    cleanupIfPossible();\n  };\n\n  /**\n   * Clean up to ensure garbage collection.\n   * This is called after the leave transition if there\n   * is any.\n   */\n\n  Vue.prototype._cleanup = function () {\n    if (this._isDestroyed) {\n      return;\n    }\n    // remove self from owner fragment\n    // do it in cleanup so that we can call $destroy with\n    // defer right when a fragment is about to be removed.\n    if (this._frag) {\n      this._frag.children.$remove(this);\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (this._data && this._data.__ob__) {\n      this._data.__ob__.removeVm(this);\n    }\n    // Clean up references to private properties and other\n    // instances. preserve reference to _data so that proxy\n    // accessors still work. The only potential side effect\n    // here is that mutating the instance after it's destroyed\n    // may affect the state of other components that are still\n    // observing the same object, but that seems to be a\n    // reasonable responsibility for the user rather than\n    // always throwing an error on them.\n    this.$el = this.$parent = this.$root = this.$children = this._watchers = this._context = this._scope = this._directives = null;\n    // call the last hook...\n    this._isDestroyed = true;\n    this._callHook('destroyed');\n    // turn off all instance listeners.\n    this.$off();\n  };\n}\n\nfunction miscMixin (Vue) {\n  /**\n   * Apply a list of filter (descriptors) to a value.\n   * Using plain for loops here because this will be called in\n   * the getter of any watcher with filters so it is very\n   * performance sensitive.\n   *\n   * @param {*} value\n   * @param {*} [oldValue]\n   * @param {Array} filters\n   * @param {Boolean} write\n   * @return {*}\n   */\n\n  Vue.prototype._applyFilters = function (value, oldValue, filters, write) {\n    var filter, fn, args, arg, offset, i, l, j, k;\n    for (i = 0, l = filters.length; i < l; i++) {\n      filter = filters[write ? l - i - 1 : i];\n      fn = resolveAsset(this.$options, 'filters', filter.name, true);\n      if (!fn) continue;\n      fn = write ? fn.write : fn.read || fn;\n      if (typeof fn !== 'function') continue;\n      args = write ? [value, oldValue] : [value];\n      offset = write ? 2 : 1;\n      if (filter.args) {\n        for (j = 0, k = filter.args.length; j < k; j++) {\n          arg = filter.args[j];\n          args[j + offset] = arg.dynamic ? this.$get(arg.value) : arg.value;\n        }\n      }\n      value = fn.apply(this, args);\n    }\n    return value;\n  };\n\n  /**\n   * Resolve a component, depending on whether the component\n   * is defined normally or using an async factory function.\n   * Resolves synchronously if already resolved, otherwise\n   * resolves asynchronously and caches the resolved\n   * constructor on the factory.\n   *\n   * @param {String|Function} value\n   * @param {Function} cb\n   */\n\n  Vue.prototype._resolveComponent = function (value, cb) {\n    var factory;\n    if (typeof value === 'function') {\n      factory = value;\n    } else {\n      factory = resolveAsset(this.$options, 'components', value, true);\n    }\n    /* istanbul ignore if */\n    if (!factory) {\n      return;\n    }\n    // async component factory\n    if (!factory.options) {\n      if (factory.resolved) {\n        // cached\n        cb(factory.resolved);\n      } else if (factory.requested) {\n        // pool callbacks\n        factory.pendingCallbacks.push(cb);\n      } else {\n        factory.requested = true;\n        var cbs = factory.pendingCallbacks = [cb];\n        factory.call(this, function resolve(res) {\n          if (isPlainObject(res)) {\n            res = Vue.extend(res);\n          }\n          // cache resolved\n          factory.resolved = res;\n          // invoke callbacks\n          for (var i = 0, l = cbs.length; i < l; i++) {\n            cbs[i](res);\n          }\n        }, function reject(reason) {\n          process.env.NODE_ENV !== 'production' && warn('Failed to resolve async component' + (typeof value === 'string' ? ': ' + value : '') + '. ' + (reason ? '\\nReason: ' + reason : ''));\n        });\n      }\n    } else {\n      // normal component\n      cb(factory);\n    }\n  };\n}\n\nvar filterRE$1 = /[^|]\\|[^|]/;\n\nfunction dataAPI (Vue) {\n  /**\n   * Get the value from an expression on this vm.\n   *\n   * @param {String} exp\n   * @param {Boolean} [asStatement]\n   * @return {*}\n   */\n\n  Vue.prototype.$get = function (exp, asStatement) {\n    var res = parseExpression(exp);\n    if (res) {\n      if (asStatement) {\n        var self = this;\n        return function statementHandler() {\n          self.$arguments = toArray(arguments);\n          var result = res.get.call(self, self);\n          self.$arguments = null;\n          return result;\n        };\n      } else {\n        try {\n          return res.get.call(this, this);\n        } catch (e) {}\n      }\n    }\n  };\n\n  /**\n   * Set the value from an expression on this vm.\n   * The expression must be a valid left-hand\n   * expression in an assignment.\n   *\n   * @param {String} exp\n   * @param {*} val\n   */\n\n  Vue.prototype.$set = function (exp, val) {\n    var res = parseExpression(exp, true);\n    if (res && res.set) {\n      res.set.call(this, this, val);\n    }\n  };\n\n  /**\n   * Delete a property on the VM\n   *\n   * @param {String} key\n   */\n\n  Vue.prototype.$delete = function (key) {\n    del(this._data, key);\n  };\n\n  /**\n   * Watch an expression, trigger callback when its\n   * value changes.\n   *\n   * @param {String|Function} expOrFn\n   * @param {Function} cb\n   * @param {Object} [options]\n   *                 - {Boolean} deep\n   *                 - {Boolean} immediate\n   * @return {Function} - unwatchFn\n   */\n\n  Vue.prototype.$watch = function (expOrFn, cb, options) {\n    var vm = this;\n    var parsed;\n    if (typeof expOrFn === 'string') {\n      parsed = parseDirective(expOrFn);\n      expOrFn = parsed.expression;\n    }\n    var watcher = new Watcher(vm, expOrFn, cb, {\n      deep: options && options.deep,\n      sync: options && options.sync,\n      filters: parsed && parsed.filters,\n      user: !options || options.user !== false\n    });\n    if (options && options.immediate) {\n      cb.call(vm, watcher.value);\n    }\n    return function unwatchFn() {\n      watcher.teardown();\n    };\n  };\n\n  /**\n   * Evaluate a text directive, including filters.\n   *\n   * @param {String} text\n   * @param {Boolean} [asStatement]\n   * @return {String}\n   */\n\n  Vue.prototype.$eval = function (text, asStatement) {\n    // check for filters.\n    if (filterRE$1.test(text)) {\n      var dir = parseDirective(text);\n      // the filter regex check might give false positive\n      // for pipes inside strings, so it's possible that\n      // we don't get any filters here\n      var val = this.$get(dir.expression, asStatement);\n      return dir.filters ? this._applyFilters(val, null, dir.filters) : val;\n    } else {\n      // no filter\n      return this.$get(text, asStatement);\n    }\n  };\n\n  /**\n   * Interpolate a piece of template text.\n   *\n   * @param {String} text\n   * @return {String}\n   */\n\n  Vue.prototype.$interpolate = function (text) {\n    var tokens = parseText(text);\n    var vm = this;\n    if (tokens) {\n      if (tokens.length === 1) {\n        return vm.$eval(tokens[0].value) + '';\n      } else {\n        return tokens.map(function (token) {\n          return token.tag ? vm.$eval(token.value) : token.value;\n        }).join('');\n      }\n    } else {\n      return text;\n    }\n  };\n\n  /**\n   * Log instance data as a plain JS object\n   * so that it is easier to inspect in console.\n   * This method assumes console is available.\n   *\n   * @param {String} [path]\n   */\n\n  Vue.prototype.$log = function (path) {\n    var data = path ? getPath(this._data, path) : this._data;\n    if (data) {\n      data = clean(data);\n    }\n    // include computed fields\n    if (!path) {\n      var key;\n      for (key in this.$options.computed) {\n        data[key] = clean(this[key]);\n      }\n      if (this._props) {\n        for (key in this._props) {\n          data[key] = clean(this[key]);\n        }\n      }\n    }\n    console.log(data);\n  };\n\n  /**\n   * \"clean\" a getter/setter converted object into a plain\n   * object copy.\n   *\n   * @param {Object} - obj\n   * @return {Object}\n   */\n\n  function clean(obj) {\n    return JSON.parse(JSON.stringify(obj));\n  }\n}\n\nfunction domAPI (Vue) {\n  /**\n   * Convenience on-instance nextTick. The callback is\n   * auto-bound to the instance, and this avoids component\n   * modules having to rely on the global Vue.\n   *\n   * @param {Function} fn\n   */\n\n  Vue.prototype.$nextTick = function (fn) {\n    nextTick(fn, this);\n  };\n\n  /**\n   * Append instance to target\n   *\n   * @param {Node} target\n   * @param {Function} [cb]\n   * @param {Boolean} [withTransition] - defaults to true\n   */\n\n  Vue.prototype.$appendTo = function (target, cb, withTransition) {\n    return insert(this, target, cb, withTransition, append, appendWithTransition);\n  };\n\n  /**\n   * Prepend instance to target\n   *\n   * @param {Node} target\n   * @param {Function} [cb]\n   * @param {Boolean} [withTransition] - defaults to true\n   */\n\n  Vue.prototype.$prependTo = function (target, cb, withTransition) {\n    target = query(target);\n    if (target.hasChildNodes()) {\n      this.$before(target.firstChild, cb, withTransition);\n    } else {\n      this.$appendTo(target, cb, withTransition);\n    }\n    return this;\n  };\n\n  /**\n   * Insert instance before target\n   *\n   * @param {Node} target\n   * @param {Function} [cb]\n   * @param {Boolean} [withTransition] - defaults to true\n   */\n\n  Vue.prototype.$before = function (target, cb, withTransition) {\n    return insert(this, target, cb, withTransition, beforeWithCb, beforeWithTransition);\n  };\n\n  /**\n   * Insert instance after target\n   *\n   * @param {Node} target\n   * @param {Function} [cb]\n   * @param {Boolean} [withTransition] - defaults to true\n   */\n\n  Vue.prototype.$after = function (target, cb, withTransition) {\n    target = query(target);\n    if (target.nextSibling) {\n      this.$before(target.nextSibling, cb, withTransition);\n    } else {\n      this.$appendTo(target.parentNode, cb, withTransition);\n    }\n    return this;\n  };\n\n  /**\n   * Remove instance from DOM\n   *\n   * @param {Function} [cb]\n   * @param {Boolean} [withTransition] - defaults to true\n   */\n\n  Vue.prototype.$remove = function (cb, withTransition) {\n    if (!this.$el.parentNode) {\n      return cb && cb();\n    }\n    var inDocument = this._isAttached && inDoc(this.$el);\n    // if we are not in document, no need to check\n    // for transitions\n    if (!inDocument) withTransition = false;\n    var self = this;\n    var realCb = function realCb() {\n      if (inDocument) self._callHook('detached');\n      if (cb) cb();\n    };\n    if (this._isFragment) {\n      removeNodeRange(this._fragmentStart, this._fragmentEnd, this, this._fragment, realCb);\n    } else {\n      var op = withTransition === false ? removeWithCb : removeWithTransition;\n      op(this.$el, this, realCb);\n    }\n    return this;\n  };\n\n  /**\n   * Shared DOM insertion function.\n   *\n   * @param {Vue} vm\n   * @param {Element} target\n   * @param {Function} [cb]\n   * @param {Boolean} [withTransition]\n   * @param {Function} op1 - op for non-transition insert\n   * @param {Function} op2 - op for transition insert\n   * @return vm\n   */\n\n  function insert(vm, target, cb, withTransition, op1, op2) {\n    target = query(target);\n    var targetIsDetached = !inDoc(target);\n    var op = withTransition === false || targetIsDetached ? op1 : op2;\n    var shouldCallHook = !targetIsDetached && !vm._isAttached && !inDoc(vm.$el);\n    if (vm._isFragment) {\n      mapNodeRange(vm._fragmentStart, vm._fragmentEnd, function (node) {\n        op(node, target, vm);\n      });\n      cb && cb();\n    } else {\n      op(vm.$el, target, vm, cb);\n    }\n    if (shouldCallHook) {\n      vm._callHook('attached');\n    }\n    return vm;\n  }\n\n  /**\n   * Check for selectors\n   *\n   * @param {String|Element} el\n   */\n\n  function query(el) {\n    return typeof el === 'string' ? document.querySelector(el) : el;\n  }\n\n  /**\n   * Append operation that takes a callback.\n   *\n   * @param {Node} el\n   * @param {Node} target\n   * @param {Vue} vm - unused\n   * @param {Function} [cb]\n   */\n\n  function append(el, target, vm, cb) {\n    target.appendChild(el);\n    if (cb) cb();\n  }\n\n  /**\n   * InsertBefore operation that takes a callback.\n   *\n   * @param {Node} el\n   * @param {Node} target\n   * @param {Vue} vm - unused\n   * @param {Function} [cb]\n   */\n\n  function beforeWithCb(el, target, vm, cb) {\n    before(el, target);\n    if (cb) cb();\n  }\n\n  /**\n   * Remove operation that takes a callback.\n   *\n   * @param {Node} el\n   * @param {Vue} vm - unused\n   * @param {Function} [cb]\n   */\n\n  function removeWithCb(el, vm, cb) {\n    remove(el);\n    if (cb) cb();\n  }\n}\n\nfunction eventsAPI (Vue) {\n  /**\n   * Listen on the given `event` with `fn`.\n   *\n   * @param {String} event\n   * @param {Function} fn\n   */\n\n  Vue.prototype.$on = function (event, fn) {\n    (this._events[event] || (this._events[event] = [])).push(fn);\n    modifyListenerCount(this, event, 1);\n    return this;\n  };\n\n  /**\n   * Adds an `event` listener that will be invoked a single\n   * time then automatically removed.\n   *\n   * @param {String} event\n   * @param {Function} fn\n   */\n\n  Vue.prototype.$once = function (event, fn) {\n    var self = this;\n    function on() {\n      self.$off(event, on);\n      fn.apply(this, arguments);\n    }\n    on.fn = fn;\n    this.$on(event, on);\n    return this;\n  };\n\n  /**\n   * Remove the given callback for `event` or all\n   * registered callbacks.\n   *\n   * @param {String} event\n   * @param {Function} fn\n   */\n\n  Vue.prototype.$off = function (event, fn) {\n    var cbs;\n    // all\n    if (!arguments.length) {\n      if (this.$parent) {\n        for (event in this._events) {\n          cbs = this._events[event];\n          if (cbs) {\n            modifyListenerCount(this, event, -cbs.length);\n          }\n        }\n      }\n      this._events = {};\n      return this;\n    }\n    // specific event\n    cbs = this._events[event];\n    if (!cbs) {\n      return this;\n    }\n    if (arguments.length === 1) {\n      modifyListenerCount(this, event, -cbs.length);\n      this._events[event] = null;\n      return this;\n    }\n    // specific handler\n    var cb;\n    var i = cbs.length;\n    while (i--) {\n      cb = cbs[i];\n      if (cb === fn || cb.fn === fn) {\n        modifyListenerCount(this, event, -1);\n        cbs.splice(i, 1);\n        break;\n      }\n    }\n    return this;\n  };\n\n  /**\n   * Trigger an event on self.\n   *\n   * @param {String|Object} event\n   * @return {Boolean} shouldPropagate\n   */\n\n  Vue.prototype.$emit = function (event) {\n    var isSource = typeof event === 'string';\n    event = isSource ? event : event.name;\n    var cbs = this._events[event];\n    var shouldPropagate = isSource || !cbs;\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      // this is a somewhat hacky solution to the question raised\n      // in #2102: for an inline component listener like <comp @test=\"doThis\">,\n      // the propagation handling is somewhat broken. Therefore we\n      // need to treat these inline callbacks differently.\n      var hasParentCbs = isSource && cbs.some(function (cb) {\n        return cb._fromParent;\n      });\n      if (hasParentCbs) {\n        shouldPropagate = false;\n      }\n      var args = toArray(arguments, 1);\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        var cb = cbs[i];\n        var res = cb.apply(this, args);\n        if (res === true && (!hasParentCbs || cb._fromParent)) {\n          shouldPropagate = true;\n        }\n      }\n    }\n    return shouldPropagate;\n  };\n\n  /**\n   * Recursively broadcast an event to all children instances.\n   *\n   * @param {String|Object} event\n   * @param {...*} additional arguments\n   */\n\n  Vue.prototype.$broadcast = function (event) {\n    var isSource = typeof event === 'string';\n    event = isSource ? event : event.name;\n    // if no child has registered for this event,\n    // then there's no need to broadcast.\n    if (!this._eventsCount[event]) return;\n    var children = this.$children;\n    var args = toArray(arguments);\n    if (isSource) {\n      // use object event to indicate non-source emit\n      // on children\n      args[0] = { name: event, source: this };\n    }\n    for (var i = 0, l = children.length; i < l; i++) {\n      var child = children[i];\n      var shouldPropagate = child.$emit.apply(child, args);\n      if (shouldPropagate) {\n        child.$broadcast.apply(child, args);\n      }\n    }\n    return this;\n  };\n\n  /**\n   * Recursively propagate an event up the parent chain.\n   *\n   * @param {String} event\n   * @param {...*} additional arguments\n   */\n\n  Vue.prototype.$dispatch = function (event) {\n    var shouldPropagate = this.$emit.apply(this, arguments);\n    if (!shouldPropagate) return;\n    var parent = this.$parent;\n    var args = toArray(arguments);\n    // use object event to indicate non-source emit\n    // on parents\n    args[0] = { name: event, source: this };\n    while (parent) {\n      shouldPropagate = parent.$emit.apply(parent, args);\n      parent = shouldPropagate ? parent.$parent : null;\n    }\n    return this;\n  };\n\n  /**\n   * Modify the listener counts on all parents.\n   * This bookkeeping allows $broadcast to return early when\n   * no child has listened to a certain event.\n   *\n   * @param {Vue} vm\n   * @param {String} event\n   * @param {Number} count\n   */\n\n  var hookRE = /^hook:/;\n  function modifyListenerCount(vm, event, count) {\n    var parent = vm.$parent;\n    // hooks do not get broadcasted so no need\n    // to do bookkeeping for them\n    if (!parent || !count || hookRE.test(event)) return;\n    while (parent) {\n      parent._eventsCount[event] = (parent._eventsCount[event] || 0) + count;\n      parent = parent.$parent;\n    }\n  }\n}\n\nfunction lifecycleAPI (Vue) {\n  /**\n   * Set instance target element and kick off the compilation\n   * process. The passed in `el` can be a selector string, an\n   * existing Element, or a DocumentFragment (for block\n   * instances).\n   *\n   * @param {Element|DocumentFragment|string} el\n   * @public\n   */\n\n  Vue.prototype.$mount = function (el) {\n    if (this._isCompiled) {\n      process.env.NODE_ENV !== 'production' && warn('$mount() should be called only once.', this);\n      return;\n    }\n    el = query(el);\n    if (!el) {\n      el = document.createElement('div');\n    }\n    this._compile(el);\n    this._initDOMHooks();\n    if (inDoc(this.$el)) {\n      this._callHook('attached');\n      ready.call(this);\n    } else {\n      this.$once('hook:attached', ready);\n    }\n    return this;\n  };\n\n  /**\n   * Mark an instance as ready.\n   */\n\n  function ready() {\n    this._isAttached = true;\n    this._isReady = true;\n    this._callHook('ready');\n  }\n\n  /**\n   * Teardown the instance, simply delegate to the internal\n   * _destroy.\n   *\n   * @param {Boolean} remove\n   * @param {Boolean} deferCleanup\n   */\n\n  Vue.prototype.$destroy = function (remove, deferCleanup) {\n    this._destroy(remove, deferCleanup);\n  };\n\n  /**\n   * Partially compile a piece of DOM and return a\n   * decompile function.\n   *\n   * @param {Element|DocumentFragment} el\n   * @param {Vue} [host]\n   * @param {Object} [scope]\n   * @param {Fragment} [frag]\n   * @return {Function}\n   */\n\n  Vue.prototype.$compile = function (el, host, scope, frag) {\n    return compile(el, this.$options, true)(this, el, host, scope, frag);\n  };\n}\n\n/**\n * The exposed Vue constructor.\n *\n * API conventions:\n * - public API methods/properties are prefixed with `$`\n * - internal methods/properties are prefixed with `_`\n * - non-prefixed properties are assumed to be proxied user\n *   data.\n *\n * @constructor\n * @param {Object} [options]\n * @public\n */\n\nfunction Vue(options) {\n  this._init(options);\n}\n\n// install internals\ninitMixin(Vue);\nstateMixin(Vue);\neventsMixin(Vue);\nlifecycleMixin(Vue);\nmiscMixin(Vue);\n\n// install instance APIs\ndataAPI(Vue);\ndomAPI(Vue);\neventsAPI(Vue);\nlifecycleAPI(Vue);\n\nvar slot = {\n\n  priority: SLOT,\n  params: ['name'],\n\n  bind: function bind() {\n    // this was resolved during component transclusion\n    var name = this.params.name || 'default';\n    var content = this.vm._slotContents && this.vm._slotContents[name];\n    if (!content || !content.hasChildNodes()) {\n      this.fallback();\n    } else {\n      this.compile(content.cloneNode(true), this.vm._context, this.vm);\n    }\n  },\n\n  compile: function compile(content, context, host) {\n    if (content && context) {\n      if (this.el.hasChildNodes() && content.childNodes.length === 1 && content.childNodes[0].nodeType === 1 && content.childNodes[0].hasAttribute('v-if')) {\n        // if the inserted slot has v-if\n        // inject fallback content as the v-else\n        var elseBlock = document.createElement('template');\n        elseBlock.setAttribute('v-else', '');\n        elseBlock.innerHTML = this.el.innerHTML;\n        // the else block should be compiled in child scope\n        elseBlock._context = this.vm;\n        content.appendChild(elseBlock);\n      }\n      var scope = host ? host._scope : this._scope;\n      this.unlink = context.$compile(content, host, scope, this._frag);\n    }\n    if (content) {\n      replace(this.el, content);\n    } else {\n      remove(this.el);\n    }\n  },\n\n  fallback: function fallback() {\n    this.compile(extractContent(this.el, true), this.vm);\n  },\n\n  unbind: function unbind() {\n    if (this.unlink) {\n      this.unlink();\n    }\n  }\n};\n\nvar partial = {\n\n  priority: PARTIAL,\n\n  params: ['name'],\n\n  // watch changes to name for dynamic partials\n  paramWatchers: {\n    name: function name(value) {\n      vIf.remove.call(this);\n      if (value) {\n        this.insert(value);\n      }\n    }\n  },\n\n  bind: function bind() {\n    this.anchor = createAnchor('v-partial');\n    replace(this.el, this.anchor);\n    this.insert(this.params.name);\n  },\n\n  insert: function insert(id) {\n    var partial = resolveAsset(this.vm.$options, 'partials', id, true);\n    if (partial) {\n      this.factory = new FragmentFactory(this.vm, partial);\n      vIf.insert.call(this);\n    }\n  },\n\n  unbind: function unbind() {\n    if (this.frag) {\n      this.frag.destroy();\n    }\n  }\n};\n\nvar elementDirectives = {\n  slot: slot,\n  partial: partial\n};\n\nvar convertArray = vFor._postProcess;\n\n/**\n * Limit filter for arrays\n *\n * @param {Number} n\n * @param {Number} offset (Decimal expected)\n */\n\nfunction limitBy(arr, n, offset) {\n  offset = offset ? parseInt(offset, 10) : 0;\n  n = toNumber(n);\n  return typeof n === 'number' ? arr.slice(offset, offset + n) : arr;\n}\n\n/**\n * Filter filter for arrays\n *\n * @param {String} search\n * @param {String} [delimiter]\n * @param {String} ...dataKeys\n */\n\nfunction filterBy(arr, search, delimiter) {\n  arr = convertArray(arr);\n  if (search == null) {\n    return arr;\n  }\n  if (typeof search === 'function') {\n    return arr.filter(search);\n  }\n  // cast to lowercase string\n  search = ('' + search).toLowerCase();\n  // allow optional `in` delimiter\n  // because why not\n  var n = delimiter === 'in' ? 3 : 2;\n  // extract and flatten keys\n  var keys = Array.prototype.concat.apply([], toArray(arguments, n));\n  var res = [];\n  var item, key, val, j;\n  for (var i = 0, l = arr.length; i < l; i++) {\n    item = arr[i];\n    val = item && item.$value || item;\n    j = keys.length;\n    if (j) {\n      while (j--) {\n        key = keys[j];\n        if (key === '$key' && contains(item.$key, search) || contains(getPath(val, key), search)) {\n          res.push(item);\n          break;\n        }\n      }\n    } else if (contains(item, search)) {\n      res.push(item);\n    }\n  }\n  return res;\n}\n\n/**\n * Filter filter for arrays\n *\n * @param {String|Array<String>|Function} ...sortKeys\n * @param {Number} [order]\n */\n\nfunction orderBy(arr) {\n  var comparator = null;\n  var sortKeys = undefined;\n  arr = convertArray(arr);\n\n  // determine order (last argument)\n  var args = toArray(arguments, 1);\n  var order = args[args.length - 1];\n  if (typeof order === 'number') {\n    order = order < 0 ? -1 : 1;\n    args = args.length > 1 ? args.slice(0, -1) : args;\n  } else {\n    order = 1;\n  }\n\n  // determine sortKeys & comparator\n  var firstArg = args[0];\n  if (!firstArg) {\n    return arr;\n  } else if (typeof firstArg === 'function') {\n    // custom comparator\n    comparator = function (a, b) {\n      return firstArg(a, b) * order;\n    };\n  } else {\n    // string keys. flatten first\n    sortKeys = Array.prototype.concat.apply([], args);\n    comparator = function (a, b, i) {\n      i = i || 0;\n      return i >= sortKeys.length - 1 ? baseCompare(a, b, i) : baseCompare(a, b, i) || comparator(a, b, i + 1);\n    };\n  }\n\n  function baseCompare(a, b, sortKeyIndex) {\n    var sortKey = sortKeys[sortKeyIndex];\n    if (sortKey) {\n      if (sortKey !== '$key') {\n        if (isObject(a) && '$value' in a) a = a.$value;\n        if (isObject(b) && '$value' in b) b = b.$value;\n      }\n      a = isObject(a) ? getPath(a, sortKey) : a;\n      b = isObject(b) ? getPath(b, sortKey) : b;\n    }\n    return a === b ? 0 : a > b ? order : -order;\n  }\n\n  // sort on a copy to avoid mutating original array\n  return arr.slice().sort(comparator);\n}\n\n/**\n * String contain helper\n *\n * @param {*} val\n * @param {String} search\n */\n\nfunction contains(val, search) {\n  var i;\n  if (isPlainObject(val)) {\n    var keys = Object.keys(val);\n    i = keys.length;\n    while (i--) {\n      if (contains(val[keys[i]], search)) {\n        return true;\n      }\n    }\n  } else if (isArray(val)) {\n    i = val.length;\n    while (i--) {\n      if (contains(val[i], search)) {\n        return true;\n      }\n    }\n  } else if (val != null) {\n    return val.toString().toLowerCase().indexOf(search) > -1;\n  }\n}\n\nvar digitsRE = /(\\d{3})(?=\\d)/g;\n\n// asset collections must be a plain object.\nvar filters = {\n\n  orderBy: orderBy,\n  filterBy: filterBy,\n  limitBy: limitBy,\n\n  /**\n   * Stringify value.\n   *\n   * @param {Number} indent\n   */\n\n  json: {\n    read: function read(value, indent) {\n      return typeof value === 'string' ? value : JSON.stringify(value, null, arguments.length > 1 ? indent : 2);\n    },\n    write: function write(value) {\n      try {\n        return JSON.parse(value);\n      } catch (e) {\n        return value;\n      }\n    }\n  },\n\n  /**\n   * 'abc' => 'Abc'\n   */\n\n  capitalize: function capitalize(value) {\n    if (!value && value !== 0) return '';\n    value = value.toString();\n    return value.charAt(0).toUpperCase() + value.slice(1);\n  },\n\n  /**\n   * 'abc' => 'ABC'\n   */\n\n  uppercase: function uppercase(value) {\n    return value || value === 0 ? value.toString().toUpperCase() : '';\n  },\n\n  /**\n   * 'AbC' => 'abc'\n   */\n\n  lowercase: function lowercase(value) {\n    return value || value === 0 ? value.toString().toLowerCase() : '';\n  },\n\n  /**\n   * 12345 => $12,345.00\n   *\n   * @param {String} sign\n   * @param {Number} decimals Decimal places\n   */\n\n  currency: function currency(value, _currency, decimals) {\n    value = parseFloat(value);\n    if (!isFinite(value) || !value && value !== 0) return '';\n    _currency = _currency != null ? _currency : '$';\n    decimals = decimals != null ? decimals : 2;\n    var stringified = Math.abs(value).toFixed(decimals);\n    var _int = decimals ? stringified.slice(0, -1 - decimals) : stringified;\n    var i = _int.length % 3;\n    var head = i > 0 ? _int.slice(0, i) + (_int.length > 3 ? ',' : '') : '';\n    var _float = decimals ? stringified.slice(-1 - decimals) : '';\n    var sign = value < 0 ? '-' : '';\n    return sign + _currency + head + _int.slice(i).replace(digitsRE, '$1,') + _float;\n  },\n\n  /**\n   * 'item' => 'items'\n   *\n   * @params\n   *  an array of strings corresponding to\n   *  the single, double, triple ... forms of the word to\n   *  be pluralized. When the number to be pluralized\n   *  exceeds the length of the args, it will use the last\n   *  entry in the array.\n   *\n   *  e.g. ['single', 'double', 'triple', 'multiple']\n   */\n\n  pluralize: function pluralize(value) {\n    var args = toArray(arguments, 1);\n    return args.length > 1 ? args[value % 10 - 1] || args[args.length - 1] : args[0] + (value === 1 ? '' : 's');\n  },\n\n  /**\n   * Debounce a handler function.\n   *\n   * @param {Function} handler\n   * @param {Number} delay = 300\n   * @return {Function}\n   */\n\n  debounce: function debounce(handler, delay) {\n    if (!handler) return;\n    if (!delay) {\n      delay = 300;\n    }\n    return _debounce(handler, delay);\n  }\n};\n\nfunction installGlobalAPI (Vue) {\n  /**\n   * Vue and every constructor that extends Vue has an\n   * associated options object, which can be accessed during\n   * compilation steps as `this.constructor.options`.\n   *\n   * These can be seen as the default options of every\n   * Vue instance.\n   */\n\n  Vue.options = {\n    directives: directives,\n    elementDirectives: elementDirectives,\n    filters: filters,\n    transitions: {},\n    components: {},\n    partials: {},\n    replace: true\n  };\n\n  /**\n   * Expose useful internals\n   */\n\n  Vue.util = util;\n  Vue.config = config;\n  Vue.set = set;\n  Vue['delete'] = del;\n  Vue.nextTick = nextTick;\n\n  /**\n   * The following are exposed for advanced usage / plugins\n   */\n\n  Vue.compiler = compiler;\n  Vue.FragmentFactory = FragmentFactory;\n  Vue.internalDirectives = internalDirectives;\n  Vue.parsers = {\n    path: path,\n    text: text,\n    template: template,\n    directive: directive,\n    expression: expression\n  };\n\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   *\n   * @param {Object} extendOptions\n   */\n\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var isFirstExtend = Super.cid === 0;\n    if (isFirstExtend && extendOptions._Ctor) {\n      return extendOptions._Ctor;\n    }\n    var name = extendOptions.name || Super.options.name;\n    if (process.env.NODE_ENV !== 'production') {\n      if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n        warn('Invalid component name: \"' + name + '\". Component names ' + 'can only contain alphanumeric characaters and the hyphen.');\n        name = null;\n      }\n    }\n    var Sub = createClass(name || 'VueComponent');\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(Super.options, extendOptions);\n    Sub['super'] = Super;\n    // allow further extension\n    Sub.extend = Super.extend;\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    config._assetTypes.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n    // cache constructor\n    if (isFirstExtend) {\n      extendOptions._Ctor = Sub;\n    }\n    return Sub;\n  };\n\n  /**\n   * A function that returns a sub-class constructor with the\n   * given name. This gives us much nicer output when\n   * logging instances in the console.\n   *\n   * @param {String} name\n   * @return {Function}\n   */\n\n  function createClass(name) {\n    /* eslint-disable no-new-func */\n    return new Function('return function ' + classify(name) + ' (options) { this._init(options) }')();\n    /* eslint-enable no-new-func */\n  }\n\n  /**\n   * Plugin system\n   *\n   * @param {Object} plugin\n   */\n\n  Vue.use = function (plugin) {\n    /* istanbul ignore if */\n    if (plugin.installed) {\n      return;\n    }\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else {\n      plugin.apply(null, args);\n    }\n    plugin.installed = true;\n    return this;\n  };\n\n  /**\n   * Apply a global mixin by merging it into the default\n   * options.\n   */\n\n  Vue.mixin = function (mixin) {\n    Vue.options = mergeOptions(Vue.options, mixin);\n  };\n\n  /**\n   * Create asset registration methods with the following\n   * signature:\n   *\n   * @param {String} id\n   * @param {*} definition\n   */\n\n  config._assetTypes.forEach(function (type) {\n    Vue[type] = function (id, definition) {\n      if (!definition) {\n        return this.options[type + 's'][id];\n      } else {\n        /* istanbul ignore if */\n        if (process.env.NODE_ENV !== 'production') {\n          if (type === 'component' && (commonTagRE.test(id) || reservedTagRE.test(id))) {\n            warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);\n          }\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          if (!definition.name) {\n            definition.name = id;\n          }\n          definition = Vue.extend(definition);\n        }\n        this.options[type + 's'][id] = definition;\n        return definition;\n      }\n    };\n  });\n\n  // expose internal transition API\n  extend(Vue.transition, transition);\n}\n\ninstallGlobalAPI(Vue);\n\nVue.version = '1.0.25';\n\n// devtools global hook\n/* istanbul ignore next */\nsetTimeout(function () {\n  if (config.devtools) {\n    if (devtools) {\n      devtools.emit('init', Vue);\n    } else if (process.env.NODE_ENV !== 'production' && inBrowser && /Chrome\\/\\d+/.test(window.navigator.userAgent)) {\n      console.log('Download the Vue Devtools for a better development experience:\\n' + 'https://github.com/vuejs/vue-devtools');\n    }\n  }\n}, 0);\n\nmodule.exports = Vue;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vue/dist/vue.common.js\n ** module id = 3\n ** module chunks = 0\n **/"],"sourceRoot":""}